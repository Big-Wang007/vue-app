(function(factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function() {
  "use strict";
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = `/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */

/* Document
   ========================================================================== */

/**
 * 1. 更正所有浏览器中的线条高度.
 * 2. 防止在iOS中更改方向后调整字体大小.
 */

html {
  line-height: 1.15; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/* Sections
   ========================================================================== */

/**
 * 删除所有浏览器中的边距.
 */

body {
  margin: 0;
}

/**
 * 在IE中一致地呈现“main”元素.
 */

main {
  display: block;
}

/**
 * 更正Chrome、Firefox和Safari中“section”和“article”上下文中“h1”元素的字体大小和边距.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/* 分组内容
   ========================================================================== */

/**
 * 1. 在Firefox中添加正确的框大小.
 * 2. 在Edge和IE中显示溢出.
 */

hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}

/**
 * 1. 更正所有浏览器中字体大小的继承和缩放.
 * 2. 更正所有浏览器中奇怪的'em'字体大小.
 */

pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/* 文本级语义
   ========================================================================== */

/**
 * 删除IE 10中活动链接的灰色背景.
 */

a {
  background-color: transparent;
}

/**
 * 1. 在Chrome 57-之后版本中删除底部边框.
 * 2. 在Chrome、Edge、IE、Opera和Safari中添加正确的文本装饰.
 */

abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}

/**
 * 在Chrome、Edge和Safari中添加正确的字体粗细.
 */

b,
strong {
  font-weight: bolder;
}

/**
 * 1. 更正所有浏览器中字体大小的继承和缩放.
 * 2. 更正所有浏览器中奇怪的'em'字体大小。.
 */

code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/**
 * 在所有浏览器中添加正确的字体大小.
 */

small {
  font-size: 80%;
}

/**
 * 防止“sub”和“sup”元素影响所有浏览器。
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/* 嵌入式内容
   ========================================================================== */

/**
 * 删除IE 10中链接内图像的边框.
 */

img {
  border-style: none;
}

/* 表单
   ========================================================================== */

/**
 * 1. 更改所有浏览器中的字体样式.
 * 2. 删除Firefox和Safari中的边距.
 */

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}

/**
 * 在IE中显示溢出.
 * 1. 在Edge中显示溢出.
 */

button,
input { /* 1 */
  overflow: visible;
}

/**
 * 删除Edge、Firefox和IE中文本转换的继承.
 * 1. 删除Firefox中文本转换的继承.
 */

button,
select { /* 1 */
  text-transform: none;
}

/**
 * 纠正iOS和Safari中无法设置可点击类型样式的问题.
 */

button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
}

/**
 * 删除Firefox中的内边框和填充.
 */

button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

/**
 * 恢复之前规则未设置的焦点样式.
 */

button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

/**
 * 更正Firefox中的填充.
 */

fieldset {
  padding: 0.35em 0.75em 0.625em;
}

/**
 * 1. 更正Edge和IE中的文本换行.
 * 2. 更正IE中“fieldset”元素的颜色继承.
 * 3. 删除填充，这样开发人员在所有浏览器中清空“fieldset”元素时就不会被抓到.
 */

legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}

/**
 * 在Chrome、Firefox和Opera中添加正确的垂直对齐.
 */

progress {
  vertical-align: baseline;
}

/**
 * 删除IE 10+中的默认垂直滚动条.
 */

textarea {
  overflow: auto;
}

/**
 * 1. 在IE 10中添加正确的框大小.
 * 2. 删除IE 10中的填充.
 */

[type="checkbox"],
[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * 修正Chrome中增减按钮的光标样式.
 */

[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. 纠正Chrome和Safari中的奇怪外观.
 * 2. 更正Safari中的轮廓样式.
 */

[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/**
 * 删除macOS上Chrome和Safari的内部填充.
 */

[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * 1. 纠正iOS和Safari中无法设置可点击类型样式的问题.
 * 2. 在Safari中将字体属性更改为“继承”.
 */

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/* 交互
   ========================================================================== */

/*
 * 在Edge、IE 10+和Firefox中添加正确的显示.
 */

details {
  display: block;
}

/*
 * 在所有浏览器中添加正确的显示.
 */

summary {
  display: list-item;
}

/* 其他
   ========================================================================== */

/**
 * 在IE 10+中添加正确的显示.
 */

template {
  display: none;
}

/**
 * 在IE 10中添加正确的显示.
 */

[hidden] {
  display: none;
}* {\r
  box-sizing: border-box;\r
}\r
\r
body {\r
  width: 100vw;\r
  height: 100vh;\r
  min-width: 1440px;\r
  min-height: 900px;\r
  overflow: auto;\r
  font-family: 'Noto Sans SC';\r
  color: #333; /* 深灰色 */\r
}\r
\r
h1,\r
h2,\r
h3,\r
h4,\r
h5,\r
h6,\r
p {\r
  margin: 0; /* 上边距较大，下边距较小 */\r
}\r
\r
a {\r
  color: #007bff; /* 蓝色 */\r
  text-decoration: none;\r
}\r
\r
/* a:hover {\r
  text-decoration: underline;\r
} */\r
\r
a:visited {\r
  color: #5c5c5c; /* 深灰色 */\r
}\r
\r
/* input,\r
textarea,\r
button,\r
select {\r
  font-family: inherit;\r
  font-size: inherit; \r
  padding: 8px; \r
  margin: 4px 0;\r
  border: 1px solid #ccc;\r
  border-radius: 4px; \r
} */\r
\r
#app {\r
  width: 100%;\r
  height: 100%;\r
}\r

.dashboard[data-v-d6af467e] {\r
  width: 100%;\r
  height: 100%;\r
  display: grid;\r
  grid-template-rows: 1fr 1fr;\r
  grid-template-columns: 50% 50%;\r
  justify-items: center;\r
  align-items: center;
}
#line-chart-main[data-v-d6af467e] {\r
  width: 100%;\r
  height: 100%;
}
#bar-chart-main[data-v-d6af467e] {\r
  width: 600px;\r
  height: 400px;
}
#pie-chart-main[data-v-d6af467e] {\r
  width: 600px;\r
  height: 400px;
}
#gauge-chart-main[data-v-d6af467e] {\r
  width: 600px;\r
  height: 400px;
}\r
.custom-pagination[data-v-ee1ada23] {
  margin-top: 24px;
  text-align: right;
  position: relative;
}
.custom-pagination[data-v-ee1ada23] .ant-pagination-total-text {
  position: absolute;
  left: 0;
}
.search[data-v-e97ab276] {
  width: 100%;
  background: #fff;
  border-radius: 8px;
  padding: 32px 24px 0;
}
.content[data-v-e97ab276] {
  background: #fff;
  border-radius: 8px;
  padding: 24px;
  margin-top: 24px;
}
/*$vite$:1*/`;
  document.head.appendChild(__vite_style__);
  /**
  * @vue/shared v3.5.17
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key2 of str.split(",")) map2[key2] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ$1 = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn$1 = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // uppercase letter
  (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97);
  const isModelListener = (key2) => key2.startsWith("onUpdate:");
  const extend$2 = Object.assign;
  const remove = (arr, el) => {
    const i2 = arr.indexOf(el);
    if (i2 > -1) {
      arr.splice(i2, 1);
    }
  };
  const hasOwnProperty$i = Object.prototype.hasOwnProperty;
  const hasOwn$3 = (val, key2) => hasOwnProperty$i.call(val, key2);
  const isArray$6 = Array.isArray;
  const isMap$1 = (val) => toTypeString$1(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString$1(val) === "[object Set]";
  const isFunction$5 = (val) => typeof val === "function";
  const isString$5 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$9 = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return (isObject$9(val) || isFunction$5(val)) && isFunction$5(val.then) && isFunction$5(val.catch);
  };
  const objectToString$2 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    return toTypeString$1(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
  const isIntegerKey = (key2) => isString$5(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction$1 = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    };
  };
  const camelizeRE$1 = /-(\w)/g;
  const camelize$1 = cacheStringFunction$1(
    (str) => {
      return str.replace(camelizeRE$1, (_2, c2) => c2 ? c2.toUpperCase() : "");
    }
  );
  const hyphenateRE$1 = /\B([A-Z])/g;
  const hyphenate$1 = cacheStringFunction$1(
    (str) => str.replace(hyphenateRE$1, "-$1").toLowerCase()
  );
  const capitalize$1 = cacheStringFunction$1((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction$1(
    (str) => {
      const s2 = str ? `on${capitalize$1(str)}` : ``;
      return s2;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i2 = 0; i2 < fns.length; i2++) {
      fns[i2](...arg);
    }
  };
  const def = (obj2, key2, value, writable = false) => {
    Object.defineProperty(obj2, key2, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
  };
  const toNumber$1 = (val) => {
    const n2 = isString$5(val) ? Number(val) : NaN;
    return isNaN(n2) ? val : n2;
  };
  let _globalThis$1;
  const getGlobalThis$1 = () => {
    return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle$2(value) {
    if (isArray$6(value)) {
      const res = {};
      for (let i2 = 0; i2 < value.length; i2++) {
        const item = value[i2];
        const normalized = isString$5(item) ? parseStringStyle(item) : normalizeStyle$2(item);
        if (normalized) {
          for (const key2 in normalized) {
            res[key2] = normalized[key2];
          }
        }
      }
      return res;
    } else if (isString$5(value) || isObject$9(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$5(value)) {
      res = value;
    } else if (isArray$6(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const normalized = normalizeClass(value[i2]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$9(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString$1 = (val) => {
    return isString$5(val) ? val : val == null ? "" : isArray$6(val) || isObject$9(val) && (val.toString === objectToString$2 || !isFunction$5(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap$1(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key2, val2], i2) => {
            entries[stringifySymbol(key2, i2) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet$1(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject$9(val) && !isArray$6(val) && !isPlainObject$3(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v2, i2 = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2
    );
  };
  /**
  * @vue/reactivity v3.5.17
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this._on = 0;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].pause();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i2, l2;
          if (this.scopes) {
            for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
              this.scopes[i2].resume();
            }
          }
          for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
            this.effects[i2].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      if (++this._on === 1) {
        this.prevScope = activeEffectScope;
        activeEffectScope = this;
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      if (this._on > 0 && --this._on === 0) {
        activeEffectScope = this.prevScope;
        this.prevScope = void 0;
      }
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i2, l2;
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].stop();
        }
        this.effects.length = 0;
        for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
          this.cleanups[i2]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub2, isComputed = false) {
    sub2.flags |= 8;
    if (isComputed) {
      sub2.next = batchedComputed;
      batchedComputed = sub2;
      return;
    }
    sub2.next = batchedSub;
    batchedSub = sub2;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e2 = batchedComputed;
      batchedComputed = void 0;
      while (e2) {
        const next2 = e2.next;
        e2.next = void 0;
        e2.flags &= -9;
        e2 = next2;
      }
    }
    let error;
    while (batchedSub) {
      let e2 = batchedSub;
      batchedSub = void 0;
      while (e2) {
        const next2 = e2.next;
        e2.next = void 0;
        e2.flags &= -9;
        if (e2.flags & 1) {
          try {
            ;
            e2.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e2 = next2;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub2) {
    for (let link = sub2.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub2) {
    let head;
    let tail = sub2.depsTail;
    let link = tail;
    while (link) {
      const prev2 = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev2;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev2;
    }
    sub2.deps = head;
    sub2.depsTail = tail;
  }
  function isDirty(sub2) {
    for (let link = sub2.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub2._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
      return;
    }
    computed2.flags |= 2;
    const dep = computed2.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2.flags |= 128;
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
          removeSub(l2, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function cleanupEffect(e2) {
    const { cleanup: cleanup2 } = e2;
    e2.cleanup = void 0;
    if (cleanup2) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup2();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub2, dep) {
      this.sub = sub2;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    // TODO isolatedDeclarations "__v_skip"
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      this.__v_skip = true;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next2 = link.nextDep;
          next2.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next2;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next2;
          }
        }
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
          addSub(l2);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target, type, key2) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key2);
      if (!dep) {
        depsMap.set(key2, dep = new Dep());
        dep.map = depsMap;
        dep.key = key2;
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target, type, key2, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray$6(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key2);
      if (targetIsArray && key2 === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key22) => {
          if (key22 === "length" || key22 === ARRAY_ITERATE_KEY || !isSymbol$1(key22) && key22 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key2 !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key2));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key2) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key2);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive$1);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator$1(this, Symbol.iterator, toReactive$1);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x2) => isArray$6(x2) ? reactiveReadArray(x2) : x2)
      );
    },
    entries() {
      return iterator$1(this, "entries", (value) => {
        value[1] = toReactive$1(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply$2(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply$2(this, "filter", fn, thisArg, (v2) => v2.map(toReactive$1), arguments);
    },
    find(fn, thisArg) {
      return apply$2(this, "find", fn, thisArg, toReactive$1, arguments);
    },
    findIndex(fn, thisArg) {
      return apply$2(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply$2(this, "findLast", fn, thisArg, toReactive$1, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply$2(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply$2(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply$2(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce$1(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce$1(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply$2(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator$1(this, "values", toReactive$1);
    }
  };
  function iterator$1(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto$2 = Array.prototype;
  function apply$2(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto$2[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive$1(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index2) {
          return fn.call(this, toReactive$1(item), index2, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index2) {
          return fn.call(this, item, index2, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce$1(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index2) {
          return fn.call(this, acc, toReactive$1(item), index2, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index2) {
          return fn.call(this, acc, item, index2, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$1)
  );
  function hasOwnProperty$h(key2) {
    if (!isSymbol$1(key2)) key2 = String(key2);
    const obj2 = toRaw(this);
    track(obj2, "has", key2);
    return obj2.hasOwnProperty(key2);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key2, receiver) {
      if (key2 === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_isShallow") {
        return isShallow2;
      } else if (key2 === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$6(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key2])) {
          return fn;
        }
        if (key2 === "hasOwnProperty") {
          return hasOwnProperty$h;
        }
      }
      const res = Reflect.get(
        target,
        key2,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key2);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key2) ? res : res.value;
      }
      if (isObject$9(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key2, value, receiver) {
      let oldValue = target[key2];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$6(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$6(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$3(target, key2);
      const result = Reflect.set(
        target,
        key2,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key2, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key2, value);
        }
      }
      return result;
    }
    deleteProperty(target, key2) {
      const hadKey = hasOwn$3(target, key2);
      target[key2];
      const result = Reflect.deleteProperty(target, key2);
      if (result && hadKey) {
        trigger(target, "delete", key2, void 0);
      }
      return result;
    }
    has(target, key2) {
      const result = Reflect.has(target, key2);
      if (!isSymbol$1(key2) || !builtInSymbols.has(key2)) {
        track(target, "has", key2);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$6(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key2) {
      return true;
    }
    deleteProperty(target, key2) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v2) => Reflect.getPrototypeOf(v2);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key2) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key2);
        if (!readonly2) {
          if (hasChanged(key2, rawKey)) {
            track(rawTarget, "get", key2);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive$1;
        if (has.call(rawTarget, key2)) {
          return wrap(target.get(key2));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key2);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key2) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key2);
        if (!readonly2) {
          if (hasChanged(key2, rawKey)) {
            track(rawTarget, "has", key2);
          }
          track(rawTarget, "has", rawKey);
        }
        return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive$1;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key2) => {
          return callback.call(thisArg, wrap(value), wrap(key2), observed);
        });
      }
    };
    extend$2(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto2 = getProto(target);
          const hadKey = proto2.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key2, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key2);
          if (!hadKey) {
            key2 = toRaw(key2);
            hadKey = has.call(target, key2);
          }
          const oldValue = get2.call(target, key2);
          target.set(key2, value);
          if (!hadKey) {
            trigger(target, "add", key2, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key2, value);
          }
          return this;
        },
        delete(key2) {
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key2);
          if (!hadKey) {
            key2 = toRaw(key2);
            hadKey = has.call(target, key2);
          }
          get2 ? get2.call(target, key2) : void 0;
          const result = target.delete(key2);
          if (hadKey) {
            trigger(target, "delete", key2, void 0);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key2, receiver) => {
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn$3(instrumentations, key2) && key2 in target ? instrumentations : target,
        key2,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$9(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn$3(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive$1 = (value) => isObject$9(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$9(value) ? readonly(value) : value;
  function isRef(r2) {
    return r2 ? r2["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef$1(value, false);
  }
  function shallowRef(value) {
    return createRef$1(value, true);
  }
  function createRef$1(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive$1(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive$1(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function triggerRef(ref2) {
    if (ref2.dep) {
      {
        ref2.dep.trigger();
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key2, receiver) => key2 === "__v_raw" ? target : unref(Reflect.get(target, key2, receiver)),
    set: (target, key2, value, receiver) => {
      const oldValue = target[key2];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key2, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$6(object) ? new Array(object.length) : {};
    for (const key2 in object) {
      ret[key2] = propertyToRef(object, key2);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  }
  function toRef(source, key2, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$5(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$9(source) && arguments.length > 1) {
      return propertyToRef(source, key2, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key2, defaultValue) {
    const val = source[key2];
    return isRef(val) ? val : new ObjectRefImpl(source, key2, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track();
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$5(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options2 = EMPTY_OBJ$1) {
    const { immediate, deep, once, scheduler, augmentJob, call: call2 } = options2;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup2;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$6(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return reactiveGetter(s2);
        } else if (isFunction$5(s2)) {
          return call2 ? call2(s2, 2) : s2();
        } else ;
      });
    } else if (isFunction$5(source)) {
      if (cb) {
        getter = call2 ? () => call2(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup2) {
            pauseTracking();
            try {
              cleanup2();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
          if (cleanup2) {
            cleanup2();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            oldValue = newValue;
            call2 ? call2(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup2 = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call2) {
          call2(cleanups, 4);
        } else {
          for (const cleanup22 of cleanups) cleanup22();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen2) {
    if (depth <= 0 || !isObject$9(value) || value["__v_skip"]) {
      return value;
    }
    seen2 = seen2 || /* @__PURE__ */ new Set();
    if (seen2.has(value)) {
      return value;
    }
    seen2.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen2);
    } else if (isArray$6(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        traverse(value[i2], depth, seen2);
      }
    } else if (isSet$1(value) || isMap$1(value)) {
      value.forEach((v2) => {
        traverse(v2, depth, seen2);
      });
    } else if (isPlainObject$3(value)) {
      for (const key2 in value) {
        traverse(value[key2], depth, seen2);
      }
      for (const key2 of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key2)) {
          traverse(value[key2], depth, seen2);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.17
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a2) => {
            var _a2, _b2;
            return (_b2 = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b2 : JSON.stringify(a2);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i2) => {
      logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open2 = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
  }
  function formatProps(props2) {
    const res = [];
    const keys2 = Object.keys(props2);
    keys2.slice(0, 3).forEach((key2) => {
      res.push(...formatProp(key2, props2[key2]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key2, value, raw) {
    if (isString$5(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key2}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key2}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key2, toRaw(value.value), true);
      return raw ? value : [`${key2}=Ref<`, value, `>`];
    } else if (isFunction$5(value)) {
      return [`${key2}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key2}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$5(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise$1(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$6(fn)) {
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ$1;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
            if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError$1(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError$1(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex$1(id) {
    let start2 = flushIndex + 1;
    let end2 = queue.length;
    while (start2 < end2) {
      const middle = start2 + end2 >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId$1(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start2 = middle + 1;
      } else {
        end2 = middle;
      }
    }
    return start2;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId$1(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId$1(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex$1(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$6(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen2, i2 = flushIndex + 1) {
    for (; i2 < queue.length; i2++) {
      const cb = queue[i2];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i2, 1);
        i2--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen2) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a2, b2) => getId$1(a2) - getId$1(b2)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId$1 = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen2) {
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs();
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev2 = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev2;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i2 = 0; i2 < directives.length; i2++) {
      let [dir3, value, arg, modifiers = EMPTY_OBJ$1] = directives[i2];
      if (dir3) {
        if (isFunction$5(dir3)) {
          dir3 = {
            mounted: dir3,
            updated: dir3
          };
        }
        if (dir3.deep) {
          traverse(value);
        }
        bindings.push({
          dir: dir3,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i2 = 0; i2 < bindings.length; i2++) {
      const binding = bindings[i2];
      if (oldBindings) {
        binding.oldValue = oldBindings[i2].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
  const isTeleportDeferred = (props2) => props2 && (props2.defer || props2.defer === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props2, select) => {
    const targetSelector = props2 && props2.to;
    if (isString$5(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder2 = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        insert(placeholder2, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace !== "svg" && isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace !== "mathml" && isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (!disabled) {
              mount(target, targetAnchor);
              updateCssVars(n2, false);
            }
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          n2.el.__isMounted = false;
          queuePostRenderEffect(() => {
            mountToTarget();
            delete n2.el.__isMounted;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          }, parentSuspense);
          return;
        }
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n2, disabled);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props: props2
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props2);
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props: props2 } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props2)) {
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          move(
            children[i2],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const disabled = isTeleportDisabled(vnode.props);
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          vnode.anchor = hydrateChildren(
            nextSibling(node2),
            vnode,
            parentNode(node2),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node2);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node2, anchor;
      if (isDisabled) {
        node2 = vnode.el;
        anchor = vnode.anchor;
      } else {
        node2 = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node2 && node2 !== anchor) {
        if (node2.nodeType === 1) node2.setAttribute("data-v-owner", ctx.uid);
        node2 = node2.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props2, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props2);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      for (const c2 of children) {
        if (c2.type !== Comment) {
          child = c2;
          break;
        }
      }
    }
    return child;
  }
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props2, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave: onLeave2,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props2;
    const key2 = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$6(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key2];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key22 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key22] === vnode) {
            delete leavingVNodesCache[key22];
          }
        };
        leavingVNodesCache[key22] = vnode;
        if (onLeave2) {
          callAsyncHook(onLeave2, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props2,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$5(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = children[i2];
      const key2 = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key2)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key2 != null ? cloneVNode(child, { key: key2 }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i2 = 0; i2 < ret.length; i2++) {
        ret[i2].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options2, extraOptions) {
    return isFunction$5(options2) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend$2({ name: options2.name }, extraOptions, { setup: options2 }))()
    ) : options2;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$6(rawRef)) {
      rawRef.forEach(
        (r2, i2) => setRef(
          r2,
          oldRawRef && (isArray$6(oldRawRef) ? oldRawRef[i2] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ$1 ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ$1 ? () => false : (key2) => {
      return hasOwn$3(rawSetupState, key2);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString$5(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$5(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$5(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$6(existing) && remove(existing, refValue);
            } else {
              if (!isArray$6(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  getGlobalThis$1().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis$1().cancelIdleCallback || ((id) => clearTimeout(id));
  const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle2) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle2 === "sp") {
      injectHook(lifecycle2, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
  }
  function renderList(source, renderItem, cache2, index2) {
    let ret;
    const cached2 = cache2;
    const sourceIsArray = isArray$6(source);
    if (sourceIsArray || isString$5(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      let isReadonlySource = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        isReadonlySource = isReadonly(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
        ret[i2] = renderItem(
          needsWrap ? isReadonlySource ? toReadonly(toReactive$1(source[i2])) : toReactive$1(source[i2]) : source[i2],
          i2,
          void 0,
          cached2
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i2 = 0; i2 < source; i2++) {
        ret[i2] = renderItem(i2 + 1, i2, void 0, cached2);
      }
    } else if (isObject$9(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i2) => renderItem(item, i2, void 0, cached2)
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
          const key2 = keys2[i2];
          ret[i2] = renderItem(source[key2], key2, i2, cached2);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  const getPublicInstance = (i2) => {
    if (!i2) return null;
    if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
    return getPublicInstance(i2.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $host: (i2) => i2.ce,
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => {
        queueJob(i2.update);
      }),
      $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
      $watch: (i2) => instanceWatch.bind(i2)
    })
  );
  const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ$1 && !state.__isScriptSetup && hasOwn$3(state, key2);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key2) {
      if (key2 === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key2[0] !== "$") {
        const n2 = accessCache[key2];
        if (n2 !== void 0) {
          switch (n2) {
            case 1:
              return setupState[key2];
            case 2:
              return data[key2];
            case 4:
              return ctx[key2];
            case 3:
              return props2[key2];
          }
        } else if (hasSetupBinding(setupState, key2)) {
          accessCache[key2] = 1;
          return setupState[key2];
        } else if (data !== EMPTY_OBJ$1 && hasOwn$3(data, key2)) {
          accessCache[key2] = 2;
          return data[key2];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$3(normalizedProps, key2)
        ) {
          accessCache[key2] = 3;
          return props2[key2];
        } else if (ctx !== EMPTY_OBJ$1 && hasOwn$3(ctx, key2)) {
          accessCache[key2] = 4;
          return ctx[key2];
        } else if (shouldCacheAccess) {
          accessCache[key2] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key2];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key2 === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key2])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ$1 && hasOwn$3(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$3(globalProperties, key2)
      ) {
        {
          return globalProperties[key2];
        }
      } else ;
    },
    set({ _: instance }, key2, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key2)) {
        setupState[key2] = value;
        return true;
      } else if (data !== EMPTY_OBJ$1 && hasOwn$3(data, key2)) {
        data[key2] = value;
        return true;
      } else if (hasOwn$3(instance.props, key2)) {
        return false;
      }
      if (key2[0] === "$" && key2.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key2] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key2) {
      let normalizedProps;
      return !!accessCache[key2] || data !== EMPTY_OBJ$1 && hasOwn$3(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$3(normalizedProps, key2) || hasOwn$3(ctx, key2) || hasOwn$3(publicPropertiesMap, key2) || hasOwn$3(appContext.config.globalProperties, key2);
    },
    defineProperty(target, key2, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key2] = 0;
      } else if (hasOwn$3(descriptor, "value")) {
        this.set(target, key2, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key2, descriptor);
    }
  };
  function normalizePropsOrEmits(props2) {
    return isArray$6(props2) ? props2.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props2;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options2 = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options2.beforeCreate) {
      callHook$1(options2.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options2;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key2 in methods) {
        const methodHandler = methods[key2];
        if (isFunction$5(methodHandler)) {
          {
            ctx[key2] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$9(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key2 in computedOptions) {
        const opt = computedOptions[key2];
        const get2 = isFunction$5(opt) ? opt.bind(publicThis, publicThis) : isFunction$5(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$5(opt) && isFunction$5(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c2 = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => c2.value,
          set: (v2) => c2.value = v2
        });
      }
    }
    if (watchOptions) {
      for (const key2 in watchOptions) {
        createWatcher(watchOptions[key2], ctx, publicThis, key2);
      }
    }
    if (provideOptions) {
      const provides = isFunction$5(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key2) => {
        provide(key2, provides[key2]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register2, hook) {
      if (isArray$6(hook)) {
        hook.forEach((_hook) => register2(_hook.bind(publicThis)));
      } else if (hook) {
        register2(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$6(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key2) => {
          Object.defineProperty(exposed, key2, {
            get: () => publicThis[key2],
            set: (val) => publicThis[key2] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$6(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key2 in injectOptions) {
      const opt = injectOptions[key2];
      let injected;
      if (isObject$9(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key2,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key2);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$6(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key2) {
    let getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
    if (isString$5(raw)) {
      const handler = ctx[raw];
      if (isFunction$5(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$5(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$9(raw)) {
      if (isArray$6(raw)) {
        raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
      } else {
        const handler = isFunction$5(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$5(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base2 = instance.type;
    const { mixins, extends: extendsOptions } = base2;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached2 = cache2.get(base2);
    let resolved;
    if (cached2) {
      resolved = cached2;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base2;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
        );
      }
      mergeOptions$1(resolved, base2, optionMergeStrategies);
    }
    if (isObject$9(base2)) {
      cache2.set(base2, resolved);
    }
    return resolved;
  }
  function mergeOptions$1(to, from2, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from2;
    if (extendsOptions) {
      mergeOptions$1(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m2) => mergeOptions$1(to, m2, strats, true)
      );
    }
    for (const key2 in from2) {
      if (asMixin && key2 === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
        to[key2] = strat ? strat(to[key2], from2[key2]) : from2[key2];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from2) {
    if (!from2) {
      return to;
    }
    if (!to) {
      return from2;
    }
    return function mergedDataFn() {
      return extend$2(
        isFunction$5(to) ? to.call(this, this) : to,
        isFunction$5(from2) ? from2.call(this, this) : from2
      );
    };
  }
  function mergeInject(to, from2) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
  }
  function normalizeInject(raw) {
    if (isArray$6(raw)) {
      const res = {};
      for (let i2 = 0; i2 < raw.length; i2++) {
        res[raw[i2]] = raw[i2];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from2) {
    return to ? [...new Set([].concat(to, from2))] : from2;
  }
  function mergeObjectOptions(to, from2) {
    return to ? extend$2(/* @__PURE__ */ Object.create(null), to, from2) : from2;
  }
  function mergeEmitsOrPropsOptions(to, from2) {
    if (to) {
      if (isArray$6(to) && isArray$6(from2)) {
        return [.../* @__PURE__ */ new Set([...to, ...from2])];
      }
      return extend$2(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from2 != null ? from2 : {})
      );
    } else {
      return from2;
    }
  }
  function mergeWatchOptions(to, from2) {
    if (!to) return from2;
    if (!from2) return to;
    const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
    for (const key2 in from2) {
      merged[key2] = mergeAsArray(to[key2], from2[key2]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$5(rootComponent)) {
        rootComponent = extend$2({}, rootComponent);
      }
      if (rootProps != null && !isObject$9(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app2 = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version: version$3,
        get config() {
          return context.config;
        },
        set config(v2) {
        },
        use(plugin, ...options2) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$5(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app2, ...options2);
          } else if (isFunction$5(plugin)) {
            installedPlugins.add(plugin);
            plugin(app2, ...options2);
          } else ;
          return app2;
        },
        mixin(mixin2) {
          {
            if (!context.mixins.includes(mixin2)) {
              context.mixins.push(mixin2);
            }
          }
          return app2;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app2;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app2;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app2._container = rootContainer;
            rootContainer.__vue_app__ = app2;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app2._instance,
              16
            );
            render2(null, app2._container);
            delete app2._container.__vue_app__;
          }
        },
        provide(key2, value) {
          context.provides[key2] = value;
          return app2;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app2;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app2;
    };
  }
  let currentApp = null;
  function provide(key2, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key2] = value;
    }
  }
  function inject(key2, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key2 in provides) {
        return provides[key2];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$5(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj2) => Object.getPrototypeOf(obj2) === internalObjectProto;
  function initProps$1(instance, rawProps, isStateful, isSSR = false) {
    const props2 = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props2, attrs);
    for (const key2 in instance.propsOptions[0]) {
      if (!(key2 in props2)) {
        props2[key2] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props2 : shallowReactive(props2);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props2;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps$2(instance, rawProps, rawPrevProps, optimized) {
    const {
      props: props2,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props2);
    const [options2] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
          let key2 = propsToUpdate[i2];
          if (isEmitListener(instance.emitsOptions, key2)) {
            continue;
          }
          const value = rawProps[key2];
          if (options2) {
            if (hasOwn$3(attrs, key2)) {
              if (value !== attrs[key2]) {
                attrs[key2] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize$1(key2);
              props2[camelizedKey] = resolvePropValue$1(
                options2,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props2, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key2 in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn$3(rawProps, key2) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate$1(key2)) === key2 || !hasOwn$3(rawProps, kebabKey))) {
          if (options2) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key2] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props2[key2] = resolvePropValue$1(
                options2,
                rawCurrentProps,
                key2,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props2[key2];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key2 in attrs) {
          if (!rawProps || !hasOwn$3(rawProps, key2) && true) {
            delete attrs[key2];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props2, attrs) {
    const [options2, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key2 in rawProps) {
        if (isReservedProp(key2)) {
          continue;
        }
        const value = rawProps[key2];
        let camelKey;
        if (options2 && hasOwn$3(options2, camelKey = camelize$1(key2))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props2[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key2)) {
          if (!(key2 in attrs) || value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props2);
      const castValues = rawCastValues || EMPTY_OBJ$1;
      for (let i2 = 0; i2 < needCastKeys.length; i2++) {
        const key2 = needCastKeys[i2];
        props2[key2] = resolvePropValue$1(
          options2,
          rawCurrentProps,
          key2,
          castValues[key2],
          instance,
          !hasOwn$3(castValues, key2)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue$1(options2, props2, key2, value, instance, isAbsent) {
    const opt = options2[key2];
    if (opt != null) {
      const hasDefault = hasOwn$3(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$5(defaultValue)) {
          const { propsDefaults } = instance;
          if (key2 in propsDefaults) {
            value = propsDefaults[key2];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key2] = defaultValue.call(
              null,
              props2
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key2, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate$1(key2))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached2 = cache2.get(comp);
    if (cached2) {
      return cached2;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$5(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props2, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend$2(normalized, props2);
        if (keys2) needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$9(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$6(raw)) {
      for (let i2 = 0; i2 < raw.length; i2++) {
        const normalizedKey = camelize$1(raw[i2]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ$1;
        }
      }
    } else if (raw) {
      for (const key2 in raw) {
        const normalizedKey = camelize$1(key2);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key2];
          const prop = normalized[normalizedKey] = isArray$6(opt) || isFunction$5(opt) ? { type: opt } : extend$2({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$6(propType)) {
            for (let index2 = 0; index2 < propType.length; ++index2) {
              const type = propType[index2];
              const typeName = isFunction$5(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$5(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn$3(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$9(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key2) {
    if (key2[0] !== "$" && !isReservedProp(key2)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
  const normalizeSlotValue = (value) => isArray$6(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot$1 = (key2, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key2 in rawSlots) {
      if (isInternalKey(key2)) continue;
      const value = rawSlots[key2];
      if (isFunction$5(value)) {
        slots[key2] = normalizeSlot$1(key2, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key2] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key2 in children) {
      if (optimized || !isInternalKey(key2)) {
        slots[key2] = children[key2];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const cacheIndexes = children.__;
      if (cacheIndexes) def(slots, "__", cacheIndexes, true);
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ$1;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key2 in slots) {
        if (!isInternalKey(key2) && deletionComparisonTarget[key2] == null) {
          delete slots[key2];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options2) {
    return baseCreateRenderer(options2);
  }
  function baseCreateRenderer(options2, createHydrationFns) {
    const target = getGlobalThis$1();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options2;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      } else if (ref3 == null && n1 && n1.ref != null) {
        setRef(n1.ref, null, parentSuspense, n1, true);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next2;
      while (el && el !== anchor) {
        next2 = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next2;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next2;
      while (el && el !== anchor) {
        next2 = hostNextSibling(el);
        hostRemove(el);
        el = next2;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props: props2, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props2 && props2.is,
        props2
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props2) {
        for (const key2 in props2) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(el, key2, null, props2[key2], namespace, parentComponent);
          }
        }
        if ("value" in props2) {
          hostPatchProp(el, "value", null, props2.value, namespace);
        }
        if (vnodeHook = props2.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
          hostSetScopeId(el, slotScopeIds[i2]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
      for (let i2 = start2; i2 < children.length; i2++) {
        const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ$1;
      const newProps = n2.props || EMPTY_OBJ$1;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              const key2 = propsToUpdate[i2];
              const prev2 = oldProps[key2];
              const next2 = newProps[key2];
              if (next2 !== prev2 || key2 === "value") {
                hostPatchProp(el, key2, prev2, next2, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i2 = 0; i2 < newChildren.length; i2++) {
        const oldVNode = oldChildren[i2];
        const newVNode = newChildren[i2];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ$1) {
          for (const key2 in oldProps) {
            if (!isReservedProp(key2) && !(key2 in newProps)) {
              hostPatchProp(
                el,
                key2,
                oldProps[key2],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key2 in newProps) {
          if (isReservedProp(key2)) continue;
          const next2 = newProps[key2];
          const prev2 = oldProps[key2];
          if (next2 !== prev2 && key2 !== "value") {
            hostPatchProp(el, key2, prev2, next2, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder2 = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder2, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props: props2 } = initialVNode;
          const { bm, m: m2, parent: parent2, root: root2, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent2, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root2.ce && // @ts-expect-error _def is private
            root2.ce._def.shadowRoot !== false) {
              root2.ce._injectChildStyle(type);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m2) {
            queuePostRenderEffect(m2, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next: next2, bu, u: u2, parent: parent2, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next2) {
                next2.el = vnode.el;
                updateComponentPreRender(instance, next2, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next2;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next2) {
            next2.el = vnode.el;
            updateComponentPreRender(instance, next2, optimized);
          } else {
            next2 = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent2, next2, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next2.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u2) {
            queuePostRenderEffect(u2, parentSuspense);
          }
          if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, next2, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps$2(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i2;
      for (i2 = 0; i2 < commonLength; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        patch(
          c1[i2],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i2 = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[i2];
        const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i2++;
      }
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i2 > e1) {
        if (i2 <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i2 <= e2) {
            patch(
              null,
              c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i2++;
          }
        }
      } else if (i2 > e2) {
        while (i2 <= e1) {
          unmount(c1[i2], parentComponent, parentSuspense, true);
          i2++;
        }
      } else {
        const s1 = i2;
        const s2 = i2;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i2 = s2; i2 <= e2; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i2);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
        for (i2 = s1; i2 <= e1; i2++) {
          const prevChild = c1[i2];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s2; j2 <= e2; j2++) {
              if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i2 = toBePatched - 1; i2 >= 0; i2--) {
          const nextIndex = s2 + i2;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i2] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i2 = 0; i2 < children.length; i2++) {
          move(children[i2], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => {
            if (vnode.ctx.isUnmounted) {
              hostRemove(el);
            } else {
              hostInsert(el, container, anchor);
            }
          };
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props: props2,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        pauseTracking();
        setRef(ref3, null, parentSuspense, vnode, true);
        resetTracking();
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end2) => {
      let next2;
      while (cur !== end2) {
        next2 = hostNextSibling(cur);
        hostRemove(cur);
        cur = next2;
      }
      hostRemove(end2);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const {
        bum,
        scope,
        job,
        subTree,
        um,
        m: m2,
        a: a2,
        parent: parent2,
        slots: { __: slotCacheKeys }
      } = instance;
      invalidateMount(m2);
      invalidateMount(a2);
      if (bum) {
        invokeArrayFns(bum);
      }
      if (parent2 && isArray$6(slotCacheKeys)) {
        slotCacheKeys.forEach((v2) => {
          parent2.renderCache[v2] = void 0;
        });
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
      for (let i2 = start2; i2 < children.length; i2++) {
        unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options2
    };
    let hydrate;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2)
    };
  }
  function resolveChildrenNamespace({ type, props: props2 }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props2 && props2.encoding && props2.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$6(ch1) && isArray$6(ch2)) {
      for (let i2 = 0; i2 < ch1.length; i2++) {
        const c1 = ch1[i2];
        let c2 = ch2[i2];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i2, j2, u2, v2, c2;
    const len2 = arr.length;
    for (i2 = 0; i2 < len2; i2++) {
      const arrI = arr[i2];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p2[i2] = j2;
          result.push(i2);
          continue;
        }
        u2 = 0;
        v2 = result.length - 1;
        while (u2 < v2) {
          c2 = u2 + v2 >> 1;
          if (arr[result[c2]] < arrI) {
            u2 = c2 + 1;
          } else {
            v2 = c2;
          }
        }
        if (arrI < arr[result[u2]]) {
          if (u2 > 0) {
            p2[i2] = result[u2 - 1];
          }
          result[u2] = i2;
        }
      }
    }
    u2 = result.length;
    v2 = result[u2 - 1];
    while (u2-- > 0) {
      result[u2] = v2;
      v2 = p2[v2];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i2 = 0; i2 < hooks.length; i2++)
        hooks[i2].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watchEffect(effect2, options2) {
    return doWatch(effect2, null, options2);
  }
  function watch(source, cb, options2) {
    return doWatch(source, cb, options2);
  }
  function doWatch(source, cb, options2 = EMPTY_OBJ$1) {
    const { immediate, deep, flush, once } = options2;
    const baseWatchOptions = extend$2({}, options2);
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options2) {
    const publicThis = this.proxy;
    const getter = isString$5(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$5(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options2 = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options2);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i2 = 0; i2 < segments.length && cur; i2++) {
        cur = cur[segments[i2]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props2, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props2.modelModifiers : props2[`${modelName}Modifiers`] || props2[`${camelize$1(modelName)}Modifiers`] || props2[`${hyphenate$1(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props2 = instance.vnode.props || EMPTY_OBJ$1;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props2, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a2) => isString$5(a2) ? a2.trim() : a2);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props2[handlerName = toHandlerKey(camelize$1(event))];
    if (!handler && isModelListener2) {
      handler = props2[handlerName = toHandlerKey(hyphenate$1(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props2[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached2 = cache2.get(comp);
    if (cached2 !== void 0) {
      return cached2;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$5(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$2(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$9(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray$6(raw)) {
      raw.forEach((key2) => normalized[key2] = null);
    } else {
      extend$2(normalized, raw);
    }
    if (isObject$9(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options2, key2) {
    if (!options2 || !isOn$1(key2)) {
      return false;
    }
    key2 = key2.slice(2).replace(/Once$/, "");
    return hasOwn$3(options2, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$3(options2, hyphenate$1(key2)) || hasOwn$3(options2, key2);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props: props2,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev2 = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key2, receiver) {
            warn$1(
              `Property '${String(
                key2
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key2, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props2) : props2,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props2) : props2,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props2) : props2,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2, null, false, true);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      setTransitionHooks(root2, vnode.transition);
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev2);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key2 in attrs) {
      if (key2 === "class" || key2 === "style" || isOn$1(key2)) {
        (res || (res = {}))[key2] = attrs[key2];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props2) => {
    const res = {};
    for (const key2 in attrs) {
      if (!isModelListener(key2) || !(key2.slice(9) in props2)) {
        res[key2] = attrs[key2];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i2 = 0; i2 < dynamicProps.length; i2++) {
          const key2 = dynamicProps[i2];
          if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i2 = 0; i2 < nextKeys.length; i2++) {
      const key2 = nextKeys[i2];
      if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent: parent2 }, el) {
    while (parent2) {
      const root2 = parent2.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent2.vnode).el = el;
        parent2 = parent2.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$6(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props2,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props2, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props2,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode$1(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$5(ref3) || isRef(ref3) || isFunction$5(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props: props2,
      key: props2 && normalizeKey(props2),
      ref: props2 && normalizeRef(props2),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$5(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode$1(type)) {
      const cloned = cloneVNode(
        type,
        props2,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props2) {
      props2 = guardReactiveProps(props2);
      let { class: klass, style } = props2;
      if (klass && !isString$5(klass)) {
        props2.class = normalizeClass(klass);
      }
      if (isObject$9(style)) {
        if (isProxy(style) && !isArray$6(style)) {
          style = extend$2({}, style);
        }
        props2.style = normalizeStyle$2(style);
      }
    }
    const shapeFlag = isString$5(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$9(type) ? 4 : isFunction$5(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props2) {
    if (!props2) return null;
    return isProxy(props2) || isInternalObject(props2) ? extend$2({}, props2) : props2;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props: props2, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$6(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$6(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode$1(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$6(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$5(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMerge = args[i2];
      for (const key2 in toMerge) {
        if (key2 === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key2 === "style") {
          ret.style = normalizeStyle$2([ret.style, toMerge.style]);
        } else if (isOn$1(key2)) {
          const existing = ret[key2];
          const incoming = toMerge[key2];
          if (incoming && existing !== incoming && !(isArray$6(existing) && existing.includes(incoming))) {
            ret[key2] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key2 !== "") {
          ret[key2] = toMerge[key2];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent2, suspense) {
    const type = vnode.type;
    const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent: parent2,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent2 ? parent2.provides : Object.create(appContext.provides),
      ids: parent2 ? parent2.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ$1,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ$1,
      data: EMPTY_OBJ$1,
      props: EMPTY_OBJ$1,
      attrs: EMPTY_OBJ$1,
      slots: EMPTY_OBJ$1,
      refs: EMPTY_OBJ$1,
      setupState: EMPTY_OBJ$1,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent2 ? parent2.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g2 = getGlobalThis$1();
    const registerGlobalSetter = (key2, setter) => {
      let setters;
      if (!(setters = g2[key2])) setters = g2[key2] = [];
      setters.push(setter);
      return (v2) => {
        if (setters.length > 1) setters.forEach((set2) => set2(v2));
        else setters[0](v2);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v2) => isInSSRComponentSetup = v2
    );
  }
  const setCurrentInstance = (instance) => {
    const prev2 = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev2);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props: props2, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps$1(instance, props2, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise$1(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult);
          }).catch((e2) => {
            handleError(e2, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult);
      }
    } else {
      finishComponentSetup(instance);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$5(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$9(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance);
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key2) {
      track(target, "get", "");
      return target[key2];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key2) {
          if (key2 in target) {
            return target[key2];
          } else if (key2 in publicPropertiesMap) {
            return publicPropertiesMap[key2](instance);
          }
        },
        has(target, key2) {
          return key2 in target || key2 in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$5(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match2) {
        name = match2[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key2 in registry) {
          if (registry[key2] === Component) {
            return key2;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$5(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c2;
  };
  function h$1(type, propsOrChildren, children) {
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$9(propsOrChildren) && !isArray$6(propsOrChildren)) {
        if (isVNode$1(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode$1(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  const version$3 = "3.5.17";
  /**
  * @vue/runtime-dom v3.5.17
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e2) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent2, anchor) => {
      parent2.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent2 = child.parentNode;
      if (parent2) {
        parent2.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props2) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props2 && props2.multiple != null) {
        el.setAttribute("multiple", props2.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node2, text) => {
      node2.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node2) => node2.parentNode,
    nextSibling: (node2) => node2.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent2, anchor, namespace, start2, end2) {
      const before = anchor ? anchor.previousSibling : parent2.lastChild;
      if (start2 && (start2 === end2 || start2.nextSibling)) {
        while (true) {
          parent2.insertBefore(start2.cloneNode(true), anchor);
          if (start2 === end2 || !(start2 = start2.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent2.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent2.firstChild,
        // last
        anchor ? anchor.previousSibling : parent2.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = /* @__PURE__ */ extend$2(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const decorate$1 = (t2) => {
    t2.displayName = "Transition";
    t2.props = TransitionPropsValidators;
    return t2;
  };
  const Transition = /* @__PURE__ */ decorate$1(
    (props2, { slots }) => h$1(BaseTransition, resolveTransitionProps(props2), slots)
  );
  const callHook = (hook, args = []) => {
    if (isArray$6(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$6(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key2 in rawProps) {
      if (!(key2 in DOMTransitionPropsValidators)) {
        baseProps[key2] = rawProps[key2];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave: onLeave2,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled) => {
      el._enterCancelled = isCancelled;
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend$2(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        if (!el._enterCancelled) {
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
        } else {
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
        }
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave2)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave2, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false, void 0, true);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true, void 0, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$9(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n2 = NumberOf(duration);
      return [n2, n2];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end2 = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e2) => {
      if (e2.target === el && ++ended >= propCount) {
        end2();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end2();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
  }
  function toMs(s2) {
    if (s2 === "auto") return 0;
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev2, next2) {
    const style = el.style;
    const isCssString = isString$5(next2);
    let hasControlledDisplay = false;
    if (next2 && !isCssString) {
      if (prev2) {
        if (!isString$5(prev2)) {
          for (const key2 in prev2) {
            if (next2[key2] == null) {
              setStyle(style, key2, "");
            }
          }
        } else {
          for (const prevStyle of prev2.split(";")) {
            const key2 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next2[key2] == null) {
              setStyle(style, key2, "");
            }
          }
        }
      }
      for (const key2 in next2) {
        if (key2 === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key2, next2[key2]);
      }
    } else {
      if (isCssString) {
        if (prev2 !== next2) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next2 += ";" + cssVarText;
          }
          style.cssText = next2;
          hasControlledDisplay = displayRE.test(next2);
        }
      } else if (prev2) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$6(val)) {
      val.forEach((v2) => setStyle(style, name, v2));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate$1(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached2 = prefixCache[rawName];
    if (cached2) {
      return cached2;
    }
    let name = camelize$1(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      const prefixed = prefixes[i2] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key2, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key2)) {
    if (isSVG && key2.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
      } else {
        el.setAttributeNS(xlinkNS, key2, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key2);
      } else {
        el.setAttribute(
          key2,
          isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key2, value, parentComponent, attrName) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      if (value != null) {
        el[key2] = key2 === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key2 === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key2);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key2];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key2] = value;
    } catch (e2) {
    }
    needRemove && el.removeAttribute(attrName || key2);
  }
  function addEventListener$1(el, event, handler, options2) {
    el.addEventListener(event, handler, options2);
  }
  function removeEventListener$1(el, event, handler, options2) {
    el.removeEventListener(event, handler, options2);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options2] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener$1(el, name, invoker, options2);
      } else if (existingInvoker) {
        removeEventListener$1(el, name, existingInvoker, options2);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options2;
    if (optionsModifierRE.test(name)) {
      options2 = {};
      let m2;
      while (m2 = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m2[0].length);
        options2[m2[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate$1(name.slice(2));
    return [event, options2];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e2) => {
      if (!e2._vts) {
        e2._vts = Date.now();
      } else if (e2._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e2, invoker.value),
        instance,
        5,
        [e2]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e2, value) {
    if (isArray$6(value)) {
      const originalStop = e2.stopImmediatePropagation;
      e2.stopImmediatePropagation = () => {
        originalStop.call(e2);
        e2._stopped = true;
      };
      return value.map(
        (fn) => (e22) => !e22._stopped && fn && fn(e22)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // lowercase letter
  key2.charCodeAt(2) > 96 && key2.charCodeAt(2) < 123;
  const patchProp = (el, key2, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key2 === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key2 === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn$1(key2)) {
      if (!isModelListener(key2)) {
        patchEvent(el, key2, prevValue, nextValue, parentComponent);
      }
    } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
      patchDOMProp(el, key2, nextValue);
      if (!el.tagName.includes("-") && (key2 === "value" || key2 === "checked" || key2 === "selected")) {
        patchAttr(el, key2, nextValue, isSVG, parentComponent, key2 !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key2) || !isString$5(nextValue))
    ) {
      patchDOMProp(el, camelize$1(key2), nextValue, parentComponent, key2);
    } else {
      if (key2 === "true-value") {
        el._trueValue = nextValue;
      } else if (key2 === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key2, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key2, value, isSVG) {
    if (isSVG) {
      if (key2 === "innerHTML" || key2 === "textContent") {
        return true;
      }
      if (key2 in el && isNativeOn(key2) && isFunction$5(value)) {
        return true;
      }
      return false;
    }
    if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate" || key2 === "autocorrect") {
      return false;
    }
    if (key2 === "form") {
      return false;
    }
    if (key2 === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key2 === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key2 === "width" || key2 === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key2) && isString$5(value)) {
      return false;
    }
    return key2 in el;
  }
  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = Symbol("_moveCb");
  const enterCbKey = Symbol("_enterCb");
  const decorate = (t2) => {
    delete t2.props.mode;
    return t2;
  };
  const TransitionGroupImpl = /* @__PURE__ */ decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props2, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          prevChildren = [];
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c2) => {
          const el = c2.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e2) => {
            if (e2 && e2.target !== el) {
              return;
            }
            if (!e2 || /transform$/.test(e2.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
        prevChildren = [];
      });
      return () => {
        const rawProps = toRaw(props2);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(
                child,
                child.el.getBoundingClientRect()
              );
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          }
        }
        return createVNode(tag, null, children);
      };
    }
  });
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c2) {
    const el = c2.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c2) {
    newPositionMap.set(c2, c2.el.getBoundingClientRect());
  }
  function applyTranslation(c2) {
    const oldPos = positionMap.get(c2);
    const newPos = newPositionMap.get(c2);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c2.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c2;
    }
  }
  function hasCSSTransform(el, root2, moveClass) {
    const clone2 = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
      });
    }
    moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
    clone2.style.display = "none";
    const container = root2.nodeType === 1 ? root2 : root2.parentNode;
    container.appendChild(clone2);
    const { hasTransform } = getTransitionInfo(clone2);
    container.removeChild(clone2);
    return hasTransform;
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e2) => e2.stopPropagation(),
    prevent: (e2) => e2.preventDefault(),
    self: (e2) => e2.target !== e2.currentTarget,
    ctrl: (e2) => !e2.ctrlKey,
    shift: (e2) => !e2.shiftKey,
    alt: (e2) => !e2.altKey,
    meta: (e2) => !e2.metaKey,
    left: (e2) => "button" in e2 && e2.button !== 0,
    middle: (e2) => "button" in e2 && e2.button !== 1,
    right: (e2) => "button" in e2 && e2.button !== 2,
    exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
  };
  const withModifiers = (fn, modifiers) => {
    const cache2 = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
      for (let i2 = 0; i2 < modifiers.length; i2++) {
        const guard = modifierGuards[modifiers[i2]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn(event, ...args);
    });
  };
  const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const render$2 = (...args) => {
    ensureRenderer().render(...args);
  };
  const createApp = (...args) => {
    const app2 = ensureRenderer().createApp(...args);
    const { mount } = app2;
    app2.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app2._component;
      if (!isFunction$5(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app2;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString$5(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  /*!
   * pinia v3.0.3
   * (c) 2025 Eduardo San Martin Morote
   * @license MIT
   */
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app2) {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      },
      use(plugin) {
        if (!this._a) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var helper$1 = {};
  /*!
   * vite-plugin-qiankun.js v1.0.14
   * (c) 2021-2022 Teng Mao Qing
   * Released under the MIT License.
   */
  var hasRequiredHelper;
  function requireHelper() {
    if (hasRequiredHelper) return helper$1;
    hasRequiredHelper = 1;
    Object.defineProperty(helper$1, "__esModule", { value: true });
    var qiankunWindow = typeof window !== "undefined" ? window.proxy || window : {};
    var renderWithQiankun = function(qiankunLifeCycle) {
      if (qiankunWindow === null || qiankunWindow === void 0 ? void 0 : qiankunWindow.__POWERED_BY_QIANKUN__) {
        if (!window.moudleQiankunAppLifeCycles) {
          window.moudleQiankunAppLifeCycles = {};
        }
        if (qiankunWindow.qiankunName) {
          window.moudleQiankunAppLifeCycles[qiankunWindow.qiankunName] = qiankunLifeCycle;
        }
      }
    };
    helper$1.default = renderWithQiankun;
    helper$1.qiankunWindow = qiankunWindow;
    helper$1.renderWithQiankun = renderWithQiankun;
    return helper$1;
  }
  var helperExports = requireHelper();
  const enUS = {
    // Options.jsx
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "",
    // Pagination.jsx
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages"
  };
  function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t2 = arguments[e2];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends$1.apply(null, arguments);
  }
  const locale$6 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "Ok",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: true,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  };
  const locale$5 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  const locale$4 = {
    lang: _extends$1({
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"]
    }, locale$6),
    timePickerLocale: _extends$1({}, locale$5)
  };
  const typeTemplate$2 = "${label} is not a valid ${type}";
  const localeValues$1 = {
    locale: "en",
    Pagination: enUS,
    DatePicker: locale$4,
    TimePicker: locale$5,
    Calendar: locale$4,
    global: {
      placeholder: "Please select"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand"
    },
    PageHeader: {
      back: "Back"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate$2,
          method: typeTemplate$2,
          array: typeTemplate$2,
          object: typeTemplate$2,
          number: typeTemplate$2,
          date: typeTemplate$2,
          boolean: typeTemplate$2,
          integer: typeTemplate$2,
          float: typeTemplate$2,
          regexp: typeTemplate$2,
          email: typeTemplate$2,
          url: typeTemplate$2,
          hex: typeTemplate$2
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    Image: {
      preview: "Preview"
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned"
    }
  };
  const LOCALE = {
    // Options.jsx
    items_per_page: "条/页",
    jump_to: "跳至",
    jump_to_confirm: "确定",
    page: "页",
    // Pagination.jsx
    prev_page: "上一页",
    next_page: "下一页",
    prev_5: "向前 5 页",
    next_5: "向后 5 页",
    prev_3: "向前 3 页",
    next_3: "向后 3 页"
  };
  const locale$3 = {
    locale: "zh_CN",
    today: "今天",
    now: "此刻",
    backToToday: "返回今天",
    ok: "确定",
    timeSelect: "选择时间",
    dateSelect: "选择日期",
    weekSelect: "选择周",
    clear: "清除",
    month: "月",
    year: "年",
    previousMonth: "上个月 (翻页上键)",
    nextMonth: "下个月 (翻页下键)",
    monthSelect: "选择月份",
    yearSelect: "选择年份",
    decadeSelect: "选择年代",
    yearFormat: "YYYY年",
    dayFormat: "D日",
    dateFormat: "YYYY年M月D日",
    dateTimeFormat: "YYYY年M月D日 HH时mm分ss秒",
    previousYear: "上一年 (Control键加左方向键)",
    nextYear: "下一年 (Control键加右方向键)",
    previousDecade: "上一年代",
    nextDecade: "下一年代",
    previousCentury: "上一世纪",
    nextCentury: "下一世纪"
  };
  const locale$2 = {
    placeholder: "请选择时间",
    rangePlaceholder: ["开始时间", "结束时间"]
  };
  const locale$1 = {
    lang: _extends$1({
      placeholder: "请选择日期",
      yearPlaceholder: "请选择年份",
      quarterPlaceholder: "请选择季度",
      monthPlaceholder: "请选择月份",
      weekPlaceholder: "请选择周",
      rangePlaceholder: ["开始日期", "结束日期"],
      rangeYearPlaceholder: ["开始年份", "结束年份"],
      rangeMonthPlaceholder: ["开始月份", "结束月份"],
      rangeQuarterPlaceholder: ["开始季度", "结束季度"],
      rangeWeekPlaceholder: ["开始周", "结束周"]
    }, locale$3),
    timePickerLocale: _extends$1({}, locale$2)
  };
  locale$1.lang.ok = "确定";
  const typeTemplate$1 = "${label}不是一个有效的${type}";
  const localeValues = {
    locale: "zh-cn",
    Pagination: LOCALE,
    DatePicker: locale$1,
    TimePicker: locale$2,
    Calendar: locale$1,
    // locales for all components
    global: {
      placeholder: "请选择"
    },
    Table: {
      filterTitle: "筛选",
      filterConfirm: "确定",
      filterReset: "重置",
      filterEmptyText: "无筛选项",
      filterCheckall: "全选",
      filterSearchPlaceholder: "在筛选项中搜索",
      selectAll: "全选当页",
      selectInvert: "反选当页",
      selectNone: "清空所有",
      selectionAll: "全选所有",
      sortTitle: "排序",
      expand: "展开行",
      collapse: "关闭行",
      triggerDesc: "点击降序",
      triggerAsc: "点击升序",
      cancelSort: "取消排序"
    },
    Tour: {
      Next: "下一步",
      Previous: "上一步",
      Finish: "结束导览"
    },
    Modal: {
      okText: "确定",
      cancelText: "取消",
      justOkText: "知道了"
    },
    Popconfirm: {
      cancelText: "取消",
      okText: "确定"
    },
    Transfer: {
      searchPlaceholder: "请输入搜索内容",
      itemUnit: "项",
      itemsUnit: "项",
      remove: "删除",
      selectCurrent: "全选当页",
      removeCurrent: "删除当页",
      selectAll: "全选所有",
      removeAll: "删除全部",
      selectInvert: "反选当页"
    },
    Upload: {
      uploading: "文件上传中",
      removeFile: "删除文件",
      uploadError: "上传错误",
      previewFile: "预览文件",
      downloadFile: "下载文件"
    },
    Empty: {
      description: "暂无数据"
    },
    Icon: {
      icon: "图标"
    },
    Text: {
      edit: "编辑",
      copy: "复制",
      copied: "复制成功",
      expand: "展开"
    },
    PageHeader: {
      back: "返回"
    },
    Form: {
      optional: "（可选）",
      defaultValidateMessages: {
        default: "字段验证错误${label}",
        required: "请输入${label}",
        enum: "${label}必须是其中一个[${enum}]",
        whitespace: "${label}不能为空字符",
        date: {
          format: "${label}日期格式无效",
          parse: "${label}不能转换为日期",
          invalid: "${label}是一个无效日期"
        },
        types: {
          string: typeTemplate$1,
          method: typeTemplate$1,
          array: typeTemplate$1,
          object: typeTemplate$1,
          number: typeTemplate$1,
          date: typeTemplate$1,
          boolean: typeTemplate$1,
          integer: typeTemplate$1,
          float: typeTemplate$1,
          regexp: typeTemplate$1,
          email: typeTemplate$1,
          url: typeTemplate$1,
          hex: typeTemplate$1
        },
        string: {
          len: "${label}须为${len}个字符",
          min: "${label}最少${min}个字符",
          max: "${label}最多${max}个字符",
          range: "${label}须在${min}-${max}字符之间"
        },
        number: {
          len: "${label}必须等于${len}",
          min: "${label}最小值为${min}",
          max: "${label}最大值为${max}",
          range: "${label}须在${min}-${max}之间"
        },
        array: {
          len: "须为${len}个${label}",
          min: "最少${min}个${label}",
          max: "最多${max}个${label}",
          range: "${label}数量须在${min}-${max}之间"
        },
        pattern: {
          mismatch: "${label}与模式不匹配${pattern}"
        }
      }
    },
    Image: {
      preview: "预览"
    },
    QRCode: {
      expired: "二维码已过期",
      refresh: "点击刷新",
      scanned: "已扫描"
    }
  };
  var dayjs_min$1 = { exports: {} };
  var dayjs_min = dayjs_min$1.exports;
  var hasRequiredDayjs_min;
  function requireDayjs_min() {
    if (hasRequiredDayjs_min) return dayjs_min$1.exports;
    hasRequiredDayjs_min = 1;
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(dayjs_min, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date()) return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S2 = function(t3) {
          return t3 instanceof _2 || !(!t3 || !t3[p2]);
        }, w2 = function t3(e3, n3, r3) {
          var i3;
          if (!e3) return g2;
          if ("string" == typeof e3) {
            var s3 = e3.toLowerCase();
            D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1) return t3(u3[0]);
          } else {
            var a3 = e3.name;
            D2[a3] = e3, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, O2 = function(t3, e3) {
          if (S2(t3)) return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _2(n3);
        }, b2 = v2;
        b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
          return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _2 = function() {
          function M3(t3) {
            this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($2);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = O2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
              var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, $3 = function(t4, e4) {
              return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a2:
              case d2:
                return $3(v3 + "Hours", 0);
              case u2:
                return $3(v3 + "Minutes", 1);
              case s2:
                return $3(v3 + "Seconds", 2);
              case i2:
                return $3(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else l3 && this.$d[l3]($3);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $3 = b2.p(f3), y3 = function(t3) {
              var e3 = O2(l3);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($3 === c2) return this.set(c2, this.$M + r3);
            if ($3 === h2) return this.set(h2, this.$y + r3);
            if ($3 === a2) return y3(1);
            if ($3 === o2) return y3(7);
            var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
            }, d3 = function(t4) {
              return b2.s(s3 % 12 || 12, t4, "0");
            }, $3 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b2.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h3(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b2.s(s3, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $3(s3, u3, true);
                  case "A":
                    return $3(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $3 = D3() / 12;
                break;
              case c2:
                $3 = D3();
                break;
              case f2:
                $3 = D3() / 3;
                break;
              case o2:
                $3 = (g3 - v3) / 6048e5;
                break;
              case a2:
                $3 = (g3 - v3) / 864e5;
                break;
              case u2:
                $3 = g3 / n2;
                break;
              case s2:
                $3 = g3 / e2;
                break;
              case i2:
                $3 = g3 / t2;
                break;
              default:
                $3 = g3;
            }
            return l3 ? $3 : b2.a($3);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = w2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
        }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
          return O2(1e3 * t3);
        }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
      });
    })(dayjs_min$1);
    return dayjs_min$1.exports;
  }
  var dayjs_minExports = requireDayjs_min();
  const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
  var zhCn$1 = { exports: {} };
  var zhCn = zhCn$1.exports;
  var hasRequiredZhCn;
  function requireZhCn() {
    if (hasRequiredZhCn) return zhCn$1.exports;
    hasRequiredZhCn = 1;
    (function(module2, exports2) {
      !function(e2, _2) {
        module2.exports = _2(requireDayjs_min());
      }(zhCn, function(e2) {
        function _2(e3) {
          return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
        }
        var t2 = _2(e2), d2 = { name: "zh-cn", weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), ordinal: function(e3, _3) {
          return "W" === _3 ? e3 + "周" : e3 + "日";
        }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日Ah点mm分", LLLL: "YYYY年M月D日ddddAh点mm分", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, relativeTime: { future: "%s内", past: "%s前", s: "几秒", m: "1 分钟", mm: "%d 分钟", h: "1 小时", hh: "%d 小时", d: "1 天", dd: "%d 天", M: "1 个月", MM: "%d 个月", y: "1 年", yy: "%d 年" }, meridiem: function(e3, _3) {
          var t3 = 100 * e3 + _3;
          return t3 < 600 ? "凌晨" : t3 < 900 ? "早上" : t3 < 1100 ? "上午" : t3 < 1300 ? "中午" : t3 < 1800 ? "下午" : "晚上";
        } };
        return t2.default.locale(d2, null, true), d2;
      });
    })(zhCn$1);
    return zhCn$1.exports;
  }
  requireZhCn();
  var en$3 = { exports: {} };
  var en$2 = en$3.exports;
  var hasRequiredEn;
  function requireEn() {
    if (hasRequiredEn) return en$3.exports;
    hasRequiredEn = 1;
    (function(module2, exports2) {
      !function(e2, n2) {
        module2.exports = n2();
      }(en$2, function() {
        return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e2) {
          var n2 = ["th", "st", "nd", "rd"], t2 = e2 % 100;
          return "[" + e2 + (n2[(t2 - 20) % 10] || n2[t2] || n2[0]) + "]";
        } };
      });
    })(en$3);
    return en$3.exports;
  }
  requireEn();
  /*!
    * shared v9.13.1
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser = typeof window !== "undefined";
  const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
  const generateFormatCacheKey = (locale2, key2, source) => friendlyJSONstringify({ l: locale2, k: key2, s: source });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber$2 = (val) => typeof val === "number" && isFinite(val);
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp$2 = (val) => toTypeString(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$2(val) && Object.keys(val).length === 0;
  const assign$2 = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty$g = Object.prototype.hasOwnProperty;
  function hasOwn$2(obj2, key2) {
    return hasOwnProperty$g.call(obj2, key2);
  }
  const isArray$5 = Array.isArray;
  const isFunction$4 = (val) => typeof val === "function";
  const isString$4 = (val) => typeof val === "string";
  const isBoolean$1 = (val) => typeof val === "boolean";
  const isObject$8 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject$8(val) && isFunction$4(val.then) && isFunction$4(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const isPlainObject$2 = (val) => {
    if (!isObject$8(val))
      return false;
    const proto2 = Object.getPrototypeOf(val);
    return proto2 === null || proto2.constructor === Object;
  };
  const toDisplayString = (val) => {
    return val == null ? "" : isArray$5(val) || isPlainObject$2(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
  };
  function join$1(items, separator = "") {
    return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
  }
  function incrementer(code2) {
    let current = code2;
    return () => ++current;
  }
  function warn(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const isNotObjectOrIsArray = (val) => !isObject$8(val) || isArray$5(val);
  function deepCopy(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw new Error("Invalid value");
    }
    const stack2 = [{ src, des }];
    while (stack2.length) {
      const { src: src2, des: des2 } = stack2.pop();
      Object.keys(src2).forEach((key2) => {
        if (isNotObjectOrIsArray(src2[key2]) || isNotObjectOrIsArray(des2[key2])) {
          des2[key2] = src2[key2];
        } else {
          stack2.push({ src: src2[key2], des: des2[key2] });
        }
      });
    }
  }
  /*!
    * message-compiler v9.13.1
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function createPosition(line2, column2, offset2) {
    return { line: line2, column: column2, offset: offset2 };
  }
  function createLocation(start2, end2, source) {
    const loc = { start: start2, end: end2 };
    return loc;
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  function format$4(message, ...args) {
    if (args.length === 1 && isObject$7(args[0])) {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return message.replace(RE_ARGS, (match2, identifier2) => {
      return args.hasOwnProperty(identifier2) ? args[identifier2] : "";
    });
  }
  const assign$1 = Object.assign;
  const isString$3 = (val) => typeof val === "string";
  const isObject$7 = (val) => val !== null && typeof val === "object";
  function join(items, separator = "") {
    return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
  }
  const CompileWarnCodes = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
  };
  const warnMessages = {
    [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
  };
  function createCompileWarn(code2, loc, ...args) {
    const msg = format$4(warnMessages[code2], ...args || []);
    const message = { message: String(msg), code: code2 };
    if (loc) {
      message.location = loc;
    }
    return message;
  }
  const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 17
  };
  const errorMessages = {
    // tokenizer error messages
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    // parser error messages
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    // generator error messages
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    // minimizer error messages
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
  };
  function createCompileError(code2, loc, options2 = {}) {
    const { domain, messages: messages2, args } = options2;
    const msg = format$4((messages2 || errorMessages)[code2] || "", ...args || []);
    const error = new SyntaxError(String(msg));
    error.code = code2;
    if (loc) {
      error.location = loc;
    }
    error.domain = domain;
    return error;
  }
  function defaultOnError(error) {
    throw error;
  }
  const CHAR_SP = " ";
  const CHAR_CR = "\r";
  const CHAR_LF = "\n";
  const CHAR_LS = String.fromCharCode(8232);
  const CHAR_PS = String.fromCharCode(8233);
  function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
    const isLF = (index3) => _buf[index3] === CHAR_LF;
    const isPS = (index3) => _buf[index3] === CHAR_PS;
    const isLS = (index3) => _buf[index3] === CHAR_LS;
    const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
    const index2 = () => _index;
    const line2 = () => _line;
    const column2 = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next2() {
      _peekOffset = 0;
      if (isLineEnd(_index)) {
        _line++;
        _column = 0;
      }
      if (isCRLF(_index)) {
        _index++;
      }
      _index++;
      _column++;
      return _buf[_index];
    }
    function peek2() {
      if (isCRLF(_index + _peekOffset)) {
        _peekOffset++;
      }
      _peekOffset++;
      return _buf[_index + _peekOffset];
    }
    function reset() {
      _index = 0;
      _line = 1;
      _column = 1;
      _peekOffset = 0;
    }
    function resetPeek(offset2 = 0) {
      _peekOffset = offset2;
    }
    function skipToPeek() {
      const target = _index + _peekOffset;
      while (target !== _index) {
        next2();
      }
      _peekOffset = 0;
    }
    return {
      index: index2,
      line: line2,
      column: column2,
      peekOffset,
      charAt,
      currentChar,
      currentPeek,
      next: next2,
      peek: peek2,
      reset,
      resetPeek,
      skipToPeek
    };
  }
  const EOF = void 0;
  const DOT = ".";
  const LITERAL_DELIMITER = "'";
  const ERROR_DOMAIN$3 = "tokenizer";
  function createTokenizer(source, options2 = {}) {
    const location2 = options2.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
      currentType: 14,
      offset: _initOffset,
      startLoc: _initLoc,
      endLoc: _initLoc,
      lastType: 14,
      lastOffset: _initOffset,
      lastStartLoc: _initLoc,
      lastEndLoc: _initLoc,
      braceNest: 0,
      inLinked: false,
      text: ""
    };
    const context = () => _context;
    const { onError } = options2;
    function emitError(code2, pos, offset2, ...args) {
      const ctx = context();
      pos.column += offset2;
      pos.offset += offset2;
      if (onError) {
        const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$3,
          args
        });
        onError(err);
      }
    }
    function getToken(context2, type, value) {
      context2.endLoc = currentPosition();
      context2.currentType = type;
      const token2 = { type };
      if (location2) {
        token2.loc = createLocation(context2.startLoc, context2.endLoc);
      }
      if (value != null) {
        token2.value = value;
      }
      return token2;
    }
    const getEndToken = (context2) => getToken(
      context2,
      14
      /* TokenTypes.EOF */
    );
    function eat(scnr, ch) {
      if (scnr.currentChar() === ch) {
        scnr.next();
        return ch;
      } else {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        return "";
      }
    }
    function peekSpaces(scnr) {
      let buf = "";
      while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
        buf += scnr.currentPeek();
        scnr.peek();
      }
      return buf;
    }
    function skipSpaces(scnr) {
      const buf = peekSpaces(scnr);
      scnr.skipToPeek();
      return buf;
    }
    function isIdentifierStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc === 95;
    }
    function isNumberStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function isNamedIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isListIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
      const ret = isNumberStart(ch);
      scnr.resetPeek();
      return ret;
    }
    function isLiteralStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === LITERAL_DELIMITER;
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDotStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 8) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ".";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedModifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 9) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDelimiterStart(scnr, context2) {
      const { currentType } = context2;
      if (!(currentType === 8 || currentType === 12)) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ":";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedReferStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 10) {
        return false;
      }
      const fn = () => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return isIdentifierStart(scnr.peek());
        } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
          return false;
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn();
        } else {
          return isTextStart(scnr, false);
        }
      };
      const ret = fn();
      scnr.resetPeek();
      return ret;
    }
    function isPluralStart(scnr) {
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === "|";
      scnr.resetPeek();
      return ret;
    }
    function detectModuloStart(scnr) {
      const spaces = peekSpaces(scnr);
      const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
      scnr.resetPeek();
      return {
        isModulo: ret,
        hasSpace: spaces.length > 0
      };
    }
    function isTextStart(scnr, reset = true) {
      const fn = (hasSpace = false, prev2 = "", detectModulo = false) => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return prev2 === "%" ? false : hasSpace;
        } else if (ch === "@" || !ch) {
          return prev2 === "%" ? true : hasSpace;
        } else if (ch === "%") {
          scnr.peek();
          return fn(hasSpace, "%", true);
        } else if (ch === "|") {
          return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
        } else if (ch === CHAR_SP) {
          scnr.peek();
          return fn(true, CHAR_SP, detectModulo);
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn(true, CHAR_LF, detectModulo);
        } else {
          return true;
        }
      };
      const ret = fn();
      reset && scnr.resetPeek();
      return ret;
    }
    function takeChar(scnr, fn) {
      const ch = scnr.currentChar();
      if (ch === EOF) {
        return EOF;
      }
      if (fn(ch)) {
        scnr.next();
        return ch;
      }
      return null;
    }
    function isIdentifier(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36;
    }
    function takeIdentifierChar(scnr) {
      return takeChar(scnr, isIdentifier);
    }
    function isNamedIdentifier(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36 || // $
      cc === 45;
    }
    function takeNamedIdentifierChar(scnr) {
      return takeChar(scnr, isNamedIdentifier);
    }
    function isDigit(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function takeDigit(scnr) {
      return takeChar(scnr, isDigit);
    }
    function isHexDigit(ch) {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57 || // 0-9
      cc >= 65 && cc <= 70 || // A-F
      cc >= 97 && cc <= 102;
    }
    function takeHexDigit(scnr) {
      return takeChar(scnr, isHexDigit);
    }
    function getDigits(scnr) {
      let ch = "";
      let num = "";
      while (ch = takeDigit(scnr)) {
        num += ch;
      }
      return num;
    }
    function readModulo(scnr) {
      skipSpaces(scnr);
      const ch = scnr.currentChar();
      if (ch !== "%") {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      }
      scnr.next();
      return "%";
    }
    function readText(scnr) {
      let buf = "";
      while (true) {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
          break;
        } else if (ch === "%") {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else {
            break;
          }
        } else if (ch === CHAR_SP || ch === CHAR_LF) {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else if (isPluralStart(scnr)) {
            break;
          } else {
            buf += ch;
            scnr.next();
          }
        } else {
          buf += ch;
          scnr.next();
        }
      }
      return buf;
    }
    function readNamedIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let name = "";
      while (ch = takeNamedIdentifierChar(scnr)) {
        name += ch;
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return name;
    }
    function readListIdentifier(scnr) {
      skipSpaces(scnr);
      let value = "";
      if (scnr.currentChar() === "-") {
        scnr.next();
        value += `-${getDigits(scnr)}`;
      } else {
        value += getDigits(scnr);
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return value;
    }
    function isLiteral2(ch) {
      return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
    }
    function readLiteral(scnr) {
      skipSpaces(scnr);
      eat(scnr, `'`);
      let ch = "";
      let literal = "";
      while (ch = takeChar(scnr, isLiteral2)) {
        if (ch === "\\") {
          literal += readEscapeSequence(scnr);
        } else {
          literal += ch;
        }
      }
      const current = scnr.currentChar();
      if (current === CHAR_LF || current === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
        if (current === CHAR_LF) {
          scnr.next();
          eat(scnr, `'`);
        }
        return literal;
      }
      eat(scnr, `'`);
      return literal;
    }
    function readEscapeSequence(scnr) {
      const ch = scnr.currentChar();
      switch (ch) {
        case "\\":
        case `'`:
          scnr.next();
          return `\\${ch}`;
        case "u":
          return readUnicodeEscapeSequence(scnr, ch, 4);
        case "U":
          return readUnicodeEscapeSequence(scnr, ch, 6);
        default:
          emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
          return "";
      }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
      eat(scnr, unicode);
      let sequence = "";
      for (let i2 = 0; i2 < digits; i2++) {
        const ch = takeHexDigit(scnr);
        if (!ch) {
          emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
          break;
        }
        sequence += ch;
      }
      return `\\${unicode}${sequence}`;
    }
    function isInvalidIdentifier(ch) {
      return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
    }
    function readInvalidIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let identifiers = "";
      while (ch = takeChar(scnr, isInvalidIdentifier)) {
        identifiers += ch;
      }
      return identifiers;
    }
    function readLinkedModifier(scnr) {
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      return name;
    }
    function readLinkedRefer(scnr) {
      const fn = (buf) => {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
          return buf;
        } else if (ch === CHAR_SP) {
          return buf;
        } else if (ch === CHAR_LF || ch === DOT) {
          buf += ch;
          scnr.next();
          return fn(buf);
        } else {
          buf += ch;
          scnr.next();
          return fn(buf);
        }
      };
      return fn("");
    }
    function readPlural(scnr) {
      skipSpaces(scnr);
      const plural = eat(
        scnr,
        "|"
        /* TokenChars.Pipe */
      );
      skipSpaces(scnr);
      return plural;
    }
    function readTokenInPlaceholder(scnr, context2) {
      let token2 = null;
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          if (context2.braceNest >= 1) {
            emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token2 = getToken(
            context2,
            2,
            "{"
            /* TokenChars.BraceLeft */
          );
          skipSpaces(scnr);
          context2.braceNest++;
          return token2;
        case "}":
          if (context2.braceNest > 0 && context2.currentType === 2) {
            emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token2 = getToken(
            context2,
            3,
            "}"
            /* TokenChars.BraceRight */
          );
          context2.braceNest--;
          context2.braceNest > 0 && skipSpaces(scnr);
          if (context2.inLinked && context2.braceNest === 0) {
            context2.inLinked = false;
          }
          return token2;
        case "@":
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token2 = readTokenInLinked(scnr, context2) || getEndToken(context2);
          context2.braceNest = 0;
          return token2;
        default: {
          let validNamedIdentifier = true;
          let validListIdentifier = true;
          let validLiteral = true;
          if (isPluralStart(scnr)) {
            if (context2.braceNest > 0) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token2 = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token2;
          }
          if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            context2.braceNest = 0;
            return readToken(scnr, context2);
          }
          if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
            token2 = getToken(context2, 5, readNamedIdentifier(scnr));
            skipSpaces(scnr);
            return token2;
          }
          if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
            token2 = getToken(context2, 6, readListIdentifier(scnr));
            skipSpaces(scnr);
            return token2;
          }
          if (validLiteral = isLiteralStart(scnr, context2)) {
            token2 = getToken(context2, 7, readLiteral(scnr));
            skipSpaces(scnr);
            return token2;
          }
          if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
            token2 = getToken(context2, 13, readInvalidIdentifier(scnr));
            emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token2.value);
            skipSpaces(scnr);
            return token2;
          }
          break;
        }
      }
      return token2;
    }
    function readTokenInLinked(scnr, context2) {
      const { currentType } = context2;
      let token2 = null;
      const ch = scnr.currentChar();
      if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
        emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
      }
      switch (ch) {
        case "@":
          scnr.next();
          token2 = getToken(
            context2,
            8,
            "@"
            /* TokenChars.LinkedAlias */
          );
          context2.inLinked = true;
          return token2;
        case ".":
          skipSpaces(scnr);
          scnr.next();
          return getToken(
            context2,
            9,
            "."
            /* TokenChars.LinkedDot */
          );
        case ":":
          skipSpaces(scnr);
          scnr.next();
          return getToken(
            context2,
            10,
            ":"
            /* TokenChars.LinkedDelimiter */
          );
        default:
          if (isPluralStart(scnr)) {
            token2 = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token2;
          }
          if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
            skipSpaces(scnr);
            return readTokenInLinked(scnr, context2);
          }
          if (isLinkedModifierStart(scnr, context2)) {
            skipSpaces(scnr);
            return getToken(context2, 12, readLinkedModifier(scnr));
          }
          if (isLinkedReferStart(scnr, context2)) {
            skipSpaces(scnr);
            if (ch === "{") {
              return readTokenInPlaceholder(scnr, context2) || token2;
            } else {
              return getToken(context2, 11, readLinkedRefer(scnr));
            }
          }
          if (currentType === 8) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
          }
          context2.braceNest = 0;
          context2.inLinked = false;
          return readToken(scnr, context2);
      }
    }
    function readToken(scnr, context2) {
      let token2 = {
        type: 14
        /* TokenTypes.EOF */
      };
      if (context2.braceNest > 0) {
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      }
      if (context2.inLinked) {
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      }
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        case "}":
          emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
          scnr.next();
          return getToken(
            context2,
            3,
            "}"
            /* TokenChars.BraceRight */
          );
        case "@":
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        default: {
          if (isPluralStart(scnr)) {
            token2 = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token2;
          }
          const { isModulo, hasSpace } = detectModuloStart(scnr);
          if (isModulo) {
            return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
          }
          if (isTextStart(scnr)) {
            return getToken(context2, 0, readText(scnr));
          }
          break;
        }
      }
      return token2;
    }
    function nextToken() {
      const { currentType, offset: offset2, startLoc, endLoc } = _context;
      _context.lastType = currentType;
      _context.lastOffset = offset2;
      _context.lastStartLoc = startLoc;
      _context.lastEndLoc = endLoc;
      _context.offset = currentOffset();
      _context.startLoc = currentPosition();
      if (_scnr.currentChar() === EOF) {
        return getToken(
          _context,
          14
          /* TokenTypes.EOF */
        );
      }
      return readToken(_scnr, _context);
    }
    return {
      nextToken,
      currentOffset,
      currentPosition,
      context
    };
  }
  const ERROR_DOMAIN$2 = "parser";
  const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function fromEscapeSequence(match2, codePoint4, codePoint6) {
    switch (match2) {
      case `\\\\`:
        return `\\`;
      // eslint-disable-next-line no-useless-escape
      case `\\'`:
        return `'`;
      default: {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);
        if (codePoint <= 55295 || codePoint >= 57344) {
          return String.fromCodePoint(codePoint);
        }
        return "�";
      }
    }
  }
  function createParser(options2 = {}) {
    const location2 = options2.location !== false;
    const { onError, onWarn } = options2;
    function emitError(tokenzer, code2, start2, offset2, ...args) {
      const end2 = tokenzer.currentPosition();
      end2.offset += offset2;
      end2.column += offset2;
      if (onError) {
        const loc = location2 ? createLocation(start2, end2) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$2,
          args
        });
        onError(err);
      }
    }
    function emitWarn(tokenzer, code2, start2, offset2, ...args) {
      const end2 = tokenzer.currentPosition();
      end2.offset += offset2;
      end2.column += offset2;
      if (onWarn) {
        const loc = location2 ? createLocation(start2, end2) : null;
        onWarn(createCompileWarn(code2, loc, args));
      }
    }
    function startNode(type, offset2, loc) {
      const node2 = { type };
      if (location2) {
        node2.start = offset2;
        node2.end = offset2;
        node2.loc = { start: loc, end: loc };
      }
      return node2;
    }
    function endNode(node2, offset2, pos, type) {
      if (location2) {
        node2.end = offset2;
        if (node2.loc) {
          node2.loc.end = pos;
        }
      }
    }
    function parseText(tokenizer, value) {
      const context = tokenizer.context();
      const node2 = startNode(3, context.offset, context.startLoc);
      node2.value = value;
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseList(tokenizer, index2) {
      const context = tokenizer.context();
      const { lastOffset: offset2, lastStartLoc: loc } = context;
      const node2 = startNode(5, offset2, loc);
      node2.index = parseInt(index2, 10);
      tokenizer.nextToken();
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseNamed(tokenizer, key2, modulo) {
      const context = tokenizer.context();
      const { lastOffset: offset2, lastStartLoc: loc } = context;
      const node2 = startNode(4, offset2, loc);
      node2.key = key2;
      if (modulo === true) {
        node2.modulo = true;
      }
      tokenizer.nextToken();
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseLiteral(tokenizer, value) {
      const context = tokenizer.context();
      const { lastOffset: offset2, lastStartLoc: loc } = context;
      const node2 = startNode(9, offset2, loc);
      node2.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
      tokenizer.nextToken();
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseLinkedModifier(tokenizer) {
      const token2 = tokenizer.nextToken();
      const context = tokenizer.context();
      const { lastOffset: offset2, lastStartLoc: loc } = context;
      const node2 = startNode(8, offset2, loc);
      if (token2.type !== 12) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
        node2.value = "";
        endNode(node2, offset2, loc);
        return {
          nextConsumeToken: token2,
          node: node2
        };
      }
      if (token2.value == null) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
      }
      node2.value = token2.value || "";
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node: node2
      };
    }
    function parseLinkedKey(tokenizer, value) {
      const context = tokenizer.context();
      const node2 = startNode(7, context.offset, context.startLoc);
      node2.value = value;
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseLinked(tokenizer) {
      const context = tokenizer.context();
      const linkedNode = startNode(6, context.offset, context.startLoc);
      let token2 = tokenizer.nextToken();
      if (token2.type === 9) {
        const parsed = parseLinkedModifier(tokenizer);
        linkedNode.modifier = parsed.node;
        token2 = parsed.nextConsumeToken || tokenizer.nextToken();
      }
      if (token2.type !== 10) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
      }
      token2 = tokenizer.nextToken();
      if (token2.type === 2) {
        token2 = tokenizer.nextToken();
      }
      switch (token2.type) {
        case 11:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          linkedNode.key = parseLinkedKey(tokenizer, token2.value || "");
          break;
        case 5:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          linkedNode.key = parseNamed(tokenizer, token2.value || "");
          break;
        case 6:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          linkedNode.key = parseList(tokenizer, token2.value || "");
          break;
        case 7:
          if (token2.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
          }
          linkedNode.key = parseLiteral(tokenizer, token2.value || "");
          break;
        default: {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
          const nextContext = tokenizer.context();
          const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
          emptyLinkedKeyNode.value = "";
          endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
          linkedNode.key = emptyLinkedKeyNode;
          endNode(linkedNode, nextContext.offset, nextContext.startLoc);
          return {
            nextConsumeToken: token2,
            node: linkedNode
          };
        }
      }
      endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node: linkedNode
      };
    }
    function parseMessage(tokenizer) {
      const context = tokenizer.context();
      const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
      const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
      const node2 = startNode(2, startOffset, startLoc);
      node2.items = [];
      let nextToken = null;
      let modulo = null;
      do {
        const token2 = nextToken || tokenizer.nextToken();
        nextToken = null;
        switch (token2.type) {
          case 0:
            if (token2.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
            }
            node2.items.push(parseText(tokenizer, token2.value || ""));
            break;
          case 6:
            if (token2.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
            }
            node2.items.push(parseList(tokenizer, token2.value || ""));
            break;
          case 4:
            modulo = true;
            break;
          case 5:
            if (token2.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
            }
            node2.items.push(parseNamed(tokenizer, token2.value || "", !!modulo));
            if (modulo) {
              emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token2));
              modulo = null;
            }
            break;
          case 7:
            if (token2.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token2));
            }
            node2.items.push(parseLiteral(tokenizer, token2.value || ""));
            break;
          case 8: {
            const parsed = parseLinked(tokenizer);
            node2.items.push(parsed.node);
            nextToken = parsed.nextConsumeToken || null;
            break;
          }
        }
      } while (context.currentType !== 14 && context.currentType !== 1);
      const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
      const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
      endNode(node2, endOffset, endLoc);
      return node2;
    }
    function parsePlural(tokenizer, offset2, loc, msgNode) {
      const context = tokenizer.context();
      let hasEmptyMessage = msgNode.items.length === 0;
      const node2 = startNode(1, offset2, loc);
      node2.cases = [];
      node2.cases.push(msgNode);
      do {
        const msg = parseMessage(tokenizer);
        if (!hasEmptyMessage) {
          hasEmptyMessage = msg.items.length === 0;
        }
        node2.cases.push(msg);
      } while (context.currentType !== 14);
      if (hasEmptyMessage) {
        emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
      }
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    function parseResource(tokenizer) {
      const context = tokenizer.context();
      const { offset: offset2, startLoc } = context;
      const msgNode = parseMessage(tokenizer);
      if (context.currentType === 14) {
        return msgNode;
      } else {
        return parsePlural(tokenizer, offset2, startLoc, msgNode);
      }
    }
    function parse2(source) {
      const tokenizer = createTokenizer(source, assign$1({}, options2));
      const context = tokenizer.context();
      const node2 = startNode(0, context.offset, context.startLoc);
      if (location2 && node2.loc) {
        node2.loc.source = source;
      }
      node2.body = parseResource(tokenizer);
      if (options2.onCacheKey) {
        node2.cacheKey = options2.onCacheKey(source);
      }
      if (context.currentType !== 14) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
      }
      endNode(node2, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node2;
    }
    return { parse: parse2 };
  }
  function getTokenCaption(token2) {
    if (token2.type === 14) {
      return "EOF";
    }
    const name = (token2.value || "").replace(/\r?\n/gu, "\\n");
    return name.length > 10 ? name.slice(0, 9) + "…" : name;
  }
  function createTransformer(ast, options2 = {}) {
    const _context = {
      ast,
      helpers: /* @__PURE__ */ new Set()
    };
    const context = () => _context;
    const helper2 = (name) => {
      _context.helpers.add(name);
      return name;
    };
    return { context, helper: helper2 };
  }
  function traverseNodes(nodes, transformer) {
    for (let i2 = 0; i2 < nodes.length; i2++) {
      traverseNode(nodes[i2], transformer);
    }
  }
  function traverseNode(node2, transformer) {
    switch (node2.type) {
      case 1:
        traverseNodes(node2.cases, transformer);
        transformer.helper(
          "plural"
          /* HelperNameMap.PLURAL */
        );
        break;
      case 2:
        traverseNodes(node2.items, transformer);
        break;
      case 6: {
        const linked = node2;
        traverseNode(linked.key, transformer);
        transformer.helper(
          "linked"
          /* HelperNameMap.LINKED */
        );
        transformer.helper(
          "type"
          /* HelperNameMap.TYPE */
        );
        break;
      }
      case 5:
        transformer.helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        );
        transformer.helper(
          "list"
          /* HelperNameMap.LIST */
        );
        break;
      case 4:
        transformer.helper(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        );
        transformer.helper(
          "named"
          /* HelperNameMap.NAMED */
        );
        break;
    }
  }
  function transform(ast, options2 = {}) {
    const transformer = createTransformer(ast);
    transformer.helper(
      "normalize"
      /* HelperNameMap.NORMALIZE */
    );
    ast.body && traverseNode(ast.body, transformer);
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
  }
  function optimize(ast) {
    const body = ast.body;
    if (body.type === 2) {
      optimizeMessageNode(body);
    } else {
      body.cases.forEach((c2) => optimizeMessageNode(c2));
    }
    return ast;
  }
  function optimizeMessageNode(message) {
    if (message.items.length === 1) {
      const item = message.items[0];
      if (item.type === 3 || item.type === 9) {
        message.static = item.value;
        delete item.value;
      }
    } else {
      const values = [];
      for (let i2 = 0; i2 < message.items.length; i2++) {
        const item = message.items[i2];
        if (!(item.type === 3 || item.type === 9)) {
          break;
        }
        if (item.value == null) {
          break;
        }
        values.push(item.value);
      }
      if (values.length === message.items.length) {
        message.static = join(values);
        for (let i2 = 0; i2 < message.items.length; i2++) {
          const item = message.items[i2];
          if (item.type === 3 || item.type === 9) {
            delete item.value;
          }
        }
      }
    }
  }
  const ERROR_DOMAIN$1 = "minifier";
  function minify(node2) {
    node2.t = node2.type;
    switch (node2.type) {
      case 0: {
        const resource = node2;
        minify(resource.body);
        resource.b = resource.body;
        delete resource.body;
        break;
      }
      case 1: {
        const plural = node2;
        const cases = plural.cases;
        for (let i2 = 0; i2 < cases.length; i2++) {
          minify(cases[i2]);
        }
        plural.c = cases;
        delete plural.cases;
        break;
      }
      case 2: {
        const message = node2;
        const items = message.items;
        for (let i2 = 0; i2 < items.length; i2++) {
          minify(items[i2]);
        }
        message.i = items;
        delete message.items;
        if (message.static) {
          message.s = message.static;
          delete message.static;
        }
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const valueNode = node2;
        if (valueNode.value) {
          valueNode.v = valueNode.value;
          delete valueNode.value;
        }
        break;
      }
      case 6: {
        const linked = node2;
        minify(linked.key);
        linked.k = linked.key;
        delete linked.key;
        if (linked.modifier) {
          minify(linked.modifier);
          linked.m = linked.modifier;
          delete linked.modifier;
        }
        break;
      }
      case 5: {
        const list2 = node2;
        list2.i = list2.index;
        delete list2.index;
        break;
      }
      case 4: {
        const named = node2;
        named.k = named.key;
        delete named.key;
        break;
      }
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: ERROR_DOMAIN$1,
          args: [node2.type]
        });
      }
    }
    delete node2.type;
  }
  const ERROR_DOMAIN = "parser";
  function createCodeGenerator(ast, options2) {
    const { filename, breakLineCode, needIndent: _needIndent } = options2;
    const location2 = options2.location !== false;
    const _context = {
      filename,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode,
      needIndent: _needIndent,
      indentLevel: 0
    };
    if (location2 && ast.loc) {
      _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code2, node2) {
      _context.code += code2;
    }
    function _newline(n2, withBreakLine = true) {
      const _breakLineCode = withBreakLine ? breakLineCode : "";
      push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
    }
    function indent(withNewLine = true) {
      const level = ++_context.indentLevel;
      withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
      const level = --_context.indentLevel;
      withNewLine && _newline(level);
    }
    function newline() {
      _newline(_context.indentLevel);
    }
    const helper2 = (key2) => `_${key2}`;
    const needIndent = () => _context.needIndent;
    return {
      context,
      push,
      indent,
      deindent,
      newline,
      helper: helper2,
      needIndent
    };
  }
  function generateLinkedNode(generator, node2) {
    const { helper: helper2 } = generator;
    generator.push(`${helper2(
      "linked"
      /* HelperNameMap.LINKED */
    )}(`);
    generateNode(generator, node2.key);
    if (node2.modifier) {
      generator.push(`, `);
      generateNode(generator, node2.modifier);
      generator.push(`, _type`);
    } else {
      generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
  }
  function generateMessageNode(generator, node2) {
    const { helper: helper2, needIndent } = generator;
    generator.push(`${helper2(
      "normalize"
      /* HelperNameMap.NORMALIZE */
    )}([`);
    generator.indent(needIndent());
    const length2 = node2.items.length;
    for (let i2 = 0; i2 < length2; i2++) {
      generateNode(generator, node2.items[i2]);
      if (i2 === length2 - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push("])");
  }
  function generatePluralNode(generator, node2) {
    const { helper: helper2, needIndent } = generator;
    if (node2.cases.length > 1) {
      generator.push(`${helper2(
        "plural"
        /* HelperNameMap.PLURAL */
      )}([`);
      generator.indent(needIndent());
      const length2 = node2.cases.length;
      for (let i2 = 0; i2 < length2; i2++) {
        generateNode(generator, node2.cases[i2]);
        if (i2 === length2 - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push(`])`);
    }
  }
  function generateResource(generator, node2) {
    if (node2.body) {
      generateNode(generator, node2.body);
    } else {
      generator.push("null");
    }
  }
  function generateNode(generator, node2) {
    const { helper: helper2 } = generator;
    switch (node2.type) {
      case 0:
        generateResource(generator, node2);
        break;
      case 1:
        generatePluralNode(generator, node2);
        break;
      case 2:
        generateMessageNode(generator, node2);
        break;
      case 6:
        generateLinkedNode(generator, node2);
        break;
      case 8:
        generator.push(JSON.stringify(node2.value), node2);
        break;
      case 7:
        generator.push(JSON.stringify(node2.value), node2);
        break;
      case 5:
        generator.push(`${helper2(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${helper2(
          "list"
          /* HelperNameMap.LIST */
        )}(${node2.index}))`, node2);
        break;
      case 4:
        generator.push(`${helper2(
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        )}(${helper2(
          "named"
          /* HelperNameMap.NAMED */
        )}(${JSON.stringify(node2.key)}))`, node2);
        break;
      case 9:
        generator.push(JSON.stringify(node2.value), node2);
        break;
      case 3:
        generator.push(JSON.stringify(node2.value), node2);
        break;
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: ERROR_DOMAIN,
          args: [node2.type]
        });
      }
    }
  }
  const generate$2 = (ast, options2 = {}) => {
    const mode = isString$3(options2.mode) ? options2.mode : "normal";
    const filename = isString$3(options2.filename) ? options2.filename : "message.intl";
    !!options2.sourceMap;
    const breakLineCode = options2.breakLineCode != null ? options2.breakLineCode : mode === "arrow" ? ";" : "\n";
    const needIndent = options2.needIndent ? options2.needIndent : mode !== "arrow";
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
      filename,
      breakLineCode,
      needIndent
    });
    generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
      generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
      generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code: code2, map: map2 } = generator.context();
    return {
      ast,
      code: code2,
      map: map2 ? map2.toJSON() : void 0
      // eslint-disable-line @typescript-eslint/no-explicit-any
    };
  };
  function baseCompile$1(source, options2 = {}) {
    const assignedOptions = assign$1({}, options2);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    if (!jit) {
      transform(ast, assignedOptions);
      return generate$2(ast, assignedOptions);
    } else {
      enambeOptimize && optimize(ast);
      enalbeMinify && minify(ast);
      return { ast, code: "" };
    }
  }
  /*!
    * core-base v9.13.1
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function initFeatureFlags$1() {
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
      getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
  }
  const pathStateMachine = [];
  pathStateMachine[
    0
    /* States.BEFORE_PATH */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      0
      /* States.BEFORE_PATH */
    ],
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4
      /* States.IN_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7
      /* States.AFTER_PATH */
    ]
  };
  pathStateMachine[
    1
    /* States.IN_PATH */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      1
      /* States.IN_PATH */
    ],
    [
      "."
      /* PathCharTypes.DOT */
    ]: [
      2
      /* States.BEFORE_IDENT */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4
      /* States.IN_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7
      /* States.AFTER_PATH */
    ]
  };
  pathStateMachine[
    2
    /* States.BEFORE_IDENT */
  ] = {
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      2
      /* States.BEFORE_IDENT */
    ],
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "0"
      /* PathCharTypes.ZERO */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    3
    /* States.IN_IDENT */
  ] = {
    [
      "i"
      /* PathCharTypes.IDENT */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "0"
      /* PathCharTypes.ZERO */
    ]: [
      3,
      0
      /* Actions.APPEND */
    ],
    [
      "w"
      /* PathCharTypes.WORKSPACE */
    ]: [
      1,
      1
      /* Actions.PUSH */
    ],
    [
      "."
      /* PathCharTypes.DOT */
    ]: [
      2,
      1
      /* Actions.PUSH */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4,
      1
      /* Actions.PUSH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: [
      7,
      1
      /* Actions.PUSH */
    ]
  };
  pathStateMachine[
    4
    /* States.IN_SUB_PATH */
  ] = {
    [
      "'"
      /* PathCharTypes.SINGLE_QUOTE */
    ]: [
      5,
      0
      /* Actions.APPEND */
    ],
    [
      '"'
      /* PathCharTypes.DOUBLE_QUOTE */
    ]: [
      6,
      0
      /* Actions.APPEND */
    ],
    [
      "["
      /* PathCharTypes.LEFT_BRACKET */
    ]: [
      4,
      2
      /* Actions.INC_SUB_PATH_DEPTH */
    ],
    [
      "]"
      /* PathCharTypes.RIGHT_BRACKET */
    ]: [
      1,
      3
      /* Actions.PUSH_SUB_PATH */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    5
    /* States.IN_SINGLE_QUOTE */
  ] = {
    [
      "'"
      /* PathCharTypes.SINGLE_QUOTE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      5,
      0
      /* Actions.APPEND */
    ]
  };
  pathStateMachine[
    6
    /* States.IN_DOUBLE_QUOTE */
  ] = {
    [
      '"'
      /* PathCharTypes.DOUBLE_QUOTE */
    ]: [
      4,
      0
      /* Actions.APPEND */
    ],
    [
      "o"
      /* PathCharTypes.END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* PathCharTypes.ELSE */
    ]: [
      6,
      0
      /* Actions.APPEND */
    ]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a2 = str.charCodeAt(0);
    const b2 = str.charCodeAt(str.length - 1);
    return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code2 = ch.charCodeAt(0);
    switch (code2) {
      case 91:
      // [
      case 93:
      // ]
      case 46:
      // .
      case 34:
      // "
      case 39:
        return ch;
      case 95:
      // _
      case 36:
      // $
      case 45:
        return "i";
      case 9:
      // Tab (HT)
      case 10:
      // Newline (LF)
      case 13:
      // Return (CR)
      case 160:
      // No-break space (NBSP)
      case 65279:
      // Byte Order Mark (BOM)
      case 8232:
      // Line Separator (LS)
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse$2(path) {
    const keys2 = [];
    let index2 = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c2;
    let key2;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions2 = [];
    actions2[
      0
      /* Actions.APPEND */
    ] = () => {
      if (key2 === void 0) {
        key2 = newChar;
      } else {
        key2 += newChar;
      }
    };
    actions2[
      1
      /* Actions.PUSH */
    ] = () => {
      if (key2 !== void 0) {
        keys2.push(key2);
        key2 = void 0;
      }
    };
    actions2[
      2
      /* Actions.INC_SUB_PATH_DEPTH */
    ] = () => {
      actions2[
        0
        /* Actions.APPEND */
      ]();
      subPathDepth++;
    };
    actions2[
      3
      /* Actions.PUSH_SUB_PATH */
    ] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions2[
          0
          /* Actions.APPEND */
        ]();
      } else {
        subPathDepth = 0;
        if (key2 === void 0) {
          return false;
        }
        key2 = formatSubPath(key2);
        if (key2 === false) {
          return false;
        } else {
          actions2[
            1
            /* Actions.PUSH */
          ]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index2 + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index2++;
        newChar = "\\" + nextChar;
        actions2[
          0
          /* Actions.APPEND */
        ]();
        return true;
      }
    }
    while (mode !== null) {
      index2++;
      c2 = path[index2];
      if (c2 === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c2);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap[
        "l"
        /* PathCharTypes.ELSE */
      ] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions2[transition[1]];
        if (action) {
          newChar = c2;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys2;
      }
    }
  }
  const cache = /* @__PURE__ */ new Map();
  function resolveWithKeyValue(obj2, path) {
    return isObject$8(obj2) ? obj2[path] : null;
  }
  function resolveValue(obj2, path) {
    if (!isObject$8(obj2)) {
      return null;
    }
    let hit = cache.get(path);
    if (!hit) {
      hit = parse$2(path);
      if (hit) {
        cache.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len2 = hit.length;
    let last2 = obj2;
    let i2 = 0;
    while (i2 < len2) {
      const val = last2[hit[i2]];
      if (val === void 0) {
        return null;
      }
      if (isFunction$4(last2)) {
        return null;
      }
      last2 = val;
      i2++;
    }
    return last2;
  }
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options2) {
    const index2 = isNumber$2(options2.pluralIndex) ? options2.pluralIndex : -1;
    return options2.named && (isNumber$2(options2.named.count) || isNumber$2(options2.named.n)) ? isNumber$2(options2.named.count) ? options2.named.count : isNumber$2(options2.named.n) ? options2.named.n : index2 : index2;
  }
  function normalizeNamed(pluralIndex, props2) {
    if (!props2.count) {
      props2.count = pluralIndex;
    }
    if (!props2.n) {
      props2.n = pluralIndex;
    }
  }
  function createMessageContext(options2 = {}) {
    const locale2 = options2.locale;
    const pluralIndex = getPluralIndex(options2);
    const pluralRule = isObject$8(options2.pluralRules) && isString$4(locale2) && isFunction$4(options2.pluralRules[locale2]) ? options2.pluralRules[locale2] : pluralDefault;
    const orgPluralRule = isObject$8(options2.pluralRules) && isString$4(locale2) && isFunction$4(options2.pluralRules[locale2]) ? pluralDefault : void 0;
    const plural = (messages2) => {
      return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
    };
    const _list = options2.list || [];
    const list2 = (index2) => _list[index2];
    const _named = options2.named || {};
    isNumber$2(options2.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key2) => _named[key2];
    function message(key2) {
      const msg = isFunction$4(options2.messages) ? options2.messages(key2) : isObject$8(options2.messages) ? options2.messages[key2] : false;
      return !msg ? options2.parent ? options2.parent.message(key2) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name) => options2.modifiers ? options2.modifiers[name] : DEFAULT_MODIFIER;
    const normalize2 = isPlainObject$2(options2.processor) && isFunction$4(options2.processor.normalize) ? options2.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$2(options2.processor) && isFunction$4(options2.processor.interpolate) ? options2.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$2(options2.processor) && isString$4(options2.processor.type) ? options2.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key2, ...args) => {
      const [arg1, arg2] = args;
      let type22 = "text";
      let modifier = "";
      if (args.length === 1) {
        if (isObject$8(arg1)) {
          modifier = arg1.modifier || modifier;
          type22 = arg1.type || type22;
        } else if (isString$4(arg1)) {
          modifier = arg1 || modifier;
        }
      } else if (args.length === 2) {
        if (isString$4(arg1)) {
          modifier = arg1 || modifier;
        }
        if (isString$4(arg2)) {
          type22 = arg2 || type22;
        }
      }
      const ret = message(key2)(ctx);
      const msg = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        type22 === "vnode" && isArray$5(ret) && modifier ? ret[0] : ret
      );
      return modifier ? _modifier(modifier)(msg, type22) : msg;
    };
    const ctx = {
      [
        "list"
        /* HelperNameMap.LIST */
      ]: list2,
      [
        "named"
        /* HelperNameMap.NAMED */
      ]: named,
      [
        "plural"
        /* HelperNameMap.PLURAL */
      ]: plural,
      [
        "linked"
        /* HelperNameMap.LINKED */
      ]: linked,
      [
        "message"
        /* HelperNameMap.MESSAGE */
      ]: message,
      [
        "type"
        /* HelperNameMap.TYPE */
      ]: type,
      [
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ]: interpolate,
      [
        "normalize"
        /* HelperNameMap.NORMALIZE */
      ]: normalize2,
      [
        "values"
        /* HelperNameMap.VALUES */
      ]: assign$2({}, _list, _named)
    };
    return ctx;
  }
  let devtools = null;
  function setDevToolsHook(hook) {
    devtools = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook(
    "function:translate"
    /* IntlifyDevToolsHooks.FunctionTranslate */
  );
  function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
  }
  const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
  const inc$1$1 = incrementer(code$1$1);
  const CoreWarnCodes = {
    // 2
    FALLBACK_TO_TRANSLATE: inc$1$1(),
    // 3
    CANNOT_FORMAT_NUMBER: inc$1$1(),
    // 4
    FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
    // 5
    CANNOT_FORMAT_DATE: inc$1$1(),
    // 6
    FALLBACK_TO_DATE_FORMAT: inc$1$1(),
    // 7
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
    // 8
    __EXTEND_POINT__: inc$1$1()
    // 9
  };
  const code$2 = CompileErrorCodes.__EXTEND_POINT__;
  const inc$2 = incrementer(code$2);
  const CoreErrorCodes = {
    INVALID_ARGUMENT: code$2,
    // 17
    INVALID_DATE_ARGUMENT: inc$2(),
    // 18
    INVALID_ISO_DATE_ARGUMENT: inc$2(),
    // 19
    NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
    // 20
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
    // 21
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
    // 22
    NOT_SUPPORT_LOCALE_TYPE: inc$2(),
    // 23
    __EXTEND_POINT__: inc$2()
    // 24
  };
  function createCoreError(code2) {
    return createCompileError(code2, null, void 0);
  }
  function getLocale(context, options2) {
    return options2.locale != null ? resolveLocale(options2.locale) : resolveLocale(context.locale);
  }
  let _resolveLocale;
  function resolveLocale(locale2) {
    if (isString$4(locale2)) {
      return locale2;
    } else {
      if (isFunction$4(locale2)) {
        if (locale2.resolvedOnce && _resolveLocale != null) {
          return _resolveLocale;
        } else if (locale2.constructor.name === "Function") {
          const resolve2 = locale2();
          if (isPromise(resolve2)) {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
          }
          return _resolveLocale = resolve2;
        } else {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
        }
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
      }
    }
  }
  function fallbackWithSimple(ctx, fallback, start2) {
    return [.../* @__PURE__ */ new Set([
      start2,
      ...isArray$5(fallback) ? fallback : isObject$8(fallback) ? Object.keys(fallback) : isString$4(fallback) ? [fallback] : [start2]
    ])];
  }
  function fallbackWithLocaleChain(ctx, fallback, start2) {
    const startLocale = isString$4(start2) ? start2 : DEFAULT_LOCALE$1;
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
      chain = [];
      let block = [start2];
      while (isArray$5(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults2 = isArray$5(fallback) || !isPlainObject$2(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
      block = isString$4(defaults2) ? [defaults2] : defaults2;
      if (isArray$5(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i2 = 0; i2 < block.length && isBoolean$1(follow); i2++) {
      const locale2 = block[i2];
      if (isString$4(locale2)) {
        follow = appendLocaleToChain(chain, block[i2], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale2, blocks) {
    let follow;
    const tokens = locale2.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale2 = target.replace(/!/g, "");
        chain.push(locale2);
        if ((isArray$5(blocks) || isPlainObject$2(blocks)) && blocks[locale2]) {
          follow = blocks[locale2];
        }
      }
    }
    return follow;
  }
  const VERSION$3 = "9.13.1";
  const NOT_REOSLVED = -1;
  const DEFAULT_LOCALE$1 = "en-US";
  const MISSING_RESOLVE_VALUE = "";
  const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
  function getDefaultLinkedModifiers() {
    return {
      upper: (val, type) => {
        return type === "text" && isString$4(val) ? val.toUpperCase() : type === "vnode" && isObject$8(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
      },
      lower: (val, type) => {
        return type === "text" && isString$4(val) ? val.toLowerCase() : type === "vnode" && isObject$8(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
      },
      capitalize: (val, type) => {
        return type === "text" && isString$4(val) ? capitalize(val) : type === "vnode" && isObject$8(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
      }
    };
  }
  let _compiler;
  function registerMessageCompiler(compiler) {
    _compiler = compiler;
  }
  let _resolver;
  function registerMessageResolver(resolver) {
    _resolver = resolver;
  }
  let _fallbacker;
  function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
  }
  let _additionalMeta = null;
  const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
  let _fallbackContext = null;
  const setFallbackContext = (context) => {
    _fallbackContext = context;
  };
  const getFallbackContext = () => _fallbackContext;
  let _cid = 0;
  function createCoreContext(options2 = {}) {
    const onWarn = isFunction$4(options2.onWarn) ? options2.onWarn : warn;
    const version2 = isString$4(options2.version) ? options2.version : VERSION$3;
    const locale2 = isString$4(options2.locale) || isFunction$4(options2.locale) ? options2.locale : DEFAULT_LOCALE$1;
    const _locale = isFunction$4(locale2) ? DEFAULT_LOCALE$1 : locale2;
    const fallbackLocale = isArray$5(options2.fallbackLocale) || isPlainObject$2(options2.fallbackLocale) || isString$4(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : _locale;
    const messages2 = isPlainObject$2(options2.messages) ? options2.messages : { [_locale]: {} };
    const datetimeFormats = isPlainObject$2(options2.datetimeFormats) ? options2.datetimeFormats : { [_locale]: {} };
    const numberFormats = isPlainObject$2(options2.numberFormats) ? options2.numberFormats : { [_locale]: {} };
    const modifiers = assign$2({}, options2.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options2.pluralRules || {};
    const missing = isFunction$4(options2.missing) ? options2.missing : null;
    const missingWarn = isBoolean$1(options2.missingWarn) || isRegExp$2(options2.missingWarn) ? options2.missingWarn : true;
    const fallbackWarn = isBoolean$1(options2.fallbackWarn) || isRegExp$2(options2.fallbackWarn) ? options2.fallbackWarn : true;
    const fallbackFormat = !!options2.fallbackFormat;
    const unresolving = !!options2.unresolving;
    const postTranslation = isFunction$4(options2.postTranslation) ? options2.postTranslation : null;
    const processor = isPlainObject$2(options2.processor) ? options2.processor : null;
    const warnHtmlMessage = isBoolean$1(options2.warnHtmlMessage) ? options2.warnHtmlMessage : true;
    const escapeParameter = !!options2.escapeParameter;
    const messageCompiler = isFunction$4(options2.messageCompiler) ? options2.messageCompiler : _compiler;
    const messageResolver = isFunction$4(options2.messageResolver) ? options2.messageResolver : _resolver || resolveWithKeyValue;
    const localeFallbacker = isFunction$4(options2.localeFallbacker) ? options2.localeFallbacker : _fallbacker || fallbackWithSimple;
    const fallbackContext = isObject$8(options2.fallbackContext) ? options2.fallbackContext : void 0;
    const internalOptions = options2;
    const __datetimeFormatters = isObject$8(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$8(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$8(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale: locale2,
      fallbackLocale,
      messages: messages2,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      messageResolver,
      localeFallbacker,
      fallbackContext,
      onWarn,
      __meta
    };
    {
      context.datetimeFormats = datetimeFormats;
      context.numberFormats = numberFormats;
      context.__datetimeFormatters = __datetimeFormatters;
      context.__numberFormatters = __numberFormatters;
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function handleMissing(context, key2, locale2, missingWarn, type) {
    const { missing, onWarn } = context;
    if (missing !== null) {
      const ret = missing(context, locale2, key2, type);
      return isString$4(ret) ? ret : key2;
    } else {
      return key2;
    }
  }
  function updateFallbackLocale(ctx, locale2, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    ctx.localeFallbacker(ctx, fallback, locale2);
  }
  function isAlmostSameLocale(locale2, compareLocale) {
    if (locale2 === compareLocale)
      return false;
    return locale2.split("-")[0] === compareLocale.split("-")[0];
  }
  function isImplicitFallback(targetLocale, locales) {
    const index2 = locales.indexOf(targetLocale);
    if (index2 === -1) {
      return false;
    }
    for (let i2 = index2 + 1; i2 < locales.length; i2++) {
      if (isAlmostSameLocale(targetLocale, locales[i2])) {
        return true;
      }
    }
    return false;
  }
  function format$3(ast) {
    const msg = (ctx) => formatParts(ctx, ast);
    return msg;
  }
  function formatParts(ctx, ast) {
    const body = ast.b || ast.body;
    if ((body.t || body.type) === 1) {
      const plural = body;
      const cases = plural.c || plural.cases;
      return ctx.plural(cases.reduce((messages2, c2) => [
        ...messages2,
        formatMessageParts(ctx, c2)
      ], []));
    } else {
      return formatMessageParts(ctx, body);
    }
  }
  function formatMessageParts(ctx, node2) {
    const _static = node2.s || node2.static;
    if (_static) {
      return ctx.type === "text" ? _static : ctx.normalize([_static]);
    } else {
      const messages2 = (node2.i || node2.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
      return ctx.normalize(messages2);
    }
  }
  function formatMessagePart(ctx, node2) {
    const type = node2.t || node2.type;
    switch (type) {
      case 3: {
        const text = node2;
        return text.v || text.value;
      }
      case 9: {
        const literal = node2;
        return literal.v || literal.value;
      }
      case 4: {
        const named = node2;
        return ctx.interpolate(ctx.named(named.k || named.key));
      }
      case 5: {
        const list2 = node2;
        return ctx.interpolate(ctx.list(list2.i != null ? list2.i : list2.index));
      }
      case 6: {
        const linked = node2;
        const modifier = linked.m || linked.modifier;
        return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
      }
      case 7: {
        const linkedKey = node2;
        return linkedKey.v || linkedKey.value;
      }
      case 8: {
        const linkedModifier = node2;
        return linkedModifier.v || linkedModifier.value;
      }
      default:
        throw new Error(`unhandled node type on format message part: ${type}`);
    }
  }
  const defaultOnCacheKey = (message) => message;
  let compileCache = /* @__PURE__ */ Object.create(null);
  const isMessageAST = (val) => isObject$8(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
  function baseCompile(message, options2 = {}) {
    let detectError = false;
    const onError = options2.onError || defaultOnError;
    options2.onError = (err) => {
      detectError = true;
      onError(err);
    };
    return { ...baseCompile$1(message, options2), detectError };
  }
  const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
    if (!isString$4(message)) {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
    }
    {
      isBoolean$1(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
      const onCacheKey = context.onCacheKey || defaultOnCacheKey;
      const cacheKey = onCacheKey(message);
      const cached2 = compileCache[cacheKey];
      if (cached2) {
        return cached2;
      }
      const { code: code2, detectError } = baseCompile(message, context);
      const msg = new Function(`return ${code2}`)();
      return !detectError ? compileCache[cacheKey] = msg : msg;
    }
  };
  function compile$1(message, context) {
    if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$4(message)) {
      isBoolean$1(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
      const onCacheKey = context.onCacheKey || defaultOnCacheKey;
      const cacheKey = onCacheKey(message);
      const cached2 = compileCache[cacheKey];
      if (cached2) {
        return cached2;
      }
      const { ast, detectError } = baseCompile(message, {
        ...context,
        location: false,
        jit: true
      });
      const msg = format$3(ast);
      return !detectError ? compileCache[cacheKey] = msg : msg;
    } else {
      const cacheKey = message.cacheKey;
      if (cacheKey) {
        const cached2 = compileCache[cacheKey];
        if (cached2) {
          return cached2;
        }
        return compileCache[cacheKey] = format$3(message);
      } else {
        return format$3(message);
      }
    }
  }
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$4(val);
  function translate$1(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
    const [key2, options2] = parseTranslateArgs(...args);
    const missingWarn = isBoolean$1(options2.missingWarn) ? options2.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean$1(options2.fallbackWarn) ? options2.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean$1(options2.escapeParameter) ? options2.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options2.resolvedMessage;
    const defaultMsgOrKey = isString$4(options2.default) || isBoolean$1(options2.default) ? !isBoolean$1(options2.default) ? options2.default : !messageCompiler ? () => key2 : key2 : fallbackFormat ? !messageCompiler ? () => key2 : key2 : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale2 = getLocale(context, options2);
    escapeParameter && escapeParams(options2);
    let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key2, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
      key2,
      locale2,
      messages2[locale2] || {}
    ];
    let format2 = formatScope;
    let cacheBaseKey = key2;
    if (!resolvedMessage && !(isString$4(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString$4(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$4(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key2;
    }
    let occurred = false;
    const onError = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, onError) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options2);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged, key2) : messaged;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const payloads = {
        timestamp: Date.now(),
        key: isString$4(key2) ? key2 : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString$4(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options2) {
    if (isArray$5(options2.list)) {
      options2.list = options2.list.map((item) => isString$4(item) ? escapeHtml(item) : item);
    } else if (isObject$8(options2.named)) {
      Object.keys(options2.named).forEach((key2) => {
        if (isString$4(options2.named[key2])) {
          options2.named[key2] = escapeHtml(options2.named[key2]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key2, locale2, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale2);
    let message = {};
    let targetLocale;
    let format2 = null;
    const type = "translate";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      message = messages2[targetLocale] || {};
      if ((format2 = resolveValue2(message, key2)) === null) {
        format2 = message[key2];
      }
      if (isString$4(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
        break;
      }
      if (!isImplicitFallback(targetLocale, locales)) {
        const missingRet = handleMissing(
          context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          key2,
          targetLocale,
          missingWarn,
          type
        );
        if (missingRet !== key2) {
          format2 = missingRet;
        }
      }
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, onError) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key2;
      return msg2;
    }
    if (messageCompiler == null) {
      const msg2 = () => format2;
      msg2.locale = targetLocale;
      msg2.key = key2;
      return msg2;
    }
    const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
    msg.locale = targetLocale;
    msg.key = key2;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    const messaged = msg(msgCtx);
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options2 = {};
    if (!isString$4(arg1) && !isNumber$2(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const key2 = isNumber$2(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber$2(arg2)) {
      options2.plural = arg2;
    } else if (isString$4(arg2)) {
      options2.default = arg2;
    } else if (isPlainObject$2(arg2) && !isEmptyObject(arg2)) {
      options2.named = arg2;
    } else if (isArray$5(arg2)) {
      options2.list = arg2;
    }
    if (isNumber$2(arg3)) {
      options2.plural = arg3;
    } else if (isString$4(arg3)) {
      options2.default = arg3;
    } else if (isPlainObject$2(arg3)) {
      assign$2(options2, arg3);
    }
    return [key2, options2];
  }
  function getCompileContext(context, locale2, key2, source, warnHtmlMessage, onError) {
    return {
      locale: locale2,
      key: key2,
      warnHtmlMessage,
      onError: (err) => {
        onError && onError(err);
        {
          throw err;
        }
      },
      onCacheKey: (source2) => generateFormatCacheKey(locale2, key2, source2)
    };
  }
  function getMessageContextOptions(context, locale2, message, options2) {
    const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key2) => {
      let val = resolveValue2(message, key2);
      if (val == null && fallbackContext) {
        const [, , message2] = resolveMessageFormat(fallbackContext, key2, locale2, fallbackLocale, fallbackWarn, missingWarn);
        val = resolveValue2(message2, key2);
      }
      if (isString$4(val) || isMessageAST(val)) {
        let occurred = false;
        const onError = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key2, locale2, val, key2, onError);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale: locale2,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options2.list) {
      ctxOptions.list = options2.list;
    }
    if (options2.named) {
      ctxOptions.named = options2.named;
    }
    if (isNumber$2(options2.plural)) {
      ctxOptions.pluralIndex = options2.plural;
    }
    return ctxOptions;
  }
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    const [key2, value, options2, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean$1(options2.missingWarn) ? options2.missingWarn : context.missingWarn;
    isBoolean$1(options2.fallbackWarn) ? options2.fallbackWarn : context.fallbackWarn;
    const part = !!options2.part;
    const locale2 = getLocale(context, options2);
    const locales = localeFallbacker(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale,
      locale2
    );
    if (!isString$4(key2) || key2 === "") {
      return new Intl.DateTimeFormat(locale2, overrides).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "datetime format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key2];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key2, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$4(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key2;
    }
    let id = `${targetLocale}__${key2}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const DATETIME_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options2 = {};
    let overrides = {};
    let value;
    if (isString$4(arg1)) {
      const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!matches) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
      const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
      value = new Date(dateTime);
      try {
        value.toISOString();
      } catch (e2) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (isDate$1(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
      }
      value = arg1;
    } else if (isNumber$2(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if (isString$4(arg2)) {
      options2.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key2) => {
        if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key2)) {
          overrides[key2] = arg2[key2];
        } else {
          options2[key2] = arg2[key2];
        }
      });
    }
    if (isString$4(arg3)) {
      options2.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options2.key || "", value, options2, overrides];
  }
  function clearDateTimeFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key2 in format2) {
      const id = `${locale2}__${key2}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number$1(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    const [key2, value, options2, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean$1(options2.missingWarn) ? options2.missingWarn : context.missingWarn;
    isBoolean$1(options2.fallbackWarn) ? options2.fallbackWarn : context.fallbackWarn;
    const part = !!options2.part;
    const locale2 = getLocale(context, options2);
    const locales = localeFallbacker(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      fallbackLocale,
      locale2
    );
    if (!isString$4(key2) || key2 === "") {
      return new Intl.NumberFormat(locale2, overrides).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "number format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = locales[i2];
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key2];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key2, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$4(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key2;
    }
    let id = `${targetLocale}__${key2}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const NUMBER_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options2 = {};
    let overrides = {};
    if (!isNumber$2(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if (isString$4(arg2)) {
      options2.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key2) => {
        if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key2)) {
          overrides[key2] = arg2[key2];
        } else {
          options2[key2] = arg2[key2];
        }
      });
    }
    if (isString$4(arg3)) {
      options2.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options2.key || "", value, options2, overrides];
  }
  function clearNumberFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key2 in format2) {
      const id = `${locale2}__${key2}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  {
    initFeatureFlags$1();
  }
  /*!
    * vue-i18n v9.13.1
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION$2 = "9.13.1";
  function initFeatureFlags() {
    if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
      getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
      getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
      getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
  }
  const code$1 = CoreWarnCodes.__EXTEND_POINT__;
  const inc$1 = incrementer(code$1);
  ({
    // 9
    NOT_SUPPORTED_PRESERVE: inc$1(),
    // 10
    NOT_SUPPORTED_FORMATTER: inc$1(),
    // 11
    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
    // 12
    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
    // 13
    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
    // 14
    NOT_FOUND_PARENT_SCOPE: inc$1(),
    // 15
    IGNORE_OBJ_FLATTEN: inc$1(),
    // 16
    NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
    // 17
    NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
    // 18
  });
  const code = CoreErrorCodes.__EXTEND_POINT__;
  const inc = incrementer(code);
  const I18nErrorCodes = {
    // composer module errors
    UNEXPECTED_RETURN_TYPE: code,
    // 24
    // legacy module errors
    INVALID_ARGUMENT: inc(),
    // 25
    // i18n module errors
    MUST_BE_CALL_SETUP_TOP: inc(),
    // 26
    NOT_INSTALLED: inc(),
    // 27
    NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
    // 28
    // directive module errors
    REQUIRED_VALUE: inc(),
    // 29
    INVALID_VALUE: inc(),
    // 30
    // vue-devtools errors
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
    // 31
    NOT_INSTALLED_WITH_PROVIDE: inc(),
    // 32
    // unexpected error
    UNEXPECTED_ERROR: inc(),
    // 33
    // not compatible legacy vue-i18n constructor
    NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
    // 34
    // bridge support vue 2.x only
    BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
    // 35
    // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
    // 36
    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
    // 37
    // for enhancement
    __EXTEND_POINT__: inc()
    // 38
  };
  function createI18nError(code2, ...args) {
    return createCompileError(code2, null, void 0);
  }
  const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
  const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
  const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
  const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
  function handleFlatJson(obj2) {
    if (!isObject$8(obj2)) {
      return obj2;
    }
    for (const key2 in obj2) {
      if (!hasOwn$2(obj2, key2)) {
        continue;
      }
      if (!key2.includes(".")) {
        if (isObject$8(obj2[key2])) {
          handleFlatJson(obj2[key2]);
        }
      } else {
        const subKeys = key2.split(".");
        const lastIndex = subKeys.length - 1;
        let currentObj = obj2;
        let hasStringValue = false;
        for (let i2 = 0; i2 < lastIndex; i2++) {
          if (!(subKeys[i2] in currentObj)) {
            currentObj[subKeys[i2]] = {};
          }
          if (!isObject$8(currentObj[subKeys[i2]])) {
            hasStringValue = true;
            break;
          }
          currentObj = currentObj[subKeys[i2]];
        }
        if (!hasStringValue) {
          currentObj[subKeys[lastIndex]] = obj2[key2];
          delete obj2[key2];
        }
        if (isObject$8(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj2;
  }
  function getLocaleMessages(locale2, options2) {
    const { messages: messages2, __i18n, messageResolver, flatJson } = options2;
    const ret = isPlainObject$2(messages2) ? messages2 : isArray$5(__i18n) ? {} : { [locale2]: {} };
    if (isArray$5(__i18n)) {
      __i18n.forEach((custom) => {
        if ("locale" in custom && "resource" in custom) {
          const { locale: locale22, resource } = custom;
          if (locale22) {
            ret[locale22] = ret[locale22] || {};
            deepCopy(resource, ret[locale22]);
          } else {
            deepCopy(resource, ret);
          }
        } else {
          isString$4(custom) && deepCopy(JSON.parse(custom), ret);
        }
      });
    }
    if (messageResolver == null && flatJson) {
      for (const key2 in ret) {
        if (hasOwn$2(ret, key2)) {
          handleFlatJson(ret[key2]);
        }
      }
    }
    return ret;
  }
  function getComponentOptions(instance) {
    return instance.type;
  }
  function adjustI18nResources(gl, options2, componentOptions) {
    let messages2 = isObject$8(options2.messages) ? options2.messages : {};
    if ("__i18nGlobal" in componentOptions) {
      messages2 = getLocaleMessages(gl.locale.value, {
        messages: messages2,
        __i18n: componentOptions.__i18nGlobal
      });
    }
    const locales = Object.keys(messages2);
    if (locales.length) {
      locales.forEach((locale2) => {
        gl.mergeLocaleMessage(locale2, messages2[locale2]);
      });
    }
    {
      if (isObject$8(options2.datetimeFormats)) {
        const locales2 = Object.keys(options2.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale2) => {
            gl.mergeDateTimeFormat(locale2, options2.datetimeFormats[locale2]);
          });
        }
      }
      if (isObject$8(options2.numberFormats)) {
        const locales2 = Object.keys(options2.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale2) => {
            gl.mergeNumberFormat(locale2, options2.numberFormats[locale2]);
          });
        }
      }
    }
  }
  function createTextNode(key2) {
    return createVNode(Text, null, key2, 0);
  }
  const DEVTOOLS_META = "__INTLIFY_META__";
  const NOOP_RETURN_ARRAY = () => [];
  const NOOP_RETURN_FALSE = () => false;
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale2, key2, type) => {
      return missing(locale2, key2, getCurrentInstance() || void 0, type);
    };
  }
  const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
    const instance = getCurrentInstance();
    let meta = null;
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
  };
  function createComposer(options2 = {}, VueI18nLegacy) {
    const { __root, __injectWithOption } = options2;
    const _isGlobal = __root === void 0;
    const flatJson = options2.flatJson;
    const _ref = inBrowser ? ref : shallowRef;
    const translateExistCompatible = !!options2.translateExistCompatible;
    let _inheritLocale = isBoolean$1(options2.inheritLocale) ? options2.inheritLocale : true;
    const _locale = _ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.locale.value : isString$4(options2.locale) ? options2.locale : DEFAULT_LOCALE$1
    );
    const _fallbackLocale = _ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.fallbackLocale.value : isString$4(options2.fallbackLocale) || isArray$5(options2.fallbackLocale) || isPlainObject$2(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : _locale.value
    );
    const _messages = _ref(getLocaleMessages(_locale.value, options2));
    const _datetimeFormats = _ref(isPlainObject$2(options2.datetimeFormats) ? options2.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = _ref(isPlainObject$2(options2.numberFormats) ? options2.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean$1(options2.missingWarn) || isRegExp$2(options2.missingWarn) ? options2.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean$1(options2.fallbackWarn) || isRegExp$2(options2.fallbackWarn) ? options2.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean$1(options2.fallbackRoot) ? options2.fallbackRoot : true;
    let _fallbackFormat = !!options2.fallbackFormat;
    let _missing = isFunction$4(options2.missing) ? options2.missing : null;
    let _runtimeMissing = isFunction$4(options2.missing) ? defineCoreMissingHandler(options2.missing) : null;
    let _postTranslation = isFunction$4(options2.postTranslation) ? options2.postTranslation : null;
    let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean$1(options2.warnHtmlMessage) ? options2.warnHtmlMessage : true;
    let _escapeParameter = !!options2.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$2(options2.modifiers) ? options2.modifiers : {};
    let _pluralRules = options2.pluralRules || __root && __root.pluralRules;
    let _context;
    const getCoreContext = () => {
      _isGlobal && setFallbackContext(null);
      const ctxOptions = {
        version: VERSION$2,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        messageResolver: options2.messageResolver,
        messageCompiler: options2.messageCompiler,
        __meta: { framework: "vue" }
      };
      {
        ctxOptions.datetimeFormats = _datetimeFormats.value;
        ctxOptions.numberFormats = _numberFormats.value;
        ctxOptions.__datetimeFormatters = isPlainObject$2(_context) ? _context.__datetimeFormatters : void 0;
        ctxOptions.__numberFormatters = isPlainObject$2(_context) ? _context.__numberFormatters : void 0;
      }
      const ctx = createCoreContext(ctxOptions);
      _isGlobal && setFallbackContext(ctx);
      return ctx;
    };
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale2 = computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages2 = computed(() => _messages.value);
    const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
    const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$4(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
      trackReactivityValues();
      let ret;
      try {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
        }
        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : void 0;
        }
        ret = fn(_context);
      } finally {
        if (__INTLIFY_PROD_DEVTOOLS__) ;
        if (!_isGlobal) {
          _context.fallbackContext = void 0;
        }
      }
      if (warnType !== "translate exists" && // for not `te` (e.g `t`)
      isNumber$2(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
        const [key2, arg2] = argumentParser();
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key2);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
      }
    };
    function t2(...args) {
      return wrapWithDeps((context) => Reflect.apply(translate$1, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key2) => key2, (val) => isString$4(val));
    }
    function rt2(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$8(arg3)) {
        throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
      }
      return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
    }
    function d2(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$4(val));
    }
    function n2(...args) {
      return wrapWithDeps((context) => Reflect.apply(number$1, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$4(val));
    }
    function normalize2(values) {
      return values.map((val) => isString$4(val) || isNumber$2(val) || isBoolean$1(val) ? createTextNode(String(val)) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize: normalize2,
      interpolate,
      type: "vnode"
    };
    function translateVNode(...args) {
      return wrapWithDeps(
        (context) => {
          let ret;
          const _context2 = context;
          try {
            _context2.processor = processor;
            ret = Reflect.apply(translate$1, null, [_context2, ...args]);
          } finally {
            _context2.processor = null;
          }
          return ret;
        },
        () => parseTranslateArgs(...args),
        "translate",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root2) => root2[TranslateVNodeSymbol](...args),
        (key2) => [createTextNode(key2)],
        (val) => isArray$5(val)
      );
    }
    function numberParts(...args) {
      return wrapWithDeps(
        (context) => Reflect.apply(number$1, null, [context, ...args]),
        () => parseNumberArgs(...args),
        "number format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root2) => root2[NumberPartsSymbol](...args),
        NOOP_RETURN_ARRAY,
        (val) => isString$4(val) || isArray$5(val)
      );
    }
    function datetimeParts(...args) {
      return wrapWithDeps(
        (context) => Reflect.apply(datetime, null, [context, ...args]),
        () => parseDateTimeArgs(...args),
        "datetime format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root2) => root2[DatetimePartsSymbol](...args),
        NOOP_RETURN_ARRAY,
        (val) => isString$4(val) || isArray$5(val)
      );
    }
    function setPluralRules(rules2) {
      _pluralRules = rules2;
      _context.pluralRules = _pluralRules;
    }
    function te(key2, locale22) {
      return wrapWithDeps(() => {
        if (!key2) {
          return false;
        }
        const targetLocale = isString$4(locale22) ? locale22 : _locale.value;
        const message = getLocaleMessage(targetLocale);
        const resolved = _context.messageResolver(message, key2);
        return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$4(resolved) : resolved != null;
      }, () => [key2], "translate exists", (root2) => {
        return Reflect.apply(root2.te, root2, [key2, locale22]);
      }, NOOP_RETURN_FALSE, (val) => isBoolean$1(val));
    }
    function resolveMessages(key2) {
      let messages22 = null;
      const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i2 = 0; i2 < locales.length; i2++) {
        const targetLocaleMessages = _messages.value[locales[i2]] || {};
        const messageValue = _context.messageResolver(targetLocaleMessages, key2);
        if (messageValue != null) {
          messages22 = messageValue;
          break;
        }
      }
      return messages22;
    }
    function tm(key2) {
      const messages22 = resolveMessages(key2);
      return messages22 != null ? messages22 : __root ? __root.tm(key2) || {} : {};
    }
    function getLocaleMessage(locale22) {
      return _messages.value[locale22] || {};
    }
    function setLocaleMessage(locale22, message) {
      if (flatJson) {
        const _message = { [locale22]: message };
        for (const key2 in _message) {
          if (hasOwn$2(_message, key2)) {
            handleFlatJson(_message[key2]);
          }
        }
        message = _message[locale22];
      }
      _messages.value[locale22] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale22, message) {
      _messages.value[locale22] = _messages.value[locale22] || {};
      const _message = { [locale22]: message };
      if (flatJson) {
        for (const key2 in _message) {
          if (hasOwn$2(_message, key2)) {
            handleFlatJson(_message[key2]);
          }
        }
      }
      message = _message[locale22];
      deepCopy(message, _messages.value[locale22]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale22) {
      return _datetimeFormats.value[locale22] || {};
    }
    function setDateTimeFormat(locale22, format2) {
      _datetimeFormats.value[locale22] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale22, format2);
    }
    function mergeDateTimeFormat(locale22, format2) {
      _datetimeFormats.value[locale22] = assign$2(_datetimeFormats.value[locale22] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale22, format2);
    }
    function getNumberFormat(locale22) {
      return _numberFormats.value[locale22] || {};
    }
    function setNumberFormat(locale22, format2) {
      _numberFormats.value[locale22] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale22, format2);
    }
    function mergeNumberFormat(locale22, format2) {
      _numberFormats.value[locale22] = assign$2(_numberFormats.value[locale22] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale22, format2);
    }
    composerID++;
    if (__root && inBrowser) {
      watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale: locale2,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages: messages2,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t: t2,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [SetPluralRulesSymbol]: setPluralRules
    };
    {
      composer.datetimeFormats = datetimeFormats;
      composer.numberFormats = numberFormats;
      composer.rt = rt2;
      composer.te = te;
      composer.tm = tm;
      composer.d = d2;
      composer.n = n2;
      composer.getDateTimeFormat = getDateTimeFormat;
      composer.setDateTimeFormat = setDateTimeFormat;
      composer.mergeDateTimeFormat = mergeDateTimeFormat;
      composer.getNumberFormat = getNumberFormat;
      composer.setNumberFormat = setNumberFormat;
      composer.mergeNumberFormat = mergeNumberFormat;
      composer[InejctWithOptionSymbol] = __injectWithOption;
      composer[TranslateVNodeSymbol] = translateVNode;
      composer[DatetimePartsSymbol] = datetimeParts;
      composer[NumberPartsSymbol] = numberParts;
    }
    return composer;
  }
  function convertComposerOptions(options2) {
    const locale2 = isString$4(options2.locale) ? options2.locale : DEFAULT_LOCALE$1;
    const fallbackLocale = isString$4(options2.fallbackLocale) || isArray$5(options2.fallbackLocale) || isPlainObject$2(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : locale2;
    const missing = isFunction$4(options2.missing) ? options2.missing : void 0;
    const missingWarn = isBoolean$1(options2.silentTranslationWarn) || isRegExp$2(options2.silentTranslationWarn) ? !options2.silentTranslationWarn : true;
    const fallbackWarn = isBoolean$1(options2.silentFallbackWarn) || isRegExp$2(options2.silentFallbackWarn) ? !options2.silentFallbackWarn : true;
    const fallbackRoot = isBoolean$1(options2.fallbackRoot) ? options2.fallbackRoot : true;
    const fallbackFormat = !!options2.formatFallbackMessages;
    const modifiers = isPlainObject$2(options2.modifiers) ? options2.modifiers : {};
    const pluralizationRules = options2.pluralizationRules;
    const postTranslation = isFunction$4(options2.postTranslation) ? options2.postTranslation : void 0;
    const warnHtmlMessage = isString$4(options2.warnHtmlInMessage) ? options2.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options2.escapeParameterHtml;
    const inheritLocale = isBoolean$1(options2.sync) ? options2.sync : true;
    let messages2 = options2.messages;
    if (isPlainObject$2(options2.sharedMessages)) {
      const sharedMessages = options2.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages2 = locales.reduce((messages22, locale22) => {
        const message = messages22[locale22] || (messages22[locale22] = {});
        assign$2(message, sharedMessages[locale22]);
        return messages22;
      }, messages2 || {});
    }
    const { __i18n, __root, __injectWithOption } = options2;
    const datetimeFormats = options2.datetimeFormats;
    const numberFormats = options2.numberFormats;
    const flatJson = options2.flatJson;
    const translateExistCompatible = options2.translateExistCompatible;
    return {
      locale: locale2,
      fallbackLocale,
      messages: messages2,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      messageResolver: options2.messageResolver,
      inheritLocale,
      translateExistCompatible,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options2 = {}, VueI18nLegacy) {
    {
      const composer = createComposer(convertComposerOptions(options2));
      const { __extender } = options2;
      const vueI18n = {
        // id
        id: composer.id,
        // locale
        get locale() {
          return composer.locale.value;
        },
        set locale(val) {
          composer.locale.value = val;
        },
        // fallbackLocale
        get fallbackLocale() {
          return composer.fallbackLocale.value;
        },
        set fallbackLocale(val) {
          composer.fallbackLocale.value = val;
        },
        // messages
        get messages() {
          return composer.messages.value;
        },
        // datetimeFormats
        get datetimeFormats() {
          return composer.datetimeFormats.value;
        },
        // numberFormats
        get numberFormats() {
          return composer.numberFormats.value;
        },
        // availableLocales
        get availableLocales() {
          return composer.availableLocales;
        },
        // formatter
        get formatter() {
          return {
            interpolate() {
              return [];
            }
          };
        },
        set formatter(val) {
        },
        // missing
        get missing() {
          return composer.getMissingHandler();
        },
        set missing(handler) {
          composer.setMissingHandler(handler);
        },
        // silentTranslationWarn
        get silentTranslationWarn() {
          return isBoolean$1(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
        },
        set silentTranslationWarn(val) {
          composer.missingWarn = isBoolean$1(val) ? !val : val;
        },
        // silentFallbackWarn
        get silentFallbackWarn() {
          return isBoolean$1(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
        },
        set silentFallbackWarn(val) {
          composer.fallbackWarn = isBoolean$1(val) ? !val : val;
        },
        // modifiers
        get modifiers() {
          return composer.modifiers;
        },
        // formatFallbackMessages
        get formatFallbackMessages() {
          return composer.fallbackFormat;
        },
        set formatFallbackMessages(val) {
          composer.fallbackFormat = val;
        },
        // postTranslation
        get postTranslation() {
          return composer.getPostTranslationHandler();
        },
        set postTranslation(handler) {
          composer.setPostTranslationHandler(handler);
        },
        // sync
        get sync() {
          return composer.inheritLocale;
        },
        set sync(val) {
          composer.inheritLocale = val;
        },
        // warnInHtmlMessage
        get warnHtmlInMessage() {
          return composer.warnHtmlMessage ? "warn" : "off";
        },
        set warnHtmlInMessage(val) {
          composer.warnHtmlMessage = val !== "off";
        },
        // escapeParameterHtml
        get escapeParameterHtml() {
          return composer.escapeParameter;
        },
        set escapeParameterHtml(val) {
          composer.escapeParameter = val;
        },
        // preserveDirectiveContent
        get preserveDirectiveContent() {
          return true;
        },
        set preserveDirectiveContent(val) {
        },
        // pluralizationRules
        get pluralizationRules() {
          return composer.pluralRules || {};
        },
        // for internal
        __composer: composer,
        // t
        t(...args) {
          const [arg1, arg2, arg3] = args;
          const options22 = {};
          let list2 = null;
          let named = null;
          if (!isString$4(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key2 = arg1;
          if (isString$4(arg2)) {
            options22.locale = arg2;
          } else if (isArray$5(arg2)) {
            list2 = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isArray$5(arg3)) {
            list2 = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key2,
            list2 || named || {},
            options22
          ]);
        },
        rt(...args) {
          return Reflect.apply(composer.rt, composer, [...args]);
        },
        // tc
        tc(...args) {
          const [arg1, arg2, arg3] = args;
          const options22 = { plural: 1 };
          let list2 = null;
          let named = null;
          if (!isString$4(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key2 = arg1;
          if (isString$4(arg2)) {
            options22.locale = arg2;
          } else if (isNumber$2(arg2)) {
            options22.plural = arg2;
          } else if (isArray$5(arg2)) {
            list2 = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isString$4(arg3)) {
            options22.locale = arg3;
          } else if (isArray$5(arg3)) {
            list2 = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key2,
            list2 || named || {},
            options22
          ]);
        },
        // te
        te(key2, locale2) {
          return composer.te(key2, locale2);
        },
        // tm
        tm(key2) {
          return composer.tm(key2);
        },
        // getLocaleMessage
        getLocaleMessage(locale2) {
          return composer.getLocaleMessage(locale2);
        },
        // setLocaleMessage
        setLocaleMessage(locale2, message) {
          composer.setLocaleMessage(locale2, message);
        },
        // mergeLocaleMessage
        mergeLocaleMessage(locale2, message) {
          composer.mergeLocaleMessage(locale2, message);
        },
        // d
        d(...args) {
          return Reflect.apply(composer.d, composer, [...args]);
        },
        // getDateTimeFormat
        getDateTimeFormat(locale2) {
          return composer.getDateTimeFormat(locale2);
        },
        // setDateTimeFormat
        setDateTimeFormat(locale2, format2) {
          composer.setDateTimeFormat(locale2, format2);
        },
        // mergeDateTimeFormat
        mergeDateTimeFormat(locale2, format2) {
          composer.mergeDateTimeFormat(locale2, format2);
        },
        // n
        n(...args) {
          return Reflect.apply(composer.n, composer, [...args]);
        },
        // getNumberFormat
        getNumberFormat(locale2) {
          return composer.getNumberFormat(locale2);
        },
        // setNumberFormat
        setNumberFormat(locale2, format2) {
          composer.setNumberFormat(locale2, format2);
        },
        // mergeNumberFormat
        mergeNumberFormat(locale2, format2) {
          composer.mergeNumberFormat(locale2, format2);
        },
        // getChoiceIndex
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getChoiceIndex(choice, choicesLength) {
          return -1;
        }
      };
      vueI18n.__extender = __extender;
      return vueI18n;
    }
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
      /* ComponentI18nScope */
    },
    i18n: {
      type: Object
    }
  };
  function getInterpolateArg({ slots }, keys2) {
    if (keys2.length === 1 && keys2[0] === "default") {
      const ret = slots.default ? slots.default() : [];
      return ret.reduce((slot, current) => {
        return [
          ...slot,
          // prettier-ignore
          ...current.type === Fragment ? current.children : [current]
        ];
      }, []);
    } else {
      return keys2.reduce((arg, key2) => {
        const slot = slots[key2];
        if (slot) {
          arg[key2] = slot();
        }
        return arg;
      }, {});
    }
  }
  function getFragmentableTag(tag) {
    return Fragment;
  }
  const TranslationImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-t",
    props: assign$2({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        validator: (val) => isNumber$2(val) || !isNaN(val)
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props2, context) {
      const { slots, attrs } = context;
      const i18n2 = props2.i18n || useI18n({
        useScope: props2.scope,
        __useComponent: true
      });
      return () => {
        const keys2 = Object.keys(slots).filter((key2) => key2 !== "_");
        const options2 = {};
        if (props2.locale) {
          options2.locale = props2.locale;
        }
        if (props2.plural !== void 0) {
          options2.plural = isString$4(props2.plural) ? +props2.plural : props2.plural;
        }
        const arg = getInterpolateArg(context, keys2);
        const children = i18n2[TranslateVNodeSymbol](props2.keypath, arg, options2);
        const assignedAttrs = assign$2({}, attrs);
        const tag = isString$4(props2.tag) || isObject$8(props2.tag) ? props2.tag : getFragmentableTag();
        return h$1(tag, assignedAttrs, children);
      };
    }
  });
  const Translation = TranslationImpl;
  function isVNode(target) {
    return isArray$5(target) && !isString$4(target[0]);
  }
  function renderFormatter(props2, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options2 = { part: true };
      let overrides = {};
      if (props2.locale) {
        options2.locale = props2.locale;
      }
      if (isString$4(props2.format)) {
        options2.key = props2.format;
      } else if (isObject$8(props2.format)) {
        if (isString$4(props2.format.key)) {
          options2.key = props2.format.key;
        }
        overrides = Object.keys(props2.format).reduce((options22, prop) => {
          return slotKeys.includes(prop) ? assign$2({}, options22, { [prop]: props2.format[prop] }) : options22;
        }, {});
      }
      const parts2 = partFormatter(...[props2.value, options2, overrides]);
      let children = [options2.key];
      if (isArray$5(parts2)) {
        children = parts2.map((part, index2) => {
          const slot = slots[part.type];
          const node2 = slot ? slot({ [part.type]: part.value, index: index2, parts: parts2 }) : [part.value];
          if (isVNode(node2)) {
            node2[0].key = `${part.type}-${index2}`;
          }
          return node2;
        });
      } else if (isString$4(parts2)) {
        children = [parts2];
      }
      const assignedAttrs = assign$2({}, attrs);
      const tag = isString$4(props2.tag) || isObject$8(props2.tag) ? props2.tag : getFragmentableTag();
      return h$1(tag, assignedAttrs, children);
    };
  }
  const NumberFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-n",
    props: assign$2({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({
        useScope: props2.scope,
        __useComponent: true
      });
      return renderFormatter(props2, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[NumberPartsSymbol](...args)
      ));
    }
  });
  const NumberFormat = NumberFormatImpl;
  const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-d",
    props: assign$2({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({
        useScope: props2.scope,
        __useComponent: true
      });
      return renderFormatter(props2, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[DatetimePartsSymbol](...args)
      ));
    }
  });
  const DatetimeFormat = DatetimeFormatImpl;
  function getComposer$2(i18n2, instance) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const _process = (binding) => {
      const { instance, modifiers, value } = binding;
      if (!instance || !instance.$) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const composer = getComposer$2(i18n2, instance.$);
      const parsedValue = parseValue(value);
      return [
        Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
        composer
      ];
    };
    const register2 = (el, binding) => {
      const [textContent, composer] = _process(binding);
      if (inBrowser && i18n2.global === composer) {
        el.__i18nWatcher = watch(composer.locale, () => {
          binding.instance && binding.instance.$forceUpdate();
        });
      }
      el.__composer = composer;
      el.textContent = textContent;
    };
    const unregister2 = (el) => {
      if (inBrowser && el.__i18nWatcher) {
        el.__i18nWatcher();
        el.__i18nWatcher = void 0;
        delete el.__i18nWatcher;
      }
      if (el.__composer) {
        el.__composer = void 0;
        delete el.__composer;
      }
    };
    const update = (el, { value }) => {
      if (el.__composer) {
        const composer = el.__composer;
        const parsedValue = parseValue(value);
        el.textContent = Reflect.apply(composer.t, composer, [
          ...makeParams(parsedValue)
        ]);
      }
    };
    const getSSRProps = (binding) => {
      const [textContent] = _process(binding);
      return { textContent };
    };
    return {
      created: register2,
      unmounted: unregister2,
      beforeUpdate: update,
      getSSRProps
    };
  }
  function parseValue(value) {
    if (isString$4(value)) {
      return { path: value };
    } else if (isPlainObject$2(value)) {
      if (!("path" in value)) {
        throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
      }
      return value;
    } else {
      throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
  }
  function makeParams(value) {
    const { path, locale: locale2, args, choice, plural } = value;
    const options2 = {};
    const named = args || {};
    if (isString$4(locale2)) {
      options2.locale = locale2;
    }
    if (isNumber$2(choice)) {
      options2.plural = choice;
    }
    if (isNumber$2(plural)) {
      options2.plural = plural;
    }
    return [path, named, options2];
  }
  function apply$1(app2, i18n2, ...options2) {
    const pluginOptions = isPlainObject$2(options2[0]) ? options2[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean$1(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall) {
      [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
      [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
      [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
    }
    {
      app2.directive("t", vTDirective(i18n2));
    }
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const options2 = this.$options;
        if (options2.i18n) {
          const optionsI18n = options2.i18n;
          if (options2.__i18n) {
            optionsI18n.__i18n = options2.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            optionsI18n.__extender = i18n2.__vueI18nExtend;
            this.$i18n = createVueI18n(optionsI18n);
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else if (options2.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, options2);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options2.__i18n,
              __injectWithOption: true,
              __extender: i18n2.__vueI18nExtend,
              __root: composer
            });
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else {
          this.$i18n = vuei18n;
        }
        if (options2.__i18nGlobal) {
          adjustI18nResources(composer, options2, options2);
        }
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key2, locale2) => this.$i18n.te(key2, locale2);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key2) => this.$i18n.tm(key2);
        i18n2.__setInstance(instance, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const _vueI18n = this.$i18n;
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        if (_vueI18n.__disposer) {
          _vueI18n.__disposer();
          delete _vueI18n.__disposer;
          delete _vueI18n.__extender;
        }
        i18n2.__deleteInstance(instance);
        delete this.$i18n;
      }
    };
  }
  function mergeToGlobal(g2, options2) {
    g2.locale = options2.locale || g2.locale;
    g2.fallbackLocale = options2.fallbackLocale || g2.fallbackLocale;
    g2.missing = options2.missing || g2.missing;
    g2.silentTranslationWarn = options2.silentTranslationWarn || g2.silentFallbackWarn;
    g2.silentFallbackWarn = options2.silentFallbackWarn || g2.silentFallbackWarn;
    g2.formatFallbackMessages = options2.formatFallbackMessages || g2.formatFallbackMessages;
    g2.postTranslation = options2.postTranslation || g2.postTranslation;
    g2.warnHtmlInMessage = options2.warnHtmlInMessage || g2.warnHtmlInMessage;
    g2.escapeParameterHtml = options2.escapeParameterHtml || g2.escapeParameterHtml;
    g2.sync = options2.sync || g2.sync;
    g2.__composer[SetPluralRulesSymbol](options2.pluralizationRules || g2.pluralizationRules);
    const messages2 = getLocaleMessages(g2.locale, {
      messages: options2.messages,
      __i18n: options2.__i18n
    });
    Object.keys(messages2).forEach((locale2) => g2.mergeLocaleMessage(locale2, messages2[locale2]));
    if (options2.datetimeFormats) {
      Object.keys(options2.datetimeFormats).forEach((locale2) => g2.mergeDateTimeFormat(locale2, options2.datetimeFormats[locale2]));
    }
    if (options2.numberFormats) {
      Object.keys(options2.numberFormats).forEach((locale2) => g2.mergeNumberFormat(locale2, options2.numberFormats[locale2]));
    }
    return g2;
  }
  const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
  function createI18n(options2 = {}, VueI18nLegacy) {
    const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean$1(options2.legacy) ? options2.legacy : __VUE_I18N_LEGACY_API__;
    const __globalInjection = isBoolean$1(options2.globalInjection) ? options2.globalInjection : true;
    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options2.allowComposition : true;
    const __instances = /* @__PURE__ */ new Map();
    const [globalScope, __global] = createGlobal(options2, __legacyMode);
    const symbol = /* @__PURE__ */ makeSymbol("");
    function __getInstance(component) {
      return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
      __instances.set(component, instance);
    }
    function __deleteInstance(component) {
      __instances.delete(component);
    }
    {
      const i18n2 = {
        // mode
        get mode() {
          return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
        },
        // allowComposition
        get allowComposition() {
          return __allowComposition;
        },
        // install plugin
        async install(app2, ...options22) {
          app2.__VUE_I18N_SYMBOL__ = symbol;
          app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
          if (isPlainObject$2(options22[0])) {
            const opts = options22[0];
            i18n2.__composerExtend = opts.__composerExtend;
            i18n2.__vueI18nExtend = opts.__vueI18nExtend;
          }
          let globalReleaseHandler = null;
          if (!__legacyMode && __globalInjection) {
            globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
          }
          if (__VUE_I18N_FULL_INSTALL__) {
            apply$1(app2, i18n2, ...options22);
          }
          if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
            app2.mixin(defineMixin(__global, __global.__composer, i18n2));
          }
          const unmountApp = app2.unmount;
          app2.unmount = () => {
            globalReleaseHandler && globalReleaseHandler();
            i18n2.dispose();
            unmountApp();
          };
        },
        // global accessor
        get global() {
          return __global;
        },
        dispose() {
          globalScope.stop();
        },
        // @internal
        __instances,
        // @internal
        __getInstance,
        // @internal
        __setInstance,
        // @internal
        __deleteInstance
      };
      return i18n2;
    }
  }
  function useI18n(options2 = {}) {
    const instance = getCurrentInstance();
    if (instance == null) {
      throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
    }
    const i18n2 = getI18nInstance(instance);
    const gl = getGlobalComposer(i18n2);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options2, componentOptions);
    if (__VUE_I18N_LEGACY_API__) {
      if (i18n2.mode === "legacy" && !options2.__useComponent) {
        if (!i18n2.allowComposition) {
          throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
        }
        return useI18nForLegacy(instance, scope, gl, options2);
      }
    }
    if (scope === "global") {
      adjustI18nResources(gl, options2, componentOptions);
      return gl;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance, options2.__useComponent);
      if (composer2 == null) {
        composer2 = gl;
      }
      return composer2;
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
      const composerOptions = assign$2({}, options2);
      if ("__i18n" in componentOptions) {
        composerOptions.__i18n = componentOptions.__i18n;
      }
      if (gl) {
        composerOptions.__root = gl;
      }
      composer = createComposer(composerOptions);
      if (i18nInternal.__composerExtend) {
        composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
      }
      setupLifeCycle(i18nInternal, instance, composer);
      i18nInternal.__setInstance(instance, composer);
    }
    return composer;
  }
  function createGlobal(options2, legacyMode, VueI18nLegacy) {
    const scope = effectScope();
    {
      const obj2 = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options2)) : scope.run(() => createComposer(options2));
      if (obj2 == null) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      return [scope, obj2];
    }
  }
  function getI18nInstance(instance) {
    {
      const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
      if (!i18n2) {
        throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
      }
      return i18n2;
    }
  }
  function getScope(options2, componentOptions) {
    return isEmptyObject(options2) ? "__i18n" in componentOptions ? "local" : "global" : !options2.useScope ? "local" : options2.useScope;
  }
  function getGlobalComposer(i18n2) {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root2 = target.root;
    let current = getParentComponentInstance(target, useComponent);
    while (current != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current);
      } else {
        if (__VUE_I18N_LEGACY_API__) {
          const vueI18n = i18nInternal.__getInstance(current);
          if (vueI18n != null) {
            composer = vueI18n.__composer;
            if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
              composer = null;
            }
          }
        }
      }
      if (composer != null) {
        break;
      }
      if (root2 === current) {
        break;
      }
      current = current.parent;
    }
    return composer;
  }
  function getParentComponentInstance(target, useComponent = false) {
    if (target == null) {
      return null;
    }
    {
      return !useComponent ? target.parent : target.vnode.ctx || target.parent;
    }
  }
  function setupLifeCycle(i18n2, target, composer) {
    {
      onMounted(() => {
      }, target);
      onUnmounted(() => {
        const _composer = composer;
        i18n2.__deleteInstance(target);
        const dispose2 = _composer[DisposeSymbol];
        if (dispose2) {
          dispose2();
          delete _composer[DisposeSymbol];
        }
      }, target);
    }
  }
  function useI18nForLegacy(instance, scope, root2, options2 = {}) {
    const isLocalScope = scope === "local";
    const _composer = shallowRef(null);
    if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
      throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    }
    const _inheritLocale = isBoolean$1(options2.inheritLocale) ? options2.inheritLocale : !isString$4(options2.locale);
    const _locale = ref(
      // prettier-ignore
      !isLocalScope || _inheritLocale ? root2.locale.value : isString$4(options2.locale) ? options2.locale : DEFAULT_LOCALE$1
    );
    const _fallbackLocale = ref(
      // prettier-ignore
      !isLocalScope || _inheritLocale ? root2.fallbackLocale.value : isString$4(options2.fallbackLocale) || isArray$5(options2.fallbackLocale) || isPlainObject$2(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : _locale.value
    );
    const _messages = ref(getLocaleMessages(_locale.value, options2));
    const _datetimeFormats = ref(isPlainObject$2(options2.datetimeFormats) ? options2.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = ref(isPlainObject$2(options2.numberFormats) ? options2.numberFormats : { [_locale.value]: {} });
    const _missingWarn = isLocalScope ? root2.missingWarn : isBoolean$1(options2.missingWarn) || isRegExp$2(options2.missingWarn) ? options2.missingWarn : true;
    const _fallbackWarn = isLocalScope ? root2.fallbackWarn : isBoolean$1(options2.fallbackWarn) || isRegExp$2(options2.fallbackWarn) ? options2.fallbackWarn : true;
    const _fallbackRoot = isLocalScope ? root2.fallbackRoot : isBoolean$1(options2.fallbackRoot) ? options2.fallbackRoot : true;
    const _fallbackFormat = !!options2.fallbackFormat;
    const _missing = isFunction$4(options2.missing) ? options2.missing : null;
    const _postTranslation = isFunction$4(options2.postTranslation) ? options2.postTranslation : null;
    const _warnHtmlMessage = isLocalScope ? root2.warnHtmlMessage : isBoolean$1(options2.warnHtmlMessage) ? options2.warnHtmlMessage : true;
    const _escapeParameter = !!options2.escapeParameter;
    const _modifiers = isLocalScope ? root2.modifiers : isPlainObject$2(options2.modifiers) ? options2.modifiers : {};
    const _pluralRules = options2.pluralRules || isLocalScope && root2.pluralRules;
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale2 = computed({
      get: () => {
        return _composer.value ? _composer.value.locale.value : _locale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.locale.value = val;
        }
        _locale.value = val;
      }
    });
    const fallbackLocale = computed({
      get: () => {
        return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.fallbackLocale.value = val;
        }
        _fallbackLocale.value = val;
      }
    });
    const messages2 = computed(() => {
      if (_composer.value) {
        return _composer.value.messages.value;
      } else {
        return _messages.value;
      }
    });
    const datetimeFormats = computed(() => _datetimeFormats.value);
    const numberFormats = computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
    }
    function setPostTranslationHandler(handler) {
      if (_composer.value) {
        _composer.value.setPostTranslationHandler(handler);
      }
    }
    function getMissingHandler() {
      return _composer.value ? _composer.value.getMissingHandler() : _missing;
    }
    function setMissingHandler(handler) {
      if (_composer.value) {
        _composer.value.setMissingHandler(handler);
      }
    }
    function warpWithDeps(fn) {
      trackReactivityValues();
      return fn();
    }
    function t2(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
    }
    function rt2(...args) {
      return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
    }
    function d2(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
    }
    function n2(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
    }
    function tm(key2) {
      return _composer.value ? _composer.value.tm(key2) : {};
    }
    function te(key2, locale22) {
      return _composer.value ? _composer.value.te(key2, locale22) : false;
    }
    function getLocaleMessage(locale22) {
      return _composer.value ? _composer.value.getLocaleMessage(locale22) : {};
    }
    function setLocaleMessage(locale22, message) {
      if (_composer.value) {
        _composer.value.setLocaleMessage(locale22, message);
        _messages.value[locale22] = message;
      }
    }
    function mergeLocaleMessage(locale22, message) {
      if (_composer.value) {
        _composer.value.mergeLocaleMessage(locale22, message);
      }
    }
    function getDateTimeFormat(locale22) {
      return _composer.value ? _composer.value.getDateTimeFormat(locale22) : {};
    }
    function setDateTimeFormat(locale22, format2) {
      if (_composer.value) {
        _composer.value.setDateTimeFormat(locale22, format2);
        _datetimeFormats.value[locale22] = format2;
      }
    }
    function mergeDateTimeFormat(locale22, format2) {
      if (_composer.value) {
        _composer.value.mergeDateTimeFormat(locale22, format2);
      }
    }
    function getNumberFormat(locale22) {
      return _composer.value ? _composer.value.getNumberFormat(locale22) : {};
    }
    function setNumberFormat(locale22, format2) {
      if (_composer.value) {
        _composer.value.setNumberFormat(locale22, format2);
        _numberFormats.value[locale22] = format2;
      }
    }
    function mergeNumberFormat(locale22, format2) {
      if (_composer.value) {
        _composer.value.mergeNumberFormat(locale22, format2);
      }
    }
    const wrapper = {
      get id() {
        return _composer.value ? _composer.value.id : -1;
      },
      locale: locale2,
      fallbackLocale,
      messages: messages2,
      datetimeFormats,
      numberFormats,
      get inheritLocale() {
        return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
      },
      set inheritLocale(val) {
        if (_composer.value) {
          _composer.value.inheritLocale = val;
        }
      },
      get availableLocales() {
        return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
      },
      get modifiers() {
        return _composer.value ? _composer.value.modifiers : _modifiers;
      },
      get pluralRules() {
        return _composer.value ? _composer.value.pluralRules : _pluralRules;
      },
      get isGlobal() {
        return _composer.value ? _composer.value.isGlobal : false;
      },
      get missingWarn() {
        return _composer.value ? _composer.value.missingWarn : _missingWarn;
      },
      set missingWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackWarn() {
        return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
      },
      set fallbackWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackRoot() {
        return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
      },
      set fallbackRoot(val) {
        if (_composer.value) {
          _composer.value.fallbackRoot = val;
        }
      },
      get fallbackFormat() {
        return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
      },
      set fallbackFormat(val) {
        if (_composer.value) {
          _composer.value.fallbackFormat = val;
        }
      },
      get warnHtmlMessage() {
        return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        if (_composer.value) {
          _composer.value.warnHtmlMessage = val;
        }
      },
      get escapeParameter() {
        return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
      },
      set escapeParameter(val) {
        if (_composer.value) {
          _composer.value.escapeParameter = val;
        }
      },
      t: t2,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      rt: rt2,
      d: d2,
      n: n2,
      tm,
      te,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getDateTimeFormat,
      setDateTimeFormat,
      mergeDateTimeFormat,
      getNumberFormat,
      setNumberFormat,
      mergeNumberFormat
    };
    function sync(composer) {
      composer.locale.value = _locale.value;
      composer.fallbackLocale.value = _fallbackLocale.value;
      Object.keys(_messages.value).forEach((locale22) => {
        composer.mergeLocaleMessage(locale22, _messages.value[locale22]);
      });
      Object.keys(_datetimeFormats.value).forEach((locale22) => {
        composer.mergeDateTimeFormat(locale22, _datetimeFormats.value[locale22]);
      });
      Object.keys(_numberFormats.value).forEach((locale22) => {
        composer.mergeNumberFormat(locale22, _numberFormats.value[locale22]);
      });
      composer.escapeParameter = _escapeParameter;
      composer.fallbackFormat = _fallbackFormat;
      composer.fallbackRoot = _fallbackRoot;
      composer.fallbackWarn = _fallbackWarn;
      composer.missingWarn = _missingWarn;
      composer.warnHtmlMessage = _warnHtmlMessage;
    }
    onBeforeMount(() => {
      if (instance.proxy == null || instance.proxy.$i18n == null) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
      }
      const composer = _composer.value = instance.proxy.$i18n.__composer;
      if (scope === "global") {
        _locale.value = composer.locale.value;
        _fallbackLocale.value = composer.fallbackLocale.value;
        _messages.value = composer.messages.value;
        _datetimeFormats.value = composer.datetimeFormats.value;
        _numberFormats.value = composer.numberFormats.value;
      } else if (isLocalScope) {
        sync(composer);
      }
    });
    return wrapper;
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
  function injectGlobalFields(app2, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const wrap = isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app2.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
    });
    const dispose2 = () => {
      delete app2.config.globalProperties.$i18n;
      globalExportMethods.forEach((method) => {
        delete app2.config.globalProperties[`$${method}`];
      });
    };
    return dispose2;
  }
  {
    initFeatureFlags();
  }
  if (__INTLIFY_JIT_COMPILATION__) {
    registerMessageCompiler(compile$1);
  } else {
    registerMessageCompiler(compileToFunction);
  }
  registerMessageResolver(resolveValue);
  registerLocaleFallbacker(fallbackWithLocaleChain);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const scriptRel = "modulepreload";
  const assetsURL = function(dep) {
    return "/vue-app/" + dep;
  };
  const seen = {};
  const __vitePreload = function preload(baseModule, deps, importerUrl) {
    let promise = Promise.resolve();
    if (false) {
      let allSettled = function(promises$2) {
        return Promise.all(promises$2.map((p$1) => Promise.resolve(p$1).then((value$1) => ({
          status: "fulfilled",
          value: value$1
        }), (reason) => ({
          status: "rejected",
          reason
        }))));
      };
      document.getElementsByTagName("link");
      const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
      const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
      promise = allSettled(deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) link.as = "script";
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) link.setAttribute("nonce", cspNonce);
        document.head.appendChild(link);
        if (isCss) return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
        });
      }));
    }
    function handlePreloadError(err$2) {
      const e$12 = new Event("vite:preloadError", { cancelable: true });
      e$12.payload = err$2;
      window.dispatchEvent(e$12);
      if (!e$12.defaultPrevented) throw err$2;
    }
    return promise.then((res) => {
      for (const item of res || []) {
        if (item.status !== "rejected") continue;
        handlePreloadError(item.reason);
      }
      return baseModule().catch(handlePreloadError);
    });
  };
  const __variableDynamicImportRuntimeHelper = (glob$1, path$13, segs) => {
    const v2 = glob$1[path$13];
    if (v2) return typeof v2 === "function" ? v2() : Promise.resolve(v2);
    return new Promise((_2, reject) => {
      (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, /* @__PURE__ */ new Error("Unknown variable dynamic import: " + path$13 + (path$13.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : ""))));
    });
  };
  const options = {
    legacy: false,
    locale: "zh",
    fallbackLocale: "zh"
  };
  const i18n = createI18n(options);
  function setupI18n() {
    setI18nLanguage(i18n, options?.locale ?? "zh");
    return i18n;
  }
  function setI18nLanguage(i18n2, locale2) {
    if ("mode" in i18n2 && i18n2.mode === "legacy") {
      i18n2.global.locale = locale2;
    } else {
      i18n2.global.locale.value = locale2;
    }
    document.querySelector("html")?.setAttribute("lang", locale2);
  }
  async function loadLocaleMessages(i18n2, locale2) {
    const localFilename = locale2.split("-")[0];
    const messages2 = await __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "./locales/en.json": () => __vitePreload(() => Promise.resolve().then(() => en$1), false ? __VITE_PRELOAD__ : void 0), "./locales/zh.json": () => __vitePreload(() => Promise.resolve().then(() => zh$1), false ? __VITE_PRELOAD__ : void 0) }), `./locales/${localFilename}.json`, 3);
    i18n2.global.setLocaleMessage(locale2, { ...messages2 });
    return nextTick();
  }
  const _sfc_main$4 = {
    __name: "App",
    setup(__props) {
      dayjs.locale("zh-cn");
      const lang = ref("zh");
      const { locale: locale2 } = useI18n();
      watch(
        () => locale2.value,
        (val) => {
          console.log(val);
          if (val === "en") {
            dayjs.locale("en-us");
            lang.value = "en";
            loadLocaleMessages(i18n, lang.value);
          } else {
            dayjs.locale("zh-cn");
            lang.value = "zh";
            loadLocaleMessages(i18n, lang.value);
          }
        },
        { deep: true }
      );
      return (_ctx, _cache) => {
        const _component_RouterView = resolveComponent("RouterView");
        const _component_a_config_provider = resolveComponent("a-config-provider");
        return openBlock(), createBlock(_component_a_config_provider, {
          locale: lang.value === "en" ? unref(localeValues$1) : unref(localeValues)
        }, {
          default: withCtx(() => [
            createVNode(_component_RouterView)
          ]),
          _: 1
        }, 8, ["locale"]);
      };
    }
  };
  /*!
    * vue-router v4.5.1
    * (c) 2025 Eduardo San Martin Morote
    * @license MIT
    */
  const isBrowser$1 = typeof document !== "undefined";
  function isRouteComponent(component) {
    return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
  }
  function isESModule(obj2) {
    return obj2.__esModule || obj2[Symbol.toStringTag] === "Module" || // support CF with dynamic imports that do not
    // add the Module string tag
    obj2.default && isRouteComponent(obj2.default);
  }
  const assign = Object.assign;
  function applyToParams(fn, params2) {
    const newParams = {};
    for (const key2 in params2) {
      const value = params2[key2];
      newParams[key2] = isArray$4(value) ? value.map(fn) : fn(value);
    }
    return newParams;
  }
  const noop$8 = () => {
  };
  const isArray$4 = Array.isArray;
  const HASH_RE = /#/g;
  const AMPERSAND_RE = /&/g;
  const SLASH_RE = /\//g;
  const EQUAL_RE = /=/g;
  const IM_RE = /\?/g;
  const PLUS_RE = /\+/g;
  const ENC_BRACKET_OPEN_RE = /%5B/g;
  const ENC_BRACKET_CLOSE_RE = /%5D/g;
  const ENC_CARET_RE = /%5E/g;
  const ENC_BACKTICK_RE = /%60/g;
  const ENC_CURLY_OPEN_RE = /%7B/g;
  const ENC_PIPE_RE = /%7C/g;
  const ENC_CURLY_CLOSE_RE = /%7D/g;
  const ENC_SPACE_RE = /%20/g;
  function commonEncode(text) {
    return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
  }
  function encodeHash(text) {
    return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryValue(text) {
    return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
  }
  function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
  }
  function encodeParam(text) {
    return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
  }
  function decode$1(text) {
    try {
      return decodeURIComponent("" + text);
    } catch (err) {
    }
    return "" + text;
  }
  const TRAILING_SLASH_RE = /\/$/;
  const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
  function parseURL(parseQuery2, location2, currentLocation = "/") {
    let path, query = {}, searchString = "", hash = "";
    const hashPos = location2.indexOf("#");
    let searchPos = location2.indexOf("?");
    if (hashPos < searchPos && hashPos >= 0) {
      searchPos = -1;
    }
    if (searchPos > -1) {
      path = location2.slice(0, searchPos);
      searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
      query = parseQuery2(searchString);
    }
    if (hashPos > -1) {
      path = path || location2.slice(0, hashPos);
      hash = location2.slice(hashPos, location2.length);
    }
    path = resolveRelativePath(path != null ? path : location2, currentLocation);
    return {
      fullPath: path + (searchString && "?") + searchString + hash,
      path,
      query,
      hash: decode$1(hash)
    };
  }
  function stringifyURL(stringifyQuery2, location2) {
    const query = location2.query ? stringifyQuery2(location2.query) : "";
    return location2.path + (query && "?") + query + (location2.hash || "");
  }
  function stripBase(pathname, base2) {
    if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
      return pathname;
    return pathname.slice(base2.length) || "/";
  }
  function isSameRouteLocation(stringifyQuery2, a2, b2) {
    const aLastIndex = a2.matched.length - 1;
    const bLastIndex = b2.matched.length - 1;
    return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
  }
  function isSameRouteRecord(a2, b2) {
    return (a2.aliasOf || a2) === (b2.aliasOf || b2);
  }
  function isSameRouteLocationParams(a2, b2) {
    if (Object.keys(a2).length !== Object.keys(b2).length)
      return false;
    for (const key2 in a2) {
      if (!isSameRouteLocationParamsValue(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  function isSameRouteLocationParamsValue(a2, b2) {
    return isArray$4(a2) ? isEquivalentArray(a2, b2) : isArray$4(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
  }
  function isEquivalentArray(a2, b2) {
    return isArray$4(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
  }
  function resolveRelativePath(to, from2) {
    if (to.startsWith("/"))
      return to;
    if (!to)
      return from2;
    const fromSegments = from2.split("/");
    const toSegments = to.split("/");
    const lastToSegment = toSegments[toSegments.length - 1];
    if (lastToSegment === ".." || lastToSegment === ".") {
      toSegments.push("");
    }
    let position2 = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
      segment = toSegments[toPosition];
      if (segment === ".")
        continue;
      if (segment === "..") {
        if (position2 > 1)
          position2--;
      } else
        break;
    }
    return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition).join("/");
  }
  const START_LOCATION_NORMALIZED = {
    path: "/",
    // TODO: could we use a symbol in the future?
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  var NavigationType;
  (function(NavigationType2) {
    NavigationType2["pop"] = "pop";
    NavigationType2["push"] = "push";
  })(NavigationType || (NavigationType = {}));
  var NavigationDirection;
  (function(NavigationDirection2) {
    NavigationDirection2["back"] = "back";
    NavigationDirection2["forward"] = "forward";
    NavigationDirection2["unknown"] = "";
  })(NavigationDirection || (NavigationDirection = {}));
  function normalizeBase(base2) {
    if (!base2) {
      if (isBrowser$1) {
        const baseEl = document.querySelector("base");
        base2 = baseEl && baseEl.getAttribute("href") || "/";
        base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
      } else {
        base2 = "/";
      }
    }
    if (base2[0] !== "/" && base2[0] !== "#")
      base2 = "/" + base2;
    return removeTrailingSlash(base2);
  }
  const BEFORE_HASH_RE = /^[^#]+#/;
  function createHref(base2, location2) {
    return base2.replace(BEFORE_HASH_RE, "#") + location2;
  }
  function getElementPosition(el, offset2) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
      behavior: offset2.behavior,
      left: elRect.left - docRect.left - (offset2.left || 0),
      top: elRect.top - docRect.top - (offset2.top || 0)
    };
  }
  const computeScrollPosition = () => ({
    left: window.scrollX,
    top: window.scrollY
  });
  function scrollToPosition(position2) {
    let scrollToOptions;
    if ("el" in position2) {
      const positionEl = position2.el;
      const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
      const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
      if (!el) {
        return;
      }
      scrollToOptions = getElementPosition(el, position2);
    } else {
      scrollToOptions = position2;
    }
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo(scrollToOptions);
    else {
      window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
    }
  }
  function getScrollKey(path, delta) {
    const position2 = history.state ? history.state.position - delta : -1;
    return position2 + path;
  }
  const scrollPositions = /* @__PURE__ */ new Map();
  function saveScrollPosition(key2, scrollPosition) {
    scrollPositions.set(key2, scrollPosition);
  }
  function getSavedScrollPosition(key2) {
    const scroll = scrollPositions.get(key2);
    scrollPositions.delete(key2);
    return scroll;
  }
  let createBaseLocation = () => location.protocol + "//" + location.host;
  function createCurrentLocation(base2, location2) {
    const { pathname, search, hash } = location2;
    const hashPos = base2.indexOf("#");
    if (hashPos > -1) {
      let slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
      let pathFromHash = hash.slice(slicePos);
      if (pathFromHash[0] !== "/")
        pathFromHash = "/" + pathFromHash;
      return stripBase(pathFromHash, "");
    }
    const path = stripBase(pathname, base2);
    return path + search + hash;
  }
  function useHistoryListeners(base2, historyState, currentLocation, replace2) {
    let listeners = [];
    let teardowns = [];
    let pauseState = null;
    const popStateHandler = ({ state }) => {
      const to = createCurrentLocation(base2, location);
      const from2 = currentLocation.value;
      const fromState = historyState.value;
      let delta = 0;
      if (state) {
        currentLocation.value = to;
        historyState.value = state;
        if (pauseState && pauseState === from2) {
          pauseState = null;
          return;
        }
        delta = fromState ? state.position - fromState.position : 0;
      } else {
        replace2(to);
      }
      listeners.forEach((listener) => {
        listener(currentLocation.value, from2, {
          delta,
          type: NavigationType.pop,
          direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
        });
      });
    };
    function pauseListeners() {
      pauseState = currentLocation.value;
    }
    function listen(callback) {
      listeners.push(callback);
      const teardown = () => {
        const index2 = listeners.indexOf(callback);
        if (index2 > -1)
          listeners.splice(index2, 1);
      };
      teardowns.push(teardown);
      return teardown;
    }
    function beforeUnloadListener() {
      const { history: history2 } = window;
      if (!history2.state)
        return;
      history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
    }
    function destroy() {
      for (const teardown of teardowns)
        teardown();
      teardowns = [];
      window.removeEventListener("popstate", popStateHandler);
      window.removeEventListener("beforeunload", beforeUnloadListener);
    }
    window.addEventListener("popstate", popStateHandler);
    window.addEventListener("beforeunload", beforeUnloadListener, {
      passive: true
    });
    return {
      pauseListeners,
      listen,
      destroy
    };
  }
  function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
      back,
      current,
      forward,
      replaced,
      position: window.history.length,
      scroll: computeScroll ? computeScrollPosition() : null
    };
  }
  function useHistoryStateNavigation(base2) {
    const { history: history2, location: location2 } = window;
    const currentLocation = {
      value: createCurrentLocation(base2, location2)
    };
    const historyState = { value: history2.state };
    if (!historyState.value) {
      changeLocation(currentLocation.value, {
        back: null,
        current: currentLocation.value,
        forward: null,
        // the length is off by one, we need to decrease it
        position: history2.length - 1,
        replaced: true,
        // don't add a scroll as the user may have an anchor, and we want
        // scrollBehavior to be triggered without a saved position
        scroll: null
      }, true);
    }
    function changeLocation(to, state, replace22) {
      const hashIndex = base2.indexOf("#");
      const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
      try {
        history2[replace22 ? "replaceState" : "pushState"](state, "", url);
        historyState.value = state;
      } catch (err) {
        {
          console.error(err);
        }
        location2[replace22 ? "replace" : "assign"](url);
      }
    }
    function replace2(to, data) {
      const state = assign({}, history2.state, buildState(
        historyState.value.back,
        // keep back and forward entries but override current position
        to,
        historyState.value.forward,
        true
      ), data, { position: historyState.value.position });
      changeLocation(to, state, true);
      currentLocation.value = to;
    }
    function push(to, data) {
      const currentState = assign(
        {},
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/router/issues/366
        historyState.value,
        history2.state,
        {
          forward: to,
          scroll: computeScrollPosition()
        }
      );
      changeLocation(currentState.current, currentState, true);
      const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
      changeLocation(to, state, false);
      currentLocation.value = to;
    }
    return {
      location: currentLocation,
      state: historyState,
      push,
      replace: replace2
    };
  }
  function createWebHistory(base2) {
    base2 = normalizeBase(base2);
    const historyNavigation = useHistoryStateNavigation(base2);
    const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
      if (!triggerListeners)
        historyListeners.pauseListeners();
      history.go(delta);
    }
    const routerHistory = assign({
      // it's overridden right after
      location: "",
      base: base2,
      go,
      createHref: createHref.bind(null, base2)
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, "location", {
      enumerable: true,
      get: () => historyNavigation.location.value
    });
    Object.defineProperty(routerHistory, "state", {
      enumerable: true,
      get: () => historyNavigation.state.value
    });
    return routerHistory;
  }
  function createWebHashHistory(base2) {
    base2 = location.host ? base2 || location.pathname + location.search : "";
    if (!base2.includes("#"))
      base2 += "#";
    return createWebHistory(base2);
  }
  function isRouteLocation(route) {
    return typeof route === "string" || route && typeof route === "object";
  }
  function isRouteName(name) {
    return typeof name === "string" || typeof name === "symbol";
  }
  const NavigationFailureSymbol = Symbol("");
  var NavigationFailureType;
  (function(NavigationFailureType2) {
    NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
    NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
    NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
  })(NavigationFailureType || (NavigationFailureType = {}));
  function createRouterError(type, params2) {
    {
      return assign(new Error(), {
        type,
        [NavigationFailureSymbol]: true
      }, params2);
    }
  }
  function isNavigationFailure(error, type) {
    return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
  }
  const BASE_PARAM_PATTERN = "[^/]+?";
  const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  };
  const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
  function tokensToParser(segments, extraOptions) {
    const options2 = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    const score = [];
    let pattern = options2.start ? "^" : "";
    const keys2 = [];
    for (const segment of segments) {
      const segmentScores = segment.length ? [] : [
        90
        /* PathScore.Root */
      ];
      if (options2.strict && !segment.length)
        pattern += "/";
      for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
        const token2 = segment[tokenIndex];
        let subSegmentScore = 40 + (options2.sensitive ? 0.25 : 0);
        if (token2.type === 0) {
          if (!tokenIndex)
            pattern += "/";
          pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
          subSegmentScore += 40;
        } else if (token2.type === 1) {
          const { value, repeatable, optional, regexp: regexp3 } = token2;
          keys2.push({
            name: value,
            repeatable,
            optional
          });
          const re22 = regexp3 ? regexp3 : BASE_PARAM_PATTERN;
          if (re22 !== BASE_PARAM_PATTERN) {
            subSegmentScore += 10;
            try {
              new RegExp(`(${re22})`);
            } catch (err) {
              throw new Error(`Invalid custom RegExp for param "${value}" (${re22}): ` + err.message);
            }
          }
          let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
          if (!tokenIndex)
            subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
            // or /:p?-:p2
            optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
          if (optional)
            subPattern += "?";
          pattern += subPattern;
          subSegmentScore += 20;
          if (optional)
            subSegmentScore += -8;
          if (repeatable)
            subSegmentScore += -20;
          if (re22 === ".*")
            subSegmentScore += -50;
        }
        segmentScores.push(subSegmentScore);
      }
      score.push(segmentScores);
    }
    if (options2.strict && options2.end) {
      const i2 = score.length - 1;
      score[i2][score[i2].length - 1] += 0.7000000000000001;
    }
    if (!options2.strict)
      pattern += "/?";
    if (options2.end)
      pattern += "$";
    else if (options2.strict && !pattern.endsWith("/"))
      pattern += "(?:/|$)";
    const re2 = new RegExp(pattern, options2.sensitive ? "" : "i");
    function parse2(path) {
      const match2 = path.match(re2);
      const params2 = {};
      if (!match2)
        return null;
      for (let i2 = 1; i2 < match2.length; i2++) {
        const value = match2[i2] || "";
        const key2 = keys2[i2 - 1];
        params2[key2.name] = value && key2.repeatable ? value.split("/") : value;
      }
      return params2;
    }
    function stringify2(params2) {
      let path = "";
      let avoidDuplicatedSlash = false;
      for (const segment of segments) {
        if (!avoidDuplicatedSlash || !path.endsWith("/"))
          path += "/";
        avoidDuplicatedSlash = false;
        for (const token2 of segment) {
          if (token2.type === 0) {
            path += token2.value;
          } else if (token2.type === 1) {
            const { value, repeatable, optional } = token2;
            const param = value in params2 ? params2[value] : "";
            if (isArray$4(param) && !repeatable) {
              throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
            }
            const text = isArray$4(param) ? param.join("/") : param;
            if (!text) {
              if (optional) {
                if (segment.length < 2) {
                  if (path.endsWith("/"))
                    path = path.slice(0, -1);
                  else
                    avoidDuplicatedSlash = true;
                }
              } else
                throw new Error(`Missing required param "${value}"`);
            }
            path += text;
          }
        }
      }
      return path || "/";
    }
    return {
      re: re2,
      score,
      keys: keys2,
      parse: parse2,
      stringify: stringify2
    };
  }
  function compareScoreArray(a2, b2) {
    let i2 = 0;
    while (i2 < a2.length && i2 < b2.length) {
      const diff = b2[i2] - a2[i2];
      if (diff)
        return diff;
      i2++;
    }
    if (a2.length < b2.length) {
      return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
    } else if (a2.length > b2.length) {
      return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
    }
    return 0;
  }
  function comparePathParserScore(a2, b2) {
    let i2 = 0;
    const aScore = a2.score;
    const bScore = b2.score;
    while (i2 < aScore.length && i2 < bScore.length) {
      const comp = compareScoreArray(aScore[i2], bScore[i2]);
      if (comp)
        return comp;
      i2++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
      if (isLastScoreNegative(aScore))
        return 1;
      if (isLastScoreNegative(bScore))
        return -1;
    }
    return bScore.length - aScore.length;
  }
  function isLastScoreNegative(score) {
    const last2 = score[score.length - 1];
    return score.length > 0 && last2[last2.length - 1] < 0;
  }
  const ROOT_TOKEN = {
    type: 0,
    value: ""
  };
  const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
  function tokenizePath(path) {
    if (!path)
      return [[]];
    if (path === "/")
      return [[ROOT_TOKEN]];
    if (!path.startsWith("/")) {
      throw new Error(`Invalid path "${path}"`);
    }
    function crash(message) {
      throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0;
    let previousState = state;
    const tokens = [];
    let segment;
    function finalizeSegment() {
      if (segment)
        tokens.push(segment);
      segment = [];
    }
    let i2 = 0;
    let char2;
    let buffer = "";
    let customRe = "";
    function consumeBuffer() {
      if (!buffer)
        return;
      if (state === 0) {
        segment.push({
          type: 0,
          value: buffer
        });
      } else if (state === 1 || state === 2 || state === 3) {
        if (segment.length > 1 && (char2 === "*" || char2 === "+"))
          crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
        segment.push({
          type: 1,
          value: buffer,
          regexp: customRe,
          repeatable: char2 === "*" || char2 === "+",
          optional: char2 === "*" || char2 === "?"
        });
      } else {
        crash("Invalid state to consume buffer");
      }
      buffer = "";
    }
    function addCharToBuffer() {
      buffer += char2;
    }
    while (i2 < path.length) {
      char2 = path[i2++];
      if (char2 === "\\" && state !== 2) {
        previousState = state;
        state = 4;
        continue;
      }
      switch (state) {
        case 0:
          if (char2 === "/") {
            if (buffer) {
              consumeBuffer();
            }
            finalizeSegment();
          } else if (char2 === ":") {
            consumeBuffer();
            state = 1;
          } else {
            addCharToBuffer();
          }
          break;
        case 4:
          addCharToBuffer();
          state = previousState;
          break;
        case 1:
          if (char2 === "(") {
            state = 2;
          } else if (VALID_PARAM_RE.test(char2)) {
            addCharToBuffer();
          } else {
            consumeBuffer();
            state = 0;
            if (char2 !== "*" && char2 !== "?" && char2 !== "+")
              i2--;
          }
          break;
        case 2:
          if (char2 === ")") {
            if (customRe[customRe.length - 1] == "\\")
              customRe = customRe.slice(0, -1) + char2;
            else
              state = 3;
          } else {
            customRe += char2;
          }
          break;
        case 3:
          consumeBuffer();
          state = 0;
          if (char2 !== "*" && char2 !== "?" && char2 !== "+")
            i2--;
          customRe = "";
          break;
        default:
          crash("Unknown state");
          break;
      }
    }
    if (state === 2)
      crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    return tokens;
  }
  function createRouteRecordMatcher(record, parent2, options2) {
    const parser = tokensToParser(tokenizePath(record.path), options2);
    const matcher = assign(parser, {
      record,
      parent: parent2,
      // these needs to be populated by the parent
      children: [],
      alias: []
    });
    if (parent2) {
      if (!matcher.record.aliasOf === !parent2.record.aliasOf)
        parent2.children.push(matcher);
    }
    return matcher;
  }
  function createRouterMatcher(routes2, globalOptions) {
    const matchers2 = [];
    const matcherMap = /* @__PURE__ */ new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
      return matcherMap.get(name);
    }
    function addRoute(record, parent2, originalRecord) {
      const isRootAdd = !originalRecord;
      const mainNormalizedRecord = normalizeRouteRecord(record);
      mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
      const options2 = mergeOptions(globalOptions, record);
      const normalizedRecords = [mainNormalizedRecord];
      if ("alias" in record) {
        const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
        for (const alias of aliases) {
          normalizedRecords.push(
            // we need to normalize again to ensure the `mods` property
            // being non enumerable
            normalizeRouteRecord(assign({}, mainNormalizedRecord, {
              // this allows us to hold a copy of the `components` option
              // so that async components cache is hold on the original record
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              // we might be the child of an alias
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
              // the aliases are always of the same kind as the original since they
              // are defined on the same record
            }))
          );
        }
      }
      let matcher;
      let originalMatcher;
      for (const normalizedRecord of normalizedRecords) {
        const { path } = normalizedRecord;
        if (parent2 && path[0] !== "/") {
          const parentPath = parent2.record.path;
          const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
          normalizedRecord.path = parent2.record.path + (path && connectingSlash + path);
        }
        matcher = createRouteRecordMatcher(normalizedRecord, parent2, options2);
        if (originalRecord) {
          originalRecord.alias.push(matcher);
        } else {
          originalMatcher = originalMatcher || matcher;
          if (originalMatcher !== matcher)
            originalMatcher.alias.push(matcher);
          if (isRootAdd && record.name && !isAliasRecord(matcher)) {
            removeRoute(record.name);
          }
        }
        if (isMatchable(matcher)) {
          insertMatcher(matcher);
        }
        if (mainNormalizedRecord.children) {
          const children = mainNormalizedRecord.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
          }
        }
        originalRecord = originalRecord || matcher;
      }
      return originalMatcher ? () => {
        removeRoute(originalMatcher);
      } : noop$8;
    }
    function removeRoute(matcherRef) {
      if (isRouteName(matcherRef)) {
        const matcher = matcherMap.get(matcherRef);
        if (matcher) {
          matcherMap.delete(matcherRef);
          matchers2.splice(matchers2.indexOf(matcher), 1);
          matcher.children.forEach(removeRoute);
          matcher.alias.forEach(removeRoute);
        }
      } else {
        const index2 = matchers2.indexOf(matcherRef);
        if (index2 > -1) {
          matchers2.splice(index2, 1);
          if (matcherRef.record.name)
            matcherMap.delete(matcherRef.record.name);
          matcherRef.children.forEach(removeRoute);
          matcherRef.alias.forEach(removeRoute);
        }
      }
    }
    function getRoutes() {
      return matchers2;
    }
    function insertMatcher(matcher) {
      const index2 = findInsertionIndex(matcher, matchers2);
      matchers2.splice(index2, 0, matcher);
      if (matcher.record.name && !isAliasRecord(matcher))
        matcherMap.set(matcher.record.name, matcher);
    }
    function resolve2(location2, currentLocation) {
      let matcher;
      let params2 = {};
      let path;
      let name;
      if ("name" in location2 && location2.name) {
        matcher = matcherMap.get(location2.name);
        if (!matcher)
          throw createRouterError(1, {
            location: location2
          });
        name = matcher.record.name;
        params2 = assign(
          // paramsFromLocation is a new object
          paramsFromLocation(
            currentLocation.params,
            // only keep params that exist in the resolved location
            // only keep optional params coming from a parent record
            matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)
          ),
          // discard any existing params in the current location that do not exist here
          // #1497 this ensures better active/exact matching
          location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
        );
        path = matcher.stringify(params2);
      } else if (location2.path != null) {
        path = location2.path;
        matcher = matchers2.find((m2) => m2.re.test(path));
        if (matcher) {
          params2 = matcher.parse(path);
          name = matcher.record.name;
        }
      } else {
        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers2.find((m2) => m2.re.test(currentLocation.path));
        if (!matcher)
          throw createRouterError(1, {
            location: location2,
            currentLocation
          });
        name = matcher.record.name;
        params2 = assign({}, currentLocation.params, location2.params);
        path = matcher.stringify(params2);
      }
      const matched = [];
      let parentMatcher = matcher;
      while (parentMatcher) {
        matched.unshift(parentMatcher.record);
        parentMatcher = parentMatcher.parent;
      }
      return {
        name,
        path,
        params: params2,
        matched,
        meta: mergeMetaFields(matched)
      };
    }
    routes2.forEach((route) => addRoute(route));
    function clearRoutes() {
      matchers2.length = 0;
      matcherMap.clear();
    }
    return {
      addRoute,
      resolve: resolve2,
      removeRoute,
      clearRoutes,
      getRoutes,
      getRecordMatcher
    };
  }
  function paramsFromLocation(params2, keys2) {
    const newParams = {};
    for (const key2 of keys2) {
      if (key2 in params2)
        newParams[key2] = params2[key2];
    }
    return newParams;
  }
  function normalizeRouteRecord(record) {
    const normalized = {
      path: record.path,
      redirect: record.redirect,
      name: record.name,
      meta: record.meta || {},
      aliasOf: record.aliasOf,
      beforeEnter: record.beforeEnter,
      props: normalizeRecordProps(record),
      children: record.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      // must be declared afterwards
      // mods: {},
      components: "components" in record ? record.components || null : record.component && { default: record.component }
    };
    Object.defineProperty(normalized, "mods", {
      value: {}
    });
    return normalized;
  }
  function normalizeRecordProps(record) {
    const propsObject = {};
    const props2 = record.props || false;
    if ("component" in record) {
      propsObject.default = props2;
    } else {
      for (const name in record.components)
        propsObject[name] = typeof props2 === "object" ? props2[name] : props2;
    }
    return propsObject;
  }
  function isAliasRecord(record) {
    while (record) {
      if (record.record.aliasOf)
        return true;
      record = record.parent;
    }
    return false;
  }
  function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
  }
  function mergeOptions(defaults2, partialOptions) {
    const options2 = {};
    for (const key2 in defaults2) {
      options2[key2] = key2 in partialOptions ? partialOptions[key2] : defaults2[key2];
    }
    return options2;
  }
  function findInsertionIndex(matcher, matchers2) {
    let lower = 0;
    let upper = matchers2.length;
    while (lower !== upper) {
      const mid = lower + upper >> 1;
      const sortOrder = comparePathParserScore(matcher, matchers2[mid]);
      if (sortOrder < 0) {
        upper = mid;
      } else {
        lower = mid + 1;
      }
    }
    const insertionAncestor = getInsertionAncestor(matcher);
    if (insertionAncestor) {
      upper = matchers2.lastIndexOf(insertionAncestor, upper - 1);
    }
    return upper;
  }
  function getInsertionAncestor(matcher) {
    let ancestor = matcher;
    while (ancestor = ancestor.parent) {
      if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
        return ancestor;
      }
    }
    return;
  }
  function isMatchable({ record }) {
    return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
  }
  function parseQuery(search) {
    const query = {};
    if (search === "" || search === "?")
      return query;
    const hasLeadingIM = search[0] === "?";
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
    for (let i2 = 0; i2 < searchParams.length; ++i2) {
      const searchParam = searchParams[i2].replace(PLUS_RE, " ");
      const eqPos = searchParam.indexOf("=");
      const key2 = decode$1(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
      const value = eqPos < 0 ? null : decode$1(searchParam.slice(eqPos + 1));
      if (key2 in query) {
        let currentValue = query[key2];
        if (!isArray$4(currentValue)) {
          currentValue = query[key2] = [currentValue];
        }
        currentValue.push(value);
      } else {
        query[key2] = value;
      }
    }
    return query;
  }
  function stringifyQuery(query) {
    let search = "";
    for (let key2 in query) {
      const value = query[key2];
      key2 = encodeQueryKey(key2);
      if (value == null) {
        if (value !== void 0) {
          search += (search.length ? "&" : "") + key2;
        }
        continue;
      }
      const values = isArray$4(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
      values.forEach((value2) => {
        if (value2 !== void 0) {
          search += (search.length ? "&" : "") + key2;
          if (value2 != null)
            search += "=" + value2;
        }
      });
    }
    return search;
  }
  function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key2 in query) {
      const value = query[key2];
      if (value !== void 0) {
        normalizedQuery[key2] = isArray$4(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
      }
    }
    return normalizedQuery;
  }
  const matchedRouteKey = Symbol("");
  const viewDepthKey = Symbol("");
  const routerKey = Symbol("");
  const routeLocationKey = Symbol("");
  const routerViewLocationKey = Symbol("");
  function useCallbacks() {
    let handlers = [];
    function add2(handler) {
      handlers.push(handler);
      return () => {
        const i2 = handlers.indexOf(handler);
        if (i2 > -1)
          handlers.splice(i2, 1);
      };
    }
    function reset() {
      handlers = [];
    }
    return {
      add: add2,
      list: () => handlers.slice(),
      reset
    };
  }
  function guardToPromiseFn(guard, to, from2, record, name, runWithContext = (fn) => fn()) {
    const enterCallbackArray = record && // name is defined if record is because of the function overload
    (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve2, reject) => {
      const next2 = (valid) => {
        if (valid === false) {
          reject(createRouterError(4, {
            from: from2,
            to
          }));
        } else if (valid instanceof Error) {
          reject(valid);
        } else if (isRouteLocation(valid)) {
          reject(createRouterError(2, {
            from: to,
            to: valid
          }));
        } else {
          if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
          record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
            enterCallbackArray.push(valid);
          }
          resolve2();
        }
      };
      const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from2, next2));
      let guardCall = Promise.resolve(guardReturn);
      if (guard.length < 3)
        guardCall = guardCall.then(next2);
      guardCall.catch((err) => reject(err));
    });
  }
  function extractComponentsGuards(matched, guardType, to, from2, runWithContext = (fn) => fn()) {
    const guards = [];
    for (const record of matched) {
      for (const name in record.components) {
        let rawComponent = record.components[name];
        if (guardType !== "beforeRouteEnter" && !record.instances[name])
          continue;
        if (isRouteComponent(rawComponent)) {
          const options2 = rawComponent.__vccOpts || rawComponent;
          const guard = options2[guardType];
          guard && guards.push(guardToPromiseFn(guard, to, from2, record, name, runWithContext));
        } else {
          let componentPromise = rawComponent();
          guards.push(() => componentPromise.then((resolved) => {
            if (!resolved)
              throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
            const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
            record.mods[name] = resolved;
            record.components[name] = resolvedComponent;
            const options2 = resolvedComponent.__vccOpts || resolvedComponent;
            const guard = options2[guardType];
            return guard && guardToPromiseFn(guard, to, from2, record, name, runWithContext)();
          }));
        }
      }
    }
    return guards;
  }
  function useLink(props2) {
    const router2 = inject(routerKey);
    const currentRoute = inject(routeLocationKey);
    const route = computed(() => {
      const to = unref(props2.to);
      return router2.resolve(to);
    });
    const activeRecordIndex = computed(() => {
      const { matched } = route.value;
      const { length: length2 } = matched;
      const routeMatched = matched[length2 - 1];
      const currentMatched = currentRoute.matched;
      if (!routeMatched || !currentMatched.length)
        return -1;
      const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
      if (index2 > -1)
        return index2;
      const parentRecordPath = getOriginalPath(matched[length2 - 2]);
      return (
        // we are dealing with nested routes
        length2 > 1 && // if the parent and matched route have the same path, this link is
        // referring to the empty child. Or we currently are on a different
        // child of the same parent
        getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
        currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length2 - 2])) : index2
      );
    });
    const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
    const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e2 = {}) {
      if (guardEvent(e2)) {
        const p2 = router2[unref(props2.replace) ? "replace" : "push"](
          unref(props2.to)
          // avoid uncaught errors are they are logged anyway
        ).catch(noop$8);
        if (props2.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
          document.startViewTransition(() => p2);
        }
        return p2;
      }
      return Promise.resolve();
    }
    return {
      route,
      href: computed(() => route.value.href),
      isActive,
      isExactActive,
      navigate
    };
  }
  function preferSingleVNode(vnodes) {
    return vnodes.length === 1 ? vnodes[0] : vnodes;
  }
  const RouterLinkImpl = /* @__PURE__ */ defineComponent({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: {
        type: [String, Object],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      // inactiveClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      },
      viewTransition: Boolean
    },
    useLink,
    setup(props2, { slots }) {
      const link = reactive(useLink(props2));
      const { options: options2 } = inject(routerKey);
      const elClass = computed(() => ({
        [getLinkClass(props2.activeClass, options2.linkActiveClass, "router-link-active")]: link.isActive,
        // [getLinkClass(
        //   props.inactiveClass,
        //   options.linkInactiveClass,
        //   'router-link-inactive'
        // )]: !link.isExactActive,
        [getLinkClass(props2.exactActiveClass, options2.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
      }));
      return () => {
        const children = slots.default && preferSingleVNode(slots.default(link));
        return props2.custom ? children : h$1("a", {
          "aria-current": link.isExactActive ? props2.ariaCurrentValue : null,
          href: link.href,
          // this would override user added attrs but Vue will still add
          // the listener, so we end up triggering both
          onClick: link.navigate,
          class: elClass.value
        }, children);
      };
    }
  });
  const RouterLink = RouterLinkImpl;
  function guardEvent(e2) {
    if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
      return;
    if (e2.defaultPrevented)
      return;
    if (e2.button !== void 0 && e2.button !== 0)
      return;
    if (e2.currentTarget && e2.currentTarget.getAttribute) {
      const target = e2.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(target))
        return;
    }
    if (e2.preventDefault)
      e2.preventDefault();
    return true;
  }
  function includesParams(outer, inner2) {
    for (const key2 in inner2) {
      const innerValue = inner2[key2];
      const outerValue = outer[key2];
      if (typeof innerValue === "string") {
        if (innerValue !== outerValue)
          return false;
      } else {
        if (!isArray$4(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
          return false;
      }
    }
    return true;
  }
  function getOriginalPath(record) {
    return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
  }
  const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
  const RouterViewImpl = /* @__PURE__ */ defineComponent({
    name: "RouterView",
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    // Better compat for @vue/compat users
    // https://github.com/vuejs/router/issues/1315
    compatConfig: { MODE: 3 },
    setup(props2, { attrs, slots }) {
      const injectedRoute = inject(routerViewLocationKey);
      const routeToDisplay = computed(() => props2.route || injectedRoute.value);
      const injectedDepth = inject(viewDepthKey, 0);
      const depth = computed(() => {
        let initialDepth = unref(injectedDepth);
        const { matched } = routeToDisplay.value;
        let matchedRoute;
        while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
          initialDepth++;
        }
        return initialDepth;
      });
      const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
      provide(viewDepthKey, computed(() => depth.value + 1));
      provide(matchedRouteKey, matchedRouteRef);
      provide(routerViewLocationKey, routeToDisplay);
      const viewRef = ref();
      watch(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from2, oldName]) => {
        if (to) {
          to.instances[name] = instance;
          if (from2 && from2 !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from2.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from2.updateGuards;
            }
          }
        }
        if (instance && to && // if there is no instance but to and from are the same this might be
        // the first visit
        (!from2 || !isSameRouteRecord(to, from2) || !oldInstance)) {
          (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
        }
      }, { flush: "post" });
      return () => {
        const route = routeToDisplay.value;
        const currentName = props2.name;
        const matchedRoute = matchedRouteRef.value;
        const ViewComponent = matchedRoute && matchedRoute.components[currentName];
        if (!ViewComponent) {
          return normalizeSlot(slots.default, { Component: ViewComponent, route });
        }
        const routePropsOption = matchedRoute.props[currentName];
        const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
        const onVnodeUnmounted = (vnode) => {
          if (vnode.component.isUnmounted) {
            matchedRoute.instances[currentName] = null;
          }
        };
        const component = h$1(ViewComponent, assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef
        }));
        return (
          // pass the vnode to the slot as a prop.
          // h and <component :is="..."> both accept vnodes
          normalizeSlot(slots.default, { Component: component, route }) || component
        );
      };
    }
  });
  function normalizeSlot(slot, data) {
    if (!slot)
      return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
  }
  const RouterView = RouterViewImpl;
  function createRouter(options2) {
    const matcher = createRouterMatcher(options2.routes, options2);
    const parseQuery$1 = options2.parseQuery || parseQuery;
    const stringifyQuery$1 = options2.stringifyQuery || stringifyQuery;
    const routerHistory = options2.history;
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    if (isBrowser$1 && options2.scrollBehavior && "scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = (
      // @ts-expect-error: intentionally avoid the type check
      applyToParams.bind(null, decode$1)
    );
    function addRoute(parentOrRoute, route) {
      let parent2;
      let record;
      if (isRouteName(parentOrRoute)) {
        parent2 = matcher.getRecordMatcher(parentOrRoute);
        record = route;
      } else {
        record = parentOrRoute;
      }
      return matcher.addRoute(record, parent2);
    }
    function removeRoute(name) {
      const recordMatcher = matcher.getRecordMatcher(name);
      if (recordMatcher) {
        matcher.removeRoute(recordMatcher);
      }
    }
    function getRoutes() {
      return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
    }
    function hasRoute(name) {
      return !!matcher.getRecordMatcher(name);
    }
    function resolve2(rawLocation, currentLocation) {
      currentLocation = assign({}, currentLocation || currentRoute.value);
      if (typeof rawLocation === "string") {
        const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
        const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
        const href2 = routerHistory.createHref(locationNormalized.fullPath);
        return assign(locationNormalized, matchedRoute2, {
          params: decodeParams(matchedRoute2.params),
          hash: decode$1(locationNormalized.hash),
          redirectedFrom: void 0,
          href: href2
        });
      }
      let matcherLocation;
      if (rawLocation.path != null) {
        matcherLocation = assign({}, rawLocation, {
          path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
        });
      } else {
        const targetParams = assign({}, rawLocation.params);
        for (const key2 in targetParams) {
          if (targetParams[key2] == null) {
            delete targetParams[key2];
          }
        }
        matcherLocation = assign({}, rawLocation, {
          params: encodeParams(targetParams)
        });
        currentLocation.params = encodeParams(currentLocation.params);
      }
      const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
      const hash = rawLocation.hash || "";
      matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
      const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path
      }));
      const href = routerHistory.createHref(fullPath);
      return assign({
        fullPath,
        // keep the hash encoded so fullPath is effectively path + encodedQuery +
        // hash
        hash,
        query: (
          // if the user is using a custom query lib like qs, we might have
          // nested objects, so we keep the query as is, meaning it can contain
          // numbers at `$route.query`, but at the point, the user will have to
          // use their own type anyway.
          // https://github.com/vuejs/router/issues/328#issuecomment-649481567
          stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
        )
      }, matchedRoute, {
        redirectedFrom: void 0,
        href
      });
    }
    function locationAsObject(to) {
      return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
    }
    function checkCanceledNavigation(to, from2) {
      if (pendingLocation !== to) {
        return createRouterError(8, {
          from: from2,
          to
        });
      }
    }
    function push(to) {
      return pushWithRedirect(to);
    }
    function replace2(to) {
      return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
      const lastMatched = to.matched[to.matched.length - 1];
      if (lastMatched && lastMatched.redirect) {
        const { redirect } = lastMatched;
        let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
        if (typeof newTargetLocation === "string") {
          newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
            // force empty params
            { path: newTargetLocation }
          );
          newTargetLocation.params = {};
        }
        return assign({
          query: to.query,
          hash: to.hash,
          // avoid transferring params if the redirect has a path
          params: newTargetLocation.path != null ? {} : to.params
        }, newTargetLocation);
      }
    }
    function pushWithRedirect(to, redirectedFrom) {
      const targetLocation = pendingLocation = resolve2(to);
      const from2 = currentRoute.value;
      const data = to.state;
      const force = to.force;
      const replace22 = to.replace === true;
      const shouldRedirect = handleRedirectRecord(targetLocation);
      if (shouldRedirect)
        return pushWithRedirect(
          assign(locationAsObject(shouldRedirect), {
            state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
            force,
            replace: replace22
          }),
          // keep original redirectedFrom if it exists
          redirectedFrom || targetLocation
        );
      const toLocation = targetLocation;
      toLocation.redirectedFrom = redirectedFrom;
      let failure;
      if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
        failure = createRouterError(16, { to: toLocation, from: from2 });
        handleScroll(
          from2,
          from2,
          // this is a push, the only way for it to be triggered from a
          // history.listen is with a redirect, which makes it become a push
          true,
          // This cannot be the first navigation because the initial location
          // cannot be manually navigated to
          false
        );
      }
      return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error) => isNavigationFailure(error) ? (
        // navigation redirects still mark the router as ready
        isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        ) ? error : markAsReady(error)
      ) : (
        // reject any unknown error
        triggerError(error, toLocation, from2)
      )).then((failure2) => {
        if (failure2) {
          if (isNavigationFailure(
            failure2,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          )) {
            return pushWithRedirect(
              // keep options
              assign({
                // preserve an existing replacement but allow the redirect to override it
                replace: replace22
              }, locationAsObject(failure2.to), {
                state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                force
              }),
              // preserve the original redirectedFrom if any
              redirectedFrom || toLocation
            );
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from2, true, replace22, data);
        }
        triggerAfterEach(toLocation, from2, failure2);
        return failure2;
      });
    }
    function checkCanceledNavigationAndReject(to, from2) {
      const error = checkCanceledNavigation(to, from2);
      return error ? Promise.reject(error) : Promise.resolve();
    }
    function runWithContext(fn) {
      const app2 = installedApps.values().next().value;
      return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
    }
    function navigate(to, from2) {
      let guards;
      const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from2);
      guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from2);
      for (const record of leavingRecords) {
        record.leaveGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from2));
        });
      }
      const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards).then(() => {
        guards = [];
        for (const guard of beforeGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from2));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from2);
        for (const record of updatingRecords) {
          record.updateGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from2));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const record of enteringRecords) {
          if (record.beforeEnter) {
            if (isArray$4(record.beforeEnter)) {
              for (const beforeEnter of record.beforeEnter)
                guards.push(guardToPromiseFn(beforeEnter, to, from2));
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from2));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        to.matched.forEach((record) => record.enterCallbacks = {});
        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from2, runWithContext);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const guard of beforeResolveGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from2));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).catch((err) => isNavigationFailure(
        err,
        8
        /* ErrorTypes.NAVIGATION_CANCELLED */
      ) ? err : Promise.reject(err));
    }
    function triggerAfterEach(to, from2, failure) {
      afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from2, failure)));
    }
    function finalizeNavigation(toLocation, from2, isPush, replace22, data) {
      const error = checkCanceledNavigation(toLocation, from2);
      if (error)
        return error;
      const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
      const state = !isBrowser$1 ? {} : history.state;
      if (isPush) {
        if (replace22 || isFirstNavigation)
          routerHistory.replace(toLocation.fullPath, assign({
            scroll: isFirstNavigation && state && state.scroll
          }, data));
        else
          routerHistory.push(toLocation.fullPath, data);
      }
      currentRoute.value = toLocation;
      handleScroll(toLocation, from2, isPush, isFirstNavigation);
      markAsReady();
    }
    let removeHistoryListener;
    function setupListeners() {
      if (removeHistoryListener)
        return;
      removeHistoryListener = routerHistory.listen((to, _from, info) => {
        if (!router2.listening)
          return;
        const toLocation = resolve2(to);
        const shouldRedirect = handleRedirectRecord(toLocation);
        if (shouldRedirect) {
          pushWithRedirect(assign(shouldRedirect, { replace: true, force: true }), toLocation).catch(noop$8);
          return;
        }
        pendingLocation = toLocation;
        const from2 = currentRoute.value;
        if (isBrowser$1) {
          saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
        }
        navigate(toLocation, from2).catch((error) => {
          if (isNavigationFailure(
            error,
            4 | 8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            return error;
          }
          if (isNavigationFailure(
            error,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          )) {
            pushWithRedirect(
              assign(locationAsObject(error.to), {
                force: true
              }),
              toLocation
              // avoid an uncaught rejection, let push call triggerError
            ).then((failure) => {
              if (isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              ) && !info.delta && info.type === NavigationType.pop) {
                routerHistory.go(-1, false);
              }
            }).catch(noop$8);
            return Promise.reject();
          }
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          }
          return triggerError(error, toLocation, from2);
        }).then((failure) => {
          failure = failure || finalizeNavigation(
            // after navigation, all matched components are resolved
            toLocation,
            from2,
            false
          );
          if (failure) {
            if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
            // entry while a different route is displayed
            !isNavigationFailure(
              failure,
              8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              routerHistory.go(-info.delta, false);
            } else if (info.type === NavigationType.pop && isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            )) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from2, failure);
        }).catch(noop$8);
      });
    }
    let readyHandlers = useCallbacks();
    let errorListeners = useCallbacks();
    let ready;
    function triggerError(error, to, from2) {
      markAsReady(error);
      const list2 = errorListeners.list();
      if (list2.length) {
        list2.forEach((handler) => handler(error, to, from2));
      } else {
        console.error(error);
      }
      return Promise.reject(error);
    }
    function isReady() {
      if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
        return Promise.resolve();
      return new Promise((resolve22, reject) => {
        readyHandlers.add([resolve22, reject]);
      });
    }
    function markAsReady(err) {
      if (!ready) {
        ready = !err;
        setupListeners();
        readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
        readyHandlers.reset();
      }
      return err;
    }
    function handleScroll(to, from2, isPush, isFirstNavigation) {
      const { scrollBehavior } = options2;
      if (!isBrowser$1 || !scrollBehavior)
        return Promise.resolve();
      const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
      return nextTick().then(() => scrollBehavior(to, from2, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from2));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = /* @__PURE__ */ new Set();
    const router2 = {
      currentRoute,
      listening: true,
      addRoute,
      removeRoute,
      clearRoutes: matcher.clearRoutes,
      hasRoute,
      getRoutes,
      resolve: resolve2,
      options: options2,
      push,
      replace: replace2,
      go,
      back: () => go(-1),
      forward: () => go(1),
      beforeEach: beforeGuards.add,
      beforeResolve: beforeResolveGuards.add,
      afterEach: afterGuards.add,
      onError: errorListeners.add,
      isReady,
      install(app2) {
        const router22 = this;
        app2.component("RouterLink", RouterLink);
        app2.component("RouterView", RouterView);
        app2.config.globalProperties.$router = router22;
        Object.defineProperty(app2.config.globalProperties, "$route", {
          enumerable: true,
          get: () => unref(currentRoute)
        });
        if (isBrowser$1 && // used for the initial navigation client side to avoid pushing
        // multiple times when the router is used in multiple apps
        !started && currentRoute.value === START_LOCATION_NORMALIZED) {
          started = true;
          push(routerHistory.location).catch((err) => {
          });
        }
        const reactiveRoute = {};
        for (const key2 in START_LOCATION_NORMALIZED) {
          Object.defineProperty(reactiveRoute, key2, {
            get: () => currentRoute.value[key2],
            enumerable: true
          });
        }
        app2.provide(routerKey, router22);
        app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
        app2.provide(routerViewLocationKey, currentRoute);
        const unmountApp = app2.unmount;
        installedApps.add(app2);
        app2.unmount = function() {
          installedApps.delete(app2);
          if (installedApps.size < 1) {
            pendingLocation = START_LOCATION_NORMALIZED;
            removeHistoryListener && removeHistoryListener();
            removeHistoryListener = null;
            currentRoute.value = START_LOCATION_NORMALIZED;
            started = false;
            ready = false;
          }
          unmountApp();
        };
      }
    };
    function runGuardQueue(guards) {
      return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
    }
    return router2;
  }
  function extractChangingRecords(to, from2) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len2 = Math.max(from2.matched.length, to.matched.length);
    for (let i2 = 0; i2 < len2; i2++) {
      const recordFrom = from2.matched[i2];
      if (recordFrom) {
        if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
          updatingRecords.push(recordFrom);
        else
          leavingRecords.push(recordFrom);
      }
      const recordTo = to.matched[i2];
      if (recordTo) {
        if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
          enteringRecords.push(recordTo);
        }
      }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
  }
  const routes = [
    {
      path: "/dashboard",
      name: "dashboard",
      component: () => __vitePreload(() => Promise.resolve().then(() => index$1), false ? __VITE_PRELOAD__ : void 0)
    },
    {
      path: "/details",
      name: "details",
      component: () => __vitePreload(() => Promise.resolve().then(() => details$1), false ? __VITE_PRELOAD__ : void 0)
    },
    {
      path: "/list",
      name: "list",
      component: () => __vitePreload(() => Promise.resolve().then(() => list$1), false ? __VITE_PRELOAD__ : void 0)
    }
  ];
  const router = createRouter({
    // 这里的import.meta.env.BASE_URL取值于vite.config.js中的base属性。
    // 只有在生产环境才需要加/vue-app/前缀访问。
    history: createWebHashHistory("/vue-app"),
    routes
  });
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  function toPrimitive(t2, r2) {
    if ("object" != _typeof$1(t2) || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != _typeof$1(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function toPropertyKey(t2) {
    var i2 = toPrimitive(t2, "string");
    return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
  }
  function _defineProperty$z(e2, r2, t2) {
    return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t2, e2;
  }
  function ownKeys$1(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2$1(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
        _defineProperty$z(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  const isFunction$3 = (val) => typeof val === "function";
  const isArray$3 = Array.isArray;
  const isString$2 = (val) => typeof val === "string";
  const isObject$6 = (val) => val !== null && typeof val === "object";
  const onRE = /^on[^a-z]/;
  const isOn = (key2) => onRE.test(key2);
  const cacheStringFunction = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction((str) => {
    return str.replace(hyphenateRE, "-$1").toLowerCase();
  });
  const hasOwnProperty$f = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key2) => hasOwnProperty$f.call(val, key2);
  function resolvePropValue(options2, props2, key2, value) {
    const opt = options2[key2];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        value = opt.type !== Function && isFunction$3(defaultValue) ? defaultValue() : defaultValue;
      }
      if (opt.type === Boolean) {
        if (!hasOwn$1(props2, key2) && !hasDefault) {
          value = false;
        } else if (value === "") {
          value = true;
        }
      }
    }
    return value;
  }
  function toPx(val) {
    if (typeof val === "number") return `${val}px`;
    return val;
  }
  function renderHelper(v2) {
    let props2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let defaultV = arguments.length > 2 ? arguments[2] : void 0;
    if (typeof v2 === "function") {
      return v2(props2);
    }
    return v2 !== null && v2 !== void 0 ? v2 : defaultV;
  }
  function wrapPromiseFn(openFn) {
    let closeFn;
    const closePromise = new Promise((resolve2) => {
      closeFn = openFn(() => {
        resolve2(true);
      });
    });
    const result = () => {
      closeFn === null || closeFn === void 0 ? void 0 : closeFn();
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  function classNames() {
    const classes = [];
    for (let i2 = 0; i2 < arguments.length; i2++) {
      const value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
      if (!value) continue;
      if (isString$2(value)) {
        classes.push(value);
      } else if (isArray$3(value)) {
        for (let i3 = 0; i3 < value.length; i3++) {
          const inner2 = classNames(value[i3]);
          if (inner2) {
            classes.push(inner2);
          }
        }
      } else if (isObject$6(value)) {
        for (const name in value) {
          if (value[name]) {
            classes.push(name);
          }
        }
      }
    }
    return classes.join(" ");
  }
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key2) {
      var result = -1;
      arr.some(function(entry, index2) {
        if (entry[0] === key2) {
          result = index2;
          return true;
        }
        return false;
      });
      return result;
    }
    return (
      /** @class */
      function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key2) {
          var index2 = getIndex(this.__entries__, key2);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key2, value) {
          var index2 = getIndex(this.__entries__, key2);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key2, value]);
          }
        };
        class_1.prototype.delete = function(key2) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key2);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key2) {
          return !!~getIndex(this.__entries__, key2);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
            var entry = _a2[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }()
    );
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle$3(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = (
    /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$3(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
        var _b2 = _a2.propertyName, propertyName = _b2 === void 0 ? "" : _b2;
        var isReflowProperty = transitionKeys.some(function(key2) {
          return !!~propertyName.indexOf(key2);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }()
  );
  var defineConfigurable = function(target, props2) {
    for (var _i = 0, _a2 = Object.keys(props2); _i < _a2.length; _i++) {
      var key2 = _a2[_i];
      Object.defineProperty(target, key2, {
        value: props2[key2],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target;
  };
  var getWindowOf = function(target) {
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position2) {
      var value = styles["border-" + position2 + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position2 = positions_1[_i];
      var value = styles["padding-" + position2];
      paddings[position2] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target) {
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles.width), height = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    return function(target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
    };
  }();
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  function createReadOnlyRect(_a2) {
    var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x: x2,
      y: y2,
      width,
      height,
      top: y2,
      right: x2 + width,
      bottom: height + y2,
      left: x2
    });
    return rect;
  }
  function createRectInit(x2, y2, width, height) {
    return { x: x2, y: y2, width, height };
  }
  var ResizeObservation = (
    /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }()
  );
  var ResizeObserverEntry = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }()
  );
  var ResizeObserverSPI = (
    /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }()
  );
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver$2 = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver2;
    }()
  );
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method) {
    ResizeObserver$2.prototype[method] = function() {
      var _a2;
      return (_a2 = observers.get(this))[method].apply(_a2, arguments);
    };
  });
  var index$2 = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
  }();
  const isValid$2 = (value) => {
    return value !== void 0 && value !== null && value !== "";
  };
  const initDefaultProps = (types2, defaultProps) => {
    const propTypes = _extends$1({}, types2);
    Object.keys(defaultProps).forEach((k2) => {
      const prop = propTypes[k2];
      if (prop) {
        if (prop.type || prop.default) {
          prop.default = defaultProps[k2];
        } else if (prop.def) {
          prop.def(defaultProps[k2]);
        } else {
          propTypes[k2] = {
            type: prop,
            default: defaultProps[k2]
          };
        }
      } else {
        throw new Error(`not have ${k2} prop`);
      }
    });
    return propTypes;
  };
  const splitAttrs = (attrs) => {
    const allAttrs = Object.keys(attrs);
    const eventAttrs = {};
    const onEvents = {};
    const extraAttrs = {};
    for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
      const key2 = allAttrs[i2];
      if (isOn(key2)) {
        eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2];
        onEvents[key2] = attrs[key2];
      } else {
        extraAttrs[key2] = attrs[key2];
      }
    }
    return {
      onEvents,
      events: eventAttrs,
      extraAttrs
    };
  };
  const parseStyleText = function() {
    let cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let camel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const res = {};
    const listDelimiter = /;(?![^(]*\))/g;
    const propertyDelimiter = /:(.+)/;
    if (typeof cssText === "object") return cssText;
    cssText.split(listDelimiter).forEach(function(item) {
      if (item) {
        const tmp = item.split(propertyDelimiter);
        if (tmp.length > 1) {
          const k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
          res[k2] = tmp[1].trim();
        }
      }
    });
    return res;
  };
  const hasProp = (instance, prop) => {
    return instance[prop] !== void 0;
  };
  const skipFlattenKey = Symbol("skipFlatten");
  const flattenChildren = function() {
    let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const temp = Array.isArray(children) ? children : [children];
    const res = [];
    temp.forEach((child) => {
      if (Array.isArray(child)) {
        res.push(...flattenChildren(child, filterEmpty2));
      } else if (child && child.type === Fragment) {
        if (child.key === skipFlattenKey) {
          res.push(child);
        } else {
          res.push(...flattenChildren(child.children, filterEmpty2));
        }
      } else if (child && isVNode$1(child)) {
        if (filterEmpty2 && !isEmptyElement(child)) {
          res.push(child);
        } else if (!filterEmpty2) {
          res.push(child);
        }
      } else if (isValid$2(child)) {
        res.push(child);
      }
    });
    return res;
  };
  const getSlot = function(self2) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (isVNode$1(self2)) {
      if (self2.type === Fragment) {
        return name === "default" ? flattenChildren(self2.children) : [];
      } else if (self2.children && self2.children[name]) {
        return flattenChildren(self2.children[name](options2));
      } else {
        return [];
      }
    } else {
      const res = self2.$slots[name] && self2.$slots[name](options2);
      return flattenChildren(res);
    }
  };
  const findDOMNode = (instance) => {
    var _a2;
    let node2 = ((_a2 = instance === null || instance === void 0 ? void 0 : instance.vnode) === null || _a2 === void 0 ? void 0 : _a2.el) || instance && (instance.$el || instance);
    while (node2 && !node2.tagName) {
      node2 = node2.nextSibling;
    }
    return node2;
  };
  const getOptionProps = (instance) => {
    const res = {};
    if (instance.$ && instance.$.vnode) {
      const props2 = instance.$.vnode.props || {};
      Object.keys(instance.$props).forEach((k2) => {
        const v2 = instance.$props[k2];
        const hyphenateKey = hyphenate(k2);
        if (v2 !== void 0 || hyphenateKey in props2) {
          res[k2] = v2;
        }
      });
    } else if (isVNode$1(instance) && typeof instance.type === "object") {
      const originProps = instance.props || {};
      const props2 = {};
      Object.keys(originProps).forEach((key2) => {
        props2[camelize(key2)] = originProps[key2];
      });
      const options2 = instance.type.props || {};
      Object.keys(options2).forEach((k2) => {
        const v2 = resolvePropValue(options2, props2, k2, props2[k2]);
        if (v2 !== void 0 || k2 in props2) {
          res[k2] = v2;
        }
      });
    }
    return res;
  };
  const getComponent = function(instance) {
    let prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
    let execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    let com = void 0;
    if (instance.$) {
      const temp = instance[prop];
      if (temp !== void 0) {
        return typeof temp === "function" && execute ? temp(options2) : temp;
      } else {
        com = instance.$slots[prop];
        com = execute && com ? com(options2) : com;
      }
    } else if (isVNode$1(instance)) {
      const temp = instance.props && instance.props[prop];
      if (temp !== void 0 && instance.props !== null) {
        return typeof temp === "function" && execute ? temp(options2) : temp;
      } else if (instance.type === Fragment) {
        com = instance.children;
      } else if (instance.children && instance.children[prop]) {
        com = instance.children[prop];
        com = execute && com ? com(options2) : com;
      }
    }
    if (Array.isArray(com)) {
      com = flattenChildren(com);
      com = com.length === 1 ? com[0] : com;
      com = com.length === 0 ? void 0 : com;
    }
    return com;
  };
  function getEvents() {
    let ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let on = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let props2 = {};
    if (ele.$) {
      props2 = _extends$1(_extends$1({}, props2), ele.$attrs);
    } else {
      props2 = _extends$1(_extends$1({}, props2), ele.props);
    }
    return splitAttrs(props2)[on ? "onEvents" : "events"];
  }
  function getStyle$3(ele, camel) {
    const props2 = (isVNode$1(ele) ? ele.props : ele.$attrs) || {};
    let style = props2.style || {};
    if (typeof style === "string") {
      style = parseStyleText(style, camel);
    }
    return style;
  }
  function isFragment(c2) {
    return c2.length === 1 && c2[0].type === Fragment;
  }
  function isEmptyElement(c2) {
    return c2 && (c2.type === Comment || c2.type === Fragment && c2.children.length === 0 || c2.type === Text && c2.children.trim() === "");
  }
  function filterEmpty() {
    let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const res = [];
    children.forEach((child) => {
      if (Array.isArray(child)) {
        res.push(...child);
      } else if ((child === null || child === void 0 ? void 0 : child.type) === Fragment) {
        res.push(...filterEmpty(child.children));
      } else {
        res.push(child);
      }
    });
    return res.filter((c2) => !isEmptyElement(c2));
  }
  function isValidElement(element) {
    if (Array.isArray(element) && element.length === 1) {
      element = element[0];
    }
    return element && element.__v_isVNode && typeof element.type !== "symbol";
  }
  function getPropsSlot(slots, props2) {
    let prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
    var _a2, _b2;
    return (_a2 = props2[prop]) !== null && _a2 !== void 0 ? _a2 : (_b2 = slots[prop]) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
  }
  const ResizeObserver$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ResizeObserver",
    props: {
      disabled: Boolean,
      onResize: Function
    },
    emits: ["resize"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const state = reactive({
        width: 0,
        height: 0,
        offsetHeight: 0,
        offsetWidth: 0
      });
      let currentElement = null;
      let resizeObserver = null;
      const destroyObserver = () => {
        if (resizeObserver) {
          resizeObserver.disconnect();
          resizeObserver = null;
        }
      };
      const onResize = (entries) => {
        const {
          onResize: onResize2
        } = props2;
        const target = entries[0].target;
        const {
          width,
          height
        } = target.getBoundingClientRect();
        const {
          offsetWidth,
          offsetHeight
        } = target;
        const fixedWidth = Math.floor(width);
        const fixedHeight = Math.floor(height);
        if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
          const size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          _extends$1(state, size);
          if (onResize2) {
            Promise.resolve().then(() => {
              onResize2(_extends$1(_extends$1({}, size), {
                offsetWidth,
                offsetHeight
              }), target);
            });
          }
        }
      };
      const instance = getCurrentInstance();
      const registerObserver = () => {
        const {
          disabled
        } = props2;
        if (disabled) {
          destroyObserver();
          return;
        }
        const element = findDOMNode(instance);
        const elementChanged = element !== currentElement;
        if (elementChanged) {
          destroyObserver();
          currentElement = element;
        }
        if (!resizeObserver && element) {
          resizeObserver = new index$2(onResize);
          resizeObserver.observe(element);
        }
      };
      onMounted(() => {
        registerObserver();
      });
      onUpdated(() => {
        registerObserver();
      });
      onUnmounted(() => {
        destroyObserver();
      });
      watch(() => props2.disabled, () => {
        registerObserver();
      }, {
        flush: "post"
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
      };
    }
  });
  let raf = (callback) => setTimeout(callback, 16);
  let caf = (num) => clearTimeout(num);
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = (callback) => window.requestAnimationFrame(callback);
    caf = (handle2) => window.cancelAnimationFrame(handle2);
  }
  let rafUUID = 0;
  const rafIds = /* @__PURE__ */ new Map();
  function cleanup(id) {
    rafIds.delete(id);
  }
  function wrapperRaf(callback) {
    let times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    const id = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id);
        callback();
      } else {
        const realId = raf(() => {
          callRef(leftTimes - 1);
        });
        rafIds.set(id, realId);
      }
    }
    callRef(times);
    return id;
  }
  wrapperRaf.cancel = (id) => {
    const realId = rafIds.get(id);
    cleanup(realId);
    return caf(realId);
  };
  const tuple = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args;
  };
  const withInstall = (comp) => {
    const c2 = comp;
    c2.install = function(app2) {
      app2.component(c2.displayName || c2.name, comp);
    };
    return comp;
  };
  function eventType() {
    return {
      type: [Function, Array]
    };
  }
  function objectType(defaultVal) {
    return {
      type: Object,
      default: defaultVal
    };
  }
  function booleanType(defaultVal) {
    return {
      type: Boolean,
      default: defaultVal
    };
  }
  function functionType(defaultVal) {
    return {
      type: Function,
      default: defaultVal
    };
  }
  function anyType(defaultVal, required) {
    const type = {
      validator: () => true,
      default: defaultVal
    };
    return required ? type : type;
  }
  function arrayType(defaultVal) {
    return {
      type: Array,
      default: defaultVal
    };
  }
  function stringType(defaultVal) {
    return {
      type: String,
      default: defaultVal
    };
  }
  function someType(types2, defaultVal) {
    return types2 ? {
      type: types2,
      default: defaultVal
    } : anyType(defaultVal);
  }
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("testPassive", null, opts);
    window.removeEventListener("testPassive", null, opts);
  } catch (e2) {
  }
  function addEventListenerWrap(target, eventType2, cb, option) {
    if (target && target.addEventListener) {
      let opt = option;
      if (opt === void 0 && supportsPassive && (eventType2 === "touchstart" || eventType2 === "touchmove" || eventType2 === "wheel")) {
        opt = {
          passive: false
        };
      }
      target.addEventListener(eventType2, cb, opt);
    }
    return {
      remove: () => {
        if (target && target.removeEventListener) {
          target.removeEventListener(eventType2, cb);
        }
      }
    };
  }
  const defaultIconPrefixCls = "anticon";
  const GlobalFormContextKey = Symbol("GlobalFormContextKey");
  const useProvideGlobalForm = (state) => {
    provide(GlobalFormContextKey, state);
  };
  const useInjectGlobalForm = () => {
    return inject(GlobalFormContextKey, {
      validateMessages: computed(() => void 0)
    });
  };
  const configProviderProps = () => ({
    iconPrefixCls: String,
    getTargetContainer: {
      type: Function
    },
    getPopupContainer: {
      type: Function
    },
    prefixCls: String,
    getPrefixCls: {
      type: Function
    },
    renderEmpty: {
      type: Function
    },
    transformCellText: {
      type: Function
    },
    csp: objectType(),
    input: objectType(),
    autoInsertSpaceInButton: {
      type: Boolean,
      default: void 0
    },
    locale: objectType(),
    pageHeader: objectType(),
    componentSize: {
      type: String
    },
    componentDisabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String,
      default: "ltr"
    },
    space: objectType(),
    virtual: {
      type: Boolean,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: true
    },
    form: objectType(),
    pagination: objectType(),
    theme: objectType(),
    select: objectType(),
    wave: objectType()
  });
  const configProviderKey = Symbol("configProvider");
  const defaultConfigProvider = {
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) return customizePrefixCls;
      return suffixCls ? `ant-${suffixCls}` : "ant";
    },
    iconPrefixCls: computed(() => defaultIconPrefixCls),
    getPopupContainer: computed(() => () => document.body),
    direction: computed(() => "ltr")
  };
  const useConfigContextInject = () => {
    return inject(configProviderKey, defaultConfigProvider);
  };
  const useConfigContextProvider = (props2) => {
    return provide(configProviderKey, props2);
  };
  const DisabledContextKey = Symbol("DisabledContextKey");
  const useInjectDisabled = () => {
    return inject(DisabledContextKey, ref(void 0));
  };
  const useProviderDisabled = (disabled) => {
    const parentDisabled = useInjectDisabled();
    provide(DisabledContextKey, computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : parentDisabled.value;
    }));
    return disabled;
  };
  const LocaleReceiver = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "LocaleReceiver",
    props: {
      componentName: String,
      defaultLocale: {
        type: [Object, Function]
      },
      children: {
        type: Function
      }
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const localeData = inject("localeData", {});
      const locale2 = computed(() => {
        const {
          componentName = "global",
          defaultLocale
        } = props2;
        const locale3 = defaultLocale || localeValues$1[componentName || "global"];
        const {
          antLocale
        } = localeData;
        const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
        return _extends$1(_extends$1({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
      });
      const localeCode = computed(() => {
        const {
          antLocale
        } = localeData;
        const localeCode2 = antLocale && antLocale.locale;
        if (antLocale && antLocale.exist && !localeCode2) {
          return localeValues$1.locale;
        }
        return localeCode2;
      });
      return () => {
        const children = props2.children || slots.default;
        const {
          antLocale
        } = localeData;
        return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
      };
    }
  });
  function useLocaleReceiver(componentName, defaultLocale, propsLocale) {
    const localeData = inject("localeData", {});
    const componentLocale = computed(() => {
      const {
        antLocale
      } = localeData;
      const locale2 = unref(defaultLocale) || localeValues$1[componentName || "global"];
      const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends$1(_extends$1(_extends$1({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {}), unref(propsLocale) || {});
    });
    return [componentLocale];
  }
  function murmur2(str) {
    var h2 = 0;
    var k2, i2 = 0, len2 = str.length;
    for (; len2 >= 4; ++i2, len2 -= 4) {
      k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len2) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  const SPLIT = "%";
  class Entity {
    constructor(instanceId) {
      this.cache = /* @__PURE__ */ new Map();
      this.instanceId = instanceId;
    }
    get(keys2) {
      return this.cache.get(Array.isArray(keys2) ? keys2.join(SPLIT) : keys2) || null;
    }
    update(keys2, valueFn) {
      const path = Array.isArray(keys2) ? keys2.join(SPLIT) : keys2;
      const prevValue = this.cache.get(path);
      const nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(path);
      } else {
        this.cache.set(path, nextValue);
      }
    }
  }
  const ATTR_TOKEN = "data-token-hash";
  const ATTR_MARK = "data-css-hash";
  const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache() {
    const cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
      const {
        firstChild
      } = document.head;
      Array.from(styles).forEach((style) => {
        style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
        if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style, firstChild);
        }
      });
      const styleHash = {};
      Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style) => {
        var _a2;
        const hash = style.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
          }
        } else {
          styleHash[hash] = true;
        }
      });
    }
    return new Entity(cssinjsInstanceId);
  }
  const StyleContextKey = Symbol("StyleContextKey");
  const getCache = () => {
    var _a2, _b2, _c2;
    const instance = getCurrentInstance();
    let cache2;
    if (instance && instance.appContext) {
      const globalCache = (_c2 = (_b2 = (_a2 = instance.appContext) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b2 === void 0 ? void 0 : _b2.globalProperties) === null || _c2 === void 0 ? void 0 : _c2.__ANTDV_CSSINJS_CACHE__;
      if (globalCache) {
        cache2 = globalCache;
      } else {
        cache2 = createCache();
        if (instance.appContext.config.globalProperties) {
          instance.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = cache2;
        }
      }
    } else {
      cache2 = createCache();
    }
    return cache2;
  };
  const defaultStyleContext = {
    cache: createCache(),
    defaultCache: true,
    hashPriority: "low"
  };
  const useStyleInject = () => {
    const cache2 = getCache();
    return inject(StyleContextKey, shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
      cache: cache2
    })));
  };
  const useStyleProvider = (props2) => {
    const parentContext = useStyleInject();
    const context = shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
      cache: createCache()
    }));
    watch([() => unref(props2), parentContext], () => {
      const mergedContext = _extends$1({}, parentContext.value);
      const propsValue = unref(props2);
      Object.keys(propsValue).forEach((key2) => {
        const value = propsValue[key2];
        if (propsValue[key2] !== void 0) {
          mergedContext[key2] = value;
        }
      });
      const {
        cache: cache2
      } = propsValue;
      mergedContext.cache = mergedContext.cache || createCache();
      mergedContext.defaultCache = !cache2 && parentContext.value.defaultCache;
      context.value = mergedContext;
    }, {
      immediate: true
    });
    provide(StyleContextKey, context);
    return context;
  };
  const styleProviderProps = () => ({
    autoClear: booleanType(),
    /** @private Test only. Not work in production. */
    mock: stringType(),
    /**
     * Only set when you need ssr to extract style on you own.
     * If not provided, it will auto create <style /> on the end of Provider in server side.
     */
    cache: objectType(),
    /** Tell children that this context is default generated context */
    defaultCache: booleanType(),
    /** Use `:where` selector to reduce hashId css selector priority */
    hashPriority: stringType(),
    /** Tell cssinjs where to inject style in */
    container: someType(),
    /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
    ssrInline: booleanType(),
    /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
    transformers: arrayType(),
    /**
     * Linters to lint css before inject in document.
     * Styles will be linted after transforming.
     * Please note that `linters` do not support dynamic update.
     */
    linters: arrayType()
  });
  withInstall(/* @__PURE__ */ defineComponent({
    name: "AStyleProvider",
    inheritAttrs: false,
    props: styleProviderProps(),
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      useStyleProvider(props2);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  }));
  function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
    const styleContext = useStyleInject();
    const fullPathStr = shallowRef("");
    const res = shallowRef();
    watchEffect(() => {
      fullPathStr.value = [prefix, ...keyPath.value].join("%");
    });
    const clearCache = (pathStr) => {
      styleContext.value.cache.update(pathStr, (prevCache) => {
        const [times = 0, cache2] = prevCache || [];
        const nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache2, false);
          return null;
        }
        return [times - 1, cache2];
      });
    };
    watch(fullPathStr, (newStr, oldStr) => {
      if (oldStr) clearCache(oldStr);
      styleContext.value.cache.update(newStr, (prevCache) => {
        const [times = 0, cache2] = prevCache || [];
        let tmpCache = cache2;
        const mergedCache = tmpCache || cacheFn();
        return [times + 1, mergedCache];
      });
      res.value = styleContext.value.cache.get(fullPathStr.value)[1];
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      clearCache(fullPathStr.value);
    });
    return res;
  }
  function canUseDom$1() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains$1(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    return false;
  }
  const APPEND_ORDER$1 = "data-vc-order";
  const MARK_KEY$1 = `vc-util-key`;
  const containerCache$1 = /* @__PURE__ */ new Map();
  function getMark$1() {
    let {
      mark
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (mark) {
      return mark.startsWith("data-") ? mark : `data-${mark}`;
    }
    return MARK_KEY$1;
  }
  function getContainer$2(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    const head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder$1(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles$1(container) {
    return Array.from((containerCache$1.get(container) || container).children).filter((node2) => node2.tagName === "STYLE");
  }
  function injectCSS$1(css2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom$1()) {
      return null;
    }
    const {
      csp,
      prepend
    } = option;
    const styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
    if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
      styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    }
    styleNode.innerHTML = css2;
    const container = getContainer$2(option);
    const {
      firstChild
    } = container;
    if (prepend) {
      if (prepend === "queue") {
        const existStyle = findStyles$1(container).filter((node2) => ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1)));
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode$1(key2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const container = getContainer$2(option);
    return findStyles$1(container).find((node2) => node2.getAttribute(getMark$1(option)) === key2);
  }
  function removeCSS(key2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const existNode = findExistNode$1(key2, option);
    if (existNode) {
      const container = getContainer$2(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer$1(container, option) {
    const cachedRealContainer = containerCache$1.get(container);
    if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
      const placeholderStyle = injectCSS$1("", option);
      const {
        parentNode
      } = placeholderStyle;
      containerCache$1.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS$1(css2, key2) {
    let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _a2, _b2, _c2;
    const container = getContainer$2(option);
    syncRealContainer$1(container, option);
    const existNode = findExistNode$1(key2, option);
    if (existNode) {
      if (((_a2 = option.csp) === null || _a2 === void 0 ? void 0 : _a2.nonce) && existNode.nonce !== ((_b2 = option.csp) === null || _b2 === void 0 ? void 0 : _b2.nonce)) {
        existNode.nonce = (_c2 = option.csp) === null || _c2 === void 0 ? void 0 : _c2.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    const newNode = injectCSS$1(css2, option);
    newNode.setAttribute(getMark$1(option), key2);
    return newNode;
  }
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i2 = 0; i2 < left.length; i2++) {
      if (left[i2] !== right[i2]) {
        return false;
      }
    }
    return true;
  }
  class ThemeCache {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    size() {
      return this.keys.length;
    }
    internalGet(derivativeOption) {
      let updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let cache2 = {
        map: this.cache
      };
      derivativeOption.forEach((derivative2) => {
        var _a2;
        if (!cache2) {
          cache2 = void 0;
        } else {
          cache2 = (_a2 = cache2 === null || cache2 === void 0 ? void 0 : cache2.map) === null || _a2 === void 0 ? void 0 : _a2.get(derivative2);
        }
      });
      if ((cache2 === null || cache2 === void 0 ? void 0 : cache2.value) && updateCallTimes) {
        cache2.value[1] = this.cacheCallTimes++;
      }
      return cache2 === null || cache2 === void 0 ? void 0 : cache2.value;
    }
    get(derivativeOption) {
      var _a2;
      return (_a2 = this.internalGet(derivativeOption, true)) === null || _a2 === void 0 ? void 0 : _a2[0];
    }
    has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
    set(derivativeOption, value) {
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
          const [targetKey] = this.keys.reduce((result, key2) => {
            const [, callTimes] = result;
            if (this.internalGet(key2)[1] < callTimes) {
              return [key2, this.internalGet(key2)[1]];
            }
            return result;
          }, [this.keys[0], this.cacheCallTimes]);
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      let cache2 = this.cache;
      derivativeOption.forEach((derivative2, index2) => {
        if (index2 === derivativeOption.length - 1) {
          cache2.set(derivative2, {
            value: [value, this.cacheCallTimes++]
          });
        } else {
          const cacheValue = cache2.get(derivative2);
          if (!cacheValue) {
            cache2.set(derivative2, {
              map: /* @__PURE__ */ new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = /* @__PURE__ */ new Map();
          }
          cache2 = cache2.get(derivative2).map;
        }
      });
    }
    deleteByPath(currentCache, derivatives) {
      var _a2;
      const cache2 = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        if (!cache2.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache2.map
          });
        }
        return (_a2 = cache2.value) === null || _a2 === void 0 ? void 0 : _a2[0];
      }
      const result = this.deleteByPath(cache2.map, derivatives.slice(1));
      if ((!cache2.map || cache2.map.size === 0) && !cache2.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
    delete(derivativeOption) {
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return void 0;
    }
  }
  ThemeCache.MAX_CACHE_SIZE = 20;
  ThemeCache.MAX_CACHE_OFFSET = 5;
  let warned = {};
  function warning$3(valid, message) {
  }
  function call(method, valid, message) {
    if (!valid && !warned[message]) {
      warned[message] = true;
    }
  }
  function warningOnce(valid, message) {
    call(warning$3, valid, message);
  }
  function noop$7() {
  }
  let warning$2 = noop$7;
  let uuid$2 = 0;
  class Theme {
    constructor(derivatives) {
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid$2;
      if (derivatives.length === 0) {
        warning$2(derivatives.length > 0);
      }
      uuid$2 += 1;
    }
    getDerivativeToken(token2) {
      return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
    }
  }
  const cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }
  const flattenTokenCache = /* @__PURE__ */ new WeakMap();
  function flattenToken(token2) {
    let str = flattenTokenCache.get(token2) || "";
    if (!str) {
      Object.keys(token2).forEach((key2) => {
        const value = token2[key2];
        str += key2;
        if (value instanceof Theme) {
          str += value.id;
        } else if (value && typeof value === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      flattenTokenCache.set(token2, str);
    }
    return str;
  }
  function token2key(token2, salt) {
    return murmur2(`${salt}_${flattenToken(token2)}`);
  }
  const randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
  const checkContent = "_bAmBoO_";
  function supportSelector(styleStr, handleElement, supportCheck) {
    var _a2, _b2;
    if (canUseDom$1()) {
      updateCSS$1(styleStr, randomSelectorKey);
      const ele = document.createElement("div");
      ele.style.position = "fixed";
      ele.style.left = "0";
      ele.style.top = "0";
      handleElement === null || handleElement === void 0 ? void 0 : handleElement(ele);
      document.body.appendChild(ele);
      const support = supportCheck ? supportCheck(ele) : (_a2 = getComputedStyle(ele).content) === null || _a2 === void 0 ? void 0 : _a2.includes(checkContent);
      (_b2 = ele.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(ele);
      removeCSS(randomSelectorKey);
      return support;
    }
    return false;
  }
  let canLayer = void 0;
  function supportLayer() {
    if (canLayer === void 0) {
      canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: "${checkContent}"!important; } }`, (ele) => {
        ele.className = randomSelectorKey;
      });
    }
    return canLayer;
  }
  const EMPTY_OVERRIDE = {};
  const hashPrefix = "css";
  const tokenKeys = /* @__PURE__ */ new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key2, instanceId) {
    if (typeof document !== "undefined") {
      const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key2}"]`);
      styles.forEach((style) => {
        var _a2;
        if (style[CSS_IN_JS_INSTANCE] === instanceId) {
          (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
        }
      });
    }
  }
  const TOKEN_THRESHOLD = 0;
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    const tokenKeyList = Array.from(tokenKeys.keys());
    const cleanableKeyList = tokenKeyList.filter((key2) => {
      const count = tokenKeys.get(key2) || 0;
      return count <= 0;
    });
    if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
      cleanableKeyList.forEach((key2) => {
        removeStyleTags(key2, instanceId);
        tokenKeys.delete(key2);
      });
    }
  }
  const getComputedToken = (originToken, overrideToken, theme2, format2) => {
    const derivativeToken = theme2.getDerivativeToken(originToken);
    let mergedDerivativeToken = _extends$1(_extends$1({}, derivativeToken), overrideToken);
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  function useCacheToken(theme2, tokens) {
    let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ref({});
    const style = useStyleInject();
    const mergedToken = computed(() => _extends$1({}, ...tokens.value));
    const tokenStr = computed(() => flattenToken(mergedToken.value));
    const overrideTokenStr = computed(() => flattenToken(option.value.override || EMPTY_OVERRIDE));
    const cachedToken = useClientCache("token", computed(() => [option.value.salt || "", theme2.value.id, tokenStr.value, overrideTokenStr.value]), () => {
      const {
        salt = "",
        override = EMPTY_OVERRIDE,
        formatToken: formatToken2,
        getComputedToken: compute
      } = option.value;
      const mergedDerivativeToken = compute ? compute(mergedToken.value, override, theme2.value) : getComputedToken(mergedToken.value, override, theme2.value, formatToken2);
      const tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      recordCleanToken(tokenKey);
      const hashId = `${hashPrefix}-${murmur2(tokenKey)}`;
      mergedDerivativeToken._hashId = hashId;
      return [mergedDerivativeToken, hashId];
    }, (cache2) => {
      var _a2;
      cleanTokenStyle(cache2[0]._tokenKey, (_a2 = style.value) === null || _a2 === void 0 ? void 0 : _a2.cache.instanceId);
    });
    return cachedToken;
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var NAMESPACE = "@namespace";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs$1 = Math.abs;
  var from = String.fromCharCode;
  function trim$2(value) {
    return value.trim();
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search, position2) {
    return value.indexOf(search, position2);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  var line = 1;
  var column = 1;
  var length$1 = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent2, type, props2, children, length2, siblings) {
    return { value, root: root2, parent: parent2, type, props: props2, children, line, column, length: length2, return: "", siblings };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length$1 ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice$1(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length$1 = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim$2(slice$1(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace$1(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice$1(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index2) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice$1(index2, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice$1(index2, position);
  }
  function compile(value) {
    return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse$1(value, root2, parent2, rule, rules2, rulesets, pseudo, points2, declarations) {
    var index2 = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property2 = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props2 = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs$1(index2 ? points2[index2 - 1] : 0)) != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$1(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent2, declarations), declarations);
              if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points2[index2++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset2:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property2 > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
                append(property2 > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2, declarations), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root2, parent2, index2, offset2, rules2, points2, type, props2 = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse$1(characters2, root2, reference, reference, props2, rulesets, length2, points2, children);
                else {
                  switch (atrule) {
                    // c(ontainer)
                    case 99:
                      if (charat(characters2, 3) === 110) break;
                    // l(ayer)
                    case 108:
                      if (charat(characters2, 2) === 97) break;
                    default:
                      offset2 = 0;
                    // d(ocument) m(edia) s(upports)
                    case 100:
                    case 109:
                    case 115:
                  }
                  if (offset2) parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points2, type, rules2, props2 = [], length2, children), children), rules2, children, length2, points2, rule ? props2 : children);
                  else parse$1(characters2, reference, reference, reference, [""], children, 0, points2, children);
                }
          }
          index2 = offset2 = property2 = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property2 = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points2[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent2, index2, offset2, rules2, points2, type, props2, children, length2, siblings) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules2 : [""];
    var size = sizeof(rule);
    for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs$1(j2 = points2[i2])), z2 = value; x2 < size; ++x2)
        if (z2 = trim$2(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props2[k2++] = z2;
    return node(value, root2, parent2, offset2 === 0 ? RULESET : type, props2, children, length2, siblings);
  }
  function comment(value, root2, parent2, siblings) {
    return node(value, root2, parent2, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root2, parent2, length2, siblings) {
    return node(value, root2, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }
  function serialize(children, callback) {
    var output = "";
    for (var i2 = 0; i2 < children.length; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify$1(element, index2, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case NAMESPACE:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(","))) return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
  const CSS_FILE_STYLE = "_FILE_STYLE__";
  let cachePathMap;
  let fromCSSFile = true;
  function prepare$1() {
    var _a2;
    if (!cachePathMap) {
      cachePathMap = {};
      if (canUseDom$1()) {
        const div2 = document.createElement("div");
        div2.className = ATTR_CACHE_MAP;
        div2.style.position = "fixed";
        div2.style.visibility = "hidden";
        div2.style.top = "-9999px";
        document.body.appendChild(div2);
        let content = getComputedStyle(div2).content || "";
        content = content.replace(/^"/, "").replace(/"$/, "");
        content.split(";").forEach((item) => {
          const [path, hash] = item.split(":");
          cachePathMap[path] = hash;
        });
        const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
        if (inlineMapStyle) {
          fromCSSFile = false;
          (_a2 = inlineMapStyle.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(inlineMapStyle);
        }
        document.body.removeChild(div2);
      }
    }
  }
  function existPath(path) {
    prepare$1();
    return !!cachePathMap[path];
  }
  function getStyleAndHash(path) {
    const hash = cachePathMap[path];
    let styleStr = null;
    if (hash && canUseDom$1()) {
      if (fromCSSFile) {
        styleStr = CSS_FILE_STYLE;
      } else {
        const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
        if (style) {
          styleStr = style.innerHTML;
        } else {
          delete cachePathMap[path];
        }
      }
    }
    return [styleStr, hash];
  }
  const isClientSide = canUseDom$1();
  const SKIP_CHECK = "_skip_check_";
  const MULTI_VALUE = "_multi_value_";
  function normalizeStyle$1(styleStr) {
    const serialized = serialize(compile(styleStr), stringify$1);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key2, hashId, hashPriority) {
    if (!hashId) {
      return key2;
    }
    const hashClassName = `.${hashId}`;
    const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
    const keys2 = key2.split(",").map((k2) => {
      var _a2;
      const fullPath = k2.trim().split(/\s+/);
      let firstPath = fullPath[0] || "";
      const htmlElement = ((_a2 = firstPath.match(/^\w+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
      firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
      return [firstPath, ...fullPath.slice(1)].join(" ");
    });
    return keys2.join(",");
  }
  const globalEffectStyleKeys = /* @__PURE__ */ new Set();
  const parseStyle = function(interpolation) {
    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let {
      root: root2,
      injectHash,
      parentSelectors
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      root: true,
      parentSelectors: []
    };
    const {
      hashId,
      layer,
      path,
      hashPriority,
      transformers = [],
      linters = []
    } = config;
    let styleStr = "";
    let effectStyle = {};
    function parseKeyframes(keyframes) {
      const animationName = keyframes.getName(hashId);
      if (!effectStyle[animationName]) {
        const [parsedStr] = parseStyle(keyframes.style, config, {
          root: false,
          parentSelectors
        });
        effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
      }
    }
    function flattenList(list2) {
      let fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      list2.forEach((item) => {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach((originStyle) => {
      const style = typeof originStyle === "string" && !root2 ? {} : originStyle;
      if (typeof style === "string") {
        styleStr += `${style}
`;
      } else if (style._keyframe) {
        parseKeyframes(style);
      } else {
        const mergedStyle = transformers.reduce((prev2, trans) => {
          var _a2;
          return ((_a2 = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a2 === void 0 ? void 0 : _a2.call(trans, prev2)) || prev2;
        }, style);
        Object.keys(mergedStyle).forEach((key2) => {
          var _a2;
          const value = mergedStyle[key2];
          if (typeof value === "object" && value && (key2 !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            let subInjectHash = false;
            let mergedKey = key2.trim();
            let nextRoot = false;
            if ((root2 || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else {
                mergedKey = injectSelectorHash(key2, hashId, hashPriority);
              }
            } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            const [parsedStr, childEffectStyle] = parseStyle(value, config, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [...parentSelectors, mergedKey]
            });
            effectStyle = _extends$1(_extends$1({}, effectStyle), childEffectStyle);
            styleStr += `${mergedKey}${parsedStr}`;
          } else {
            let appendStyle = function(cssKey, cssValue) {
              const styleName = cssKey.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
              let formatValue = cssValue;
              if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = `${formatValue}px`;
              }
              if (cssKey === "animationName" && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += `${styleName}:${formatValue};`;
            };
            const actualValue = (_a2 = value === null || value === void 0 ? void 0 : value.value) !== null && _a2 !== void 0 ? _a2 : value;
            if (typeof value === "object" && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {
              actualValue.forEach((item) => {
                appendStyle(key2, item);
              });
            } else {
              appendStyle(key2, actualValue);
            }
          }
        });
      }
    });
    if (!root2) {
      styleStr = `{${styleStr}}`;
    } else if (layer && supportLayer()) {
      const layerCells = layer.split(",");
      const layerName = layerCells[layerCells.length - 1].trim();
      styleStr = `@layer ${layerName} {${styleStr}}`;
      if (layerCells.length > 1) {
        styleStr = `@layer ${layer}{%%%:%}${styleStr}`;
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path, styleStr) {
    return murmur2(`${path.join("%")}${styleStr}`);
  }
  function useStyleRegister(info, styleFn) {
    const styleContext = useStyleInject();
    const tokenKey = computed(() => info.value.token._tokenKey);
    const fullPath = computed(() => [tokenKey.value, ...info.value.path]);
    let isMergedClientSide = isClientSide;
    useClientCache(
      "style",
      fullPath,
      // Create cache if needed
      () => {
        const {
          path,
          hashId,
          layer,
          nonce,
          clientOnly,
          order = 0
        } = info.value;
        const cachePath = fullPath.value.join("|");
        if (existPath(cachePath)) {
          const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
          if (inlineCacheStyleStr) {
            return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];
          }
        }
        const styleObj = styleFn();
        const {
          hashPriority,
          container,
          transformers,
          linters,
          cache: cache2
        } = styleContext.value;
        const [parsedStyle, effectStyle] = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer,
          path: path.join("-"),
          transformers,
          linters
        });
        const styleStr = normalizeStyle$1(parsedStyle);
        const styleId = uniqueHash(fullPath.value, styleStr);
        if (isMergedClientSide) {
          const mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: order
          };
          const nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          const style = updateCSS$1(styleStr, styleId, mergedCSSConfig);
          style[CSS_IN_JS_INSTANCE] = cache2.instanceId;
          style.setAttribute(ATTR_TOKEN, tokenKey.value);
          Object.keys(effectStyle).forEach((effectKey) => {
            if (!globalEffectStyleKeys.has(effectKey)) {
              globalEffectStyleKeys.add(effectKey);
              updateCSS$1(normalizeStyle$1(effectStyle[effectKey]), `_effect-${effectKey}`, {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: container
              });
            }
          });
        }
        return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];
      },
      // Remove cache if no need
      (_ref, fromHMR) => {
        let [, , styleId] = _ref;
        if ((fromHMR || styleContext.value.autoClear) && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      }
    );
    return (node2) => {
      return node2;
    };
  }
  class Keyframe {
    constructor(name, style) {
      this._keyframe = true;
      this.name = name;
      this.style = style;
    }
    getName() {
      let hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return hashId ? `${hashId}-${this.name}` : this.name;
    }
  }
  function noSplit(list2) {
    list2.notSplit = true;
    return list2;
  }
  ({
    // Border
    borderBlock: noSplit(["borderTop", "borderBottom"]),
    borderBlockStart: noSplit(["borderTop"]),
    borderBlockEnd: noSplit(["borderBottom"]),
    borderInline: noSplit(["borderLeft", "borderRight"]),
    borderInlineStart: noSplit(["borderLeft"]),
    borderInlineEnd: noSplit(["borderRight"])
  });
  const version$2 = "4.2.6";
  const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
  function bound01(n2, max3) {
    if (isOnePointZero(n2)) {
      n2 = "100%";
    }
    var isPercent = isPercentage(n2);
    n2 = max3 === 360 ? n2 : Math.min(max3, Math.max(0, parseFloat(n2)));
    if (isPercent) {
      n2 = parseInt(String(n2 * max3), 10) / 100;
    }
    if (Math.abs(n2 - max3) < 1e-6) {
      return 1;
    }
    if (max3 === 360) {
      n2 = (n2 < 0 ? n2 % max3 + max3 : n2 % max3) / parseFloat(String(max3));
    } else {
      n2 = n2 % max3 / parseFloat(String(max3));
    }
    return n2;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n2) {
    return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
  }
  function isPercentage(n2) {
    return typeof n2 === "string" && n2.indexOf("%") !== -1;
  }
  function boundAlpha(a2) {
    a2 = parseFloat(a2);
    if (isNaN(a2) || a2 < 0 || a2 > 1) {
      a2 = 1;
    }
    return a2;
  }
  function convertToPercentage(n2) {
    if (n2 <= 1) {
      return "".concat(Number(n2) * 100, "%");
    }
    return n2;
  }
  function pad2(c2) {
    return c2.length === 1 ? "0" + c2 : String(c2);
  }
  function rgbToRgb(r2, g2, b2) {
    return {
      r: bound01(r2, 255) * 255,
      g: bound01(g2, 255) * 255,
      b: bound01(b2, 255) * 255
    };
  }
  function rgbToHsl(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max3 = Math.max(r2, g2, b2);
    var min3 = Math.min(r2, g2, b2);
    var h2 = 0;
    var s2 = 0;
    var l2 = (max3 + min3) / 2;
    if (max3 === min3) {
      s2 = 0;
      h2 = 0;
    } else {
      var d2 = max3 - min3;
      s2 = l2 > 0.5 ? d2 / (2 - max3 - min3) : d2 / (max3 + min3);
      switch (max3) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s: s2, l: l2 };
  }
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p2 + (q2 - p2) * (6 * t2);
    }
    if (t2 < 1 / 2) {
      return q2;
    }
    if (t2 < 2 / 3) {
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    }
    return p2;
  }
  function hslToRgb(h2, s2, l2) {
    var r2;
    var g2;
    var b2;
    h2 = bound01(h2, 360);
    s2 = bound01(s2, 100);
    l2 = bound01(l2, 100);
    if (s2 === 0) {
      g2 = l2;
      b2 = l2;
      r2 = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      var p2 = 2 * l2 - q2;
      r2 = hue2rgb(p2, q2, h2 + 1 / 3);
      g2 = hue2rgb(p2, q2, h2);
      b2 = hue2rgb(p2, q2, h2 - 1 / 3);
    }
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHsv(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max3 = Math.max(r2, g2, b2);
    var min3 = Math.min(r2, g2, b2);
    var h2 = 0;
    var v2 = max3;
    var d2 = max3 - min3;
    var s2 = max3 === 0 ? 0 : d2 / max3;
    if (max3 === min3) {
      h2 = 0;
    } else {
      switch (max3) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s: s2, v: v2 };
  }
  function hsvToRgb(h2, s2, v2) {
    h2 = bound01(h2, 360) * 6;
    s2 = bound01(s2, 100);
    v2 = bound01(v2, 100);
    var i2 = Math.floor(h2);
    var f2 = h2 - i2;
    var p2 = v2 * (1 - s2);
    var q2 = v2 * (1 - f2 * s2);
    var t2 = v2 * (1 - (1 - f2) * s2);
    var mod = i2 % 6;
    var r2 = [v2, q2, p2, p2, t2, v2][mod];
    var g2 = [t2, v2, v2, q2, p2, p2][mod];
    var b2 = [p2, p2, t2, v2, v2, q2][mod];
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHex(r2, g2, b2, allow3Char) {
    var hex = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16))
    ];
    if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToHex(r2, g2, b2, a2, allow4Char) {
    var hex = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16)),
      pad2(convertDecimalToHex(a2))
    ];
    if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
  }
  function convertDecimalToHex(d2) {
    return Math.round(parseFloat(d2) * 255).toString(16);
  }
  function convertHexToDecimal(h2) {
    return parseIntFromHex(h2) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color2) {
    return {
      r: color2 >> 16,
      g: (color2 & 65280) >> 8,
      b: color2 & 255
    };
  }
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function inputToRGB(color2) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a2 = 1;
    var s2 = null;
    var v2 = null;
    var l2 = null;
    var ok = false;
    var format2 = false;
    if (typeof color2 === "string") {
      color2 = stringInputToObject(color2);
    }
    if (typeof color2 === "object") {
      if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
        rgb = rgbToRgb(color2.r, color2.g, color2.b);
        ok = true;
        format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
        s2 = convertToPercentage(color2.s);
        v2 = convertToPercentage(color2.v);
        rgb = hsvToRgb(color2.h, s2, v2);
        ok = true;
        format2 = "hsv";
      } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
        s2 = convertToPercentage(color2.s);
        l2 = convertToPercentage(color2.l);
        rgb = hslToRgb(color2.h, s2, l2);
        ok = true;
        format2 = "hsl";
      }
      if (Object.prototype.hasOwnProperty.call(color2, "a")) {
        a2 = color2.a;
      }
    }
    a2 = boundAlpha(a2);
    return {
      ok,
      format: color2.format || format2,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a2
    };
  }
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color2) {
    color2 = color2.trim().toLowerCase();
    if (color2.length === 0) {
      return false;
    }
    var named = false;
    if (names[color2]) {
      color2 = names[color2];
      named = true;
    } else if (color2 === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match2 = matchers.rgb.exec(color2);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3] };
    }
    match2 = matchers.rgba.exec(color2);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
    }
    match2 = matchers.hsl.exec(color2);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3] };
    }
    match2 = matchers.hsla.exec(color2);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
    }
    match2 = matchers.hsv.exec(color2);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3] };
    }
    match2 = matchers.hsva.exec(color2);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
    }
    match2 = matchers.hex8.exec(color2);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        a: convertHexToDecimal(match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex6.exec(color2);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        format: named ? "name" : "hex"
      };
    }
    match2 = matchers.hex4.exec(color2);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        a: convertHexToDecimal(match2[4] + match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex3.exec(color2);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color2) {
    return Boolean(matchers.CSS_UNIT.exec(String(color2)));
  }
  var TinyColor = (
    /** @class */
    function() {
      function TinyColor2(color2, opts) {
        if (color2 === void 0) {
          color2 = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a2;
        if (color2 instanceof TinyColor2) {
          return color2;
        }
        if (typeof color2 === "number") {
          color2 = numberInputToObject(color2);
        }
        this.originalInput = color2;
        var rgb = inputToRGB(color2);
        this.originalInput = color2;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R2;
        var G;
        var B2;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.isMonochrome = function() {
        var s2 = this.toHsl().s;
        return s2 === 0;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s2 = Math.round(hsv.s * 100);
        var v2 = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s2 = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toHexShortString = function(allowShortChar) {
        if (allowShortChar === void 0) {
          allowShortChar = false;
        }
        return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r2 = Math.round(this.r);
        var g2 = Math.round(this.g);
        var b2 = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x2) {
          return "".concat(Math.round(bound01(x2, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x2) {
          return Math.round(bound01(x2, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
          var _b2 = _a2[_i], key2 = _b2[0], value = _b2[1];
          if (hex === value) {
            return key2;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color2, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color2).toRgb();
        var p2 = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s2 = hsv.s;
        var v2 = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        var alpha = fg.a + bg.a * (1 - fg.a);
        return new TinyColor2({
          r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
          g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
          b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
          a: alpha
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n2) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n2;
        for (var i2 = 1; i2 < n2; i2++) {
          result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color2) {
        return this.toRgbString() === new TinyColor2(color2).toRgbString();
      };
      return TinyColor2;
    }()
  );
  var hueStep = 2;
  var saturationStep = 0.16;
  var saturationStep2 = 0.05;
  var brightnessStep1 = 0.05;
  var brightnessStep2 = 0.15;
  var lightColorCount = 5;
  var darkColorCount = 4;
  var darkColorMap = [{
    index: 7,
    opacity: 0.15
  }, {
    index: 6,
    opacity: 0.25
  }, {
    index: 5,
    opacity: 0.3
  }, {
    index: 5,
    opacity: 0.45
  }, {
    index: 5,
    opacity: 0.65
  }, {
    index: 5,
    opacity: 0.85
  }, {
    index: 4,
    opacity: 0.9
  }, {
    index: 3,
    opacity: 0.95
  }, {
    index: 2,
    opacity: 0.97
  }, {
    index: 1,
    opacity: 0.98
  }];
  function toHsv(_ref) {
    var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
    var hsv = rgbToHsv(r2, g2, b2);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v
    };
  }
  function toHex$1(_ref2) {
    var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
    return "#".concat(rgbToHex(r2, g2, b2, false));
  }
  function mix$1(rgb1, rgb2, amount) {
    var p2 = amount / 100;
    var rgb = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b
    };
    return rgb;
  }
  function getHue(hsv, i2, light) {
    var hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i2, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    var saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i2;
    } else if (i2 === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i2;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i2 === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Number(saturation.toFixed(2));
  }
  function getValue$3(hsv, i2, light) {
    var value;
    if (light) {
      value = hsv.v + brightnessStep1 * i2;
    } else {
      value = hsv.v - brightnessStep2 * i2;
    }
    if (value > 1) {
      value = 1;
    }
    return Number(value.toFixed(2));
  }
  function generate$1(color2) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var patterns = [];
    var pColor = inputToRGB(color2);
    for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
      var hsv = toHsv(pColor);
      var colorString = toHex$1(inputToRGB({
        h: getHue(hsv, i2, true),
        s: getSaturation(hsv, i2, true),
        v: getValue$3(hsv, i2, true)
      }));
      patterns.push(colorString);
    }
    patterns.push(toHex$1(pColor));
    for (var _i = 1; _i <= darkColorCount; _i += 1) {
      var _hsv = toHsv(pColor);
      var _colorString = toHex$1(inputToRGB({
        h: getHue(_hsv, _i),
        s: getSaturation(_hsv, _i),
        v: getValue$3(_hsv, _i)
      }));
      patterns.push(_colorString);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(function(_ref3) {
        var index2 = _ref3.index, opacity = _ref3.opacity;
        var darkColorString = toHex$1(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
        return darkColorString;
      });
    }
    return patterns;
  }
  var presetPrimaryColors = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1890FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
  };
  var presetPalettes = {};
  var presetDarkPalettes = {};
  Object.keys(presetPrimaryColors).forEach(function(key2) {
    presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
    presetPalettes[key2].primary = presetPalettes[key2][5];
    presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
      theme: "dark",
      backgroundColor: "#141414"
    });
    presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
  });
  var blue = presetPalettes.blue;
  const genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
      sizeXL: sizeUnit * (sizeStep + 4),
      sizeLG: sizeUnit * (sizeStep + 2),
      sizeMD: sizeUnit * (sizeStep + 1),
      sizeMS: sizeUnit * sizeStep,
      size: sizeUnit * sizeStep,
      sizeSM: sizeUnit * (sizeStep - 1),
      sizeXS: sizeUnit * (sizeStep - 2),
      sizeXXS: sizeUnit * (sizeStep - 3)
      // 4
    };
  }
  const defaultPresetColors = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  const seedToken = _extends$1(_extends$1({}, defaultPresetColors), {
    // Color
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorTextBase: "",
    colorBgBase: "",
    // Font
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontSize: 14,
    // Line
    lineWidth: 1,
    lineType: "solid",
    // Motion
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    // Radius
    borderRadius: 6,
    // Size
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    // Control Base
    controlHeight: 32,
    // zIndex
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    // Image
    opacityImage: 1,
    // Wireframe
    wireframe: false
  });
  function genColorMapToken(seed2, _ref) {
    let {
      generateColorPalettes: generateColorPalettes2,
      generateNeutralColorPalettes: generateNeutralColorPalettes2
    } = _ref;
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed2;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    return _extends$1(_extends$1({}, neutralColors), {
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
      colorWhite: "#fff"
    });
  }
  const genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase > 16 ? 16 : radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return _extends$1({
      // motion
      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
      // line
      lineWidthBold: lineWidth + 1
    }, genRadius(borderRadius));
  }
  const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
  const getSolidColor = (baseColor, brightness) => {
    const instance = new TinyColor(baseColor);
    return instance.darken(brightness).toHexString();
  };
  const generateColorPalettes = (baseColor) => {
    const colors = generate$1(baseColor);
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[4],
      6: colors[5],
      7: colors[6],
      8: colors[4],
      9: colors[5],
      10: colors[6]
      // 8: colors[7],
      // 9: colors[8],
      // 10: colors[9],
    };
  };
  const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor$1(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
      colorFill: getAlphaColor$1(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
      colorBgLayout: getSolidColor(colorBgBase, 4),
      colorBgContainer: getSolidColor(colorBgBase, 0),
      colorBgElevated: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
      colorBorder: getSolidColor(colorBgBase, 15),
      colorBorderSecondary: getSolidColor(colorBgBase, 6)
    };
  };
  function getFontSizes(base2) {
    const fontSizes = new Array(10).fill(null).map((_2, index2) => {
      const i2 = index2 - 1;
      const baseSize = base2 * Math.pow(2.71828, i2 / 5);
      const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base2;
    return fontSizes.map((size) => {
      const height = size + 8;
      return {
        size,
        lineHeight: height / size
      };
    });
  }
  const genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    return {
      fontSizeSM: fontSizes[0],
      fontSize: fontSizes[1],
      fontSizeLG: fontSizes[2],
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight: lineHeights[1],
      lineHeightLG: lineHeights[2],
      lineHeightSM: lineHeights[0],
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  function derivative(token2) {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = generate$1(token2[colorKey]);
      return new Array(10).fill(1).reduce((prev2, _2, i2) => {
        prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = _extends$1(_extends$1({}, prev2), cur);
      return prev2;
    }, {});
    return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, token2), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
  }
  function isStableColor(color2) {
    return color2 >= 0 && color2 <= 255;
  }
  function getAlphaColor(frontColor, backgroundColor2) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new TinyColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new TinyColor(backgroundColor2).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r2 = Math.round((fR - bR * (1 - fA)) / fA);
      const g2 = Math.round((fG - bG * (1 - fA)) / fA);
      const b2 = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
        return new TinyColor({
          r: r2,
          g: g2,
          b: b2,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new TinyColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  var __rest$F = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function formatToken(derivativeToken) {
    const {
      override
    } = derivativeToken, restToken = __rest$F(derivativeToken, ["override"]);
    const overrideTokens = _extends$1({}, override);
    Object.keys(seedToken).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = _extends$1(_extends$1({}, restToken), overrideTokens);
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    const screenXXXL = 2e3;
    const aliasToken = _extends$1(_extends$1(_extends$1({}, mergedToken), {
      colorLink: mergedToken.colorInfoText,
      colorLinkHover: mergedToken.colorInfoHover,
      colorLinkActive: mergedToken.colorInfoActive,
      // ============== Background ============== //
      colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
      // ============== Split ============== //
      colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
      // ============== Text ============== //
      colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
      // Font
      fontSizeIcon: mergedToken.fontSizeSM,
      // Control
      lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
      // Checkbox size and expand icon size
      controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      screenXXLMax: screenXXXL - 1,
      screenXXXL,
      screenXXXLMin: screenXXXL,
      // FIXME: component box-shadow, should be removed
      boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
      boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), overrideTokens);
    return aliasToken;
  }
  const operationUnit = (token2) => ({
    // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
    // And Typography use this to generate link style which should not do this.
    color: token2.colorLink,
    textDecoration: "none",
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "&:focus, &:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    }
  });
  const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
    const unitWidth = width / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = outerRadius * 1 / Math.sqrt(2);
    const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
    const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
    const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
    return {
      pointerEvents: "none",
      width,
      height: width,
      overflow: "hidden",
      "&::after": {
        content: '""',
        position: "absolute",
        width: shadowWidth,
        height: shadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${innerRadius}px 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      },
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width,
        height: width / 2,
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
        },
        content: '""'
      }
    };
  };
  function genPresetColor(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}-1`];
      const lightBorderColor = token2[`${colorKey}-3`];
      const darkColor = token2[`${colorKey}-6`];
      const textColor = token2[`${colorKey}-7`];
      return _extends$1(_extends$1({}, prev2), genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      }));
    }, {});
  }
  const textEllipsis = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  };
  const resetComponent = (token2) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: token2.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: token2.fontFamily
  });
  const resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  const clearFix = () => ({
    // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/21864
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  const genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      [`&:active,
  &:hover`]: {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      // https://github.com/ant-design/ant-design/issues/22503
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  const genCommonStyle = (token2, componentPrefixCls) => {
    const {
      fontFamily,
      fontSize
    } = token2;
    const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    return {
      [rootPrefixSelector]: {
        fontFamily,
        fontSize,
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        },
        [rootPrefixSelector]: {
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          }
        }
      }
    };
  };
  const genFocusOutline = (token2) => ({
    outline: `${token2.lineWidthBold}px solid ${token2.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
  });
  const genFocusStyle = (token2) => ({
    "&:focus-visible": _extends$1({}, genFocusOutline(token2))
  });
  function genComponentStyleHook(component, styleFn, getDefaultToken) {
    return (_prefixCls) => {
      const prefixCls = computed(() => _prefixCls === null || _prefixCls === void 0 ? void 0 : _prefixCls.value);
      const [theme2, token2, hashId] = useToken();
      const {
        getPrefixCls,
        iconPrefixCls
      } = useConfigContextInject();
      const rootPrefixCls = computed(() => getPrefixCls());
      const sharedInfo = computed(() => {
        return {
          theme: theme2.value,
          token: token2.value,
          hashId: hashId.value,
          path: ["Shared", rootPrefixCls.value]
        };
      });
      useStyleRegister(sharedInfo, () => [{
        // Link
        "&": genLinkStyle(token2.value)
      }]);
      const componentInfo = computed(() => {
        return {
          theme: theme2.value,
          token: token2.value,
          hashId: hashId.value,
          path: [component, prefixCls.value, iconPrefixCls.value]
        };
      });
      return [useStyleRegister(componentInfo, () => {
        const {
          token: proxyToken,
          flush
        } = statisticToken(token2.value);
        const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
        const mergedComponentToken = _extends$1(_extends$1({}, defaultComponentToken), token2.value[component]);
        const componentCls = `.${prefixCls.value}`;
        const mergedToken = merge$2(proxyToken, {
          componentCls,
          prefixCls: prefixCls.value,
          iconCls: `.${iconPrefixCls.value}`,
          antCls: `.${rootPrefixCls.value}`
        }, mergedComponentToken);
        const styleInterpolation = styleFn(mergedToken, {
          hashId: hashId.value,
          prefixCls: prefixCls.value,
          rootPrefixCls: rootPrefixCls.value,
          iconPrefixCls: iconPrefixCls.value,
          overrideComponentToken: token2.value[component]
        });
        flush(component, mergedComponentToken);
        return [genCommonStyle(token2.value, prefixCls.value), styleInterpolation];
      }), hashId];
    };
  }
  const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
  let recording = true;
  function merge$2() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    if (!enableStatistic) {
      return _extends$1({}, ...objs);
    }
    recording = false;
    const ret = {};
    objs.forEach((obj2) => {
      const keys2 = Object.keys(obj2);
      keys2.forEach((key2) => {
        Object.defineProperty(ret, key2, {
          configurable: true,
          enumerable: true,
          get: () => obj2[key2]
        });
      });
    });
    recording = true;
    return ret;
  }
  function noop$6() {
  }
  function statisticToken(token2) {
    let tokenKeys2;
    let proxy = token2;
    let flush = noop$6;
    if (enableStatistic) {
      tokenKeys2 = /* @__PURE__ */ new Set();
      proxy = new Proxy(token2, {
        get(obj2, prop) {
          if (recording) {
            tokenKeys2.add(prop);
          }
          return obj2[prop];
        }
      });
      flush = (componentName, componentToken) => {
        ({
          global: Array.from(tokenKeys2),
          component: componentToken
        });
      };
    }
    return {
      token: proxy,
      keys: tokenKeys2,
      flush
    };
  }
  const defaultTheme = createTheme(derivative);
  const defaultConfig = {
    token: seedToken,
    hashed: true
  };
  const DesignTokenContextKey = Symbol("DesignTokenContext");
  const globalDesignTokenApi = shallowRef();
  const useDesignTokenProvider = (value) => {
    provide(DesignTokenContextKey, value);
    watch(value, () => {
      globalDesignTokenApi.value = unref(value);
      triggerRef(globalDesignTokenApi);
    }, {
      immediate: true,
      deep: true
    });
  };
  const DesignTokenProvider = /* @__PURE__ */ defineComponent({
    props: {
      value: objectType()
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      useDesignTokenProvider(computed(() => props2.value));
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  function useToken() {
    const designTokenContext = inject(DesignTokenContextKey, computed(() => globalDesignTokenApi.value || defaultConfig));
    const salt = computed(() => `${version$2}-${designTokenContext.value.hashed || ""}`);
    const mergedTheme = computed(() => designTokenContext.value.theme || defaultTheme);
    const cacheToken = useCacheToken(mergedTheme, computed(() => [seedToken, designTokenContext.value.token]), computed(() => ({
      salt: salt.value,
      override: _extends$1({
        override: designTokenContext.value.token
      }, designTokenContext.value.components),
      formatToken
    })));
    return [mergedTheme, computed(() => cacheToken.value[0]), computed(() => designTokenContext.value.hashed ? cacheToken.value[1] : "")];
  }
  const Empty$2 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    setup() {
      const [, token2] = useToken();
      const themeStyle = computed(() => {
        const bgColor = new TinyColor(token2.value.colorBgBase);
        if (bgColor.toHsl().l < 0.5) {
          return {
            opacity: 0.65
          };
        }
        return {};
      });
      return () => createVNode("svg", {
        "style": themeStyle.value,
        "width": "184",
        "height": "152",
        "viewBox": "0 0 184 152",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("g", {
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "transform": "translate(24 31.67)"
      }, [createVNode("ellipse", {
        "fill-opacity": ".8",
        "fill": "#F5F5F7",
        "cx": "67.797",
        "cy": "106.89",
        "rx": "67.797",
        "ry": "12.668"
      }, null), createVNode("path", {
        "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        "fill": "#AEB8C2"
      }, null), createVNode("path", {
        "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        "fill": "url(#linearGradient-1)",
        "transform": "translate(13.56)"
      }, null), createVNode("path", {
        "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        "fill": "#F5F5F7"
      }, null), createVNode("path", {
        "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        "fill": "#DCE0E6"
      }, null)]), createVNode("path", {
        "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        "fill": "#DCE0E6"
      }, null), createVNode("g", {
        "transform": "translate(149.65 15.383)",
        "fill": "#FFF"
      }, [createVNode("ellipse", {
        "cx": "20.654",
        "cy": "3.167",
        "rx": "2.849",
        "ry": "2.815"
      }, null), createVNode("path", {
        "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
      }, null)])])]);
    }
  });
  Empty$2.PRESENTED_IMAGE_DEFAULT = true;
  const Simple = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    setup() {
      const [, token2] = useToken();
      const color2 = computed(() => {
        const {
          colorFill,
          colorFillTertiary,
          colorFillQuaternary,
          colorBgContainer
        } = token2.value;
        return {
          borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
          shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
          contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
        };
      });
      return () => createVNode("svg", {
        "width": "64",
        "height": "41",
        "viewBox": "0 0 64 41",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("g", {
        "transform": "translate(0 1)",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("ellipse", {
        "fill": color2.value.shadowColor,
        "cx": "32",
        "cy": "33",
        "rx": "32",
        "ry": "7"
      }, null), createVNode("g", {
        "fill-rule": "nonzero",
        "stroke": color2.value.borderColor
      }, [createVNode("path", {
        "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
      }, null), createVNode("path", {
        "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        "fill": color2.value.contentColor
      }, null)])])]);
    }
  });
  Simple.PRESENTED_IMAGE_SIMPLE = true;
  const genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
        // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            height: "100%",
            margin: "auto"
          }
        },
        // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  const useStyle$k = genComponentStyleHook("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG
    } = token2;
    const emptyToken = merge$2(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: controlHeightLG * 2.5,
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: controlHeightLG * 0.875
    });
    return [genSharedEmptyStyle(emptyToken)];
  });
  var __rest$E = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const emptyProps = () => ({
    prefixCls: String,
    imageStyle: objectType(),
    image: anyType(),
    description: anyType()
  });
  const Empty = /* @__PURE__ */ defineComponent({
    name: "AEmpty",
    compatConfig: {
      MODE: 3
    },
    inheritAttrs: false,
    props: emptyProps(),
    setup(props2, _ref) {
      let {
        slots = {},
        attrs
      } = _ref;
      const {
        direction,
        prefixCls: prefixClsRef
      } = useConfigInject("empty", props2);
      const [wrapSSR, hashId] = useStyle$k(prefixClsRef);
      return () => {
        var _a2, _b2;
        const prefixCls = prefixClsRef.value;
        const _c2 = _extends$1(_extends$1({}, props2), attrs), {
          image: mergedImage = ((_a2 = slots.image) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || h$1(Empty$2),
          description = ((_b2 = slots.description) === null || _b2 === void 0 ? void 0 : _b2.call(slots)) || void 0,
          imageStyle,
          class: className = ""
        } = _c2, restProps = __rest$E(_c2, ["image", "description", "imageStyle", "class"]);
        const image = typeof mergedImage === "function" ? mergedImage() : mergedImage;
        const isNormal = typeof image === "object" && "type" in image && image.type.PRESENTED_IMAGE_SIMPLE;
        return wrapSSR(createVNode(LocaleReceiver, {
          "componentName": "Empty",
          "children": (locale2) => {
            const des = typeof description !== "undefined" ? description : locale2.description;
            const alt = typeof des === "string" ? des : "empty";
            let imageNode = null;
            if (typeof image === "string") {
              imageNode = createVNode("img", {
                "alt": alt,
                "src": image
              }, null);
            } else {
              imageNode = image;
            }
            return createVNode("div", _objectSpread2$1({
              "class": classNames(prefixCls, className, hashId.value, {
                [`${prefixCls}-normal`]: isNormal,
                [`${prefixCls}-rtl`]: direction.value === "rtl"
              })
            }, restProps), [createVNode("div", {
              "class": `${prefixCls}-image`,
              "style": imageStyle
            }, [imageNode]), des && createVNode("p", {
              "class": `${prefixCls}-description`
            }, [des]), slots.default && createVNode("div", {
              "class": `${prefixCls}-footer`
            }, [filterEmpty(slots.default())])]);
          }
        }, null));
      };
    }
  });
  Empty.PRESENTED_IMAGE_DEFAULT = () => h$1(Empty$2);
  Empty.PRESENTED_IMAGE_SIMPLE = () => h$1(Simple);
  const Empty$1 = withInstall(Empty);
  const DefaultRenderEmpty = (props2) => {
    const {
      prefixCls
    } = useConfigInject("empty", props2);
    const renderHtml = (componentName) => {
      switch (componentName) {
        case "Table":
        case "List":
          return createVNode(Empty$1, {
            "image": Empty$1.PRESENTED_IMAGE_SIMPLE
          }, null);
        case "Select":
        case "TreeSelect":
        case "Cascader":
        case "Transfer":
        case "Mentions":
          return createVNode(Empty$1, {
            "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
            "class": `${prefixCls.value}-small`
          }, null);
        default:
          return createVNode(Empty$1, null, null);
      }
    };
    return renderHtml(props2.componentName);
  };
  function renderEmpty(componentName) {
    return createVNode(DefaultRenderEmpty, {
      "componentName": componentName
    }, null);
  }
  const SizeContextKey = Symbol("SizeContextKey");
  const useInjectSize = () => {
    return inject(SizeContextKey, ref(void 0));
  };
  const useProviderSize = (size) => {
    const parentSize = useInjectSize();
    provide(SizeContextKey, computed(() => size.value || parentSize.value));
    return size;
  };
  const useConfigInject = (name, props2) => {
    const sizeContext = useInjectSize();
    const disabledContext = useInjectDisabled();
    const configProvider = inject(configProviderKey, _extends$1(_extends$1({}, defaultConfigProvider), {
      renderEmpty: (name2) => h$1(DefaultRenderEmpty, {
        componentName: name2
      })
    }));
    const prefixCls = computed(() => configProvider.getPrefixCls(name, props2.prefixCls));
    const direction = computed(() => {
      var _a2, _b2;
      return (_a2 = props2.direction) !== null && _a2 !== void 0 ? _a2 : (_b2 = configProvider.direction) === null || _b2 === void 0 ? void 0 : _b2.value;
    });
    const iconPrefixCls = computed(() => {
      var _a2;
      return (_a2 = props2.iconPrefixCls) !== null && _a2 !== void 0 ? _a2 : configProvider.iconPrefixCls.value;
    });
    const rootPrefixCls = computed(() => configProvider.getPrefixCls());
    const autoInsertSpaceInButton = computed(() => {
      var _a2;
      return (_a2 = configProvider.autoInsertSpaceInButton) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const renderEmpty2 = configProvider.renderEmpty;
    const space = configProvider.space;
    const pageHeader = configProvider.pageHeader;
    const form = configProvider.form;
    const getTargetContainer = computed(() => {
      var _a2, _b2;
      return (_a2 = props2.getTargetContainer) !== null && _a2 !== void 0 ? _a2 : (_b2 = configProvider.getTargetContainer) === null || _b2 === void 0 ? void 0 : _b2.value;
    });
    const getPopupContainer = computed(() => {
      var _a2, _b2, _c2;
      return (_b2 = (_a2 = props2.getContainer) !== null && _a2 !== void 0 ? _a2 : props2.getPopupContainer) !== null && _b2 !== void 0 ? _b2 : (_c2 = configProvider.getPopupContainer) === null || _c2 === void 0 ? void 0 : _c2.value;
    });
    const dropdownMatchSelectWidth = computed(() => {
      var _a2, _b2;
      return (_a2 = props2.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b2 = configProvider.dropdownMatchSelectWidth) === null || _b2 === void 0 ? void 0 : _b2.value;
    });
    const virtual = computed(() => {
      var _a2;
      return (props2.virtual === void 0 ? ((_a2 = configProvider.virtual) === null || _a2 === void 0 ? void 0 : _a2.value) !== false : props2.virtual !== false) && dropdownMatchSelectWidth.value !== false;
    });
    const size = computed(() => props2.size || sizeContext.value);
    const autocomplete = computed(() => {
      var _a2, _b2, _c2;
      return (_a2 = props2.autocomplete) !== null && _a2 !== void 0 ? _a2 : (_c2 = (_b2 = configProvider.input) === null || _b2 === void 0 ? void 0 : _b2.value) === null || _c2 === void 0 ? void 0 : _c2.autocomplete;
    });
    const disabled = computed(() => {
      var _a2;
      return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const csp = computed(() => {
      var _a2;
      return (_a2 = props2.csp) !== null && _a2 !== void 0 ? _a2 : configProvider.csp;
    });
    const wave = computed(() => {
      var _a2, _b2;
      return (_a2 = props2.wave) !== null && _a2 !== void 0 ? _a2 : (_b2 = configProvider.wave) === null || _b2 === void 0 ? void 0 : _b2.value;
    });
    return {
      configProvider,
      prefixCls,
      direction,
      size,
      getTargetContainer,
      getPopupContainer,
      space,
      pageHeader,
      form,
      autoInsertSpaceInButton,
      renderEmpty: renderEmpty2,
      virtual,
      dropdownMatchSelectWidth,
      rootPrefixCls,
      getPrefixCls: configProvider.getPrefixCls,
      autocomplete,
      csp,
      iconPrefixCls,
      disabled,
      select: configProvider.select,
      wave
    };
  };
  function omit$1(obj2, fields) {
    const shallowCopy = _extends$1({}, obj2);
    for (let i2 = 0; i2 < fields.length; i2 += 1) {
      const key2 = fields[i2];
      delete shallowCopy[key2];
    }
    return shallowCopy;
  }
  function t$1(t2) {
    return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
  }
  function e$2(t2, e2) {
    return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
  }
  function n$1(t2, n2) {
    if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
      var r2 = getComputedStyle(t2, null);
      return e$2(r2.overflowY, n2) || e$2(r2.overflowX, n2) || function(t3) {
        var e2 = function(t4) {
          if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
          try {
            return t4.ownerDocument.defaultView.frameElement;
          } catch (t5) {
            return null;
          }
        }(t3);
        return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
      }(t2);
    }
    return false;
  }
  function r$1(t2, e2, n2, r2, i2, o2, l2, d2) {
    return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
  }
  var i$1 = function(e2, i2) {
    var o2 = window, l2 = i2.scrollMode, d2 = i2.block, f2 = i2.inline, h2 = i2.boundary, u2 = i2.skipOverflowHiddenElements, s2 = "function" == typeof h2 ? h2 : function(t2) {
      return t2 !== h2;
    };
    if (!t$1(e2)) throw new TypeError("Invalid target");
    for (var a2, c2, g2 = document.scrollingElement || document.documentElement, p2 = [], m2 = e2; t$1(m2) && s2(m2); ) {
      if ((m2 = null == (c2 = (a2 = m2).parentElement) ? a2.getRootNode().host || null : c2) === g2) {
        p2.push(m2);
        break;
      }
      null != m2 && m2 === document.body && n$1(m2) && !n$1(document.documentElement) || null != m2 && n$1(m2, u2) && p2.push(m2);
    }
    for (var w2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, v2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b2 = e2.getBoundingClientRect(), y2 = b2.height, E2 = b2.width, M2 = b2.top, V2 = b2.right, x2 = b2.bottom, I2 = b2.left, C = "start" === d2 || "nearest" === d2 ? M2 : "end" === d2 ? x2 : M2 + y2 / 2, R2 = "center" === f2 ? I2 + E2 / 2 : "end" === f2 ? V2 : I2, T2 = [], k2 = 0; k2 < p2.length; k2++) {
      var B2 = p2[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j2 = D2.left;
      if ("if-needed" === l2 && M2 >= 0 && I2 >= 0 && x2 <= v2 && V2 <= w2 && M2 >= Y2 && x2 <= S2 && I2 >= j2 && V2 <= L2) return T2;
      var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F2 = parseInt(N2.borderBottomWidth, 10), G = 0, J2 = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z2 - F2 : 0, Q = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X / B2.offsetWidth : 0, U = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
      if (g2 === B2) G = "start" === d2 ? C : "end" === d2 ? C - v2 : "nearest" === d2 ? r$1(H, H + v2, v2, z2, F2, H + C, H + C + y2, y2) : C - v2 / 2, J2 = "start" === f2 ? R2 : "center" === f2 ? R2 - w2 / 2 : "end" === f2 ? R2 - w2 : r$1(W, W + w2, w2, q2, A2, W + R2, W + R2 + E2, E2), G = Math.max(0, G + H), J2 = Math.max(0, J2 + W);
      else {
        G = "start" === d2 ? C - Y2 - z2 : "end" === d2 ? C - S2 + F2 + P2 : "nearest" === d2 ? r$1(Y2, S2, O2, z2, F2 + P2, C, C + y2, y2) : C - (Y2 + O2 / 2) + P2 / 2, J2 = "start" === f2 ? R2 - j2 - q2 : "center" === f2 ? R2 - (j2 + X / 2) + K / 2 : "end" === f2 ? R2 - L2 + A2 + K : r$1(j2, L2, X, q2, A2 + K, R2, R2 + E2, E2);
        var Z = B2.scrollLeft, $2 = B2.scrollTop;
        C += $2 - (G = Math.max(0, Math.min($2 + G / U, B2.scrollHeight - O2 / U + P2))), R2 += Z - (J2 = Math.max(0, Math.min(Z + J2 / Q, B2.scrollWidth - X / Q + K)));
      }
      T2.push({ el: B2, top: G, left: J2 });
    }
    return T2;
  };
  function isOptionsObject(options2) {
    return options2 === Object(options2) && Object.keys(options2).length !== 0;
  }
  function defaultBehavior(actions2, behavior) {
    if (behavior === void 0) {
      behavior = "auto";
    }
    var canSmoothScroll = "scrollBehavior" in document.body.style;
    actions2.forEach(function(_ref) {
      var el = _ref.el, top = _ref.top, left = _ref.left;
      if (el.scroll && canSmoothScroll) {
        el.scroll({
          top,
          left,
          behavior
        });
      } else {
        el.scrollTop = top;
        el.scrollLeft = left;
      }
    });
  }
  function getOptions(options2) {
    if (options2 === false) {
      return {
        block: "end",
        inline: "nearest"
      };
    }
    if (isOptionsObject(options2)) {
      return options2;
    }
    return {
      block: "start",
      inline: "nearest"
    };
  }
  function scrollIntoView(target, options2) {
    var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
    if (isOptionsObject(options2) && typeof options2.behavior === "function") {
      return options2.behavior(isTargetAttached ? i$1(target, options2) : []);
    }
    if (!isTargetAttached) {
      return;
    }
    var computeOptions = getOptions(options2);
    return defaultBehavior(i$1(target, computeOptions), computeOptions.behavior);
  }
  function easeInOutCubic(t2, b2, c2, d2) {
    const cc = c2 - b2;
    t2 /= d2 / 2;
    if (t2 < 1) {
      return cc / 2 * t2 * t2 * t2 + b2;
    }
    return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
  }
  function isWindow$1(obj2) {
    return obj2 !== null && obj2 !== void 0 && obj2 === obj2.window;
  }
  function getScroll$1(target, top) {
    var _a2, _b2;
    if (typeof window === "undefined") {
      return 0;
    }
    const method = "scrollTop";
    let result = 0;
    if (isWindow$1(target)) {
      result = target["scrollY"];
    } else if (target instanceof Document) {
      result = target.documentElement[method];
    } else if (target instanceof HTMLElement) {
      result = target[method];
    } else if (target) {
      result = target[method];
    }
    if (target && !isWindow$1(target) && typeof result !== "number") {
      result = (_b2 = ((_a2 = target.ownerDocument) !== null && _a2 !== void 0 ? _a2 : target).documentElement) === null || _b2 === void 0 ? void 0 : _b2[method];
    }
    return result;
  }
  function scrollTo(y2) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      getContainer: getContainer2 = () => window,
      callback,
      duration = 450
    } = options2;
    const container = getContainer2();
    const scrollTop = getScroll$1(container);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time2 = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(time2 > duration ? duration : time2, scrollTop, y2, duration);
      if (isWindow$1(container)) {
        container.scrollTo(window.scrollX, nextScrollTop);
      } else if (container instanceof Document) {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time2 < duration) {
        wrapperRaf(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    wrapperRaf(frameFunc);
  }
  function e$1(e2, t2) {
    for (var n2 = 0; n2 < t2.length; n2++) {
      var r2 = t2[n2];
      r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
    }
  }
  function t(t2, n2, r2) {
    return r2 && e$1(t2, r2), t2;
  }
  function n() {
    return (n = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  function r(e2, t2) {
    e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
  }
  function i(e2, t2) {
    if (null == e2) return {};
    var n2, r2, i2 = {}, o2 = Object.keys(e2);
    for (r2 = 0; r2 < o2.length; r2++) t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
    return i2;
  }
  function o(e2) {
    return 1 == (null != (t2 = e2) && "object" == typeof t2 && false === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
    var t2;
  }
  var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
  function l(e2) {
    var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
    if (n2) {
      var r2 = n2.toString().match(c);
      return r2 ? r2[1] : "";
    }
    return "";
  }
  var s = function(e2) {
    var t2, n2;
    return false !== o(e2) && "function" == typeof (t2 = e2.constructor) && false !== o(n2 = t2.prototype) && false !== n2.hasOwnProperty("isPrototypeOf");
  }, v = function(e2) {
    return e2;
  }, y = v;
  var d = function(e2, t2) {
    return f.call(e2, t2);
  }, h = Number.isInteger || function(e2) {
    return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
  }, b = Array.isArray || function(e2) {
    return "[object Array]" === a.call(e2);
  }, O = function(e2) {
    return "[object Function]" === a.call(e2);
  }, g = function(e2) {
    return s(e2) && d(e2, "_vueTypes_name");
  }, m$1 = function(e2) {
    return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
      return d(e2, t2);
    }));
  };
  function j(e2, t2) {
    return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
  }
  function _(e2, t2, n2) {
    var r2;
    var i2 = true, o2 = "";
    r2 = s(e2) ? e2 : { type: e2 };
    var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
    if (m$1(r2) && null !== r2.type) {
      if (void 0 === r2.type || true === r2.type) return i2;
      if (!r2.required && void 0 === t2) return i2;
      b(r2.type) ? (i2 = r2.type.some(function(e3) {
        return true === _(e3, t2);
      }), o2 = r2.type.map(function(e3) {
        return l(e3);
      }).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
        if (null == e3) return "";
        var t3 = e3.constructor.toString().match(c);
        return t3 ? t3[1] : "";
      }(t2) === o2 : t2 instanceof r2.type;
    }
    if (!i2) {
      var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
      return a2;
    }
    if (d(r2, "validator") && O(r2.validator)) {
      var f2 = y, v2 = [];
      if (y = function(e3) {
        v2.push(e3);
      }, i2 = r2.validator(t2), y = f2, !i2) {
        var p2 = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
        return v2.length = 0, p2;
      }
    }
    return i2;
  }
  function T(e2, t2) {
    var n2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get: function() {
      return this.required = true, this;
    } }, def: { value: function(e3) {
      return void 0 !== e3 || this.default ? O(e3) || true === _(this, e3) ? (this.default = b(e3) ? function() {
        return [].concat(e3);
      } : s(e3) ? function() {
        return Object.assign({}, e3);
      } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
    } } }), r2 = n2.validator;
    return O(r2) && (n2.validator = j(r2, n2)), n2;
  }
  function w(e2, t2) {
    var n2 = T(e2, t2);
    return Object.defineProperty(n2, "validate", { value: function(e3) {
      return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
    } });
  }
  function k(e2, t2, n2) {
    var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
      o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
    }), Object.defineProperties({}, o2));
    if (u2._vueTypes_name = e2, !s(n2)) return u2;
    var a2, f2, c2 = n2.validator, l2 = i(n2, ["validator"]);
    if (O(c2)) {
      var v2 = u2.validator;
      v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
        return v2.call(this, e3) && c2.call(this, e3);
      } : c2, u2);
    }
    return Object.assign(u2, l2);
  }
  function P(e2) {
    return e2.replace(/^(?!\s*$)/gm, "  ");
  }
  var x = function() {
    return w("any", {});
  }, A = function() {
    return w("function", { type: Function });
  }, E = function() {
    return w("boolean", { type: Boolean });
  }, N = function() {
    return w("string", { type: String });
  }, q = function() {
    return w("number", { type: Number });
  }, S = function() {
    return w("array", { type: Array });
  }, V = function() {
    return w("object", { type: Object });
  }, F = function() {
    return T("integer", { type: Number, validator: function(e2) {
      return h(e2);
    } });
  }, D = function() {
    return T("symbol", { validator: function(e2) {
      return "symbol" == typeof e2;
    } });
  };
  function L(e2, t2) {
    if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2) throw new TypeError("[VueTypes error]: You must provide a function as argument");
    return T(e2.name || "<<anonymous function>>", { validator: function(n2) {
      var r2 = e2(n2);
      return r2 || y(this._vueTypes_name + " - " + t2), r2;
    } });
  }
  function Y(e2) {
    if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
    var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
      if (null != t3) {
        var n3 = t3.constructor;
        -1 === e3.indexOf(n3) && e3.push(n3);
      }
      return e3;
    }, []);
    return T("oneOf", { type: n2.length > 0 ? n2 : void 0, validator: function(n3) {
      var r2 = -1 !== e2.indexOf(n3);
      return r2 || y(t2), r2;
    } });
  }
  function B(e2) {
    if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
    for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
      var i2 = e2[r2];
      if (m$1(i2)) {
        if (g(i2) && "oneOf" === i2._vueTypes_name) {
          n2 = n2.concat(i2.type);
          continue;
        }
        if (O(i2.validator) && (t2 = true), true !== i2.type && i2.type) {
          n2 = n2.concat(i2.type);
          continue;
        }
      }
      n2.push(i2);
    }
    return n2 = n2.filter(function(e3, t3) {
      return n2.indexOf(e3) === t3;
    }), T("oneOfType", t2 ? { type: n2, validator: function(t3) {
      var n3 = [], r3 = e2.some(function(e3) {
        var r4 = _(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3);
        return "string" == typeof r4 && n3.push(r4), true === r4;
      });
      return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
    } } : { type: n2 });
  }
  function I(e2) {
    return T("arrayOf", { type: Array, validator: function(t2) {
      var n2, r2 = t2.every(function(t3) {
        return true === (n2 = _(e2, t3));
      });
      return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
    } });
  }
  function J(e2) {
    return T("instanceOf", { type: e2 });
  }
  function M(e2) {
    return T("objectOf", { type: Object, validator: function(t2) {
      var n2, r2 = Object.keys(t2).every(function(r3) {
        return true === (n2 = _(e2, t2[r3]));
      });
      return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
    } });
  }
  function R(e2) {
    var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
      var n3;
      return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
    }), r2 = T("shape", { type: Object, validator: function(r3) {
      var i2 = this;
      if (!s(r3)) return false;
      var o2 = Object.keys(r3);
      if (n2.length > 0 && n2.some(function(e3) {
        return -1 === o2.indexOf(e3);
      })) {
        var u2 = n2.filter(function(e3) {
          return -1 === o2.indexOf(e3);
        });
        return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
      }
      return o2.every(function(n3) {
        if (-1 === t2.indexOf(n3)) return true === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
        var o3 = _(e2[n3], r3[n3]);
        return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), true === o3;
      });
    } });
    return Object.defineProperty(r2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(r2, "loose", { get: function() {
      return this._vueTypes_isLoose = true, this;
    } }), r2;
  }
  var $ = function() {
    function e2() {
    }
    return e2.extend = function(e3) {
      var t2 = this;
      if (b(e3)) return e3.forEach(function(e4) {
        return t2.extend(e4);
      }), this;
      var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i(e3, ["name", "validate", "getter"]);
      if (d(this, n2)) throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
      var c2, l2 = f2.type;
      return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? { get: function() {
        return k(n2, l2, f2);
      } } : { value: function() {
        var e4, t3 = k(n2, l2, f2);
        return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
      } })) : (c2 = a2 ? { get: function() {
        var e4 = Object.assign({}, f2);
        return o2 ? w(n2, e4) : T(n2, e4);
      }, enumerable: true } : { value: function() {
        var e4, t3, r3 = Object.assign({}, f2);
        return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
      }, enumerable: true }, Object.defineProperty(this, n2, c2));
    }, t(e2, null, [{ key: "any", get: function() {
      return x();
    } }, { key: "func", get: function() {
      return A().def(this.defaults.func);
    } }, { key: "bool", get: function() {
      return E().def(this.defaults.bool);
    } }, { key: "string", get: function() {
      return N().def(this.defaults.string);
    } }, { key: "number", get: function() {
      return q().def(this.defaults.number);
    } }, { key: "array", get: function() {
      return S().def(this.defaults.array);
    } }, { key: "object", get: function() {
      return V().def(this.defaults.object);
    } }, { key: "integer", get: function() {
      return F().def(this.defaults.integer);
    } }, { key: "symbol", get: function() {
      return D();
    } }]), e2;
  }();
  function z(e2) {
    var i2;
    return void 0 === e2 && (e2 = { func: function() {
    }, bool: true, string: "", number: 0, array: function() {
      return [];
    }, object: function() {
      return {};
    }, integer: 0 }), (i2 = function(i3) {
      function o2() {
        return i3.apply(this, arguments) || this;
      }
      return r(o2, i3), t(o2, null, [{ key: "sensibleDefaults", get: function() {
        return n({}, this.defaults);
      }, set: function(t2) {
        this.defaults = false !== t2 ? n({}, true !== t2 ? t2 : e2) : {};
      } }]), o2;
    }($)).defaults = n({}, e2), i2;
  }
  $.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = { validate: function(e2, t2) {
    return true === _(t2, e2);
  }, toType: function(e2, t2, n2) {
    return void 0 === n2 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
  } };
  (function(e2) {
    function t2() {
      return e2.apply(this, arguments) || this;
    }
    return r(t2, e2), t2;
  })(z());
  const PropTypes = z({
    func: void 0,
    bool: void 0,
    string: void 0,
    number: void 0,
    array: void 0,
    object: void 0,
    integer: void 0
  });
  PropTypes.extend([{
    name: "looseBool",
    getter: true,
    type: Boolean,
    default: void 0
  }, {
    name: "style",
    getter: true,
    type: [String, Object],
    default: void 0
  }, {
    name: "VueNode",
    getter: true,
    type: null
  }]);
  const devWarning = (valid, component, message) => {
    warningOnce(valid, `[ant-design-vue: ${component}] ${message}`);
  };
  function getKey$2(data, index2) {
    const {
      key: key2
    } = data;
    let value;
    if ("value" in data) {
      ({
        value
      } = data);
    }
    if (key2 !== null && key2 !== void 0) {
      return key2;
    }
    if (value !== void 0) {
      return value;
    }
    return `rc-index-key-${index2}`;
  }
  function fillFieldNames$1(fieldNames, childrenAsData) {
    const {
      label,
      value,
      options: options2
    } = fieldNames || {};
    return {
      label: label || (childrenAsData ? "children" : "label"),
      value: value || "value",
      options: options2 || "options"
    };
  }
  function flattenOptions(options2) {
    let {
      fieldNames,
      childrenAsData
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const flattenList = [];
    const {
      label: fieldLabel,
      value: fieldValue,
      options: fieldOptions
    } = fillFieldNames$1(fieldNames, false);
    function dig(list2, isGroupOption) {
      list2.forEach((data) => {
        const label = data[fieldLabel];
        if (isGroupOption || !(fieldOptions in data)) {
          const value = data[fieldValue];
          flattenList.push({
            key: getKey$2(data, flattenList.length),
            groupOption: isGroupOption,
            data,
            label,
            value
          });
        } else {
          let grpLabel = label;
          if (grpLabel === void 0 && childrenAsData) {
            grpLabel = data.label;
          }
          flattenList.push({
            key: getKey$2(data, flattenList.length),
            group: true,
            data,
            label: grpLabel
          });
          dig(data[fieldOptions], true);
        }
      });
    }
    dig(options2, false);
    return flattenList;
  }
  function injectPropsWithOption(option) {
    const newOption = _extends$1({}, option);
    if (!("props" in newOption)) {
      Object.defineProperty(newOption, "props", {
        get() {
          return newOption;
        }
      });
    }
    return newOption;
  }
  function getSeparatedContent(text, tokens) {
    if (!tokens || !tokens.length) {
      return null;
    }
    let match2 = false;
    function separate(str, _ref) {
      let [token2, ...restTokens] = _ref;
      if (!token2) {
        return [str];
      }
      const list3 = str.split(token2);
      match2 = match2 || list3.length > 1;
      return list3.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter((unit) => unit);
    }
    const list2 = separate(text, tokens);
    return match2 ? list2 : null;
  }
  function returnEmptyString() {
    return "";
  }
  function returnDocument(element) {
    if (element) {
      return element.ownerDocument;
    }
    return window.document;
  }
  function noop$5() {
  }
  const triggerProps = () => ({
    action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def([]),
    showAction: PropTypes.any.def([]),
    hideAction: PropTypes.any.def([]),
    getPopupClassNameFromAlign: PropTypes.any.def(returnEmptyString),
    onPopupVisibleChange: Function,
    afterPopupVisibleChange: PropTypes.func.def(noop$5),
    popup: PropTypes.any,
    arrow: PropTypes.bool.def(true),
    popupStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: PropTypes.string.def("rc-trigger-popup"),
    popupClassName: PropTypes.string.def(""),
    popupPlacement: String,
    builtinPlacements: PropTypes.object,
    popupTransitionName: String,
    popupAnimation: PropTypes.any,
    mouseEnterDelay: PropTypes.number.def(0),
    mouseLeaveDelay: PropTypes.number.def(0.1),
    zIndex: Number,
    focusDelay: PropTypes.number.def(0),
    blurDelay: PropTypes.number.def(0.15),
    getPopupContainer: Function,
    getDocument: PropTypes.func.def(returnDocument),
    forceRender: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: false
    },
    mask: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    // onPopupAlign: PropTypes.func.def(noop),
    popupAlign: PropTypes.object.def(() => ({})),
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    maskTransitionName: String,
    maskAnimation: String,
    stretch: String,
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    autoDestroy: {
      type: Boolean,
      default: false
    },
    mobile: Object,
    getTriggerDOMNode: Function
  });
  const innerProps = {
    visible: Boolean,
    prefixCls: String,
    zIndex: Number,
    destroyPopupOnHide: Boolean,
    forceRender: Boolean,
    arrow: {
      type: Boolean,
      default: true
    },
    // Legacy Motion
    animation: [String, Object],
    transitionName: String,
    // Measure
    stretch: {
      type: String
    },
    // Align
    align: {
      type: Object
    },
    point: {
      type: Object
    },
    getRootDomNode: {
      type: Function
    },
    getClassNameFromAlign: {
      type: Function
    },
    onAlign: {
      type: Function
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    },
    onTouchstart: {
      type: Function
    }
  };
  const mobileProps = _extends$1(_extends$1({}, innerProps), {
    mobile: {
      type: Object
    }
  });
  const popupProps = _extends$1(_extends$1({}, innerProps), {
    mask: Boolean,
    mobile: {
      type: Object
    },
    maskAnimation: String,
    maskTransitionName: String
  });
  function getMotion$1(_ref) {
    let {
      prefixCls,
      animation,
      transitionName: transitionName2
    } = _ref;
    if (animation) {
      return {
        name: `${prefixCls}-${animation}`
      };
    }
    if (transitionName2) {
      return {
        name: transitionName2
      };
    }
    return {};
  }
  function Mask(props2) {
    const {
      prefixCls,
      visible,
      zIndex,
      mask,
      maskAnimation,
      maskTransitionName
    } = props2;
    if (!mask) {
      return null;
    }
    let motion = {};
    if (maskTransitionName || maskAnimation) {
      motion = getMotion$1({
        prefixCls,
        transitionName: maskTransitionName,
        animation: maskAnimation
      });
    }
    return createVNode(Transition, _objectSpread2$1({
      "appear": true
    }, motion), {
      default: () => [withDirectives(createVNode("div", {
        "style": {
          zIndex
        },
        "class": `${prefixCls}-mask`
      }, null), [[resolveDirective("if"), visible]])]
    });
  }
  Mask.displayName = "Mask";
  const MobilePopupInner = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "MobilePopupInner",
    inheritAttrs: false,
    props: mobileProps,
    emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
    setup(props2, _ref) {
      let {
        expose,
        slots
      } = _ref;
      const elementRef = ref();
      expose({
        forceAlign: () => {
        },
        getElement: () => elementRef.value
      });
      return () => {
        var _a2;
        const {
          zIndex,
          visible,
          prefixCls,
          mobile: {
            popupClassName,
            popupStyle,
            popupMotion = {},
            popupRender
          } = {}
        } = props2;
        const mergedStyle = _extends$1({
          zIndex
        }, popupStyle);
        let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        if (childNode.length > 1) {
          childNode = createVNode("div", {
            "class": `${prefixCls}-content`
          }, [childNode]);
        }
        if (popupRender) {
          childNode = popupRender(childNode);
        }
        const mergedClassName = classNames(prefixCls, popupClassName);
        return createVNode(Transition, _objectSpread2$1({
          "ref": elementRef
        }, popupMotion), {
          default: () => [visible ? createVNode("div", {
            "class": mergedClassName,
            "style": mergedStyle
          }, [childNode]) : null]
        });
      };
    }
  });
  var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const StatusQueue = ["measure", "align", null, "motion"];
  const useVisibleStatus = (visible, doMeasure) => {
    const status = shallowRef(null);
    const rafRef = shallowRef();
    const destroyRef = shallowRef(false);
    function setStatus(nextStatus) {
      if (!destroyRef.value) {
        status.value = nextStatus;
      }
    }
    function cancelRaf() {
      wrapperRaf.cancel(rafRef.value);
    }
    function goNextStatus(callback) {
      cancelRaf();
      rafRef.value = wrapperRaf(() => {
        let newStatus = status.value;
        switch (status.value) {
          case "align":
            newStatus = "motion";
            break;
          case "motion":
            newStatus = "stable";
            break;
        }
        setStatus(newStatus);
        callback === null || callback === void 0 ? void 0 : callback();
      });
    }
    watch(visible, () => {
      setStatus("measure");
    }, {
      immediate: true,
      flush: "post"
    });
    onMounted(() => {
      watch(status, () => {
        switch (status.value) {
          case "measure":
            doMeasure();
            break;
        }
        if (status.value) {
          rafRef.value = wrapperRaf(() => __awaiter$1(void 0, void 0, void 0, function* () {
            const index2 = StatusQueue.indexOf(status.value);
            const nextStatus = StatusQueue[index2 + 1];
            if (nextStatus && index2 !== -1) {
              setStatus(nextStatus);
            }
          }));
        }
      }, {
        immediate: true,
        flush: "post"
      });
    });
    onBeforeUnmount(() => {
      destroyRef.value = true;
      cancelRaf();
    });
    return [status, goNextStatus];
  };
  const useStretchStyle = (stretch) => {
    const targetSize = shallowRef({
      width: 0,
      height: 0
    });
    function measureStretch(element) {
      targetSize.value = {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
    }
    const style = computed(() => {
      const sizeStyle = {};
      if (stretch.value) {
        const {
          width,
          height
        } = targetSize.value;
        if (stretch.value.indexOf("height") !== -1 && height) {
          sizeStyle.height = `${height}px`;
        } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
          sizeStyle.minHeight = `${height}px`;
        }
        if (stretch.value.indexOf("width") !== -1 && width) {
          sizeStyle.width = `${width}px`;
        } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
          sizeStyle.minWidth = `${width}px`;
        }
      }
      return sizeStyle;
    });
    return [style, measureStretch];
  };
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$y(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _typeof(obj2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj3) {
      return typeof obj3;
    } : function(obj3) {
      return obj3 && "function" == typeof Symbol && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    }, _typeof(obj2);
  }
  function _defineProperty$y(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var vendorPrefix;
  var jsCssMap = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    // IE did it wrong again ...
    ms: "-ms-",
    O: "-o-"
  };
  function getVendorPrefix() {
    if (vendorPrefix !== void 0) {
      return vendorPrefix;
    }
    vendorPrefix = "";
    var style = document.createElement("p").style;
    var testProp = "Transform";
    for (var key2 in jsCssMap) {
      if (key2 + testProp in style) {
        vendorPrefix = key2;
      }
    }
    return vendorPrefix;
  }
  function getTransitionName$1() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
  }
  function getTransformName() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
  }
  function setTransitionProperty(node2, value) {
    var name = getTransitionName$1();
    if (name) {
      node2.style[name] = value;
      if (name !== "transitionProperty") {
        node2.style.transitionProperty = value;
      }
    }
  }
  function setTransform(node2, value) {
    var name = getTransformName();
    if (name) {
      node2.style[name] = value;
      if (name !== "transform") {
        node2.style.transform = value;
      }
    }
  }
  function getTransitionProperty(node2) {
    return node2.style.transitionProperty || node2.style[getTransitionName$1()];
  }
  function getTransformXY(node2) {
    var style = window.getComputedStyle(node2, null);
    var transform2 = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
    if (transform2 && transform2 !== "none") {
      var matrix2 = transform2.replace(/[^0-9\-.,]/g, "").split(",");
      return {
        x: parseFloat(matrix2[12] || matrix2[4], 0),
        y: parseFloat(matrix2[13] || matrix2[5], 0)
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  var matrix2d = /matrix\((.*)\)/;
  var matrix3d = /matrix3d\((.*)\)/;
  function setTransformXY(node2, xy) {
    var style = window.getComputedStyle(node2, null);
    var transform2 = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
    if (transform2 && transform2 !== "none") {
      var arr;
      var match2d = transform2.match(matrix2d);
      if (match2d) {
        match2d = match2d[1];
        arr = match2d.split(",").map(function(item) {
          return parseFloat(item, 10);
        });
        arr[4] = xy.x;
        arr[5] = xy.y;
        setTransform(node2, "matrix(".concat(arr.join(","), ")"));
      } else {
        var match3d = transform2.match(matrix3d)[1];
        arr = match3d.split(",").map(function(item) {
          return parseFloat(item, 10);
        });
        arr[12] = xy.x;
        arr[13] = xy.y;
        setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
      }
    } else {
      setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
    }
  }
  var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
  var getComputedStyleX;
  function forceRelayout(elem) {
    var originalStyle = elem.style.display;
    elem.style.display = "none";
    elem.offsetHeight;
    elem.style.display = originalStyle;
  }
  function css(el, name, v2) {
    var value = v2;
    if (_typeof(name) === "object") {
      for (var i2 in name) {
        if (name.hasOwnProperty(i2)) {
          css(el, i2, name[i2]);
        }
      }
      return void 0;
    }
    if (typeof value !== "undefined") {
      if (typeof value === "number") {
        value = "".concat(value, "px");
      }
      el.style[name] = value;
      return void 0;
    }
    return getComputedStyleX(el, name);
  }
  function getClientPosition(elem) {
    var box2;
    var x2;
    var y2;
    var doc2 = elem.ownerDocument;
    var body = doc2.body;
    var docElem = doc2 && doc2.documentElement;
    box2 = elem.getBoundingClientRect();
    x2 = Math.floor(box2.left);
    y2 = Math.floor(box2.top);
    x2 -= docElem.clientLeft || body.clientLeft || 0;
    y2 -= docElem.clientTop || body.clientTop || 0;
    return {
      left: x2,
      top: y2
    };
  }
  function getScroll(w2, top) {
    var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
    var method = "scroll".concat(top ? "Top" : "Left");
    if (typeof ret !== "number") {
      var d2 = w2.document;
      ret = d2.documentElement[method];
      if (typeof ret !== "number") {
        ret = d2.body[method];
      }
    }
    return ret;
  }
  function getScrollLeft(w2) {
    return getScroll(w2);
  }
  function getScrollTop(w2) {
    return getScroll(w2, true);
  }
  function getOffset$2(el) {
    var pos = getClientPosition(el);
    var doc2 = el.ownerDocument;
    var w2 = doc2.defaultView || doc2.parentWindow;
    pos.left += getScrollLeft(w2);
    pos.top += getScrollTop(w2);
    return pos;
  }
  function isWindow(obj2) {
    return obj2 !== null && obj2 !== void 0 && obj2 == obj2.window;
  }
  function getDocument(node2) {
    if (isWindow(node2)) {
      return node2.document;
    }
    if (node2.nodeType === 9) {
      return node2;
    }
    return node2.ownerDocument;
  }
  function _getComputedStyle(elem, name, cs) {
    var computedStyle = cs;
    var val = "";
    var d2 = getDocument(elem);
    computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
    if (computedStyle) {
      val = computedStyle.getPropertyValue(name) || computedStyle[name];
    }
    return val;
  }
  var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
  var RE_POS = /^(top|right|bottom|left)$/;
  var CURRENT_STYLE = "currentStyle";
  var RUNTIME_STYLE = "runtimeStyle";
  var LEFT = "left";
  var PX = "px";
  function _getComputedStyleIE(elem, name) {
    var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
    if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
      var style = elem.style;
      var left = style[LEFT];
      var rsLeft = elem[RUNTIME_STYLE][LEFT];
      elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
      style[LEFT] = name === "fontSize" ? "1em" : ret || 0;
      ret = style.pixelLeft + PX;
      style[LEFT] = left;
      elem[RUNTIME_STYLE][LEFT] = rsLeft;
    }
    return ret === "" ? "auto" : ret;
  }
  if (typeof window !== "undefined") {
    getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
  }
  function getOffsetDirection(dir3, option) {
    if (dir3 === "left") {
      return option.useCssRight ? "right" : dir3;
    }
    return option.useCssBottom ? "bottom" : dir3;
  }
  function oppositeOffsetDirection(dir3) {
    if (dir3 === "left") {
      return "right";
    } else if (dir3 === "right") {
      return "left";
    } else if (dir3 === "top") {
      return "bottom";
    } else if (dir3 === "bottom") {
      return "top";
    }
  }
  function setLeftTop(elem, offset2, option) {
    if (css(elem, "position") === "static") {
      elem.style.position = "relative";
    }
    var presetH = -999;
    var presetV = -999;
    var horizontalProperty = getOffsetDirection("left", option);
    var verticalProperty = getOffsetDirection("top", option);
    var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
    var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
    if (horizontalProperty !== "left") {
      presetH = 999;
    }
    if (verticalProperty !== "top") {
      presetV = 999;
    }
    var originalTransition = "";
    var originalOffset = getOffset$2(elem);
    if ("left" in offset2 || "top" in offset2) {
      originalTransition = getTransitionProperty(elem) || "";
      setTransitionProperty(elem, "none");
    }
    if ("left" in offset2) {
      elem.style[oppositeHorizontalProperty] = "";
      elem.style[horizontalProperty] = "".concat(presetH, "px");
    }
    if ("top" in offset2) {
      elem.style[oppositeVerticalProperty] = "";
      elem.style[verticalProperty] = "".concat(presetV, "px");
    }
    forceRelayout(elem);
    var old = getOffset$2(elem);
    var originalStyle = {};
    for (var key2 in offset2) {
      if (offset2.hasOwnProperty(key2)) {
        var dir3 = getOffsetDirection(key2, option);
        var preset = key2 === "left" ? presetH : presetV;
        var off = originalOffset[key2] - old[key2];
        if (dir3 === key2) {
          originalStyle[dir3] = preset + off;
        } else {
          originalStyle[dir3] = preset - off;
        }
      }
    }
    css(elem, originalStyle);
    forceRelayout(elem);
    if ("left" in offset2 || "top" in offset2) {
      setTransitionProperty(elem, originalTransition);
    }
    var ret = {};
    for (var _key in offset2) {
      if (offset2.hasOwnProperty(_key)) {
        var _dir = getOffsetDirection(_key, option);
        var _off = offset2[_key] - originalOffset[_key];
        if (_key === _dir) {
          ret[_dir] = originalStyle[_dir] + _off;
        } else {
          ret[_dir] = originalStyle[_dir] - _off;
        }
      }
    }
    css(elem, ret);
  }
  function setTransform$1(elem, offset2) {
    var originalOffset = getOffset$2(elem);
    var originalXY = getTransformXY(elem);
    var resultXY = {
      x: originalXY.x,
      y: originalXY.y
    };
    if ("left" in offset2) {
      resultXY.x = originalXY.x + offset2.left - originalOffset.left;
    }
    if ("top" in offset2) {
      resultXY.y = originalXY.y + offset2.top - originalOffset.top;
    }
    setTransformXY(elem, resultXY);
  }
  function setOffset(elem, offset2, option) {
    if (option.ignoreShake) {
      var oriOffset = getOffset$2(elem);
      var oLeft = oriOffset.left.toFixed(0);
      var oTop = oriOffset.top.toFixed(0);
      var tLeft = offset2.left.toFixed(0);
      var tTop = offset2.top.toFixed(0);
      if (oLeft === tLeft && oTop === tTop) {
        return;
      }
    }
    if (option.useCssRight || option.useCssBottom) {
      setLeftTop(elem, offset2, option);
    } else if (option.useCssTransform && getTransformName() in document.body.style) {
      setTransform$1(elem, offset2);
    } else {
      setLeftTop(elem, offset2, option);
    }
  }
  function each$5(arr, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      fn(arr[i2]);
    }
  }
  function isBorderBoxFn(elem) {
    return getComputedStyleX(elem, "boxSizing") === "border-box";
  }
  var BOX_MODELS = ["margin", "border", "padding"];
  var CONTENT_INDEX = -1;
  var PADDING_INDEX = 2;
  var BORDER_INDEX = 1;
  var MARGIN_INDEX = 0;
  function swap(elem, options2, callback) {
    var old = {};
    var style = elem.style;
    var name;
    for (name in options2) {
      if (options2.hasOwnProperty(name)) {
        old[name] = style[name];
        style[name] = options2[name];
      }
    }
    callback.call(elem);
    for (name in options2) {
      if (options2.hasOwnProperty(name)) {
        style[name] = old[name];
      }
    }
  }
  function getPBMWidth(elem, props2, which) {
    var value = 0;
    var prop;
    var j2;
    var i2;
    for (j2 = 0; j2 < props2.length; j2++) {
      prop = props2[j2];
      if (prop) {
        for (i2 = 0; i2 < which.length; i2++) {
          var cssProp = void 0;
          if (prop === "border") {
            cssProp = "".concat(prop).concat(which[i2], "Width");
          } else {
            cssProp = prop + which[i2];
          }
          value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
        }
      }
    }
    return value;
  }
  var domUtils = {
    getParent: function getParent2(element) {
      var parent2 = element;
      do {
        if (parent2.nodeType === 11 && parent2.host) {
          parent2 = parent2.host;
        } else {
          parent2 = parent2.parentNode;
        }
      } while (parent2 && parent2.nodeType !== 1 && parent2.nodeType !== 9);
      return parent2;
    }
  };
  each$5(["Width", "Height"], function(name) {
    domUtils["doc".concat(name)] = function(refWin) {
      var d2 = refWin.document;
      return Math.max(
        // firefox chrome documentElement.scrollHeight< body.scrollHeight
        // ie standard mode : documentElement.scrollHeight> body.scrollHeight
        d2.documentElement["scroll".concat(name)],
        // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
        d2.body["scroll".concat(name)],
        domUtils["viewport".concat(name)](d2)
      );
    };
    domUtils["viewport".concat(name)] = function(win) {
      var prop = "client".concat(name);
      var doc2 = win.document;
      var body = doc2.body;
      var documentElement = doc2.documentElement;
      var documentElementProp = documentElement[prop];
      return doc2.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
    };
  });
  function getWH(elem, name, ex) {
    var extra = ex;
    if (isWindow(elem)) {
      return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
    }
    var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
    var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
    var isBorderBox = isBorderBoxFn(elem);
    var cssBoxValue = 0;
    if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
      borderBoxValue = void 0;
      cssBoxValue = getComputedStyleX(elem, name);
      if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name] || 0;
      }
      cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
    }
    if (extra === void 0) {
      extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth(elem, ["border", "padding"], which);
      }
      return cssBoxValue;
    } else if (borderBoxValueOrIsBorderBox) {
      if (extra === BORDER_INDEX) {
        return val;
      }
      return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
    }
    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
  }
  var cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  };
  function getWHIgnoreDisplay() {
    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var val;
    var elem = args[0];
    if (elem.offsetWidth !== 0) {
      val = getWH.apply(void 0, args);
    } else {
      swap(elem, cssShow, function() {
        val = getWH.apply(void 0, args);
      });
    }
    return val;
  }
  each$5(["width", "height"], function(name) {
    var first = name.charAt(0).toUpperCase() + name.slice(1);
    domUtils["outer".concat(first)] = function(el, includeMargin) {
      return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
    };
    var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
    domUtils[name] = function(elem, v2) {
      var val = v2;
      if (val !== void 0) {
        if (elem) {
          var isBorderBox = isBorderBoxFn(elem);
          if (isBorderBox) {
            val += getPBMWidth(elem, ["padding", "border"], which);
          }
          return css(elem, name, val);
        }
        return void 0;
      }
      return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
    };
  });
  function mix(to, from2) {
    for (var i2 in from2) {
      if (from2.hasOwnProperty(i2)) {
        to[i2] = from2[i2];
      }
    }
    return to;
  }
  var utils$2 = {
    getWindow: function getWindow(node2) {
      if (node2 && node2.document && node2.setTimeout) {
        return node2;
      }
      var doc2 = node2.ownerDocument || node2;
      return doc2.defaultView || doc2.parentWindow;
    },
    getDocument,
    offset: function offset2(el, value, option) {
      if (typeof value !== "undefined") {
        setOffset(el, value, option || {});
      } else {
        return getOffset$2(el);
      }
    },
    isWindow,
    each: each$5,
    css,
    clone: function clone2(obj2) {
      var i2;
      var ret = {};
      for (i2 in obj2) {
        if (obj2.hasOwnProperty(i2)) {
          ret[i2] = obj2[i2];
        }
      }
      var overflow = obj2.overflow;
      if (overflow) {
        for (i2 in obj2) {
          if (obj2.hasOwnProperty(i2)) {
            ret.overflow[i2] = obj2.overflow[i2];
          }
        }
      }
      return ret;
    },
    mix,
    getWindowScrollLeft: function getWindowScrollLeft(w2) {
      return getScrollLeft(w2);
    },
    getWindowScrollTop: function getWindowScrollTop(w2) {
      return getScrollTop(w2);
    },
    merge: function merge2() {
      var ret = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        utils$2.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
      }
      return ret;
    },
    viewportWidth: 0,
    viewportHeight: 0
  };
  mix(utils$2, domUtils);
  var getParent$1 = utils$2.getParent;
  function getOffsetParent(element) {
    if (utils$2.isWindow(element) || element.nodeType === 9) {
      return null;
    }
    var doc2 = utils$2.getDocument(element);
    var body = doc2.body;
    var parent2;
    var positionStyle = utils$2.css(element, "position");
    var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
    if (!skipStatic) {
      return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
    }
    for (parent2 = getParent$1(element); parent2 && parent2 !== body && parent2.nodeType !== 9; parent2 = getParent$1(parent2)) {
      positionStyle = utils$2.css(parent2, "position");
      if (positionStyle !== "static") {
        return parent2;
      }
    }
    return null;
  }
  var getParent$1$1 = utils$2.getParent;
  function isAncestorFixed(element) {
    if (utils$2.isWindow(element) || element.nodeType === 9) {
      return false;
    }
    var doc2 = utils$2.getDocument(element);
    var body = doc2.body;
    var parent2 = null;
    for (
      parent2 = getParent$1$1(element);
      // 修复元素位于 document.documentElement 下导致崩溃问题
      parent2 && parent2 !== body && parent2 !== doc2;
      parent2 = getParent$1$1(parent2)
    ) {
      var positionStyle = utils$2.css(parent2, "position");
      if (positionStyle === "fixed") {
        return true;
      }
    }
    return false;
  }
  function getVisibleRectForElement(element, alwaysByViewport) {
    var visibleRect = {
      left: 0,
      right: Infinity,
      top: 0,
      bottom: Infinity
    };
    var el = getOffsetParent(element);
    var doc2 = utils$2.getDocument(element);
    var win = doc2.defaultView || doc2.parentWindow;
    var body = doc2.body;
    var documentElement = doc2.documentElement;
    while (el) {
      if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
      // viewport. In some browsers, el.offsetParent may be
      // document.documentElement, so check for that too.
      el !== body && el !== documentElement && utils$2.css(el, "overflow") !== "visible") {
        var pos = utils$2.offset(el);
        pos.left += el.clientLeft;
        pos.top += el.clientTop;
        visibleRect.top = Math.max(visibleRect.top, pos.top);
        visibleRect.right = Math.min(
          visibleRect.right,
          // consider area without scrollBar
          pos.left + el.clientWidth
        );
        visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
        visibleRect.left = Math.max(visibleRect.left, pos.left);
      } else if (el === body || el === documentElement) {
        break;
      }
      el = getOffsetParent(el);
    }
    var originalPosition = null;
    if (!utils$2.isWindow(element) && element.nodeType !== 9) {
      originalPosition = element.style.position;
      var position2 = utils$2.css(element, "position");
      if (position2 === "absolute") {
        element.style.position = "fixed";
      }
    }
    var scrollX = utils$2.getWindowScrollLeft(win);
    var scrollY = utils$2.getWindowScrollTop(win);
    var viewportWidth = utils$2.viewportWidth(win);
    var viewportHeight = utils$2.viewportHeight(win);
    var documentWidth = documentElement.scrollWidth;
    var documentHeight = documentElement.scrollHeight;
    var bodyStyle = window.getComputedStyle(body);
    if (bodyStyle.overflowX === "hidden") {
      documentWidth = win.innerWidth;
    }
    if (bodyStyle.overflowY === "hidden") {
      documentHeight = win.innerHeight;
    }
    if (element.style) {
      element.style.position = originalPosition;
    }
    if (alwaysByViewport || isAncestorFixed(element)) {
      visibleRect.left = Math.max(visibleRect.left, scrollX);
      visibleRect.top = Math.max(visibleRect.top, scrollY);
      visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
    } else {
      var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
      visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
      var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
      visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
    }
    return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
  }
  function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
    var pos = utils$2.clone(elFuturePos);
    var size = {
      width: elRegion.width,
      height: elRegion.height
    };
    if (overflow.adjustX && pos.left < visibleRect.left) {
      pos.left = visibleRect.left;
    }
    if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
      size.width -= pos.left + size.width - visibleRect.right;
    }
    if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
      pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
    }
    if (overflow.adjustY && pos.top < visibleRect.top) {
      pos.top = visibleRect.top;
    }
    if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
      size.height -= pos.top + size.height - visibleRect.bottom;
    }
    if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
      pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
    }
    return utils$2.mix(pos, size);
  }
  function getRegion(node2) {
    var offset2;
    var w2;
    var h2;
    if (!utils$2.isWindow(node2) && node2.nodeType !== 9) {
      offset2 = utils$2.offset(node2);
      w2 = utils$2.outerWidth(node2);
      h2 = utils$2.outerHeight(node2);
    } else {
      var win = utils$2.getWindow(node2);
      offset2 = {
        left: utils$2.getWindowScrollLeft(win),
        top: utils$2.getWindowScrollTop(win)
      };
      w2 = utils$2.viewportWidth(win);
      h2 = utils$2.viewportHeight(win);
    }
    offset2.width = w2;
    offset2.height = h2;
    return offset2;
  }
  function getAlignOffset(region, align) {
    var V2 = align.charAt(0);
    var H = align.charAt(1);
    var w2 = region.width;
    var h2 = region.height;
    var x2 = region.left;
    var y2 = region.top;
    if (V2 === "c") {
      y2 += h2 / 2;
    } else if (V2 === "b") {
      y2 += h2;
    }
    if (H === "c") {
      x2 += w2 / 2;
    } else if (H === "r") {
      x2 += w2;
    }
    return {
      left: x2,
      top: y2
    };
  }
  function getElFuturePos(elRegion, refNodeRegion, points2, offset2, targetOffset2) {
    var p1 = getAlignOffset(refNodeRegion, points2[1]);
    var p2 = getAlignOffset(elRegion, points2[0]);
    var diff = [p2.left - p1.left, p2.top - p1.top];
    return {
      left: Math.round(elRegion.left - diff[0] + offset2[0] - targetOffset2[0]),
      top: Math.round(elRegion.top - diff[1] + offset2[1] - targetOffset2[1])
    };
  }
  function isFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
  }
  function isFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
  }
  function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
  }
  function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
  }
  function flip(points2, reg, map2) {
    var ret = [];
    utils$2.each(points2, function(p2) {
      ret.push(p2.replace(reg, function(m2) {
        return map2[m2];
      }));
    });
    return ret;
  }
  function flipOffset(offset2, index2) {
    offset2[index2] = -offset2[index2];
    return offset2;
  }
  function convertOffset(str, offsetLen) {
    var n2;
    if (/%$/.test(str)) {
      n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
    } else {
      n2 = parseInt(str, 10);
    }
    return n2 || 0;
  }
  function normalizeOffset(offset2, el) {
    offset2[0] = convertOffset(offset2[0], el.width);
    offset2[1] = convertOffset(offset2[1], el.height);
  }
  function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
    var points2 = align.points;
    var offset2 = align.offset || [0, 0];
    var targetOffset2 = align.targetOffset || [0, 0];
    var overflow = align.overflow;
    var source = align.source || el;
    offset2 = [].concat(offset2);
    targetOffset2 = [].concat(targetOffset2);
    overflow = overflow || {};
    var newOverflowCfg = {};
    var fail = 0;
    var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
    var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
    var elRegion = getRegion(source);
    normalizeOffset(offset2, elRegion);
    normalizeOffset(targetOffset2, tgtRegion);
    var elFuturePos = getElFuturePos(elRegion, tgtRegion, points2, offset2, targetOffset2);
    var newElRegion = utils$2.merge(elRegion, elFuturePos);
    if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
      if (overflow.adjustX) {
        if (isFailX(elFuturePos, elRegion, visibleRect)) {
          var newPoints = flip(points2, /[lr]/gi, {
            l: "r",
            r: "l"
          });
          var newOffset = flipOffset(offset2, 0);
          var newTargetOffset = flipOffset(targetOffset2, 0);
          var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
          if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points2 = newPoints;
            offset2 = newOffset;
            targetOffset2 = newTargetOffset;
          }
        }
      }
      if (overflow.adjustY) {
        if (isFailY(elFuturePos, elRegion, visibleRect)) {
          var _newPoints = flip(points2, /[tb]/gi, {
            t: "b",
            b: "t"
          });
          var _newOffset = flipOffset(offset2, 1);
          var _newTargetOffset = flipOffset(targetOffset2, 1);
          var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
          if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points2 = _newPoints;
            offset2 = _newOffset;
            targetOffset2 = _newTargetOffset;
          }
        }
      }
      if (fail) {
        elFuturePos = getElFuturePos(elRegion, tgtRegion, points2, offset2, targetOffset2);
        utils$2.mix(newElRegion, elFuturePos);
      }
      var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
      var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
      if (isStillFailX || isStillFailY) {
        var _newPoints2 = points2;
        if (isStillFailX) {
          _newPoints2 = flip(points2, /[lr]/gi, {
            l: "r",
            r: "l"
          });
        }
        if (isStillFailY) {
          _newPoints2 = flip(points2, /[tb]/gi, {
            t: "b",
            b: "t"
          });
        }
        points2 = _newPoints2;
        offset2 = align.offset || [0, 0];
        targetOffset2 = align.targetOffset || [0, 0];
      }
      newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
      newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
      if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
        newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
      }
    }
    if (newElRegion.width !== elRegion.width) {
      utils$2.css(source, "width", utils$2.width(source) + newElRegion.width - elRegion.width);
    }
    if (newElRegion.height !== elRegion.height) {
      utils$2.css(source, "height", utils$2.height(source) + newElRegion.height - elRegion.height);
    }
    utils$2.offset(source, {
      left: newElRegion.left,
      top: newElRegion.top
    }, {
      useCssRight: align.useCssRight,
      useCssBottom: align.useCssBottom,
      useCssTransform: align.useCssTransform,
      ignoreShake: align.ignoreShake
    });
    return {
      points: points2,
      offset: offset2,
      targetOffset: targetOffset2,
      overflow: newOverflowCfg
    };
  }
  function isOutOfVisibleRect(target, alwaysByViewport) {
    var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
    var targetRegion = getRegion(target);
    return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
  }
  function alignElement(el, refNode, align) {
    var target = align.target || refNode;
    var refNodeRegion = getRegion(target);
    var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
    return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
  }
  alignElement.__getOffsetParent = getOffsetParent;
  alignElement.__getVisibleRectForElement = getVisibleRectForElement;
  function alignPoint(el, tgtPoint, align) {
    var pageX;
    var pageY;
    var doc2 = utils$2.getDocument(el);
    var win = doc2.defaultView || doc2.parentWindow;
    var scrollX = utils$2.getWindowScrollLeft(win);
    var scrollY = utils$2.getWindowScrollTop(win);
    var viewportWidth = utils$2.viewportWidth(win);
    var viewportHeight = utils$2.viewportHeight(win);
    if ("pageX" in tgtPoint) {
      pageX = tgtPoint.pageX;
    } else {
      pageX = scrollX + tgtPoint.clientX;
    }
    if ("pageY" in tgtPoint) {
      pageY = tgtPoint.pageY;
    } else {
      pageY = scrollY + tgtPoint.clientY;
    }
    var tgtRegion = {
      left: pageX,
      top: pageY,
      width: 0,
      height: 0
    };
    var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
    var points2 = [align.points[0], "cc"];
    return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
      points: points2
    }), pointInView);
  }
  function cloneElement(vnode) {
    let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let ele = vnode;
    if (Array.isArray(vnode)) {
      ele = filterEmpty(vnode)[0];
    }
    if (!ele) {
      return null;
    }
    const node2 = cloneVNode(ele, nodeProps, mergeRef);
    node2.props = override ? _extends$1(_extends$1({}, node2.props), nodeProps) : node2.props;
    warning$2(typeof node2.props.class !== "object");
    return node2;
  }
  const ensureValidVNode = (slot) => {
    return (slot || []).some((child) => {
      if (!isVNode$1(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
      return true;
    }) ? slot : null;
  };
  function customRenderSlot(slots, name, props2, fallback) {
    var _a2;
    const slot = (_a2 = slots[name]) === null || _a2 === void 0 ? void 0 : _a2.call(slots, props2);
    if (ensureValidVNode(slot)) {
      return slot;
    }
    return fallback === null || fallback === void 0 ? void 0 : fallback();
  }
  const isVisible = (element) => {
    if (!element) {
      return false;
    }
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      const box2 = element.getBBox();
      if (box2.width || box2.height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      const box2 = element.getBoundingClientRect();
      if (box2.width || box2.height) {
        return true;
      }
    }
    return false;
  };
  function isSamePoint(prev2, next2) {
    if (prev2 === next2) return true;
    if (!prev2 || !next2) return false;
    if ("pageX" in next2 && "pageY" in next2) {
      return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
    }
    if ("clientX" in next2 && "clientY" in next2) {
      return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
    }
    return false;
  }
  function restoreFocus(activeElement, container) {
    if (activeElement !== document.activeElement && contains$1(container, activeElement) && typeof activeElement.focus === "function") {
      activeElement.focus();
    }
  }
  function monitorResize(element, callback) {
    let prevWidth = null;
    let prevHeight = null;
    function onResize(_ref) {
      let [{
        target
      }] = _ref;
      if (!document.documentElement.contains(target)) return;
      const {
        width,
        height
      } = target.getBoundingClientRect();
      const fixedWidth = Math.floor(width);
      const fixedHeight = Math.floor(height);
      if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
        Promise.resolve().then(() => {
          callback({
            width: fixedWidth,
            height: fixedHeight
          });
        });
      }
      prevWidth = fixedWidth;
      prevHeight = fixedHeight;
    }
    const resizeObserver = new index$2(onResize);
    if (element) {
      resizeObserver.observe(element);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }
  const useBuffer = (callback, buffer) => {
    let called = false;
    let timeout = null;
    function cancelTrigger() {
      clearTimeout(timeout);
    }
    function trigger2(force) {
      if (!called || force === true) {
        if (callback() === false) {
          return;
        }
        called = true;
        cancelTrigger();
        timeout = setTimeout(() => {
          called = false;
        }, buffer.value);
      } else {
        cancelTrigger();
        timeout = setTimeout(() => {
          called = false;
          trigger2();
        }, buffer.value);
      }
    }
    return [trigger2, () => {
      called = false;
      cancelTrigger();
    }];
  };
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function assocIndexOf(array, key2) {
    var length2 = array.length;
    while (length2--) {
      if (eq(array[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  var arrayProto$1 = Array.prototype;
  var splice = arrayProto$1.splice;
  function listCacheDelete(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet$1(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet$1(key2, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet$1;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet$1;
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$2 = root.Symbol;
  var objectProto$g = Object.prototype;
  var hasOwnProperty$e = objectProto$g.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$g.toString;
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$f = Object.prototype;
  var nativeObjectToString = objectProto$f.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObject$5(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$2(value) {
    if (!isObject$5(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$e = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$d = objectProto$e.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject$5(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue$2(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  function getNative(object, key2) {
    var value = getValue$2(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  var Map$1 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$d = Object.prototype;
  var hasOwnProperty$c = objectProto$d.hasOwnProperty;
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$c.call(data, key2) ? data[key2] : void 0;
  }
  var objectProto$c = Object.prototype;
  var hasOwnProperty$b = objectProto$c.hasOwnProperty;
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$b.call(data, key2);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size = data.size;
    data.set(key2, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var LARGE_ARRAY_SIZE$1 = 200;
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
        pairs.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index2 = -1, length2 = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache2, key2) {
    return cache2.has(key2);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack2.set(array, other);
    stack2.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen2.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array);
    stack2["delete"](other);
    return result;
  }
  var Uint8Array$1 = root.Uint8Array;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
  var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
  var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag$4:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$3:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
          return false;
        }
        return true;
      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        return eq(+object, +other);
      case errorTag$2:
        return object.name == other.name && object.message == other.message;
      case regexpTag$3:
      case stringTag$3:
        return object == other + "";
      case mapTag$6:
        var convert = mapToArray;
      case setTag$6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack2.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object);
        return result;
      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }
    }
    return false;
  }
  function arrayPush(array, values) {
    var index2 = -1, length2 = values.length, offset2 = array.length;
    while (++index2 < length2) {
      array[offset2 + index2] = values[index2];
    }
    return array;
  }
  var isArray$2 = Array.isArray;
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$b = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }
  var objectProto$a = Object.prototype;
  var hasOwnProperty$a = objectProto$a.hasOwnProperty;
  var propertyIsEnumerable = objectProto$a.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
  var isBuffer$1 = nativeIsBuffer || stubFalse;
  var MAX_SAFE_INTEGER$2 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER$2 : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }
  var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty$9.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$8 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
    return value === proto2;
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$8 = objectProto$7.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty$8.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function isArrayLike$1(value) {
    return value != null && isLength(value.length) && !isFunction$2(value);
  }
  function keys$1(object) {
    return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$7 = objectProto$6.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty$7.call(other, key2))) {
        return false;
      }
    }
    var objStacked = stack2.get(object);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack2.set(object, other);
    stack2.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object);
    stack2["delete"](other);
    return result;
  }
  var DataView = getNative(root, "DataView");
  var Promise$1 = getNative(root, "Promise");
  var Set$1 = getNative(root, "Set");
  var WeakMap$2 = getNative(root, "WeakMap");
  var mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$2 = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;
          case mapCtorString:
            return mapTag$4;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$4;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$2 = "[object Object]";
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$6 = objectProto$5.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray$2(object), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag$1 : getTag(object), othTag = othIsArr ? arrayTag$1 : getTag(other);
    objTag = objTag == argsTag$1 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$1 ? objectTag$2 : othTag;
    var objIsObj = objTag == objectTag$2, othIsObj = othTag == objectTag$2, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer$1(object)) {
      if (!isBuffer$1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray$2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty$6.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$6.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  function isEqual$1(value, other) {
    return baseIsEqual(value, other);
  }
  const alignProps = {
    align: Object,
    target: [Object, Function],
    onAlign: Function,
    monitorBufferTime: Number,
    monitorWindowResize: Boolean,
    disabled: Boolean
  };
  function getElement(func) {
    if (typeof func !== "function") return null;
    return func();
  }
  function getPoint(point) {
    if (typeof point !== "object" || !point) return null;
    return point;
  }
  const Align = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Align",
    props: alignProps,
    emits: ["align"],
    setup(props2, _ref) {
      let {
        expose,
        slots
      } = _ref;
      const cacheRef = ref({});
      const nodeRef = ref();
      const [forceAlign, cancelForceAlign] = useBuffer(() => {
        const {
          disabled: latestDisabled,
          target: latestTarget,
          align: latestAlign,
          onAlign: latestOnAlign
        } = props2;
        if (!latestDisabled && latestTarget && nodeRef.value) {
          const source = nodeRef.value;
          let result;
          const element = getElement(latestTarget);
          const point = getPoint(latestTarget);
          cacheRef.value.element = element;
          cacheRef.value.point = point;
          cacheRef.value.align = latestAlign;
          const {
            activeElement
          } = document;
          if (element && isVisible(element)) {
            result = alignElement(source, element, latestAlign);
          } else if (point) {
            result = alignPoint(source, point, latestAlign);
          }
          restoreFocus(activeElement, source);
          if (latestOnAlign && result) {
            latestOnAlign(source, result);
          }
          return true;
        }
        return false;
      }, computed(() => props2.monitorBufferTime));
      const resizeMonitor = ref({
        cancel: () => {
        }
      });
      const sourceResizeMonitor = ref({
        cancel: () => {
        }
      });
      const goAlign = () => {
        const target = props2.target;
        const element = getElement(target);
        const point = getPoint(target);
        if (nodeRef.value !== sourceResizeMonitor.value.element) {
          sourceResizeMonitor.value.cancel();
          sourceResizeMonitor.value.element = nodeRef.value;
          sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);
        }
        if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual$1(cacheRef.value.align, props2.align)) {
          forceAlign();
          if (resizeMonitor.value.element !== element) {
            resizeMonitor.value.cancel();
            resizeMonitor.value.element = element;
            resizeMonitor.value.cancel = monitorResize(element, forceAlign);
          }
        }
      };
      onMounted(() => {
        nextTick(() => {
          goAlign();
        });
      });
      onUpdated(() => {
        nextTick(() => {
          goAlign();
        });
      });
      watch(() => props2.disabled, (disabled) => {
        if (!disabled) {
          forceAlign();
        } else {
          cancelForceAlign();
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const winResizeRef = ref(null);
      watch(() => props2.monitorWindowResize, (monitorWindowResize) => {
        if (monitorWindowResize) {
          if (!winResizeRef.value) {
            winResizeRef.value = addEventListenerWrap(window, "resize", forceAlign);
          }
        } else if (winResizeRef.value) {
          winResizeRef.value.remove();
          winResizeRef.value = null;
        }
      }, {
        flush: "post"
      });
      onUnmounted(() => {
        resizeMonitor.value.cancel();
        sourceResizeMonitor.value.cancel();
        if (winResizeRef.value) winResizeRef.value.remove();
        cancelForceAlign();
      });
      expose({
        forceAlign: () => forceAlign(true)
      });
      return () => {
        const child = slots === null || slots === void 0 ? void 0 : slots.default();
        if (child) {
          return cloneElement(child[0], {
            ref: nodeRef
          }, true, true);
        }
        return null;
      };
    }
  });
  tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
  const getTransitionDirection = (placement) => {
    if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
      return `slide-down`;
    }
    return `slide-up`;
  };
  const getTransitionProps = function(transitionName2) {
    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const transitionProps = transitionName2 ? _extends$1({
      name: transitionName2,
      appear: true,
      // type: 'animation',
      // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
      // appearActiveClass: `antdv-base-transtion`,
      // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
      enterFromClass: `${transitionName2}-enter ${transitionName2}-enter-prepare ${transitionName2}-enter-start`,
      enterActiveClass: `${transitionName2}-enter ${transitionName2}-enter-prepare`,
      enterToClass: `${transitionName2}-enter ${transitionName2}-enter-active`,
      leaveFromClass: ` ${transitionName2}-leave`,
      leaveActiveClass: `${transitionName2}-leave ${transitionName2}-leave-active`,
      leaveToClass: `${transitionName2}-leave ${transitionName2}-leave-active`
    }, opt) : _extends$1({
      css: false
    }, opt);
    return transitionProps;
  };
  const getTransitionGroupProps = function(transitionName2) {
    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const transitionProps = transitionName2 ? _extends$1({
      name: transitionName2,
      appear: true,
      // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
      appearActiveClass: `${transitionName2}`,
      appearToClass: `${transitionName2}-appear ${transitionName2}-appear-active`,
      enterFromClass: `${transitionName2}-appear ${transitionName2}-enter ${transitionName2}-appear-prepare ${transitionName2}-enter-prepare`,
      enterActiveClass: `${transitionName2}`,
      enterToClass: `${transitionName2}-enter ${transitionName2}-appear ${transitionName2}-appear-active ${transitionName2}-enter-active`,
      leaveActiveClass: `${transitionName2} ${transitionName2}-leave`,
      leaveToClass: `${transitionName2}-leave-active`
    }, opt) : _extends$1({
      css: false
    }, opt);
    return transitionProps;
  };
  const getTransitionName = (rootPrefixCls, motion, transitionName2) => {
    if (transitionName2 !== void 0) {
      return transitionName2;
    }
    return `${rootPrefixCls}-${motion}`;
  };
  const PopupInner = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "PopupInner",
    inheritAttrs: false,
    props: innerProps,
    emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
    setup(props2, _ref) {
      let {
        expose,
        attrs,
        slots
      } = _ref;
      const alignRef = shallowRef();
      const elementRef = shallowRef();
      const alignedClassName = shallowRef();
      const [stretchStyle, measureStretchStyle] = useStretchStyle(toRef(props2, "stretch"));
      const doMeasure = () => {
        if (props2.stretch) {
          measureStretchStyle(props2.getRootDomNode());
        }
      };
      const visible = shallowRef(false);
      let timeoutId;
      watch(() => props2.visible, (val) => {
        clearTimeout(timeoutId);
        if (val) {
          timeoutId = setTimeout(() => {
            visible.value = props2.visible;
          });
        } else {
          visible.value = false;
        }
      }, {
        immediate: true
      });
      const [status, goNextStatus] = useVisibleStatus(visible, doMeasure);
      const prepareResolveRef = shallowRef();
      const getAlignTarget = () => {
        if (props2.point) {
          return props2.point;
        }
        return props2.getRootDomNode;
      };
      const forceAlign = () => {
        var _a2;
        (_a2 = alignRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      const onInternalAlign = (popupDomNode, matchAlign) => {
        var _a2;
        const nextAlignedClassName = props2.getClassNameFromAlign(matchAlign);
        const preAlignedClassName = alignedClassName.value;
        if (alignedClassName.value !== nextAlignedClassName) {
          alignedClassName.value = nextAlignedClassName;
        }
        if (status.value === "align") {
          if (preAlignedClassName !== nextAlignedClassName) {
            Promise.resolve().then(() => {
              forceAlign();
            });
          } else {
            goNextStatus(() => {
              var _a3;
              (_a3 = prepareResolveRef.value) === null || _a3 === void 0 ? void 0 : _a3.call(prepareResolveRef);
            });
          }
          (_a2 = props2.onAlign) === null || _a2 === void 0 ? void 0 : _a2.call(props2, popupDomNode, matchAlign);
        }
      };
      const motion = computed(() => {
        const m2 = typeof props2.animation === "object" ? props2.animation : getMotion$1(props2);
        ["onAfterEnter", "onAfterLeave"].forEach((eventName) => {
          const originFn = m2[eventName];
          m2[eventName] = (node2) => {
            goNextStatus();
            status.value = "stable";
            originFn === null || originFn === void 0 ? void 0 : originFn(node2);
          };
        });
        return m2;
      });
      const onShowPrepare = () => {
        return new Promise((resolve2) => {
          prepareResolveRef.value = resolve2;
        });
      };
      watch([motion, status], () => {
        if (!motion.value && status.value === "motion") {
          goNextStatus();
        }
      }, {
        immediate: true
      });
      expose({
        forceAlign,
        getElement: () => {
          return elementRef.value.$el || elementRef.value;
        }
      });
      const alignDisabled = computed(() => {
        var _a2;
        if (((_a2 = props2.align) === null || _a2 === void 0 ? void 0 : _a2.points) && (status.value === "align" || status.value === "stable")) {
          return false;
        }
        return true;
      });
      return () => {
        var _a2;
        const {
          zIndex,
          align,
          prefixCls,
          destroyPopupOnHide,
          onMouseenter,
          onMouseleave,
          onTouchstart = () => {
          },
          onMousedown
        } = props2;
        const statusValue = status.value;
        const mergedStyle = [_extends$1(_extends$1({}, stretchStyle.value), {
          zIndex,
          opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
          // pointerEvents: statusValue === 'stable' ? null : 'none',
          pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
        }), attrs.style];
        let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
          visible: props2.visible
        }));
        if (childNode.length > 1) {
          childNode = createVNode("div", {
            "class": `${prefixCls}-content`
          }, [childNode]);
        }
        const mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value, !props2.arrow && `${prefixCls}-arrow-hidden`);
        const hasAnimate = visible.value || !props2.visible;
        const transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({
          "ref": elementRef
        }, transitionProps), {}, {
          "onBeforeEnter": onShowPrepare
        }), {
          default: () => {
            return !destroyPopupOnHide || props2.visible ? withDirectives(createVNode(Align, {
              "target": getAlignTarget(),
              "key": "popup",
              "ref": alignRef,
              "monitorWindowResize": true,
              "disabled": alignDisabled.value,
              "align": align,
              "onAlign": onInternalAlign
            }, {
              default: () => createVNode("div", {
                "class": mergedClassName,
                "onMouseenter": onMouseenter,
                "onMouseleave": onMouseleave,
                "onMousedown": withModifiers(onMousedown, ["capture"]),
                [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: withModifiers(onTouchstart, ["capture"]),
                "style": mergedStyle
              }, [childNode])
            }), [[vShow, visible.value]]) : null;
          }
        });
      };
    }
  });
  const Popup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Popup",
    inheritAttrs: false,
    props: popupProps,
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        expose
      } = _ref;
      const innerVisible = shallowRef(false);
      const inMobile = shallowRef(false);
      const popupRef = shallowRef();
      const rootRef = shallowRef();
      watch([() => props2.visible, () => props2.mobile], () => {
        innerVisible.value = props2.visible;
        if (props2.visible && props2.mobile) {
          inMobile.value = true;
        }
      }, {
        immediate: true,
        flush: "post"
      });
      expose({
        forceAlign: () => {
          var _a2;
          (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
        },
        getElement: () => {
          var _a2;
          return (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.getElement();
        }
      });
      return () => {
        const cloneProps = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
          visible: innerVisible.value
        });
        const popupNode = inMobile.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
          "mobile": props2.mobile,
          "ref": popupRef
        }), {
          default: slots.default
        }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
          "ref": popupRef
        }), {
          default: slots.default
        });
        return createVNode("div", {
          "ref": rootRef
        }, [createVNode(Mask, cloneProps, null), popupNode]);
      };
    }
  });
  function isPointsEq(a1, a2, isAlignPoint) {
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignFromPlacement(builtinPlacements, placementStr, align) {
    const baseAlign = builtinPlacements[placementStr] || {};
    return _extends$1(_extends$1({}, baseAlign), align);
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    const {
      points: points2
    } = align;
    const placements2 = Object.keys(builtinPlacements);
    for (let i2 = 0; i2 < placements2.length; i2 += 1) {
      const placement = placements2[i2];
      if (isPointsEq(builtinPlacements[placement].points, points2, isAlignPoint)) {
        return `${prefixCls}-placement-${placement}`;
      }
    }
    return "";
  }
  const BaseMixin = {
    methods: {
      setState() {
        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        let newState = typeof state === "function" ? state(this.$data, this.$props) : state;
        if (this.getDerivedStateFromProps) {
          const s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends$1(_extends$1({}, this.$data), newState));
          if (s2 === null) {
            return;
          } else {
            newState = _extends$1(_extends$1({}, newState), s2 || {});
          }
        }
        _extends$1(this.$data, newState);
        if (this._.isMounted) {
          this.$forceUpdate();
        }
        nextTick(() => {
          callback && callback();
        });
      },
      __emit() {
        const args = [].slice.call(arguments, 0);
        let eventName = args[0];
        eventName = `on${eventName[0].toUpperCase()}${eventName.substring(1)}`;
        const event = this.$props[eventName] || this.$attrs[eventName];
        if (args.length && event) {
          if (Array.isArray(event)) {
            for (let i2 = 0, l2 = event.length; i2 < l2; i2++) {
              event[i2](...args.slice(1));
            }
          } else {
            event(...args.slice(1));
          }
        }
      }
    }
  };
  const PortalContextKey = Symbol("PortalContextKey");
  const useProvidePortal = function(instance) {
    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      inTriggerContext: true
    };
    provide(PortalContextKey, {
      inTriggerContext: config.inTriggerContext,
      shouldRender: computed(() => {
        const {
          sPopupVisible,
          popupRef,
          forceRender,
          autoDestroy
        } = instance || {};
        let shouldRender = false;
        if (sPopupVisible || popupRef || forceRender) {
          shouldRender = true;
        }
        if (!sPopupVisible && autoDestroy) {
          shouldRender = false;
        }
        return shouldRender;
      })
    });
  };
  const useInjectPortal = () => {
    useProvidePortal({}, {
      inTriggerContext: false
    });
    const portalContext = inject(PortalContextKey, {
      shouldRender: computed(() => false),
      inTriggerContext: false
    });
    return {
      shouldRender: computed(() => portalContext.shouldRender.value || portalContext.inTriggerContext === false)
    };
  };
  const Portal$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Portal",
    inheritAttrs: false,
    props: {
      getContainer: PropTypes.func.isRequired,
      didUpdate: Function
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      let isSSR = true;
      let container;
      const {
        shouldRender
      } = useInjectPortal();
      function setContainer() {
        if (shouldRender.value) {
          container = props2.getContainer();
        }
      }
      onBeforeMount(() => {
        isSSR = false;
        setContainer();
      });
      onMounted(() => {
        if (container) return;
        setContainer();
      });
      const stopWatch = watch(shouldRender, () => {
        if (shouldRender.value && !container) {
          container = props2.getContainer();
        }
        if (container) {
          stopWatch();
        }
      });
      onUpdated(() => {
        nextTick(() => {
          var _a2;
          if (shouldRender.value) {
            (_a2 = props2.didUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(props2, props2);
          }
        });
      });
      return () => {
        var _a2;
        if (!shouldRender.value) return null;
        if (isSSR) {
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
        return container ? createVNode(Teleport, {
          "to": container
        }, slots) : null;
      };
    }
  });
  let cached;
  function getScrollBarSize(fresh) {
    if (typeof document === "undefined") {
      return 0;
    }
    if (cached === void 0) {
      const inner2 = document.createElement("div");
      inner2.style.width = "100%";
      inner2.style.height = "200px";
      const outer = document.createElement("div");
      const outerStyle = outer.style;
      outerStyle.position = "absolute";
      outerStyle.top = "0";
      outerStyle.left = "0";
      outerStyle.pointerEvents = "none";
      outerStyle.visibility = "hidden";
      outerStyle.width = "200px";
      outerStyle.height = "150px";
      outerStyle.overflow = "hidden";
      outer.appendChild(inner2);
      document.body.appendChild(outer);
      const widthContained = inner2.offsetWidth;
      outer.style.overflow = "scroll";
      let widthScroll = inner2.offsetWidth;
      if (widthContained === widthScroll) {
        widthScroll = outer.clientWidth;
      }
      document.body.removeChild(outer);
      cached = widthContained - widthScroll;
    }
    return cached;
  }
  function ensureSize(str) {
    const match2 = str.match(/^(.*)px$/);
    const value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
    return Number.isNaN(value) ? getScrollBarSize() : value;
  }
  function getTargetScrollBarSize(target) {
    if (typeof document === "undefined" || !target || !(target instanceof Element)) {
      return {
        width: 0,
        height: 0
      };
    }
    const {
      width,
      height
    } = getComputedStyle(target, "::-webkit-scrollbar");
    return {
      width: ensureSize(width),
      height: ensureSize(height)
    };
  }
  const UNIQUE_ID = `vc-util-locker-${Date.now()}`;
  let uuid$1 = 0;
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }
  function useScrollLocker(lock) {
    const mergedLock = computed(() => !!lock && !!lock.value);
    uuid$1 += 1;
    const id = `${UNIQUE_ID}_${uuid$1}`;
    watchEffect((onClear) => {
      if (!canUseDom$1()) {
        return;
      }
      if (mergedLock.value) {
        const scrollbarSize = getScrollBarSize();
        const isOverflow = isBodyOverflowing();
        updateCSS$1(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
      } else {
        removeCSS(id);
      }
      onClear(() => {
        removeCSS(id);
      });
    }, {
      flush: "post"
    });
  }
  let openCount = 0;
  const supportDom = canUseDom$1();
  const getParent = (getContainer2) => {
    if (!supportDom) {
      return null;
    }
    if (getContainer2) {
      if (typeof getContainer2 === "string") {
        return document.querySelectorAll(getContainer2)[0];
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      if (typeof getContainer2 === "object" && getContainer2 instanceof window.HTMLElement) {
        return getContainer2;
      }
    }
    return document.body;
  };
  const Portal = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "PortalWrapper",
    inheritAttrs: false,
    props: {
      wrapperClassName: String,
      forceRender: {
        type: Boolean,
        default: void 0
      },
      getContainer: PropTypes.any,
      visible: {
        type: Boolean,
        default: void 0
      },
      autoLock: booleanType(),
      didUpdate: Function
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const container = shallowRef();
      const componentRef = shallowRef();
      const rafId = shallowRef();
      const triggerUpdate = shallowRef(1);
      const defaultContainer2 = canUseDom$1() && document.createElement("div");
      const removeCurrentContainer = () => {
        var _a2, _b2;
        if (container.value === defaultContainer2) {
          (_b2 = (_a2 = container.value) === null || _a2 === void 0 ? void 0 : _a2.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(container.value);
        }
        container.value = null;
      };
      let parent2 = null;
      const attachToParent = function() {
        let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (force || container.value && !container.value.parentNode) {
          parent2 = getParent(props2.getContainer);
          if (parent2) {
            parent2.appendChild(container.value);
            return true;
          }
          return false;
        }
        return true;
      };
      const getContainer2 = () => {
        if (!supportDom) {
          return null;
        }
        if (!container.value) {
          container.value = defaultContainer2;
          attachToParent(true);
        }
        setWrapperClassName();
        return container.value;
      };
      const setWrapperClassName = () => {
        const {
          wrapperClassName
        } = props2;
        if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
          container.value.className = wrapperClassName;
        }
      };
      onUpdated(() => {
        setWrapperClassName();
        attachToParent();
      });
      useScrollLocker(computed(() => {
        return props2.autoLock && props2.visible && canUseDom$1() && (container.value === document.body || container.value === defaultContainer2);
      }));
      onMounted(() => {
        let init2 = false;
        watch([() => props2.visible, () => props2.getContainer], (_ref2, _ref3) => {
          let [visible, getContainer22] = _ref2;
          let [prevVisible, prevGetContainer] = _ref3;
          if (supportDom) {
            parent2 = getParent(props2.getContainer);
            if (parent2 === document.body) {
              if (visible && !prevVisible) {
                openCount += 1;
              } else if (init2) {
                openCount -= 1;
              }
            }
          }
          if (init2) {
            const getContainerIsFunc = typeof getContainer22 === "function" && typeof prevGetContainer === "function";
            if (getContainerIsFunc ? getContainer22.toString() !== prevGetContainer.toString() : getContainer22 !== prevGetContainer) {
              removeCurrentContainer();
            }
          }
          init2 = true;
        }, {
          immediate: true,
          flush: "post"
        });
        nextTick(() => {
          if (!attachToParent()) {
            rafId.value = wrapperRaf(() => {
              triggerUpdate.value += 1;
            });
          }
        });
      });
      onBeforeUnmount(() => {
        const {
          visible
        } = props2;
        if (supportDom && parent2 === document.body) {
          openCount = visible && openCount ? openCount - 1 : openCount;
        }
        removeCurrentContainer();
        wrapperRaf.cancel(rafId.value);
      });
      return () => {
        const {
          forceRender,
          visible
        } = props2;
        let portal = null;
        const childProps = {
          getOpenCount: () => openCount,
          getContainer: getContainer2
        };
        if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {
          portal = createVNode(Portal$1, {
            "getContainer": getContainer2,
            "ref": componentRef,
            "didUpdate": props2.didUpdate
          }, {
            default: () => {
              var _a2;
              return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, childProps);
            }
          });
        }
        return portal;
      };
    }
  });
  const ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
  const Trigger = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Trigger",
    mixins: [BaseMixin],
    inheritAttrs: false,
    props: triggerProps(),
    setup(props2) {
      const align = computed(() => {
        const {
          popupPlacement,
          popupAlign,
          builtinPlacements
        } = props2;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      });
      const popupRef = shallowRef(null);
      const setPopupRef = (val) => {
        popupRef.value = val;
      };
      return {
        vcTriggerContext: inject("vcTriggerContext", {}),
        popupRef,
        setPopupRef,
        triggerRef: shallowRef(null),
        align,
        focusTime: null,
        clickOutsideHandler: null,
        contextmenuOutsideHandler1: null,
        contextmenuOutsideHandler2: null,
        touchOutsideHandler: null,
        attachId: null,
        delayTimer: null,
        hasPopupMouseDown: false,
        preClickTime: null,
        preTouchTime: null,
        mouseDownTimeout: null,
        childOriginEvents: {}
      };
    },
    data() {
      const props2 = this.$props;
      let popupVisible;
      if (this.popupVisible !== void 0) {
        popupVisible = !!props2.popupVisible;
      } else {
        popupVisible = !!props2.defaultPopupVisible;
      }
      ALL_HANDLERS.forEach((h2) => {
        this[`fire${h2}`] = (e2) => {
          this.fireEvents(h2, e2);
        };
      });
      return {
        prevPopupVisible: popupVisible,
        sPopupVisible: popupVisible,
        point: null
      };
    },
    watch: {
      popupVisible(val) {
        if (val !== void 0) {
          this.prevPopupVisible = this.sPopupVisible;
          this.sPopupVisible = val;
        }
      }
    },
    created() {
      provide("vcTriggerContext", {
        onPopupMouseDown: this.onPopupMouseDown,
        onPopupMouseenter: this.onPopupMouseenter,
        onPopupMouseleave: this.onPopupMouseleave
      });
      useProvidePortal(this);
    },
    deactivated() {
      this.setPopupVisible(false);
    },
    mounted() {
      this.$nextTick(() => {
        this.updatedCal();
      });
    },
    updated() {
      this.$nextTick(() => {
        this.updatedCal();
      });
    },
    beforeUnmount() {
      this.clearDelayTimer();
      this.clearOutsideHandler();
      clearTimeout(this.mouseDownTimeout);
      wrapperRaf.cancel(this.attachId);
    },
    methods: {
      updatedCal() {
        const props2 = this.$props;
        const state = this.$data;
        if (state.sPopupVisible) {
          let currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
            currentDocument = props2.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive ? {
              passive: false
            } : false);
          }
          if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
            currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
            this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
          }
          if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
            this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
          }
        } else {
          this.clearOutsideHandler();
        }
      },
      onMouseenter(e2) {
        const {
          mouseEnterDelay
        } = this.$props;
        this.fireEvents("onMouseenter", e2);
        this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      },
      onMouseMove(e2) {
        this.fireEvents("onMousemove", e2);
        this.setPoint(e2);
      },
      onMouseleave(e2) {
        this.fireEvents("onMouseleave", e2);
        this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
      },
      onPopupMouseenter() {
        const {
          vcTriggerContext = {}
        } = this;
        if (vcTriggerContext.onPopupMouseenter) {
          vcTriggerContext.onPopupMouseenter();
        }
        this.clearDelayTimer();
      },
      onPopupMouseleave(e2) {
        var _a2;
        if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$1((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement(), e2.relatedTarget)) {
          return;
        }
        if (this.isMouseLeaveToHide()) {
          this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
        }
        const {
          vcTriggerContext = {}
        } = this;
        if (vcTriggerContext.onPopupMouseleave) {
          vcTriggerContext.onPopupMouseleave(e2);
        }
      },
      onFocus(e2) {
        this.fireEvents("onFocus", e2);
        this.clearDelayTimer();
        if (this.isFocusToShow()) {
          this.focusTime = Date.now();
          this.delaySetPopupVisible(true, this.$props.focusDelay);
        }
      },
      onMousedown(e2) {
        this.fireEvents("onMousedown", e2);
        this.preClickTime = Date.now();
      },
      onTouchstart(e2) {
        this.fireEvents("onTouchstart", e2);
        this.preTouchTime = Date.now();
      },
      onBlur(e2) {
        if (!contains$1(e2.target, e2.relatedTarget || document.activeElement)) {
          this.fireEvents("onBlur", e2);
          this.clearDelayTimer();
          if (this.isBlurToHide()) {
            this.delaySetPopupVisible(false, this.$props.blurDelay);
          }
        }
      },
      onContextmenu(e2) {
        e2.preventDefault();
        this.fireEvents("onContextmenu", e2);
        this.setPopupVisible(true, e2);
      },
      onContextmenuClose() {
        if (this.isContextmenuToShow()) {
          this.close();
        }
      },
      onClick(event) {
        this.fireEvents("onClick", event);
        if (this.focusTime) {
          let preTime;
          if (this.preClickTime && this.preTouchTime) {
            preTime = Math.min(this.preClickTime, this.preTouchTime);
          } else if (this.preClickTime) {
            preTime = this.preClickTime;
          } else if (this.preTouchTime) {
            preTime = this.preTouchTime;
          }
          if (Math.abs(preTime - this.focusTime) < 20) {
            return;
          }
          this.focusTime = 0;
        }
        this.preClickTime = 0;
        this.preTouchTime = 0;
        if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        if (event && event.domEvent) {
          event.domEvent.preventDefault();
        }
        const nextVisible = !this.$data.sPopupVisible;
        if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
          this.setPopupVisible(!this.$data.sPopupVisible, event);
        }
      },
      onPopupMouseDown() {
        const {
          vcTriggerContext = {}
        } = this;
        this.hasPopupMouseDown = true;
        clearTimeout(this.mouseDownTimeout);
        this.mouseDownTimeout = setTimeout(() => {
          this.hasPopupMouseDown = false;
        }, 0);
        if (vcTriggerContext.onPopupMouseDown) {
          vcTriggerContext.onPopupMouseDown(...arguments);
        }
      },
      onDocumentClick(event) {
        if (this.$props.mask && !this.$props.maskClosable) {
          return;
        }
        const target = event.target;
        const root2 = this.getRootDomNode();
        const popupNode = this.getPopupDomNode();
        if (
          // mousedown on the target should also close popup when action is contextMenu.
          // https://github.com/ant-design/ant-design/issues/29853
          (!contains$1(root2, target) || this.isContextMenuOnly()) && !contains$1(popupNode, target) && !this.hasPopupMouseDown
        ) {
          this.delaySetPopupVisible(false, 0.1);
        }
      },
      getPopupDomNode() {
        var _a2;
        return ((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement()) || null;
      },
      getRootDomNode() {
        var _a2, _b2, _c2, _d;
        const {
          getTriggerDOMNode
        } = this.$props;
        if (getTriggerDOMNode) {
          const domNode = ((_b2 = (_a2 = this.triggerRef) === null || _a2 === void 0 ? void 0 : _a2.$el) === null || _b2 === void 0 ? void 0 : _b2.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
          return findDOMNode(getTriggerDOMNode(domNode));
        }
        try {
          const domNode = ((_d = (_c2 = this.triggerRef) === null || _c2 === void 0 ? void 0 : _c2.$el) === null || _d === void 0 ? void 0 : _d.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return findDOMNode(this);
      },
      handleGetPopupClassFromAlign(align) {
        const className = [];
        const props2 = this.$props;
        const {
          popupPlacement,
          builtinPlacements,
          prefixCls,
          alignPoint: alignPoint2,
          getPopupClassNameFromAlign
        } = props2;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      },
      getPopupAlign() {
        const props2 = this.$props;
        const {
          popupPlacement,
          popupAlign,
          builtinPlacements
        } = props2;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      },
      getComponent() {
        const mouseProps = {};
        if (this.isMouseEnterToShow()) {
          mouseProps.onMouseenter = this.onPopupMouseenter;
        }
        if (this.isMouseLeaveToHide()) {
          mouseProps.onMouseleave = this.onPopupMouseleave;
        }
        mouseProps.onMousedown = this.onPopupMouseDown;
        mouseProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
        const {
          handleGetPopupClassFromAlign,
          getRootDomNode,
          $attrs
        } = this;
        const {
          prefixCls,
          destroyPopupOnHide,
          popupClassName,
          popupAnimation,
          popupTransitionName,
          popupStyle,
          mask,
          maskAnimation,
          maskTransitionName,
          zIndex,
          stretch,
          alignPoint: alignPoint2,
          mobile,
          arrow,
          forceRender
        } = this.$props;
        const {
          sPopupVisible,
          point
        } = this.$data;
        const popupProps2 = _extends$1(_extends$1({
          prefixCls,
          arrow,
          destroyPopupOnHide,
          visible: sPopupVisible,
          point: alignPoint2 ? point : null,
          align: this.align,
          animation: popupAnimation,
          getClassNameFromAlign: handleGetPopupClassFromAlign,
          stretch,
          getRootDomNode,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          class: popupClassName,
          style: popupStyle,
          onAlign: $attrs.onPopupAlign || noop$5
        }, mouseProps), {
          ref: this.setPopupRef,
          mobile,
          forceRender
        });
        return createVNode(Popup, popupProps2, {
          default: this.$slots.popup || (() => getComponent(this, "popup"))
        });
      },
      attachParent(popupContainer) {
        wrapperRaf.cancel(this.attachId);
        const {
          getPopupContainer,
          getDocument: getDocument2
        } = this.$props;
        const domNode = this.getRootDomNode();
        let mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          this.attachId = wrapperRaf(() => {
            this.attachParent(popupContainer);
          });
        }
      },
      getContainer() {
        const {
          $props: props2
        } = this;
        const {
          getDocument: getDocument2
        } = props2;
        const popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
        popupContainer.style.position = "absolute";
        popupContainer.style.top = "0";
        popupContainer.style.left = "0";
        popupContainer.style.width = "100%";
        this.attachParent(popupContainer);
        return popupContainer;
      },
      setPopupVisible(sPopupVisible, event) {
        const {
          alignPoint: alignPoint2,
          sPopupVisible: prevPopupVisible,
          onPopupVisibleChange
        } = this;
        this.clearDelayTimer();
        if (prevPopupVisible !== sPopupVisible) {
          if (!hasProp(this, "popupVisible")) {
            this.setState({
              sPopupVisible,
              prevPopupVisible
            });
          }
          onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
        }
        if (alignPoint2 && event && sPopupVisible) {
          this.setPoint(event);
        }
      },
      setPoint(point) {
        const {
          alignPoint: alignPoint2
        } = this.$props;
        if (!alignPoint2 || !point) return;
        this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      },
      handlePortalUpdate() {
        if (this.prevPopupVisible !== this.sPopupVisible) {
          this.afterPopupVisibleChange(this.sPopupVisible);
        }
      },
      delaySetPopupVisible(visible, delayS, event) {
        const delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          const point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = setTimeout(() => {
            this.setPopupVisible(visible, point);
            this.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      },
      clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      },
      clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextmenuOutsideHandler1) {
          this.contextmenuOutsideHandler1.remove();
          this.contextmenuOutsideHandler1 = null;
        }
        if (this.contextmenuOutsideHandler2) {
          this.contextmenuOutsideHandler2.remove();
          this.contextmenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      },
      createTwoChains(event) {
        let fn = () => {
        };
        const events2 = getEvents(this);
        if (this.childOriginEvents[event] && events2[event]) {
          return this[`fire${event}`];
        }
        fn = this.childOriginEvents[event] || events2[event] || fn;
        return fn;
      },
      isClickToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      },
      isContextMenuOnly() {
        const {
          action
        } = this.$props;
        return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
      },
      isContextmenuToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
      },
      isClickToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      },
      isMouseEnterToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
      },
      isMouseLeaveToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
      },
      isFocusToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      },
      isBlurToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      },
      forcePopupAlign() {
        var _a2;
        if (this.$data.sPopupVisible) {
          (_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
        }
      },
      fireEvents(type, e2) {
        if (this.childOriginEvents[type]) {
          this.childOriginEvents[type](e2);
        }
        const event = this.$props[type] || this.$attrs[type];
        if (event) {
          event(e2);
        }
      },
      close() {
        this.setPopupVisible(false);
      }
    },
    render() {
      const {
        $attrs
      } = this;
      const children = filterEmpty(getSlot(this));
      const {
        alignPoint: alignPoint2,
        getPopupContainer
      } = this.$props;
      const child = children[0];
      this.childOriginEvents = getEvents(child);
      const newChildProps = {
        key: "trigger"
      };
      if (this.isContextmenuToShow()) {
        newChildProps.onContextmenu = this.onContextmenu;
      } else {
        newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
      }
      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = this.onClick;
        newChildProps.onMousedown = this.onMousedown;
        newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
      } else {
        newChildProps.onClick = this.createTwoChains("onClick");
        newChildProps.onMousedown = this.createTwoChains("onMousedown");
        newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
      }
      if (this.isMouseEnterToShow()) {
        newChildProps.onMouseenter = this.onMouseenter;
        if (alignPoint2) {
          newChildProps.onMousemove = this.onMouseMove;
        }
      } else {
        newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
      }
      if (this.isMouseLeaveToHide()) {
        newChildProps.onMouseleave = this.onMouseleave;
      } else {
        newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
      }
      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
      } else {
        newChildProps.onFocus = this.createTwoChains("onFocus");
        newChildProps.onBlur = (e2) => {
          if (e2 && (!e2.relatedTarget || !contains$1(e2.target, e2.relatedTarget))) {
            this.createTwoChains("onBlur")(e2);
          }
        };
      }
      const childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
      if (childrenClassName) {
        newChildProps.class = childrenClassName;
      }
      const trigger2 = cloneElement(child, _extends$1(_extends$1({}, newChildProps), {
        ref: "triggerRef"
      }), true, true);
      const portal = createVNode(Portal, {
        "key": "portal",
        "getContainer": getPopupContainer && (() => getPopupContainer(this.getRootDomNode())),
        "didUpdate": this.handlePortalUpdate,
        "visible": this.$data.sPopupVisible
      }, {
        default: this.getComponent
      });
      return createVNode(Fragment, null, [trigger2, portal]);
    }
  });
  var __rest$D = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const getBuiltInPlacements = (dropdownMatchSelectWidth) => {
    const adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
    return {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        }
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        }
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        }
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        }
      }
    };
  };
  const SelectTrigger = /* @__PURE__ */ defineComponent({
    name: "SelectTrigger",
    inheritAttrs: false,
    props: {
      dropdownAlign: Object,
      visible: {
        type: Boolean,
        default: void 0
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      dropdownClassName: String,
      dropdownStyle: PropTypes.object,
      placement: String,
      empty: {
        type: Boolean,
        default: void 0
      },
      prefixCls: String,
      popupClassName: String,
      animation: String,
      transitionName: String,
      getPopupContainer: Function,
      dropdownRender: Function,
      containerWidth: Number,
      dropdownMatchSelectWidth: PropTypes.oneOfType([Number, Boolean]).def(true),
      popupElement: PropTypes.any,
      direction: String,
      getTriggerDOMNode: Function,
      onPopupVisibleChange: Function,
      onPopupMouseEnter: Function,
      onPopupFocusin: Function,
      onPopupFocusout: Function
    },
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose
      } = _ref;
      const builtInPlacements = computed(() => {
        const {
          dropdownMatchSelectWidth
        } = props2;
        return getBuiltInPlacements(dropdownMatchSelectWidth);
      });
      const popupRef = ref();
      expose({
        getPopupElement: () => {
          return popupRef.value;
        }
      });
      return () => {
        const _a2 = _extends$1(_extends$1({}, props2), attrs), {
          empty = false
        } = _a2, restProps = __rest$D(_a2, ["empty"]);
        const {
          visible,
          dropdownAlign,
          prefixCls,
          popupElement,
          dropdownClassName,
          dropdownStyle,
          direction = "ltr",
          placement,
          dropdownMatchSelectWidth,
          containerWidth,
          dropdownRender,
          animation,
          transitionName: transitionName2,
          getPopupContainer,
          getTriggerDOMNode,
          onPopupVisibleChange,
          onPopupMouseEnter,
          onPopupFocusin,
          onPopupFocusout
        } = restProps;
        const dropdownPrefixCls = `${prefixCls}-dropdown`;
        let popupNode = popupElement;
        if (dropdownRender) {
          popupNode = dropdownRender({
            menuNode: popupElement,
            props: props2
          });
        }
        const mergedTransitionName = animation ? `${dropdownPrefixCls}-${animation}` : transitionName2;
        const popupStyle = _extends$1({
          minWidth: `${containerWidth}px`
        }, dropdownStyle);
        if (typeof dropdownMatchSelectWidth === "number") {
          popupStyle.width = `${dropdownMatchSelectWidth}px`;
        } else if (dropdownMatchSelectWidth) {
          popupStyle.width = `${containerWidth}px`;
        }
        return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "showAction": onPopupVisibleChange ? ["click"] : [],
          "hideAction": onPopupVisibleChange ? ["click"] : [],
          "popupPlacement": placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
          "builtinPlacements": builtInPlacements.value,
          "prefixCls": dropdownPrefixCls,
          "popupTransitionName": mergedTransitionName,
          "popupAlign": dropdownAlign,
          "popupVisible": visible,
          "getPopupContainer": getPopupContainer,
          "popupClassName": classNames(dropdownClassName, {
            [`${dropdownPrefixCls}-empty`]: empty
          }),
          "popupStyle": popupStyle,
          "getTriggerDOMNode": getTriggerDOMNode,
          "onPopupVisibleChange": onPopupVisibleChange
        }), {
          default: slots.default,
          popup: () => createVNode("div", {
            "ref": popupRef,
            "onMouseenter": onPopupMouseEnter,
            "onFocusin": onPopupFocusin,
            "onFocusout": onPopupFocusout
          }, [popupNode])
        });
      };
    }
  });
  const KeyCode = {
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * LEFT
     */
    LEFT: 37,
    /**
     * UP
     */
    UP: 38,
    /**
     * RIGHT
     */
    RIGHT: 39,
    /**
     * DOWN
     */
    DOWN: 40,
    /**
     * N
     */
    N: 78,
    /**
     * P
     */
    P: 80,
    /**
     * META
     */
    META: 91,
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    /**
     * EQUALS
     */
    EQUALS: 187,
    /**
     * WIN_KEY
     */
    WIN_KEY: 224
  };
  const TransBtn = (props2, _ref) => {
    let {
      slots
    } = _ref;
    var _a2;
    const {
      class: className,
      customizeIcon,
      customizeIconProps,
      onMousedown,
      onClick
    } = props2;
    let icon;
    if (typeof customizeIcon === "function") {
      icon = customizeIcon(customizeIconProps);
    } else {
      icon = isVNode$1(customizeIcon) ? cloneVNode(customizeIcon) : customizeIcon;
    }
    return createVNode("span", {
      "class": className,
      "onMousedown": (event) => {
        event.preventDefault();
        if (onMousedown) {
          onMousedown(event);
        }
      },
      "style": {
        userSelect: "none",
        WebkitUserSelect: "none"
      },
      "unselectable": "on",
      "onClick": onClick,
      "aria-hidden": true
    }, [icon !== void 0 ? icon : createVNode("span", {
      "class": className.split(/\s+/).map((cls) => `${cls}-icon`)
    }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
  };
  TransBtn.inheritAttrs = false;
  TransBtn.displayName = "TransBtn";
  TransBtn.props = {
    class: String,
    customizeIcon: PropTypes.any,
    customizeIconProps: PropTypes.any,
    onMousedown: Function,
    onClick: Function
  };
  var __rest$C = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const BaseInputInner = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    // inheritAttrs: false,
    props: {
      disabled: PropTypes.looseBool,
      type: PropTypes.string,
      value: PropTypes.any,
      tag: {
        type: String,
        default: "input"
      },
      size: PropTypes.string,
      onChange: Function,
      onInput: Function,
      onBlur: Function,
      onFocus: Function,
      onKeydown: Function,
      onCompositionstart: Function,
      onCompositionend: Function,
      onKeyup: Function,
      onPaste: Function,
      onMousedown: Function
    },
    emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
    setup(props2, _ref) {
      let {
        expose
      } = _ref;
      const inputRef = shallowRef(null);
      const focus = () => {
        if (inputRef.value) {
          inputRef.value.focus();
        }
      };
      const blur = () => {
        if (inputRef.value) {
          inputRef.value.blur();
        }
      };
      const setSelectionRange = (start2, end2, direction) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start2, end2, direction);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: inputRef,
        setSelectionRange,
        select,
        getSelectionStart: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectionStart;
        },
        getSelectionEnd: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectionEnd;
        },
        getScrollTop: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTop;
        }
      });
      return () => {
        const {
          tag: Tag,
          value
        } = props2, restProps = __rest$C(props2, ["tag", "value"]);
        return createVNode(Tag, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          "ref": inputRef,
          "value": value
        }), null);
      };
    }
  });
  function getOffset$1(node2) {
    const box2 = node2.getBoundingClientRect();
    const docElem = document.documentElement;
    return {
      left: box2.left + (window.scrollX || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
      top: box2.top + (window.scrollY || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
    };
  }
  function styleObjectToString(style) {
    return Object.keys(style).reduce((acc, name) => {
      const styleValue = style[name];
      if (typeof styleValue === "undefined" || styleValue === null) {
        return acc;
      }
      acc += `${name}: ${style[name]};`;
      return acc;
    }, "");
  }
  var __rest$B = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const BaseInput$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    inheritAttrs: false,
    props: {
      disabled: PropTypes.looseBool,
      type: PropTypes.string,
      value: PropTypes.any,
      lazy: PropTypes.bool.def(true),
      tag: {
        type: String,
        default: "input"
      },
      size: PropTypes.string,
      style: PropTypes.oneOfType([String, Object]),
      class: PropTypes.string
    },
    emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
    setup(props2, _ref) {
      let {
        emit: emit2,
        attrs,
        expose
      } = _ref;
      const inputRef = shallowRef(null);
      const renderValue = ref();
      const isComposing = ref(false);
      watch([() => props2.value, isComposing], () => {
        if (isComposing.value) return;
        renderValue.value = props2.value;
      }, {
        immediate: true
      });
      const handleChange = (e2) => {
        emit2("change", e2);
      };
      const onCompositionstart = (e2) => {
        isComposing.value = true;
        e2.target.composing = true;
        emit2("compositionstart", e2);
      };
      const onCompositionend = (e2) => {
        isComposing.value = false;
        e2.target.composing = false;
        emit2("compositionend", e2);
        const event = document.createEvent("HTMLEvents");
        event.initEvent("input", true, true);
        e2.target.dispatchEvent(event);
        handleChange(e2);
      };
      const handleInput = (e2) => {
        if (isComposing.value && props2.lazy) {
          renderValue.value = e2.target.value;
          return;
        }
        emit2("input", e2);
      };
      const handleBlur = (e2) => {
        emit2("blur", e2);
      };
      const handleFocus = (e2) => {
        emit2("focus", e2);
      };
      const focus = () => {
        if (inputRef.value) {
          inputRef.value.focus();
        }
      };
      const blur = () => {
        if (inputRef.value) {
          inputRef.value.blur();
        }
      };
      const handleKeyDown = (e2) => {
        emit2("keydown", e2);
      };
      const handleKeyUp = (e2) => {
        emit2("keyup", e2);
      };
      const setSelectionRange = (start2, end2, direction) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start2, end2, direction);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: computed(() => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input;
        }),
        setSelectionRange,
        select,
        getSelectionStart: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getSelectionStart();
        },
        getSelectionEnd: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getSelectionEnd();
        },
        getScrollTop: () => {
          var _a2;
          return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getScrollTop();
        }
      });
      const handleMousedown = (e2) => {
        emit2("mousedown", e2);
      };
      const handlePaste = (e2) => {
        emit2("paste", e2);
      };
      const styleString = computed(() => {
        return props2.style && typeof props2.style !== "string" ? styleObjectToString(props2.style) : props2.style;
      });
      return () => {
        const {
          style,
          lazy
        } = props2, restProps = __rest$B(props2, ["style", "lazy"]);
        return createVNode(BaseInputInner, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
          "style": styleString.value,
          "onInput": handleInput,
          "onChange": handleChange,
          "onBlur": handleBlur,
          "onFocus": handleFocus,
          "ref": inputRef,
          "value": renderValue.value,
          "onCompositionstart": onCompositionstart,
          "onCompositionend": onCompositionend,
          "onKeyup": handleKeyUp,
          "onKeydown": handleKeyDown,
          "onPaste": handlePaste,
          "onMousedown": handleMousedown
        }), null);
      };
    }
  });
  const inputProps$2 = {
    inputRef: PropTypes.any,
    prefixCls: String,
    id: String,
    inputElement: PropTypes.VueNode,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    autocomplete: String,
    editable: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    value: String,
    open: {
      type: Boolean,
      default: void 0
    },
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    /** Pass accessibility props to input */
    attrs: PropTypes.object,
    onKeydown: {
      type: Function
    },
    onMousedown: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onPaste: {
      type: Function
    },
    onCompositionstart: {
      type: Function
    },
    onCompositionend: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    }
  };
  const Input$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "SelectInput",
    inheritAttrs: false,
    props: inputProps$2,
    setup(props2) {
      let blurTimeout = null;
      const VCSelectContainerEvent = inject("VCSelectContainerEvent");
      return () => {
        var _a2;
        const {
          prefixCls,
          id,
          inputElement,
          disabled,
          tabindex,
          autofocus,
          autocomplete,
          editable,
          activeDescendantId,
          value,
          onKeydown,
          onMousedown,
          onChange,
          onPaste,
          onCompositionstart,
          onCompositionend,
          onFocus,
          onBlur,
          open: open2,
          inputRef,
          attrs
        } = props2;
        let inputNode = inputElement || createVNode(BaseInput$1, null, null);
        const inputProps2 = inputNode.props || {};
        const {
          onKeydown: onOriginKeyDown,
          onInput: onOriginInput,
          onFocus: onOriginFocus,
          onBlur: onOriginBlur,
          onMousedown: onOriginMouseDown,
          onCompositionstart: onOriginCompositionStart,
          onCompositionend: onOriginCompositionEnd,
          style
        } = inputProps2;
        inputNode = cloneElement(inputNode, _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({
          type: "search"
        }, inputProps2), {
          id,
          ref: inputRef,
          disabled,
          tabindex,
          lazy: false,
          autocomplete: autocomplete || "off",
          autofocus,
          class: classNames(`${prefixCls}-selection-search-input`, (_a2 = inputNode === null || inputNode === void 0 ? void 0 : inputNode.props) === null || _a2 === void 0 ? void 0 : _a2.class),
          role: "combobox",
          "aria-expanded": open2,
          "aria-haspopup": "listbox",
          "aria-owns": `${id}_list`,
          "aria-autocomplete": "list",
          "aria-controls": `${id}_list`,
          "aria-activedescendant": activeDescendantId
        }), attrs), {
          value: editable ? value : "",
          readonly: !editable,
          unselectable: !editable ? "on" : null,
          style: _extends$1(_extends$1({}, style), {
            opacity: editable ? null : 0
          }),
          onKeydown: (event) => {
            onKeydown(event);
            if (onOriginKeyDown) {
              onOriginKeyDown(event);
            }
          },
          onMousedown: (event) => {
            onMousedown(event);
            if (onOriginMouseDown) {
              onOriginMouseDown(event);
            }
          },
          onInput: (event) => {
            onChange(event);
            if (onOriginInput) {
              onOriginInput(event);
            }
          },
          onCompositionstart(event) {
            onCompositionstart(event);
            if (onOriginCompositionStart) {
              onOriginCompositionStart(event);
            }
          },
          onCompositionend(event) {
            onCompositionend(event);
            if (onOriginCompositionEnd) {
              onOriginCompositionEnd(event);
            }
          },
          onPaste,
          onFocus: function() {
            clearTimeout(blurTimeout);
            onOriginFocus && onOriginFocus(arguments.length <= 0 ? void 0 : arguments[0]);
            onFocus && onFocus(arguments.length <= 0 ? void 0 : arguments[0]);
            VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.focus(arguments.length <= 0 ? void 0 : arguments[0]);
          },
          onBlur: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            blurTimeout = setTimeout(() => {
              onOriginBlur && onOriginBlur(args[0]);
              onBlur && onBlur(args[0]);
              VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.blur(args[0]);
            }, 100);
          }
        }), inputNode.type === "textarea" ? {} : {
          type: "search"
        }), true, true);
        return inputNode;
      };
    }
  });
  const attributes = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`;
  const eventsName = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`;
  const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
  const ariaPrefix = "aria-";
  const dataPrefix = "data-";
  function match(key2, prefix) {
    return key2.indexOf(prefix) === 0;
  }
  function pickAttrs(props2) {
    let ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = _extends$1({}, ariaOnly);
    }
    const attrs = {};
    Object.keys(props2).forEach((key2) => {
      if (
        // Aria
        mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || // Data
        mergedConfig.data && match(key2, dataPrefix) || // Attr
        mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))
      ) {
        attrs[key2] = props2[key2];
      }
    });
    return attrs;
  }
  const OverflowContextProviderKey = Symbol("OverflowContextProviderKey");
  const OverflowContextProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "OverflowContextProvider",
    inheritAttrs: false,
    props: {
      value: {
        type: Object
      }
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      provide(OverflowContextProviderKey, computed(() => props2.value));
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const useInjectOverflowContext = () => {
    return inject(OverflowContextProviderKey, computed(() => null));
  };
  var __rest$A = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const UNDEFINED$1 = void 0;
  const Item$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Item",
    props: {
      prefixCls: String,
      item: PropTypes.any,
      renderItem: Function,
      responsive: Boolean,
      itemKey: {
        type: [String, Number]
      },
      registerSize: Function,
      display: Boolean,
      order: Number,
      component: PropTypes.any,
      invalidate: Boolean
    },
    setup(props2, _ref) {
      let {
        slots,
        expose
      } = _ref;
      const mergedHidden = computed(() => props2.responsive && !props2.display);
      const itemNodeRef = ref();
      expose({
        itemNodeRef
      });
      function internalRegisterSize(width) {
        props2.registerSize(props2.itemKey, width);
      }
      onUnmounted(() => {
        internalRegisterSize(null);
      });
      return () => {
        var _a2;
        const {
          prefixCls,
          invalidate,
          item,
          renderItem,
          responsive,
          registerSize,
          itemKey: itemKey2,
          display,
          order,
          component: Component = "div"
        } = props2, restProps = __rest$A(props2, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]);
        const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        const childNode = renderItem && item !== UNDEFINED$1 ? renderItem(item) : children;
        let overflowStyle;
        if (!invalidate) {
          overflowStyle = {
            opacity: mergedHidden.value ? 0 : 1,
            height: mergedHidden.value ? 0 : UNDEFINED$1,
            overflowY: mergedHidden.value ? "hidden" : UNDEFINED$1,
            order: responsive ? order : UNDEFINED$1,
            pointerEvents: mergedHidden.value ? "none" : UNDEFINED$1,
            position: mergedHidden.value ? "absolute" : UNDEFINED$1
          };
        }
        const overflowProps2 = {};
        if (mergedHidden.value) {
          overflowProps2["aria-hidden"] = true;
        }
        return createVNode(ResizeObserver$1, {
          "disabled": !responsive,
          "onResize": (_ref2) => {
            let {
              offsetWidth
            } = _ref2;
            internalRegisterSize(offsetWidth);
          }
        }, {
          default: () => createVNode(Component, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(!invalidate && prefixCls),
            "style": overflowStyle
          }, overflowProps2), restProps), {}, {
            "ref": itemNodeRef
          }), {
            default: () => [childNode]
          })
        });
      };
    }
  });
  var __rest$z = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const RawItem = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "RawItem",
    inheritAttrs: false,
    props: {
      component: PropTypes.any,
      title: PropTypes.any,
      id: String,
      onMouseenter: {
        type: Function
      },
      onMouseleave: {
        type: Function
      },
      onClick: {
        type: Function
      },
      onKeydown: {
        type: Function
      },
      onFocus: {
        type: Function
      },
      role: String,
      tabindex: Number
    },
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const context = useInjectOverflowContext();
      return () => {
        var _a2;
        if (!context.value) {
          const {
            component: Component = "div"
          } = props2, restProps2 = __rest$z(props2, ["component"]);
          return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, restProps2), attrs), {
            default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
          });
        }
        const _b2 = context.value, {
          className: contextClassName
        } = _b2, restContext = __rest$z(_b2, ["className"]);
        const {
          class: className
        } = attrs, restProps = __rest$z(attrs, ["class"]);
        return createVNode(OverflowContextProvider, {
          "value": null
        }, {
          default: () => [createVNode(Item$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(contextClassName, className)
          }, restContext), restProps), props2), slots)]
        });
      };
    }
  });
  var __rest$y = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const RESPONSIVE = "responsive";
  const INVALIDATE = "invalidate";
  function defaultRenderRest(omittedItems) {
    return `+ ${omittedItems.length} ...`;
  }
  const overflowProps = () => {
    return {
      id: String,
      prefixCls: String,
      data: Array,
      itemKey: [String, Number, Function],
      /** Used for `responsive`. It will limit render node to avoid perf issue */
      itemWidth: {
        type: Number,
        default: 10
      },
      renderItem: Function,
      /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
      renderRawItem: Function,
      maxCount: [Number, String],
      renderRest: Function,
      /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
      renderRawRest: Function,
      suffix: PropTypes.any,
      component: String,
      itemComponent: PropTypes.any,
      /** @private This API may be refactor since not well design */
      onVisibleChange: Function,
      /** When set to `full`, ssr will render full items by default and remove at client side */
      ssr: String,
      onMousedown: Function,
      role: String
    };
  };
  const Overflow = /* @__PURE__ */ defineComponent({
    name: "Overflow",
    inheritAttrs: false,
    props: overflowProps(),
    emits: ["visibleChange"],
    setup(props2, _ref) {
      let {
        attrs,
        emit: emit2,
        slots
      } = _ref;
      const fullySSR = computed(() => props2.ssr === "full");
      const containerWidth = shallowRef(null);
      const mergedContainerWidth = computed(() => containerWidth.value || 0);
      const itemWidths = shallowRef(/* @__PURE__ */ new Map());
      const prevRestWidth = shallowRef(0);
      const restWidth = shallowRef(0);
      const suffixWidth = shallowRef(0);
      const suffixFixedStart = shallowRef(null);
      const displayCount = shallowRef(null);
      const mergedDisplayCount = computed(() => {
        if (displayCount.value === null && fullySSR.value) {
          return Number.MAX_SAFE_INTEGER;
        }
        return displayCount.value || 0;
      });
      const restReady = shallowRef(false);
      const itemPrefixCls = computed(() => `${props2.prefixCls}-item`);
      const mergedRestWidth = computed(() => Math.max(prevRestWidth.value, restWidth.value));
      const isResponsive = computed(() => !!(props2.data.length && props2.maxCount === RESPONSIVE));
      const invalidate = computed(() => props2.maxCount === INVALIDATE);
      const showRest = computed(() => isResponsive.value || typeof props2.maxCount === "number" && props2.data.length > props2.maxCount);
      const mergedData = computed(() => {
        let items = props2.data;
        if (isResponsive.value) {
          if (containerWidth.value === null && fullySSR.value) {
            items = props2.data;
          } else {
            items = props2.data.slice(0, Math.min(props2.data.length, mergedContainerWidth.value / props2.itemWidth));
          }
        } else if (typeof props2.maxCount === "number") {
          items = props2.data.slice(0, props2.maxCount);
        }
        return items;
      });
      const omittedItems = computed(() => {
        if (isResponsive.value) {
          return props2.data.slice(mergedDisplayCount.value + 1);
        }
        return props2.data.slice(mergedData.value.length);
      });
      const getKey2 = (item, index2) => {
        var _a2;
        if (typeof props2.itemKey === "function") {
          return props2.itemKey(item);
        }
        return (_a2 = props2.itemKey && (item === null || item === void 0 ? void 0 : item[props2.itemKey])) !== null && _a2 !== void 0 ? _a2 : index2;
      };
      const mergedRenderItem = computed(() => props2.renderItem || ((item) => item));
      const updateDisplayCount = (count, notReady) => {
        displayCount.value = count;
        if (!notReady) {
          restReady.value = count < props2.data.length - 1;
          emit2("visibleChange", count);
        }
      };
      const onOverflowResize = (_2, element) => {
        containerWidth.value = element.clientWidth;
      };
      const registerSize = (key2, width) => {
        const clone2 = new Map(itemWidths.value);
        if (width === null) {
          clone2.delete(key2);
        } else {
          clone2.set(key2, width);
        }
        itemWidths.value = clone2;
      };
      const registerOverflowSize = (_2, width) => {
        prevRestWidth.value = restWidth.value;
        restWidth.value = width;
      };
      const registerSuffixSize = (_2, width) => {
        suffixWidth.value = width;
      };
      const getItemWidth = (index2) => {
        return itemWidths.value.get(getKey2(mergedData.value[index2], index2));
      };
      watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, () => props2.itemKey, mergedData], () => {
        if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
          let totalWidth = suffixWidth.value;
          const len2 = mergedData.value.length;
          const lastIndex = len2 - 1;
          if (!len2) {
            updateDisplayCount(0);
            suffixFixedStart.value = null;
            return;
          }
          for (let i2 = 0; i2 < len2; i2 += 1) {
            const currentItemWidth = getItemWidth(i2);
            if (currentItemWidth === void 0) {
              updateDisplayCount(i2 - 1, true);
              break;
            }
            totalWidth += currentItemWidth;
            if (
              // Only one means `totalWidth` is the final width
              lastIndex === 0 && totalWidth <= mergedContainerWidth.value || // Last two width will be the final width
              i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value
            ) {
              updateDisplayCount(lastIndex);
              suffixFixedStart.value = null;
              break;
            } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
              updateDisplayCount(i2 - 1);
              suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
              break;
            }
          }
          if (props2.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {
            suffixFixedStart.value = null;
          }
        }
      });
      return () => {
        const displayRest = restReady.value && !!omittedItems.value.length;
        const {
          itemComponent,
          renderRawItem,
          renderRawRest,
          renderRest,
          prefixCls = "rc-overflow",
          suffix,
          component: Component = "div",
          id,
          onMousedown
        } = props2;
        const {
          class: className,
          style
        } = attrs, restAttrs = __rest$y(attrs, ["class", "style"]);
        let suffixStyle = {};
        if (suffixFixedStart.value !== null && isResponsive.value) {
          suffixStyle = {
            position: "absolute",
            left: `${suffixFixedStart.value}px`,
            top: 0
          };
        }
        const itemSharedProps = {
          prefixCls: itemPrefixCls.value,
          responsive: isResponsive.value,
          component: itemComponent,
          invalidate: invalidate.value
        };
        const internalRenderItemNode = renderRawItem ? (item, index2) => {
          const key2 = getKey2(item, index2);
          return createVNode(OverflowContextProvider, {
            "key": key2,
            "value": _extends$1(_extends$1({}, itemSharedProps), {
              order: index2,
              item,
              itemKey: key2,
              registerSize,
              display: index2 <= mergedDisplayCount.value
            })
          }, {
            default: () => [renderRawItem(item, index2)]
          });
        } : (item, index2) => {
          const key2 = getKey2(item, index2);
          return createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
            "order": index2,
            "key": key2,
            "item": item,
            "renderItem": mergedRenderItem.value,
            "itemKey": key2,
            "registerSize": registerSize,
            "display": index2 <= mergedDisplayCount.value
          }), null);
        };
        let restNode = () => null;
        const restContextProps = {
          order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
          className: `${itemPrefixCls.value} ${itemPrefixCls.value}-rest`,
          registerSize: registerOverflowSize,
          display: displayRest
        };
        if (!renderRawRest) {
          const mergedRenderRest = renderRest || defaultRenderRest;
          restNode = () => createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps), {
            default: () => typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems.value) : mergedRenderRest
          });
        } else if (renderRawRest) {
          restNode = () => createVNode(OverflowContextProvider, {
            "value": _extends$1(_extends$1({}, itemSharedProps), restContextProps)
          }, {
            default: () => [renderRawRest(omittedItems.value)]
          });
        }
        const overflowNode = () => {
          var _a2;
          return createVNode(Component, _objectSpread2$1({
            "id": id,
            "class": classNames(!invalidate.value && prefixCls, className),
            "style": style,
            "onMousedown": onMousedown,
            "role": props2.role
          }, restAttrs), {
            default: () => [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
              "order": mergedDisplayCount.value,
              "class": `${itemPrefixCls.value}-suffix`,
              "registerSize": registerSuffixSize,
              "display": true,
              "style": suffixStyle
            }), {
              default: () => suffix
            }), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
          });
        };
        return createVNode(ResizeObserver$1, {
          "disabled": !isResponsive.value,
          "onResize": onOverflowResize
        }, {
          default: overflowNode
        });
      };
    }
  });
  Overflow.Item = RawItem;
  Overflow.RESPONSIVE = RESPONSIVE;
  Overflow.INVALIDATE = INVALIDATE;
  const TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
  function useInjectLegacySelectContext() {
    return inject(TreeSelectLegacyContextPropsKey, {});
  }
  const props$1 = {
    id: String,
    prefixCls: String,
    values: PropTypes.array,
    open: {
      type: Boolean,
      default: void 0
    },
    searchValue: String,
    inputRef: PropTypes.any,
    placeholder: PropTypes.any,
    disabled: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    autocomplete: String,
    activeDescendantId: String,
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    compositionStatus: Boolean,
    removeIcon: PropTypes.any,
    choiceTransitionName: String,
    maxTagCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: PropTypes.any.def(() => (omittedValues) => `+ ${omittedValues.length} ...`),
    tagRender: Function,
    onToggleOpen: {
      type: Function
    },
    onRemove: Function,
    onInputChange: Function,
    onInputPaste: Function,
    onInputKeyDown: Function,
    onInputMouseDown: Function,
    onInputCompositionStart: Function,
    onInputCompositionEnd: Function
  };
  const onPreventMouseDown = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  const SelectSelector = /* @__PURE__ */ defineComponent({
    name: "MultipleSelectSelector",
    inheritAttrs: false,
    props: props$1,
    setup(props2) {
      const measureRef = shallowRef();
      const inputWidth = shallowRef(0);
      const focused = shallowRef(false);
      const legacyTreeSelectContext = useInjectLegacySelectContext();
      const selectionPrefixCls = computed(() => `${props2.prefixCls}-selection`);
      const inputValue = computed(() => props2.open || props2.mode === "tags" ? props2.searchValue : "");
      const inputEditable = computed(() => props2.mode === "tags" || props2.showSearch && (props2.open || focused.value));
      const targetValue = ref("");
      watchEffect(() => {
        targetValue.value = inputValue.value;
      });
      onMounted(() => {
        watch(targetValue, () => {
          inputWidth.value = measureRef.value.scrollWidth;
        }, {
          flush: "post",
          immediate: true
        });
      });
      function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
        return createVNode("span", {
          "class": classNames(`${selectionPrefixCls.value}-item`, {
            [`${selectionPrefixCls.value}-item-disabled`]: itemDisabled
          }),
          "title": typeof title === "string" || typeof title === "number" ? title.toString() : void 0
        }, [createVNode("span", {
          "class": `${selectionPrefixCls.value}-item-content`
        }, [content]), closable && createVNode(TransBtn, {
          "class": `${selectionPrefixCls.value}-item-remove`,
          "onMousedown": onPreventMouseDown,
          "onClick": onClose,
          "customizeIcon": props2.removeIcon
        }, {
          default: () => [createTextVNode("×")]
        })]);
      }
      function customizeRenderSelector(value, content, itemDisabled, closable, onClose, option) {
        var _a2;
        const onMouseDown = (e2) => {
          onPreventMouseDown(e2);
          props2.onToggleOpen(!open);
        };
        let originData = option;
        if (legacyTreeSelectContext.keyEntities) {
          originData = ((_a2 = legacyTreeSelectContext.keyEntities[value]) === null || _a2 === void 0 ? void 0 : _a2.node) || {};
        }
        return createVNode("span", {
          "key": value,
          "onMousedown": onMouseDown
        }, [props2.tagRender({
          label: content,
          value,
          disabled: itemDisabled,
          closable,
          onClose,
          option: originData
        })]);
      }
      function renderItem(valueItem) {
        const {
          disabled: itemDisabled,
          label,
          value,
          option
        } = valueItem;
        const closable = !props2.disabled && !itemDisabled;
        let displayLabel = label;
        if (typeof props2.maxTagTextLength === "number") {
          if (typeof label === "string" || typeof label === "number") {
            const strLabel = String(displayLabel);
            if (strLabel.length > props2.maxTagTextLength) {
              displayLabel = `${strLabel.slice(0, props2.maxTagTextLength)}...`;
            }
          }
        }
        const onClose = (event) => {
          var _a2;
          if (event) event.stopPropagation();
          (_a2 = props2.onRemove) === null || _a2 === void 0 ? void 0 : _a2.call(props2, valueItem);
        };
        return typeof props2.tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, option) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
      }
      function renderRest(omittedValues) {
        const {
          maxTagPlaceholder = (omittedValues2) => `+ ${omittedValues2.length} ...`
        } = props2;
        const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        return defaultRenderSelector(content, content, false);
      }
      const handleInput = (e2) => {
        const composing = e2.target.composing;
        targetValue.value = e2.target.value;
        if (!composing) {
          props2.onInputChange(e2);
        }
      };
      return () => {
        const {
          id,
          prefixCls,
          values,
          open: open2,
          inputRef,
          placeholder: placeholder2,
          disabled,
          autofocus,
          autocomplete,
          activeDescendantId,
          tabindex,
          compositionStatus,
          onInputPaste,
          onInputKeyDown,
          onInputMouseDown,
          onInputCompositionStart,
          onInputCompositionEnd
        } = props2;
        const inputNode = createVNode("div", {
          "class": `${selectionPrefixCls.value}-search`,
          "style": {
            width: inputWidth.value + "px"
          },
          "key": "input"
        }, [createVNode(Input$1, {
          "inputRef": inputRef,
          "open": open2,
          "prefixCls": prefixCls,
          "id": id,
          "inputElement": null,
          "disabled": disabled,
          "autofocus": autofocus,
          "autocomplete": autocomplete,
          "editable": inputEditable.value,
          "activeDescendantId": activeDescendantId,
          "value": targetValue.value,
          "onKeydown": onInputKeyDown,
          "onMousedown": onInputMouseDown,
          "onChange": handleInput,
          "onPaste": onInputPaste,
          "onCompositionstart": onInputCompositionStart,
          "onCompositionend": onInputCompositionEnd,
          "tabindex": tabindex,
          "attrs": pickAttrs(props2, true),
          "onFocus": () => focused.value = true,
          "onBlur": () => focused.value = false
        }, null), createVNode("span", {
          "ref": measureRef,
          "class": `${selectionPrefixCls.value}-search-mirror`,
          "aria-hidden": true
        }, [targetValue.value, createTextVNode(" ")])]);
        const selectionNode = createVNode(Overflow, {
          "prefixCls": `${selectionPrefixCls.value}-overflow`,
          "data": values,
          "renderItem": renderItem,
          "renderRest": renderRest,
          "suffix": inputNode,
          "itemKey": "key",
          "maxCount": props2.maxTagCount,
          "key": "overflow"
        }, null);
        return createVNode(Fragment, null, [selectionNode, !values.length && !inputValue.value && !compositionStatus && createVNode("span", {
          "class": `${selectionPrefixCls.value}-placeholder`
        }, [placeholder2])]);
      };
    }
  });
  const props = {
    inputElement: PropTypes.any,
    id: String,
    prefixCls: String,
    values: PropTypes.array,
    open: {
      type: Boolean,
      default: void 0
    },
    searchValue: String,
    inputRef: PropTypes.any,
    placeholder: PropTypes.any,
    compositionStatus: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    autocomplete: String,
    activeDescendantId: String,
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    activeValue: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    optionLabelRender: Function,
    onInputChange: Function,
    onInputPaste: Function,
    onInputKeyDown: Function,
    onInputMouseDown: Function,
    onInputCompositionStart: Function,
    onInputCompositionEnd: Function
  };
  const SingleSelector = /* @__PURE__ */ defineComponent({
    name: "SingleSelector",
    setup(props2) {
      const inputChanged = shallowRef(false);
      const combobox = computed(() => props2.mode === "combobox");
      const inputEditable = computed(() => combobox.value || props2.showSearch);
      const inputValue = computed(() => {
        let inputValue2 = props2.searchValue || "";
        if (combobox.value && props2.activeValue && !inputChanged.value) {
          inputValue2 = props2.activeValue;
        }
        return inputValue2;
      });
      const legacyTreeSelectContext = useInjectLegacySelectContext();
      watch([combobox, () => props2.activeValue], () => {
        if (combobox.value) {
          inputChanged.value = false;
        }
      }, {
        immediate: true
      });
      const hasTextInput = computed(() => props2.mode !== "combobox" && !props2.open && !props2.showSearch ? false : !!inputValue.value || props2.compositionStatus);
      const title = computed(() => {
        const item = props2.values[0];
        return item && (typeof item.label === "string" || typeof item.label === "number") ? item.label.toString() : void 0;
      });
      const renderPlaceholder = () => {
        if (props2.values[0]) {
          return null;
        }
        const hiddenStyle = hasTextInput.value ? {
          visibility: "hidden"
        } : void 0;
        return createVNode("span", {
          "class": `${props2.prefixCls}-selection-placeholder`,
          "style": hiddenStyle
        }, [props2.placeholder]);
      };
      const handleInput = (e2) => {
        const composing = e2.target.composing;
        if (!composing) {
          inputChanged.value = true;
          props2.onInputChange(e2);
        }
      };
      return () => {
        var _a2, _b2, _c2, _d;
        const {
          inputElement,
          prefixCls,
          id,
          values,
          inputRef,
          disabled,
          autofocus,
          autocomplete,
          activeDescendantId,
          open: open2,
          tabindex,
          optionLabelRender,
          onInputKeyDown,
          onInputMouseDown,
          onInputPaste,
          onInputCompositionStart,
          onInputCompositionEnd
        } = props2;
        const item = values[0];
        let titleNode = null;
        if (item && legacyTreeSelectContext.customSlots) {
          const key2 = (_a2 = item.key) !== null && _a2 !== void 0 ? _a2 : item.value;
          const originData = ((_b2 = legacyTreeSelectContext.keyEntities[key2]) === null || _b2 === void 0 ? void 0 : _b2.node) || {};
          titleNode = legacyTreeSelectContext.customSlots[(_c2 = originData.slots) === null || _c2 === void 0 ? void 0 : _c2.title] || legacyTreeSelectContext.customSlots.title || item.label;
          if (typeof titleNode === "function") {
            titleNode = titleNode(originData);
          }
        } else {
          titleNode = optionLabelRender && item ? optionLabelRender(item.option) : item === null || item === void 0 ? void 0 : item.label;
        }
        return createVNode(Fragment, null, [createVNode("span", {
          "class": `${prefixCls}-selection-search`
        }, [createVNode(Input$1, {
          "inputRef": inputRef,
          "prefixCls": prefixCls,
          "id": id,
          "open": open2,
          "inputElement": inputElement,
          "disabled": disabled,
          "autofocus": autofocus,
          "autocomplete": autocomplete,
          "editable": inputEditable.value,
          "activeDescendantId": activeDescendantId,
          "value": inputValue.value,
          "onKeydown": onInputKeyDown,
          "onMousedown": onInputMouseDown,
          "onChange": handleInput,
          "onPaste": onInputPaste,
          "onCompositionstart": onInputCompositionStart,
          "onCompositionend": onInputCompositionEnd,
          "tabindex": tabindex,
          "attrs": pickAttrs(props2, true)
        }, null)]), !combobox.value && item && !hasTextInput.value && createVNode("span", {
          "class": `${prefixCls}-selection-item`,
          "title": title.value
        }, [createVNode(Fragment, {
          "key": (_d = item.key) !== null && _d !== void 0 ? _d : item.value
        }, [titleNode])]), renderPlaceholder()]);
      };
    }
  });
  SingleSelector.props = props;
  SingleSelector.inheritAttrs = false;
  function isValidateOpenKey(currentKeyCode) {
    return ![
      // System function button
      KeyCode.ESC,
      KeyCode.SHIFT,
      KeyCode.BACKSPACE,
      KeyCode.TAB,
      KeyCode.WIN_KEY,
      KeyCode.ALT,
      KeyCode.META,
      KeyCode.WIN_KEY_RIGHT,
      KeyCode.CTRL,
      KeyCode.SEMICOLON,
      KeyCode.EQUALS,
      KeyCode.CAPS_LOCK,
      KeyCode.CONTEXT_MENU,
      // F1-F12
      KeyCode.F1,
      KeyCode.F2,
      KeyCode.F3,
      KeyCode.F4,
      KeyCode.F5,
      KeyCode.F6,
      KeyCode.F7,
      KeyCode.F8,
      KeyCode.F9,
      KeyCode.F10,
      KeyCode.F11,
      KeyCode.F12
    ].includes(currentKeyCode);
  }
  function useLock() {
    let duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
    let lock = null;
    let timeout;
    onBeforeUnmount(() => {
      clearTimeout(timeout);
    });
    function doLock(locked) {
      if (locked || lock === null) {
        lock = locked;
      }
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        lock = null;
      }, duration);
    }
    return [() => lock, doLock];
  }
  function createRef() {
    const func = (node2) => {
      func.current = node2;
    };
    return func;
  }
  const Selector = /* @__PURE__ */ defineComponent({
    name: "Selector",
    inheritAttrs: false,
    props: {
      id: String,
      prefixCls: String,
      showSearch: {
        type: Boolean,
        default: void 0
      },
      open: {
        type: Boolean,
        default: void 0
      },
      /** Display in the Selector value, it's not same as `value` prop */
      values: PropTypes.array,
      multiple: {
        type: Boolean,
        default: void 0
      },
      mode: String,
      searchValue: String,
      activeValue: String,
      inputElement: PropTypes.any,
      autofocus: {
        type: Boolean,
        default: void 0
      },
      activeDescendantId: String,
      tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      disabled: {
        type: Boolean,
        default: void 0
      },
      placeholder: PropTypes.any,
      removeIcon: PropTypes.any,
      // Tags
      maxTagCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      maxTagTextLength: Number,
      maxTagPlaceholder: PropTypes.any,
      tagRender: Function,
      optionLabelRender: Function,
      /** Check if `tokenSeparators` contains `\n` or `\r\n` */
      tokenWithEnter: {
        type: Boolean,
        default: void 0
      },
      // Motion
      choiceTransitionName: String,
      onToggleOpen: {
        type: Function
      },
      /** `onSearch` returns go next step boolean to check if need do toggle open */
      onSearch: Function,
      onSearchSubmit: Function,
      onRemove: Function,
      onInputKeyDown: {
        type: Function
      },
      /**
       * @private get real dom for trigger align.
       * This may be removed after React provides replacement of `findDOMNode`
       */
      domRef: Function
    },
    setup(props2, _ref) {
      let {
        expose
      } = _ref;
      const inputRef = createRef();
      const compositionStatus = ref(false);
      const [getInputMouseDown, setInputMouseDown] = useLock(0);
      const onInternalInputKeyDown = (event) => {
        const {
          which
        } = event;
        if (which === KeyCode.UP || which === KeyCode.DOWN) {
          event.preventDefault();
        }
        if (props2.onInputKeyDown) {
          props2.onInputKeyDown(event);
        }
        if (which === KeyCode.ENTER && props2.mode === "tags" && !compositionStatus.value && !props2.open) {
          props2.onSearchSubmit(event.target.value);
        }
        if (isValidateOpenKey(which)) {
          props2.onToggleOpen(true);
        }
      };
      const onInternalInputMouseDown = () => {
        setInputMouseDown(true);
      };
      let pastedText = null;
      const triggerOnSearch = (value) => {
        if (props2.onSearch(value, true, compositionStatus.value) !== false) {
          props2.onToggleOpen(true);
        }
      };
      const onInputCompositionStart = () => {
        compositionStatus.value = true;
      };
      const onInputCompositionEnd = (e2) => {
        compositionStatus.value = false;
        if (props2.mode !== "combobox") {
          triggerOnSearch(e2.target.value);
        }
      };
      const onInputChange = (event) => {
        let {
          target: {
            value
          }
        } = event;
        if (props2.tokenWithEnter && pastedText && /[\r\n]/.test(pastedText)) {
          const replacedText = pastedText.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
          value = value.replace(replacedText, pastedText);
        }
        pastedText = null;
        triggerOnSearch(value);
      };
      const onInputPaste = (e2) => {
        const {
          clipboardData
        } = e2;
        const value = clipboardData.getData("text");
        pastedText = value;
      };
      const onClick = (_ref2) => {
        let {
          target
        } = _ref2;
        if (target !== inputRef.current) {
          const isIE = document.body.style.msTouchAction !== void 0;
          if (isIE) {
            setTimeout(() => {
              inputRef.current.focus();
            });
          } else {
            inputRef.current.focus();
          }
        }
      };
      const onMousedown = (event) => {
        const inputMouseDown = getInputMouseDown();
        if (event.target !== inputRef.current && !inputMouseDown) {
          event.preventDefault();
        }
        if (props2.mode !== "combobox" && (!props2.showSearch || !inputMouseDown) || !props2.open) {
          if (props2.open) {
            props2.onSearch("", true, false);
          }
          props2.onToggleOpen();
        }
      };
      expose({
        focus: () => {
          inputRef.current.focus();
        },
        blur: () => {
          inputRef.current.blur();
        }
      });
      return () => {
        const {
          prefixCls,
          domRef,
          mode
        } = props2;
        const sharedProps = {
          inputRef,
          onInputKeyDown: onInternalInputKeyDown,
          onInputMouseDown: onInternalInputMouseDown,
          onInputChange,
          onInputPaste,
          compositionStatus: compositionStatus.value,
          onInputCompositionStart,
          onInputCompositionEnd
        };
        const selectNode = mode === "multiple" || mode === "tags" ? createVNode(SelectSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null) : createVNode(SingleSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null);
        return createVNode("div", {
          "ref": domRef,
          "class": `${prefixCls}-selector`,
          "onClick": onClick,
          "onMousedown": onMousedown
        }, [selectNode]);
      };
    }
  });
  function useSelectTriggerControl(refs, open2, triggerOpen) {
    function onGlobalMouseDown(event) {
      var _a2, _b2, _c2;
      let target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      const elements = [(_a2 = refs[0]) === null || _a2 === void 0 ? void 0 : _a2.value, (_c2 = (_b2 = refs[1]) === null || _b2 === void 0 ? void 0 : _b2.value) === null || _c2 === void 0 ? void 0 : _c2.getPopupElement()];
      if (open2.value && elements.every((element) => element && !element.contains(target) && element !== target)) {
        triggerOpen(false);
      }
    }
    onMounted(() => {
      window.addEventListener("mousedown", onGlobalMouseDown);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("mousedown", onGlobalMouseDown);
    });
  }
  function useDelayReset() {
    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    const bool = shallowRef(false);
    let delay;
    const cancelLatest = () => {
      clearTimeout(delay);
    };
    onMounted(() => {
      cancelLatest();
    });
    const delaySetBool = (value, callback) => {
      cancelLatest();
      delay = setTimeout(() => {
        bool.value = value;
        if (callback) {
          callback();
        }
      }, timeout);
    };
    return [bool, delaySetBool, cancelLatest];
  }
  const BaseSelectContextKey = Symbol("BaseSelectContextKey");
  function useProvideBaseSelectProps(props2) {
    return provide(BaseSelectContextKey, props2);
  }
  function useBaseProps() {
    return inject(BaseSelectContextKey, {});
  }
  const isMobile = () => {
    if (typeof navigator === "undefined" || typeof window === "undefined") {
      return false;
    }
    const agent = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substring(0, 4));
  };
  function toReactive(objectRef) {
    if (!isRef(objectRef)) return reactive(objectRef);
    const proxy = new Proxy({}, {
      get(_2, p2, receiver) {
        return Reflect.get(objectRef.value, p2, receiver);
      },
      set(_2, p2, value) {
        objectRef.value[p2] = value;
        return true;
      },
      deleteProperty(_2, p2) {
        return Reflect.deleteProperty(objectRef.value, p2);
      },
      has(_2, p2) {
        return Reflect.has(objectRef.value, p2);
      },
      ownKeys() {
        return Object.keys(objectRef.value);
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    });
    return reactive(proxy);
  }
  var __rest$x = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"];
  const baseSelectPrivateProps = () => {
    return {
      prefixCls: String,
      id: String,
      omitDomProps: Array,
      // >>> Value
      displayValues: Array,
      onDisplayValuesChange: Function,
      // >>> Active
      /** Current dropdown list active item string value */
      activeValue: String,
      /** Link search input with target element */
      activeDescendantId: String,
      onActiveValueChange: Function,
      // >>> Search
      searchValue: String,
      /** Trigger onSearch, return false to prevent trigger open event */
      onSearch: Function,
      /** Trigger when search text match the `tokenSeparators`. Will provide split content */
      onSearchSplit: Function,
      maxLength: Number,
      OptionList: PropTypes.any,
      /** Tell if provided `options` is empty */
      emptyOptions: Boolean
    };
  };
  const baseSelectPropsWithoutPrivate = () => {
    return {
      showSearch: {
        type: Boolean,
        default: void 0
      },
      tagRender: {
        type: Function
      },
      optionLabelRender: {
        type: Function
      },
      direction: {
        type: String
      },
      // MISC
      tabindex: Number,
      autofocus: Boolean,
      notFoundContent: PropTypes.any,
      placeholder: PropTypes.any,
      onClear: Function,
      choiceTransitionName: String,
      // >>> Mode
      mode: String,
      // >>> Status
      disabled: {
        type: Boolean,
        default: void 0
      },
      loading: {
        type: Boolean,
        default: void 0
      },
      // >>> Open
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        default: void 0
      },
      onDropdownVisibleChange: {
        type: Function
      },
      // >>> Customize Input
      /** @private Internal usage. Do not use in your production. */
      getInputElement: {
        type: Function
      },
      /** @private Internal usage. Do not use in your production. */
      getRawInputElement: {
        type: Function
      },
      // >>> Selector
      maxTagTextLength: Number,
      maxTagCount: {
        type: [String, Number]
      },
      maxTagPlaceholder: PropTypes.any,
      // >>> Search
      tokenSeparators: {
        type: Array
      },
      // >>> Icons
      allowClear: {
        type: Boolean,
        default: void 0
      },
      showArrow: {
        type: Boolean,
        default: void 0
      },
      inputIcon: PropTypes.any,
      /** Clear all icon */
      clearIcon: PropTypes.any,
      /** Selector remove icon */
      removeIcon: PropTypes.any,
      // >>> Dropdown
      animation: String,
      transitionName: String,
      dropdownStyle: {
        type: Object
      },
      dropdownClassName: String,
      dropdownMatchSelectWidth: {
        type: [Boolean, Number],
        default: void 0
      },
      dropdownRender: {
        type: Function
      },
      dropdownAlign: Object,
      placement: {
        type: String
      },
      getPopupContainer: {
        type: Function
      },
      // >>> Focus
      showAction: {
        type: Array
      },
      onBlur: {
        type: Function
      },
      onFocus: {
        type: Function
      },
      // >>> Rest Events
      onKeyup: Function,
      onKeydown: Function,
      onMousedown: Function,
      onPopupScroll: Function,
      onInputKeyDown: Function,
      onMouseenter: Function,
      onMouseleave: Function,
      onClick: Function
    };
  };
  const baseSelectProps = () => {
    return _extends$1(_extends$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate());
  };
  function isMultiple$1(mode) {
    return mode === "tags" || mode === "multiple";
  }
  const BaseSelect = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "BaseSelect",
    inheritAttrs: false,
    props: initDefaultProps(baseSelectProps(), {
      showAction: [],
      notFoundContent: "Not Found"
    }),
    setup(props2, _ref) {
      let {
        attrs,
        expose,
        slots
      } = _ref;
      const multiple = computed(() => isMultiple$1(props2.mode));
      const mergedShowSearch = computed(() => props2.showSearch !== void 0 ? props2.showSearch : multiple.value || props2.mode === "combobox");
      const mobile = shallowRef(false);
      onMounted(() => {
        mobile.value = isMobile();
      });
      const legacyTreeSelectContext = useInjectLegacySelectContext();
      const containerRef = shallowRef(null);
      const selectorDomRef = createRef();
      const triggerRef2 = shallowRef(null);
      const selectorRef = shallowRef(null);
      const listRef = shallowRef(null);
      const blurRef = ref(false);
      const [mockFocused, setMockFocused, cancelSetMockFocused] = useDelayReset();
      const focus = () => {
        var _a2;
        (_a2 = selectorRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = selectorRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur,
        scrollTo: (arg) => {
          var _a2;
          return (_a2 = listRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
        }
      });
      const mergedSearchValue = computed(() => {
        var _a2;
        if (props2.mode !== "combobox") {
          return props2.searchValue;
        }
        const val = (_a2 = props2.displayValues[0]) === null || _a2 === void 0 ? void 0 : _a2.value;
        return typeof val === "string" || typeof val === "number" ? String(val) : "";
      });
      const initOpen = props2.open !== void 0 ? props2.open : props2.defaultOpen;
      const innerOpen = shallowRef(initOpen);
      const mergedOpen = shallowRef(initOpen);
      const setInnerOpen = (val) => {
        innerOpen.value = props2.open !== void 0 ? props2.open : val;
        mergedOpen.value = innerOpen.value;
      };
      watch(() => props2.open, () => {
        setInnerOpen(props2.open);
      });
      const emptyListContent = computed(() => !props2.notFoundContent && props2.emptyOptions);
      watchEffect(() => {
        mergedOpen.value = innerOpen.value;
        if (props2.disabled || emptyListContent.value && mergedOpen.value && props2.mode === "combobox") {
          mergedOpen.value = false;
        }
      });
      const triggerOpen = computed(() => emptyListContent.value ? false : mergedOpen.value);
      const onToggleOpen = (newOpen) => {
        const nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen.value;
        if (mergedOpen.value !== nextOpen && !props2.disabled) {
          setInnerOpen(nextOpen);
          props2.onDropdownVisibleChange && props2.onDropdownVisibleChange(nextOpen);
          if (!nextOpen && popupFocused.value) {
            popupFocused.value = false;
            setMockFocused(false, () => {
              focusRef.value = false;
              blurRef.value = false;
            });
          }
        }
      };
      const tokenWithEnter = computed(() => (props2.tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)));
      const onInternalSearch = (searchText, fromTyping, isCompositing) => {
        var _a2, _b2;
        let ret = true;
        let newSearchText = searchText;
        (_a2 = props2.onActiveValueChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, null);
        const patchLabels = isCompositing ? null : getSeparatedContent(searchText, props2.tokenSeparators);
        if (props2.mode !== "combobox" && patchLabels) {
          newSearchText = "";
          (_b2 = props2.onSearchSplit) === null || _b2 === void 0 ? void 0 : _b2.call(props2, patchLabels);
          onToggleOpen(false);
          ret = false;
        }
        if (props2.onSearch && mergedSearchValue.value !== newSearchText) {
          props2.onSearch(newSearchText, {
            source: fromTyping ? "typing" : "effect"
          });
        }
        return ret;
      };
      const onInternalSearchSubmit = (searchText) => {
        var _a2;
        if (!searchText || !searchText.trim()) {
          return;
        }
        (_a2 = props2.onSearch) === null || _a2 === void 0 ? void 0 : _a2.call(props2, searchText, {
          source: "submit"
        });
      };
      watch(mergedOpen, () => {
        if (!mergedOpen.value && !multiple.value && props2.mode !== "combobox") {
          onInternalSearch("", false, false);
        }
      }, {
        immediate: true,
        flush: "post"
      });
      watch(() => props2.disabled, () => {
        if (innerOpen.value && !!props2.disabled) {
          setInnerOpen(false);
        }
        if (props2.disabled && !blurRef.value) {
          setMockFocused(false);
        }
      }, {
        immediate: true
      });
      const [getClearLock, setClearLock] = useLock();
      const onInternalKeyDown = function(event) {
        var _a2;
        const clearLock = getClearLock();
        const {
          which
        } = event;
        if (which === KeyCode.ENTER) {
          if (props2.mode !== "combobox") {
            event.preventDefault();
          }
          if (!mergedOpen.value) {
            onToggleOpen(true);
          }
        }
        setClearLock(!!mergedSearchValue.value);
        if (which === KeyCode.BACKSPACE && !clearLock && multiple.value && !mergedSearchValue.value && props2.displayValues.length) {
          const cloneDisplayValues = [...props2.displayValues];
          let removedDisplayValue = null;
          for (let i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
            const current = cloneDisplayValues[i2];
            if (!current.disabled) {
              cloneDisplayValues.splice(i2, 1);
              removedDisplayValue = current;
              break;
            }
          }
          if (removedDisplayValue) {
            props2.onDisplayValuesChange(cloneDisplayValues, {
              type: "remove",
              values: [removedDisplayValue]
            });
          }
        }
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        if (mergedOpen.value && listRef.value) {
          listRef.value.onKeydown(event, ...rest);
        }
        (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, event, ...rest);
      };
      const onInternalKeyUp = function(event) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }
        if (mergedOpen.value && listRef.value) {
          listRef.value.onKeyup(event, ...rest);
        }
        if (props2.onKeyup) {
          props2.onKeyup(event, ...rest);
        }
      };
      const onSelectorRemove = (val) => {
        const newValues = props2.displayValues.filter((i2) => i2 !== val);
        props2.onDisplayValuesChange(newValues, {
          type: "remove",
          values: [val]
        });
      };
      const focusRef = shallowRef(false);
      const onContainerFocus = function() {
        setMockFocused(true);
        if (!props2.disabled) {
          if (props2.onFocus && !focusRef.value) {
            props2.onFocus(...arguments);
          }
          if (props2.showAction && props2.showAction.includes("focus")) {
            onToggleOpen(true);
          }
        }
        focusRef.value = true;
      };
      const popupFocused = ref(false);
      const onContainerBlur = function() {
        if (popupFocused.value) {
          return;
        }
        blurRef.value = true;
        setMockFocused(false, () => {
          focusRef.value = false;
          blurRef.value = false;
          onToggleOpen(false);
        });
        if (props2.disabled) {
          return;
        }
        const searchVal = mergedSearchValue.value;
        if (searchVal) {
          if (props2.mode === "tags") {
            props2.onSearch(searchVal, {
              source: "submit"
            });
          } else if (props2.mode === "multiple") {
            props2.onSearch("", {
              source: "blur"
            });
          }
        }
        if (props2.onBlur) {
          props2.onBlur(...arguments);
        }
      };
      const onPopupFocusin = () => {
        popupFocused.value = true;
      };
      const onPopupFocusout = () => {
        popupFocused.value = false;
      };
      provide("VCSelectContainerEvent", {
        focus: onContainerFocus,
        blur: onContainerBlur
      });
      const activeTimeoutIds = [];
      onMounted(() => {
        activeTimeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
        activeTimeoutIds.splice(0, activeTimeoutIds.length);
      });
      onBeforeUnmount(() => {
        activeTimeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
        activeTimeoutIds.splice(0, activeTimeoutIds.length);
      });
      const onInternalMouseDown = function(event) {
        var _a2, _b2;
        const {
          target
        } = event;
        const popupElement = (_a2 = triggerRef2.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupElement();
        if (popupElement && popupElement.contains(target)) {
          const timeoutId = setTimeout(() => {
            var _a3;
            const index2 = activeTimeoutIds.indexOf(timeoutId);
            if (index2 !== -1) {
              activeTimeoutIds.splice(index2, 1);
            }
            cancelSetMockFocused();
            if (!mobile.value && !popupElement.contains(document.activeElement)) {
              (_a3 = selectorRef.value) === null || _a3 === void 0 ? void 0 : _a3.focus();
            }
          });
          activeTimeoutIds.push(timeoutId);
        }
        for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          restArgs[_key3 - 1] = arguments[_key3];
        }
        (_b2 = props2.onMousedown) === null || _b2 === void 0 ? void 0 : _b2.call(props2, event, ...restArgs);
      };
      const containerWidth = shallowRef(null);
      const onPopupMouseEnter = () => {
      };
      onMounted(() => {
        watch(triggerOpen, () => {
          var _a2;
          if (triggerOpen.value) {
            const newWidth = Math.ceil((_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth);
            if (containerWidth.value !== newWidth && !Number.isNaN(newWidth)) {
              containerWidth.value = newWidth;
            }
          }
        }, {
          immediate: true,
          flush: "post"
        });
      });
      useSelectTriggerControl([containerRef, triggerRef2], triggerOpen, onToggleOpen);
      useProvideBaseSelectProps(toReactive(_extends$1(_extends$1({}, toRefs(props2)), {
        open: mergedOpen,
        triggerOpen,
        showSearch: mergedShowSearch,
        multiple,
        toggleOpen: onToggleOpen
      })));
      return () => {
        const _a2 = _extends$1(_extends$1({}, props2), attrs), {
          prefixCls,
          id,
          open: open2,
          defaultOpen,
          mode,
          // Search related
          showSearch,
          searchValue,
          onSearch,
          // Icons
          allowClear,
          clearIcon,
          showArrow,
          inputIcon,
          // Others
          disabled,
          loading,
          getInputElement,
          getPopupContainer,
          placement,
          // Dropdown
          animation,
          transitionName: transitionName2,
          dropdownStyle,
          dropdownClassName,
          dropdownMatchSelectWidth,
          dropdownRender,
          dropdownAlign,
          showAction,
          direction,
          // Tags
          tokenSeparators,
          tagRender,
          optionLabelRender,
          // Events
          onPopupScroll,
          onDropdownVisibleChange,
          onFocus,
          onBlur,
          onKeyup,
          onKeydown,
          onMousedown,
          onClear,
          omitDomProps,
          getRawInputElement,
          displayValues,
          onDisplayValuesChange,
          emptyOptions,
          activeDescendantId,
          activeValue,
          OptionList: OptionList2
        } = _a2, restProps = __rest$x(_a2, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]);
        const customizeInputElement = mode === "combobox" && getInputElement && getInputElement() || null;
        const customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
        const domProps = _extends$1({}, restProps);
        let onTriggerVisibleChange;
        if (customizeRawInputElement) {
          onTriggerVisibleChange = (newOpen) => {
            onToggleOpen(newOpen);
          };
        }
        DEFAULT_OMIT_PROPS.forEach((propName) => {
          delete domProps[propName];
        });
        omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach((propName) => {
          delete domProps[propName];
        });
        const mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple.value && mode !== "combobox";
        let arrowNode;
        if (mergedShowArrow) {
          arrowNode = createVNode(TransBtn, {
            "class": classNames(`${prefixCls}-arrow`, {
              [`${prefixCls}-arrow-loading`]: loading
            }),
            "customizeIcon": inputIcon,
            "customizeIconProps": {
              loading,
              searchValue: mergedSearchValue.value,
              open: mergedOpen.value,
              focused: mockFocused.value,
              showSearch: mergedShowSearch.value
            }
          }, null);
        }
        let clearNode;
        const onClearMouseDown = () => {
          onClear === null || onClear === void 0 ? void 0 : onClear();
          onDisplayValuesChange([], {
            type: "clear",
            values: displayValues
          });
          onInternalSearch("", false, false);
        };
        if (!disabled && allowClear && (displayValues.length || mergedSearchValue.value)) {
          clearNode = createVNode(TransBtn, {
            "class": `${prefixCls}-clear`,
            "onMousedown": onClearMouseDown,
            "customizeIcon": clearIcon
          }, {
            default: () => [createTextVNode("×")]
          });
        }
        const optionList = createVNode(OptionList2, {
          "ref": listRef
        }, _extends$1(_extends$1({}, legacyTreeSelectContext.customSlots), {
          option: slots.option
        }));
        const mergedClassName = classNames(prefixCls, attrs.class, {
          [`${prefixCls}-focused`]: mockFocused.value,
          [`${prefixCls}-multiple`]: multiple.value,
          [`${prefixCls}-single`]: !multiple.value,
          [`${prefixCls}-allow-clear`]: allowClear,
          [`${prefixCls}-show-arrow`]: mergedShowArrow,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-loading`]: loading,
          [`${prefixCls}-open`]: mergedOpen.value,
          [`${prefixCls}-customize-input`]: customizeInputElement,
          [`${prefixCls}-show-search`]: mergedShowSearch.value
        });
        const selectorNode = createVNode(SelectTrigger, {
          "ref": triggerRef2,
          "disabled": disabled,
          "prefixCls": prefixCls,
          "visible": triggerOpen.value,
          "popupElement": optionList,
          "containerWidth": containerWidth.value,
          "animation": animation,
          "transitionName": transitionName2,
          "dropdownStyle": dropdownStyle,
          "dropdownClassName": dropdownClassName,
          "direction": direction,
          "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
          "dropdownRender": dropdownRender,
          "dropdownAlign": dropdownAlign,
          "placement": placement,
          "getPopupContainer": getPopupContainer,
          "empty": emptyOptions,
          "getTriggerDOMNode": () => selectorDomRef.current,
          "onPopupVisibleChange": onTriggerVisibleChange,
          "onPopupMouseEnter": onPopupMouseEnter,
          "onPopupFocusin": onPopupFocusin,
          "onPopupFocusout": onPopupFocusout
        }, {
          default: () => {
            return customizeRawInputElement ? isValidElement(customizeRawInputElement) && cloneElement(customizeRawInputElement, {
              ref: selectorDomRef
            }, false, true) : createVNode(Selector, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
              "domRef": selectorDomRef,
              "prefixCls": prefixCls,
              "inputElement": customizeInputElement,
              "ref": selectorRef,
              "id": id,
              "showSearch": mergedShowSearch.value,
              "mode": mode,
              "activeDescendantId": activeDescendantId,
              "tagRender": tagRender,
              "optionLabelRender": optionLabelRender,
              "values": displayValues,
              "open": mergedOpen.value,
              "onToggleOpen": onToggleOpen,
              "activeValue": activeValue,
              "searchValue": mergedSearchValue.value,
              "onSearch": onInternalSearch,
              "onSearchSubmit": onInternalSearchSubmit,
              "onRemove": onSelectorRemove,
              "tokenWithEnter": tokenWithEnter.value
            }), null);
          }
        });
        let renderNode;
        if (customizeRawInputElement) {
          renderNode = selectorNode;
        } else {
          renderNode = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, domProps), {}, {
            "class": mergedClassName,
            "ref": containerRef,
            "onMousedown": onInternalMouseDown,
            "onKeydown": onInternalKeyDown,
            "onKeyup": onInternalKeyUp
          }), [mockFocused.value && !mergedOpen.value && createVNode("span", {
            "style": {
              width: 0,
              height: 0,
              position: "absolute",
              overflow: "hidden",
              opacity: 0
            },
            "aria-live": "polite"
          }, [`${displayValues.map((_ref2) => {
            let {
              label,
              value
            } = _ref2;
            return ["number", "string"].includes(typeof label) ? label : value;
          }).join(", ")}`]), selectorNode, arrowNode, clearNode]);
        }
        return renderNode;
      };
    }
  });
  const Filter = (_ref, _ref2) => {
    let {
      height,
      offset: offset2,
      prefixCls,
      onInnerResize
    } = _ref;
    let {
      slots
    } = _ref2;
    var _a2;
    let outerStyle = {};
    let innerStyle = {
      display: "flex",
      flexDirection: "column"
    };
    if (offset2 !== void 0) {
      outerStyle = {
        height: `${height}px`,
        position: "relative",
        overflow: "hidden"
      };
      innerStyle = _extends$1(_extends$1({}, innerStyle), {
        transform: `translateY(${offset2}px)`,
        position: "absolute",
        left: 0,
        right: 0,
        top: 0
      });
    }
    return createVNode("div", {
      "style": outerStyle
    }, [createVNode(ResizeObserver$1, {
      "onResize": (_ref3) => {
        let {
          offsetHeight
        } = _ref3;
        if (offsetHeight && onInnerResize) {
          onInnerResize();
        }
      }
    }, {
      default: () => [createVNode("div", {
        "style": innerStyle,
        "class": classNames({
          [`${prefixCls}-holder-inner`]: prefixCls
        })
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]
    })]);
  };
  Filter.displayName = "Filter";
  Filter.inheritAttrs = false;
  Filter.props = {
    prefixCls: String,
    /** Virtual filler height. Should be `count * itemMinHeight` */
    height: Number,
    /** Set offset of visible items. Should be the top of start item position */
    offset: Number,
    onInnerResize: Function
  };
  const Item = (_ref, _ref2) => {
    let {
      setRef: setRef2
    } = _ref;
    let {
      slots
    } = _ref2;
    var _a2;
    const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
    return children && children.length ? cloneVNode(children[0], {
      ref: setRef2
    }) : children;
  };
  Item.props = {
    setRef: {
      type: Function,
      default: () => {
      }
    }
  };
  const MIN_SIZE = 20;
  function getPageY(e2) {
    return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
  }
  const ScrollBar = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ScrollBar",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      scrollTop: Number,
      scrollHeight: Number,
      height: Number,
      count: Number,
      onScroll: {
        type: Function
      },
      onStartMove: {
        type: Function
      },
      onStopMove: {
        type: Function
      }
    },
    setup() {
      return {
        moveRaf: null,
        scrollbarRef: createRef(),
        thumbRef: createRef(),
        visibleTimeout: null,
        state: reactive({
          dragging: false,
          pageY: null,
          startTop: null,
          visible: false
        })
      };
    },
    watch: {
      scrollTop: {
        handler() {
          this.delayHidden();
        },
        flush: "post"
      }
    },
    mounted() {
      var _a2, _b2;
      (_a2 = this.scrollbarRef.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive ? {
        passive: false
      } : false);
      (_b2 = this.thumbRef.current) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("touchstart", this.onMouseDown, supportsPassive ? {
        passive: false
      } : false);
    },
    beforeUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    },
    methods: {
      delayHidden() {
        clearTimeout(this.visibleTimeout);
        this.state.visible = true;
        this.visibleTimeout = setTimeout(() => {
          this.state.visible = false;
        }, 2e3);
      },
      onScrollbarTouchStart(e2) {
        e2.preventDefault();
      },
      onContainerMouseDown(e2) {
        e2.stopPropagation();
        e2.preventDefault();
      },
      // ======================= Clean =======================
      patchEvents() {
        window.addEventListener("mousemove", this.onMouseMove);
        window.addEventListener("mouseup", this.onMouseUp);
        this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, supportsPassive ? {
          passive: false
        } : false);
        this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
      },
      removeEvents() {
        window.removeEventListener("mousemove", this.onMouseMove);
        window.removeEventListener("mouseup", this.onMouseUp);
        this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive ? {
          passive: false
        } : false);
        if (this.thumbRef.current) {
          this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, supportsPassive ? {
            passive: false
          } : false);
          this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, supportsPassive ? {
            passive: false
          } : false);
          this.thumbRef.current.removeEventListener("touchend", this.onMouseUp);
        }
        wrapperRaf.cancel(this.moveRaf);
      },
      // ======================= Thumb =======================
      onMouseDown(e2) {
        const {
          onStartMove
        } = this.$props;
        _extends$1(this.state, {
          dragging: true,
          pageY: getPageY(e2),
          startTop: this.getTop()
        });
        onStartMove();
        this.patchEvents();
        e2.stopPropagation();
        e2.preventDefault();
      },
      onMouseMove(e2) {
        const {
          dragging,
          pageY,
          startTop
        } = this.state;
        const {
          onScroll
        } = this.$props;
        wrapperRaf.cancel(this.moveRaf);
        if (dragging) {
          const offsetY = getPageY(e2) - pageY;
          const newTop = startTop + offsetY;
          const enableScrollRange = this.getEnableScrollRange();
          const enableHeightRange = this.getEnableHeightRange();
          const ptg = enableHeightRange ? newTop / enableHeightRange : 0;
          const newScrollTop = Math.ceil(ptg * enableScrollRange);
          this.moveRaf = wrapperRaf(() => {
            onScroll(newScrollTop);
          });
        }
      },
      onMouseUp() {
        const {
          onStopMove
        } = this.$props;
        this.state.dragging = false;
        onStopMove();
        this.removeEvents();
      },
      // ===================== Calculate =====================
      getSpinHeight() {
        const {
          height,
          scrollHeight
        } = this.$props;
        let baseHeight = height / scrollHeight * 100;
        baseHeight = Math.max(baseHeight, MIN_SIZE);
        baseHeight = Math.min(baseHeight, height / 2);
        return Math.floor(baseHeight);
      },
      getEnableScrollRange() {
        const {
          scrollHeight,
          height
        } = this.$props;
        return scrollHeight - height || 0;
      },
      getEnableHeightRange() {
        const {
          height
        } = this.$props;
        const spinHeight = this.getSpinHeight();
        return height - spinHeight || 0;
      },
      getTop() {
        const {
          scrollTop
        } = this.$props;
        const enableScrollRange = this.getEnableScrollRange();
        const enableHeightRange = this.getEnableHeightRange();
        if (scrollTop === 0 || enableScrollRange === 0) {
          return 0;
        }
        const ptg = scrollTop / enableScrollRange;
        return ptg * enableHeightRange;
      },
      // Not show scrollbar when height is large than scrollHeight
      showScroll() {
        const {
          height,
          scrollHeight
        } = this.$props;
        return scrollHeight > height;
      }
    },
    render() {
      const {
        dragging,
        visible
      } = this.state;
      const {
        prefixCls
      } = this.$props;
      const spinHeight = this.getSpinHeight() + "px";
      const top = this.getTop() + "px";
      const canScroll = this.showScroll();
      const mergedVisible = canScroll && visible;
      return createVNode("div", {
        "ref": this.scrollbarRef,
        "class": classNames(`${prefixCls}-scrollbar`, {
          [`${prefixCls}-scrollbar-show`]: canScroll
        }),
        "style": {
          width: "8px",
          top: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display: mergedVisible ? void 0 : "none"
        },
        "onMousedown": this.onContainerMouseDown,
        "onMousemove": this.delayHidden
      }, [createVNode("div", {
        "ref": this.thumbRef,
        "class": classNames(`${prefixCls}-scrollbar-thumb`, {
          [`${prefixCls}-scrollbar-thumb-moving`]: dragging
        }),
        "style": {
          width: "100%",
          height: spinHeight,
          top,
          left: 0,
          position: "absolute",
          background: "rgba(0, 0, 0, 0.5)",
          borderRadius: "99px",
          cursor: "pointer",
          userSelect: "none"
        },
        "onMousedown": this.onMouseDown
      }, null)]);
    }
  });
  function useHeights(mergedData, getKey2, onItemAdd, onItemRemove) {
    const instance = /* @__PURE__ */ new Map();
    const heights = /* @__PURE__ */ new Map();
    const updatedMark = ref(Symbol("update"));
    watch(mergedData, () => {
      updatedMark.value = Symbol("update");
    });
    let collectRaf = void 0;
    function cancelRaf() {
      wrapperRaf.cancel(collectRaf);
    }
    function collectHeight() {
      cancelRaf();
      collectRaf = wrapperRaf(() => {
        instance.forEach((element, key2) => {
          if (element && element.offsetParent) {
            const {
              offsetHeight
            } = element;
            if (heights.get(key2) !== offsetHeight) {
              updatedMark.value = Symbol("update");
              heights.set(key2, element.offsetHeight);
            }
          }
        });
      });
    }
    function setInstance(item, ins) {
      const key2 = getKey2(item);
      instance.get(key2);
      if (ins) {
        instance.set(key2, ins.$el || ins);
        collectHeight();
      } else {
        instance.delete(key2);
      }
    }
    onUnmounted(() => {
      cancelRaf();
    });
    return [setInstance, collectHeight, heights, updatedMark];
  }
  function useScrollTo(containerRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, triggerFlash) {
    let scroll;
    return (arg) => {
      if (arg === null || arg === void 0) {
        triggerFlash();
        return;
      }
      wrapperRaf.cancel(scroll);
      const data = mergedData.value;
      const itemHeight = props2.itemHeight;
      if (typeof arg === "number") {
        syncScrollTop(arg);
      } else if (arg && typeof arg === "object") {
        let index2;
        const {
          align
        } = arg;
        if ("index" in arg) {
          ({
            index: index2
          } = arg);
        } else {
          index2 = data.findIndex((item) => getKey2(item) === arg.key);
        }
        const {
          offset: offset2 = 0
        } = arg;
        const syncScroll = (times, targetAlign) => {
          if (times < 0 || !containerRef.value) return;
          const height = containerRef.value.clientHeight;
          let needCollectHeight = false;
          let newTargetAlign = targetAlign;
          if (height) {
            const mergedAlign = targetAlign || align;
            let stackTop = 0;
            let itemTop = 0;
            let itemBottom = 0;
            const maxLen = Math.min(data.length, index2);
            for (let i2 = 0; i2 <= maxLen; i2 += 1) {
              const key2 = getKey2(data[i2]);
              itemTop = stackTop;
              const cacheHeight = heights.get(key2);
              itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
              stackTop = itemBottom;
              if (i2 === index2 && cacheHeight === void 0) {
                needCollectHeight = true;
              }
            }
            const scrollTop = containerRef.value.scrollTop;
            let targetTop = null;
            switch (mergedAlign) {
              case "top":
                targetTop = itemTop - offset2;
                break;
              case "bottom":
                targetTop = itemBottom - height + offset2;
                break;
              default: {
                const scrollBottom = scrollTop + height;
                if (itemTop < scrollTop) {
                  newTargetAlign = "top";
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = "bottom";
                }
              }
            }
            if (targetTop !== null && targetTop !== scrollTop) {
              syncScrollTop(targetTop);
            }
          }
          scroll = wrapperRaf(() => {
            if (needCollectHeight) {
              collectHeight();
            }
            syncScroll(times - 1, newTargetAlign);
          }, 2);
        };
        syncScroll(5);
      }
    };
  }
  const isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
  const useOriginScroll = (isScrollAtTop, isScrollAtBottom) => {
    let lock = false;
    let lockTimeout = null;
    function lockScroll() {
      clearTimeout(lockTimeout);
      lock = true;
      lockTimeout = setTimeout(() => {
        lock = false;
      }, 50);
    }
    return function(deltaY) {
      let smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const originScroll = (
        // Pass origin wheel when on the top
        deltaY < 0 && isScrollAtTop.value || // Pass origin wheel when on the bottom
        deltaY > 0 && isScrollAtBottom.value
      );
      if (smoothOffset && originScroll) {
        clearTimeout(lockTimeout);
        lock = false;
      } else if (!originScroll || lock) {
        lockScroll();
      }
      return !lock && originScroll;
    };
  };
  function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
    let offsetRef = 0;
    let nextFrame2 = null;
    let wheelValue = null;
    let isMouseScroll = false;
    const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    function onWheel(event) {
      if (!inVirtual.value) return;
      wrapperRaf.cancel(nextFrame2);
      const {
        deltaY
      } = event;
      offsetRef += deltaY;
      wheelValue = deltaY;
      if (originScroll(deltaY)) return;
      if (!isFF) {
        event.preventDefault();
      }
      nextFrame2 = wrapperRaf(() => {
        const patchMultiple = isMouseScroll ? 10 : 1;
        onWheelDelta(offsetRef * patchMultiple);
        offsetRef = 0;
      });
    }
    function onFireFoxScroll(event) {
      if (!inVirtual.value) return;
      isMouseScroll = event.detail === wheelValue;
    }
    return [onWheel, onFireFoxScroll];
  }
  const SMOOTH_PTG = 14 / 15;
  function useMobileTouchMove(inVirtual, listRef, callback) {
    let touched = false;
    let touchY = 0;
    let element = null;
    let interval = null;
    const cleanUpEvents = () => {
      if (element) {
        element.removeEventListener("touchmove", onTouchMove);
        element.removeEventListener("touchend", onTouchEnd);
      }
    };
    const onTouchMove = (e2) => {
      if (touched) {
        const currentY = Math.ceil(e2.touches[0].pageY);
        let offsetY = touchY - currentY;
        touchY = currentY;
        if (callback(offsetY)) {
          e2.preventDefault();
        }
        clearInterval(interval);
        interval = setInterval(() => {
          offsetY *= SMOOTH_PTG;
          if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
            clearInterval(interval);
          }
        }, 16);
      }
    };
    const onTouchEnd = () => {
      touched = false;
      cleanUpEvents();
    };
    const onTouchStart = (e2) => {
      cleanUpEvents();
      if (e2.touches.length === 1 && !touched) {
        touched = true;
        touchY = Math.ceil(e2.touches[0].pageY);
        element = e2.target;
        element.addEventListener("touchmove", onTouchMove, {
          passive: false
        });
        element.addEventListener("touchend", onTouchEnd);
      }
    };
    const noop2 = () => {
    };
    onMounted(() => {
      document.addEventListener("touchmove", noop2, {
        passive: false
      });
      watch(inVirtual, (val) => {
        listRef.value.removeEventListener("touchstart", onTouchStart);
        cleanUpEvents();
        clearInterval(interval);
        if (val) {
          listRef.value.addEventListener("touchstart", onTouchStart, {
            passive: false
          });
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      document.removeEventListener("touchmove", noop2);
    });
  }
  var __rest$w = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const EMPTY_DATA$1 = [];
  const ScrollStyle = {
    overflowY: "auto",
    overflowAnchor: "none"
  };
  function renderChildren(list2, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
    let {
      getKey: getKey2
    } = _ref;
    return list2.slice(startIndex, endIndex + 1).map((item, index2) => {
      const eleIndex = startIndex + index2;
      const node2 = renderFunc(item, eleIndex, {
        // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
      });
      const key2 = getKey2(item);
      return createVNode(Item, {
        "key": key2,
        "setRef": (ele) => setNodeRef(item, ele)
      }, {
        default: () => [node2]
      });
    });
  }
  const List = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "List",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      data: PropTypes.array,
      height: Number,
      itemHeight: Number,
      /** If not match virtual scroll condition, Set List still use height of container. */
      fullHeight: {
        type: Boolean,
        default: void 0
      },
      itemKey: {
        type: [String, Number, Function],
        required: true
      },
      component: {
        type: [String, Object]
      },
      /** Set `false` will always use real scroll instead of virtual one */
      virtual: {
        type: Boolean,
        default: void 0
      },
      children: Function,
      onScroll: Function,
      onMousedown: Function,
      onMouseenter: Function,
      onVisibleChange: Function
    },
    setup(props2, _ref2) {
      let {
        expose
      } = _ref2;
      const useVirtual = computed(() => {
        const {
          height,
          itemHeight,
          virtual
        } = props2;
        return !!(virtual !== false && height && itemHeight);
      });
      const inVirtual = computed(() => {
        const {
          height,
          itemHeight,
          data: data2
        } = props2;
        return useVirtual.value && data2 && itemHeight * data2.length > height;
      });
      const state = reactive({
        scrollTop: 0,
        scrollMoving: false
      });
      const data = computed(() => {
        return props2.data || EMPTY_DATA$1;
      });
      const mergedData = shallowRef([]);
      watch(data, () => {
        mergedData.value = toRaw(data.value).slice();
      }, {
        immediate: true
      });
      const itemKey2 = shallowRef((_item) => void 0);
      watch(() => props2.itemKey, (val) => {
        if (typeof val === "function") {
          itemKey2.value = val;
        } else {
          itemKey2.value = (item) => item === null || item === void 0 ? void 0 : item[val];
        }
      }, {
        immediate: true
      });
      const componentRef = shallowRef();
      const fillerInnerRef = shallowRef();
      const scrollBarRef = shallowRef();
      const getKey2 = (item) => {
        return itemKey2.value(item);
      };
      const sharedConfig = {
        getKey: getKey2
      };
      function syncScrollTop(newTop) {
        let value;
        if (typeof newTop === "function") {
          value = newTop(state.scrollTop);
        } else {
          value = newTop;
        }
        const alignedTop = keepInRange(value);
        if (componentRef.value) {
          componentRef.value.scrollTop = alignedTop;
        }
        state.scrollTop = alignedTop;
      }
      const [setInstance, collectHeight, heights, updatedMark] = useHeights(mergedData, getKey2);
      const calRes = reactive({
        scrollHeight: void 0,
        start: 0,
        end: 0,
        offset: void 0
      });
      const offsetHeight = shallowRef(0);
      onMounted(() => {
        nextTick(() => {
          var _a2;
          offsetHeight.value = ((_a2 = fillerInnerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
        });
      });
      onUpdated(() => {
        nextTick(() => {
          var _a2;
          offsetHeight.value = ((_a2 = fillerInnerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
        });
      });
      watch([useVirtual, mergedData], () => {
        if (!useVirtual.value) {
          _extends$1(calRes, {
            scrollHeight: void 0,
            start: 0,
            end: mergedData.value.length - 1,
            offset: void 0
          });
        }
      }, {
        immediate: true
      });
      watch([useVirtual, mergedData, offsetHeight, inVirtual], () => {
        if (useVirtual.value && !inVirtual.value) {
          _extends$1(calRes, {
            scrollHeight: offsetHeight.value,
            start: 0,
            end: mergedData.value.length - 1,
            offset: void 0
          });
        }
        if (componentRef.value) {
          state.scrollTop = componentRef.value.scrollTop;
        }
      }, {
        immediate: true
      });
      watch([inVirtual, useVirtual, () => state.scrollTop, mergedData, updatedMark, () => props2.height, offsetHeight], () => {
        if (!useVirtual.value || !inVirtual.value) {
          return;
        }
        let itemTop = 0;
        let startIndex;
        let startOffset;
        let endIndex;
        const dataLen = mergedData.value.length;
        const data2 = mergedData.value;
        const scrollTop = state.scrollTop;
        const {
          itemHeight,
          height
        } = props2;
        const scrollTopHeight = scrollTop + height;
        for (let i2 = 0; i2 < dataLen; i2 += 1) {
          const item = data2[i2];
          const key2 = getKey2(item);
          let cacheHeight = heights.get(key2);
          if (cacheHeight === void 0) {
            cacheHeight = itemHeight;
          }
          const currentItemBottom = itemTop + cacheHeight;
          if (startIndex === void 0 && currentItemBottom >= scrollTop) {
            startIndex = i2;
            startOffset = itemTop;
          }
          if (endIndex === void 0 && currentItemBottom > scrollTopHeight) {
            endIndex = i2;
          }
          itemTop = currentItemBottom;
        }
        if (startIndex === void 0) {
          startIndex = 0;
          startOffset = 0;
          endIndex = Math.ceil(height / itemHeight);
        }
        if (endIndex === void 0) {
          endIndex = dataLen - 1;
        }
        endIndex = Math.min(endIndex + 1, dataLen);
        _extends$1(calRes, {
          scrollHeight: itemTop,
          start: startIndex,
          end: endIndex,
          offset: startOffset
        });
      }, {
        immediate: true
      });
      const maxScrollHeight = computed(() => calRes.scrollHeight - props2.height);
      function keepInRange(newScrollTop) {
        let newTop = newScrollTop;
        if (!Number.isNaN(maxScrollHeight.value)) {
          newTop = Math.min(newTop, maxScrollHeight.value);
        }
        newTop = Math.max(newTop, 0);
        return newTop;
      }
      const isScrollAtTop = computed(() => state.scrollTop <= 0);
      const isScrollAtBottom = computed(() => state.scrollTop >= maxScrollHeight.value);
      const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
      function onScrollBar(newScrollTop) {
        const newTop = newScrollTop;
        syncScrollTop(newTop);
      }
      function onFallbackScroll(e2) {
        var _a2;
        const {
          scrollTop: newScrollTop
        } = e2.currentTarget;
        if (newScrollTop !== state.scrollTop) {
          syncScrollTop(newScrollTop);
        }
        (_a2 = props2.onScroll) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
      }
      const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, (offsetY) => {
        syncScrollTop((top) => {
          const newTop = top + offsetY;
          return newTop;
        });
      });
      useMobileTouchMove(useVirtual, componentRef, (deltaY, smoothOffset) => {
        if (originScroll(deltaY, smoothOffset)) {
          return false;
        }
        onRawWheel({
          preventDefault() {
          },
          deltaY
        });
        return true;
      });
      function onMozMousePixelScroll(e2) {
        if (useVirtual.value) {
          e2.preventDefault();
        }
      }
      const removeEventListener2 = () => {
        if (componentRef.value) {
          componentRef.value.removeEventListener("wheel", onRawWheel, supportsPassive ? {
            passive: false
          } : false);
          componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll);
          componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        }
      };
      watchEffect(() => {
        nextTick(() => {
          if (componentRef.value) {
            removeEventListener2();
            componentRef.value.addEventListener("wheel", onRawWheel, supportsPassive ? {
              passive: false
            } : false);
            componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll);
            componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
          }
        });
      });
      onBeforeUnmount(() => {
        removeEventListener2();
      });
      const scrollTo2 = useScrollTo(componentRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, () => {
        var _a2;
        (_a2 = scrollBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.delayHidden();
      });
      expose({
        scrollTo: scrollTo2
      });
      const componentStyle = computed(() => {
        let cs = null;
        if (props2.height) {
          cs = _extends$1({
            [props2.fullHeight ? "height" : "maxHeight"]: props2.height + "px"
          }, ScrollStyle);
          if (useVirtual.value) {
            cs.overflowY = "hidden";
            if (state.scrollMoving) {
              cs.pointerEvents = "none";
            }
          }
        }
        return cs;
      });
      watch([() => calRes.start, () => calRes.end, mergedData], () => {
        if (props2.onVisibleChange) {
          const renderList2 = mergedData.value.slice(calRes.start, calRes.end + 1);
          props2.onVisibleChange(renderList2, mergedData.value);
        }
      }, {
        flush: "post"
      });
      const delayHideScrollBar = () => {
        var _a2;
        (_a2 = scrollBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.delayHidden();
      };
      return {
        state,
        mergedData,
        componentStyle,
        onFallbackScroll,
        onScrollBar,
        componentRef,
        useVirtual,
        calRes,
        collectHeight,
        setInstance,
        sharedConfig,
        scrollBarRef,
        fillerInnerRef,
        delayHideScrollBar
      };
    },
    render() {
      const _a2 = _extends$1(_extends$1({}, this.$props), this.$attrs), {
        prefixCls = "rc-virtual-list",
        height,
        itemHeight,
        // eslint-disable-next-line no-unused-vars
        fullHeight,
        data,
        itemKey: itemKey2,
        virtual,
        component: Component = "div",
        onScroll,
        children = this.$slots.default,
        style,
        class: className
      } = _a2, restProps = __rest$w(_a2, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]);
      const mergedClassName = classNames(prefixCls, className);
      const {
        scrollTop
      } = this.state;
      const {
        scrollHeight,
        offset: offset2,
        start: start2,
        end: end2
      } = this.calRes;
      const {
        componentStyle,
        onFallbackScroll,
        onScrollBar,
        useVirtual,
        collectHeight,
        sharedConfig,
        setInstance,
        mergedData,
        delayHideScrollBar
      } = this;
      return createVNode("div", _objectSpread2$1({
        "style": _extends$1(_extends$1({}, style), {
          position: "relative"
        }),
        "class": mergedClassName
      }, restProps), [createVNode(Component, {
        "class": `${prefixCls}-holder`,
        "style": componentStyle,
        "ref": "componentRef",
        "onScroll": onFallbackScroll,
        "onMouseenter": delayHideScrollBar
      }, {
        default: () => [createVNode(Filter, {
          "prefixCls": prefixCls,
          "height": scrollHeight,
          "offset": offset2,
          "onInnerResize": collectHeight,
          "ref": "fillerInnerRef"
        }, {
          default: () => renderChildren(mergedData, start2, end2, setInstance, children, sharedConfig)
        })]
      }), useVirtual && createVNode(ScrollBar, {
        "ref": "scrollBarRef",
        "prefixCls": prefixCls,
        "scrollTop": scrollTop,
        "height": height,
        "scrollHeight": scrollHeight,
        "count": mergedData.length,
        "onScroll": onScrollBar,
        "onStartMove": () => {
          this.state.scrollMoving = true;
        },
        "onStopMove": () => {
          this.state.scrollMoving = false;
        }
      }, null)]);
    }
  });
  function useMemo(getValue2, condition, shouldUpdate) {
    const cacheRef = ref(getValue2());
    watch(condition, (next2, pre) => {
      if (shouldUpdate) {
        if (shouldUpdate(next2, pre)) {
          cacheRef.value = getValue2();
        }
      } else {
        cacheRef.value = getValue2();
      }
    });
    return cacheRef;
  }
  function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion);
  }
  const SelectContextKey = Symbol("SelectContextKey");
  function useProvideSelectProps(props2) {
    return provide(SelectContextKey, props2);
  }
  function useSelectProps() {
    return inject(SelectContextKey, {});
  }
  var __rest$v = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function isTitleType(content) {
    return typeof content === "string" || typeof content === "number";
  }
  const OptionList = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "OptionList",
    inheritAttrs: false,
    setup(_2, _ref) {
      let {
        expose,
        slots
      } = _ref;
      const baseProps = useBaseProps();
      const props2 = useSelectProps();
      const itemPrefixCls = computed(() => `${baseProps.prefixCls}-item`);
      const memoFlattenOptions = useMemo(() => props2.flattenOptions, [() => baseProps.open, () => props2.flattenOptions], (next2) => next2[0]);
      const listRef = createRef();
      const onListMouseDown = (event) => {
        event.preventDefault();
      };
      const scrollIntoView2 = (args) => {
        if (listRef.current) {
          listRef.current.scrollTo(typeof args === "number" ? {
            index: args
          } : args);
        }
      };
      const getEnabledActiveIndex = function(index2) {
        let offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        const len2 = memoFlattenOptions.value.length;
        for (let i2 = 0; i2 < len2; i2 += 1) {
          const current = (index2 + i2 * offset2 + len2) % len2;
          const {
            group,
            data
          } = memoFlattenOptions.value[current];
          if (!group && !data.disabled) {
            return current;
          }
        }
        return -1;
      };
      const state = reactive({
        activeIndex: getEnabledActiveIndex(0)
      });
      const setActive = function(index2) {
        let fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.activeIndex = index2;
        const info = {
          source: fromKeyboard ? "keyboard" : "mouse"
        };
        const flattenItem = memoFlattenOptions.value[index2];
        if (!flattenItem) {
          props2.onActiveValue(null, -1, info);
          return;
        }
        props2.onActiveValue(flattenItem.value, index2, info);
      };
      watch([() => memoFlattenOptions.value.length, () => baseProps.searchValue], () => {
        setActive(props2.defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
      }, {
        immediate: true
      });
      const isSelected = (value) => props2.rawValues.has(value) && baseProps.mode !== "combobox";
      watch([() => baseProps.open, () => baseProps.searchValue], () => {
        if (!baseProps.multiple && baseProps.open && props2.rawValues.size === 1) {
          const value = Array.from(props2.rawValues)[0];
          const index2 = toRaw(memoFlattenOptions.value).findIndex((_ref2) => {
            let {
              data
            } = _ref2;
            return data[props2.fieldNames.value] === value;
          });
          if (index2 !== -1) {
            setActive(index2);
            nextTick(() => {
              scrollIntoView2(index2);
            });
          }
        }
        if (baseProps.open) {
          nextTick(() => {
            var _a2;
            (_a2 = listRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(void 0);
          });
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const onSelectValue = (value) => {
        if (value !== void 0) {
          props2.onSelect(value, {
            selected: !props2.rawValues.has(value)
          });
        }
        if (!baseProps.multiple) {
          baseProps.toggleOpen(false);
        }
      };
      const getLabel = (item) => typeof item.label === "function" ? item.label() : item.label;
      function renderItem(index2) {
        const item = memoFlattenOptions.value[index2];
        if (!item) return null;
        const itemData = item.data || {};
        const {
          value
        } = itemData;
        const {
          group
        } = item;
        const attrs = pickAttrs(itemData, true);
        const mergedLabel = getLabel(item);
        return item ? createVNode("div", _objectSpread2$1(_objectSpread2$1({
          "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
        }, attrs), {}, {
          "key": index2,
          "role": group ? "presentation" : "option",
          "id": `${baseProps.id}_list_${index2}`,
          "aria-selected": isSelected(value)
        }), [value]) : null;
      }
      const onKeydown = (event) => {
        const {
          which,
          ctrlKey
        } = event;
        switch (which) {
          // >>> Arrow keys & ctrl + n/p on Mac
          case KeyCode.N:
          case KeyCode.P:
          case KeyCode.UP:
          case KeyCode.DOWN: {
            let offset2 = 0;
            if (which === KeyCode.UP) {
              offset2 = -1;
            } else if (which === KeyCode.DOWN) {
              offset2 = 1;
            } else if (isPlatformMac() && ctrlKey) {
              if (which === KeyCode.N) {
                offset2 = 1;
              } else if (which === KeyCode.P) {
                offset2 = -1;
              }
            }
            if (offset2 !== 0) {
              const nextActiveIndex = getEnabledActiveIndex(state.activeIndex + offset2, offset2);
              scrollIntoView2(nextActiveIndex);
              setActive(nextActiveIndex, true);
            }
            break;
          }
          // >>> Select
          case KeyCode.ENTER: {
            const item = memoFlattenOptions.value[state.activeIndex];
            if (item && !item.data.disabled) {
              onSelectValue(item.value);
            } else {
              onSelectValue(void 0);
            }
            if (baseProps.open) {
              event.preventDefault();
            }
            break;
          }
          // >>> Close
          case KeyCode.ESC: {
            baseProps.toggleOpen(false);
            if (baseProps.open) {
              event.stopPropagation();
            }
          }
        }
      };
      const onKeyup = () => {
      };
      const scrollTo2 = (index2) => {
        scrollIntoView2(index2);
      };
      expose({
        onKeydown,
        onKeyup,
        scrollTo: scrollTo2
      });
      return () => {
        const {
          id,
          notFoundContent,
          onPopupScroll
        } = baseProps;
        const {
          menuItemSelectedIcon,
          fieldNames,
          virtual,
          listHeight,
          listItemHeight
        } = props2;
        const renderOption = slots.option;
        const {
          activeIndex
        } = state;
        const omitFieldNameList = Object.keys(fieldNames).map((key2) => fieldNames[key2]);
        if (memoFlattenOptions.value.length === 0) {
          return createVNode("div", {
            "role": "listbox",
            "id": `${id}_list`,
            "class": `${itemPrefixCls.value}-empty`,
            "onMousedown": onListMouseDown
          }, [notFoundContent]);
        }
        return createVNode(Fragment, null, [createVNode("div", {
          "role": "listbox",
          "id": `${id}_list`,
          "style": {
            height: 0,
            width: 0,
            overflow: "hidden"
          }
        }, [renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)]), createVNode(List, {
          "itemKey": "key",
          "ref": listRef,
          "data": memoFlattenOptions.value,
          "height": listHeight,
          "itemHeight": listItemHeight,
          "fullHeight": false,
          "onMousedown": onListMouseDown,
          "onScroll": onPopupScroll,
          "virtual": virtual
        }, {
          default: (item, itemIndex) => {
            var _a2;
            const {
              group,
              groupOption,
              data,
              value
            } = item;
            const {
              key: key2
            } = data;
            const label = typeof item.label === "function" ? item.label() : item.label;
            if (group) {
              const groupTitle = (_a2 = data.title) !== null && _a2 !== void 0 ? _a2 : isTitleType(label) && label;
              return createVNode("div", {
                "class": classNames(itemPrefixCls.value, `${itemPrefixCls.value}-group`),
                "title": groupTitle
              }, [renderOption ? renderOption(data) : label !== void 0 ? label : key2]);
            }
            const {
              disabled,
              title,
              children,
              style,
              class: cls,
              className
            } = data, otherProps = __rest$v(data, ["disabled", "title", "children", "style", "class", "className"]);
            const passedProps = omit$1(otherProps, omitFieldNameList);
            const selected = isSelected(value);
            const optionPrefixCls = `${itemPrefixCls.value}-option`;
            const optionClassName = classNames(itemPrefixCls.value, optionPrefixCls, cls, className, {
              [`${optionPrefixCls}-grouped`]: groupOption,
              [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !disabled,
              [`${optionPrefixCls}-disabled`]: disabled,
              [`${optionPrefixCls}-selected`]: selected
            });
            const mergedLabel = getLabel(item);
            const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
            const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
            let optionTitle = isTitleType(content) ? content.toString() : void 0;
            if (title !== void 0) {
              optionTitle = title;
            }
            return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, passedProps), {}, {
              "aria-selected": selected,
              "class": optionClassName,
              "title": optionTitle,
              "onMousemove": (e2) => {
                if (otherProps.onMousemove) {
                  otherProps.onMousemove(e2);
                }
                if (activeIndex === itemIndex || disabled) {
                  return;
                }
                setActive(itemIndex);
              },
              "onClick": (e2) => {
                if (!disabled) {
                  onSelectValue(value);
                }
                if (otherProps.onClick) {
                  otherProps.onClick(e2);
                }
              },
              "style": style
            }), [createVNode("div", {
              "class": `${optionPrefixCls}-content`
            }, [renderOption ? renderOption(data) : content]), isValidElement(menuItemSelectedIcon) || selected, iconVisible && createVNode(TransBtn, {
              "class": `${itemPrefixCls.value}-option-state`,
              "customizeIcon": menuItemSelectedIcon,
              "customizeIconProps": {
                isSelected: selected
              }
            }, {
              default: () => [selected ? "✓" : null]
            })]);
          }
        })]);
      };
    }
  });
  var __rest$u = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function convertNodeToOption(node2) {
    const _a2 = node2, {
      key: key2,
      children
    } = _a2, _b2 = _a2.props, {
      value,
      disabled
    } = _b2, restProps = __rest$u(_b2, ["value", "disabled"]);
    const child = children === null || children === void 0 ? void 0 : children.default;
    return _extends$1({
      key: key2,
      value: value !== void 0 ? value : key2,
      children: child,
      disabled: disabled || disabled === ""
    }, restProps);
  }
  function convertChildrenToData(nodes) {
    let optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const dd = flattenChildren(nodes).map((node2, index2) => {
      var _a2;
      if (!isValidElement(node2) || !node2.type) {
        return null;
      }
      const {
        type: {
          isSelectOptGroup
        },
        key: key2,
        children,
        props: props2
      } = node2;
      if (optionOnly || !isSelectOptGroup) {
        return convertNodeToOption(node2);
      }
      const child = children && children.default ? children.default() : void 0;
      const label = (props2 === null || props2 === void 0 ? void 0 : props2.label) || ((_a2 = children.label) === null || _a2 === void 0 ? void 0 : _a2.call(children)) || key2;
      return _extends$1(_extends$1({
        key: `__RC_SELECT_GRP__${key2 === null ? index2 : String(key2)}__`
      }, props2), {
        label,
        options: convertChildrenToData(child || [])
      });
    }).filter((data) => data);
    return dd;
  }
  function useOptions(options2, children, fieldNames) {
    const mergedOptions = shallowRef();
    const valueOptions = shallowRef();
    const labelOptions = shallowRef();
    const tempMergedOptions = shallowRef([]);
    watch([options2, children], () => {
      if (options2.value) {
        tempMergedOptions.value = toRaw(options2.value).slice();
      } else {
        tempMergedOptions.value = convertChildrenToData(children.value);
      }
    }, {
      immediate: true,
      deep: true
    });
    watchEffect(() => {
      const newOptions = tempMergedOptions.value;
      const newValueOptions = /* @__PURE__ */ new Map();
      const newLabelOptions = /* @__PURE__ */ new Map();
      const fieldNamesValue = fieldNames.value;
      function dig(optionList) {
        let isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        for (let i2 = 0; i2 < optionList.length; i2 += 1) {
          const option = optionList[i2];
          if (!option[fieldNamesValue.options] || isChildren) {
            newValueOptions.set(option[fieldNamesValue.value], option);
            newLabelOptions.set(option[fieldNamesValue.label], option);
          } else {
            dig(option[fieldNamesValue.options], true);
          }
        }
      }
      dig(newOptions);
      mergedOptions.value = newOptions;
      valueOptions.value = newValueOptions;
      labelOptions.value = newLabelOptions;
    });
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }
  let uuid = 0;
  const isBrowserClient = canUseDom$1();
  function getUUID() {
    let retId;
    if (isBrowserClient) {
      retId = uuid;
      uuid += 1;
    } else {
      retId = "TEST_OR_SSR";
    }
    return retId;
  }
  function useId() {
    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref("");
    const innerId = `rc_select_${getUUID()}`;
    return id.value || innerId;
  }
  function toArray$4(value) {
    if (Array.isArray(value)) {
      return value;
    }
    return value !== void 0 ? [value] : [];
  }
  function includes(test, search) {
    return toArray$4(test).join("").toUpperCase().includes(search);
  }
  const useFilterOptions = (options2, fieldNames, searchValue, filterOption, optionFilterProp) => computed(() => {
    const searchValueVal = searchValue.value;
    const optionFilterPropValue = optionFilterProp === null || optionFilterProp === void 0 ? void 0 : optionFilterProp.value;
    const filterOptionValue = filterOption === null || filterOption === void 0 ? void 0 : filterOption.value;
    if (!searchValueVal || filterOptionValue === false) {
      return options2.value;
    }
    const {
      options: fieldOptions,
      label: fieldLabel,
      value: fieldValue
    } = fieldNames.value;
    const filteredOptions = [];
    const customizeFilter = typeof filterOptionValue === "function";
    const upperSearch = searchValueVal.toUpperCase();
    const filterFunc = customizeFilter ? filterOptionValue : (_2, option) => {
      if (optionFilterPropValue) {
        return includes(option[optionFilterPropValue], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
    options2.value.forEach((item) => {
      if (item[fieldOptions]) {
        const matchGroup = filterFunc(searchValueVal, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValueVal, wrapOption(subItem)));
          if (subOptions.length) {
            filteredOptions.push(_extends$1(_extends$1({}, item), {
              [fieldOptions]: subOptions
            }));
          }
        }
        return;
      }
      if (filterFunc(searchValueVal, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  });
  const useCache = (labeledValues, valueOptions) => {
    const cacheRef = shallowRef({
      values: /* @__PURE__ */ new Map(),
      options: /* @__PURE__ */ new Map()
    });
    const filledLabeledValues = computed(() => {
      const {
        values: prevValueCache,
        options: prevOptionCache
      } = cacheRef.value;
      const patchedValues = labeledValues.value.map((item) => {
        var _a2;
        if (item.label === void 0) {
          return _extends$1(_extends$1({}, item), {
            label: (_a2 = prevValueCache.get(item.value)) === null || _a2 === void 0 ? void 0 : _a2.label
          });
        }
        return item;
      });
      const valueCache = /* @__PURE__ */ new Map();
      const optionCache = /* @__PURE__ */ new Map();
      patchedValues.forEach((item) => {
        valueCache.set(item.value, item);
        optionCache.set(item.value, valueOptions.value.get(item.value) || prevOptionCache.get(item.value));
      });
      cacheRef.value.values = valueCache;
      cacheRef.value.options = optionCache;
      return patchedValues;
    });
    const getOption = (val) => valueOptions.value.get(val) || cacheRef.value.options.get(val);
    return [filledLabeledValues, getOption];
  };
  function useMergedState(defaultStateValue, option) {
    const {
      defaultValue,
      value = ref()
    } = option || {};
    let initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    if (value.value !== void 0) {
      initValue = unref(value);
    }
    if (defaultValue !== void 0) {
      initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
    const innerValue = ref(initValue);
    const mergedValue = ref(initValue);
    watchEffect(() => {
      let val = value.value !== void 0 ? value.value : innerValue.value;
      if (option.postState) {
        val = option.postState(val);
      }
      mergedValue.value = val;
    });
    function triggerChange(newValue) {
      const preVal = mergedValue.value;
      innerValue.value = newValue;
      if (toRaw(mergedValue.value) !== newValue && option.onChange) {
        option.onChange(newValue, preVal);
      }
    }
    watch(value, () => {
      innerValue.value = value.value;
    });
    return [mergedValue, triggerChange];
  }
  function useState(defaultStateValue) {
    const initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    const innerValue = ref(initValue);
    function triggerChange(newValue) {
      innerValue.value = newValue;
    }
    return [innerValue, triggerChange];
  }
  const OMIT_DOM_PROPS = ["inputValue"];
  function selectProps$1() {
    return _extends$1(_extends$1({}, baseSelectPropsWithoutPrivate()), {
      prefixCls: String,
      id: String,
      backfill: {
        type: Boolean,
        default: void 0
      },
      // >>> Field Names
      fieldNames: Object,
      // >>> Search
      /** @deprecated Use `searchValue` instead */
      inputValue: String,
      searchValue: String,
      onSearch: Function,
      autoClearSearchValue: {
        type: Boolean,
        default: void 0
      },
      // >>> Select
      onSelect: Function,
      onDeselect: Function,
      // >>> Options
      /**
       * In Select, `false` means do nothing.
       * In TreeSelect, `false` will highlight match item.
       * It's by design.
       */
      filterOption: {
        type: [Boolean, Function],
        default: void 0
      },
      filterSort: Function,
      optionFilterProp: String,
      optionLabelProp: String,
      options: Array,
      defaultActiveFirstOption: {
        type: Boolean,
        default: void 0
      },
      virtual: {
        type: Boolean,
        default: void 0
      },
      listHeight: Number,
      listItemHeight: Number,
      // >>> Icon
      menuItemSelectedIcon: PropTypes.any,
      mode: String,
      labelInValue: {
        type: Boolean,
        default: void 0
      },
      value: PropTypes.any,
      defaultValue: PropTypes.any,
      onChange: Function,
      children: Array
    });
  }
  function isRawValue(value) {
    return !value || typeof value !== "object";
  }
  const Select$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "VcSelect",
    inheritAttrs: false,
    props: initDefaultProps(selectProps$1(), {
      prefixCls: "vc-select",
      autoClearSearchValue: true,
      listHeight: 200,
      listItemHeight: 20,
      dropdownMatchSelectWidth: true
    }),
    setup(props2, _ref) {
      let {
        expose,
        attrs,
        slots
      } = _ref;
      const mergedId = useId(toRef(props2, "id"));
      const multiple = computed(() => isMultiple$1(props2.mode));
      const childrenAsData = computed(() => !!(!props2.options && props2.children));
      const mergedFilterOption = computed(() => {
        if (props2.filterOption === void 0 && props2.mode === "combobox") {
          return false;
        }
        return props2.filterOption;
      });
      const mergedFieldNames = computed(() => fillFieldNames$1(props2.fieldNames, childrenAsData.value));
      const [mergedSearchValue, setSearchValue] = useMergedState("", {
        value: computed(() => props2.searchValue !== void 0 ? props2.searchValue : props2.inputValue),
        postState: (search) => search || ""
      });
      const parsedOptions = useOptions(toRef(props2, "options"), toRef(props2, "children"), mergedFieldNames);
      const {
        valueOptions,
        labelOptions,
        options: mergedOptions
      } = parsedOptions;
      const convert2LabelValues = (draftValues) => {
        const valueList = toArray$4(draftValues);
        return valueList.map((val) => {
          var _a2, _b2;
          let rawValue;
          let rawLabel;
          let rawKey;
          let rawDisabled;
          if (isRawValue(val)) {
            rawValue = val;
          } else {
            rawKey = val.key;
            rawLabel = val.label;
            rawValue = (_a2 = val.value) !== null && _a2 !== void 0 ? _a2 : rawKey;
          }
          const option = valueOptions.value.get(rawValue);
          if (option) {
            if (rawLabel === void 0) rawLabel = option === null || option === void 0 ? void 0 : option[props2.optionLabelProp || mergedFieldNames.value.label];
            if (rawKey === void 0) rawKey = (_b2 = option === null || option === void 0 ? void 0 : option.key) !== null && _b2 !== void 0 ? _b2 : rawValue;
            rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
          }
          return {
            label: rawLabel,
            value: rawValue,
            key: rawKey,
            disabled: rawDisabled,
            option
          };
        });
      };
      const [internalValue, setInternalValue] = useMergedState(props2.defaultValue, {
        value: toRef(props2, "value")
      });
      const rawLabeledValues = computed(() => {
        var _a2;
        const values = convert2LabelValues(internalValue.value);
        if (props2.mode === "combobox" && !((_a2 = values[0]) === null || _a2 === void 0 ? void 0 : _a2.value)) {
          return [];
        }
        return values;
      });
      const [mergedValues, getMixedOption] = useCache(rawLabeledValues, valueOptions);
      const displayValues = computed(() => {
        if (!props2.mode && mergedValues.value.length === 1) {
          const firstValue = mergedValues.value[0];
          if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
            return [];
          }
        }
        return mergedValues.value.map((item) => {
          var _a2;
          return _extends$1(_extends$1({}, item), {
            label: (_a2 = typeof item.label === "function" ? item.label() : item.label) !== null && _a2 !== void 0 ? _a2 : item.value
          });
        });
      });
      const rawValues = computed(() => new Set(mergedValues.value.map((val) => val.value)));
      watchEffect(() => {
        var _a2;
        if (props2.mode === "combobox") {
          const strValue = (_a2 = mergedValues.value[0]) === null || _a2 === void 0 ? void 0 : _a2.value;
          if (strValue !== void 0 && strValue !== null) {
            setSearchValue(String(strValue));
          }
        }
      }, {
        flush: "post"
      });
      const createTagOption = (val, label) => {
        const mergedLabel = label !== null && label !== void 0 ? label : val;
        return {
          [mergedFieldNames.value.value]: val,
          [mergedFieldNames.value.label]: mergedLabel
        };
      };
      const filledTagOptions = shallowRef();
      watchEffect(() => {
        if (props2.mode !== "tags") {
          filledTagOptions.value = mergedOptions.value;
          return;
        }
        const cloneOptions = mergedOptions.value.slice();
        const existOptions = (val) => valueOptions.value.has(val);
        [...mergedValues.value].sort((a2, b2) => a2.value < b2.value ? -1 : 1).forEach((item) => {
          const val = item.value;
          if (!existOptions(val)) {
            cloneOptions.push(createTagOption(val, item.label));
          }
        });
        filledTagOptions.value = cloneOptions;
      });
      const filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, toRef(props2, "optionFilterProp"));
      const filledSearchOptions = computed(() => {
        if (props2.mode !== "tags" || !mergedSearchValue.value || filteredOptions.value.some((item) => item[props2.optionFilterProp || "value"] === mergedSearchValue.value)) {
          return filteredOptions.value;
        }
        return [createTagOption(mergedSearchValue.value), ...filteredOptions.value];
      });
      const orderedFilteredOptions = computed(() => {
        if (!props2.filterSort) {
          return filledSearchOptions.value;
        }
        return [...filledSearchOptions.value].sort((a2, b2) => props2.filterSort(a2, b2));
      });
      const displayOptions = computed(() => flattenOptions(orderedFilteredOptions.value, {
        fieldNames: mergedFieldNames.value,
        childrenAsData: childrenAsData.value
      }));
      const triggerChange = (values) => {
        const labeledValues = convert2LabelValues(values);
        setInternalValue(labeledValues);
        if (props2.onChange && // Trigger event only when value changed
        (labeledValues.length !== mergedValues.value.length || labeledValues.some((newVal, index2) => {
          var _a2;
          return ((_a2 = mergedValues.value[index2]) === null || _a2 === void 0 ? void 0 : _a2.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
        }))) {
          const returnValues = props2.labelInValue ? labeledValues.map((v2) => {
            return _extends$1(_extends$1({}, v2), {
              originLabel: v2.label,
              label: typeof v2.label === "function" ? v2.label() : v2.label
            });
          }) : labeledValues.map((v2) => v2.value);
          const returnOptions = labeledValues.map((v2) => injectPropsWithOption(getMixedOption(v2.value)));
          props2.onChange(
            // Value
            multiple.value ? returnValues : returnValues[0],
            // Option
            multiple.value ? returnOptions : returnOptions[0]
          );
        }
      };
      const [activeValue, setActiveValue] = useState(null);
      const [accessibilityIndex, setAccessibilityIndex] = useState(0);
      const mergedDefaultActiveFirstOption = computed(() => props2.defaultActiveFirstOption !== void 0 ? props2.defaultActiveFirstOption : props2.mode !== "combobox");
      const onActiveValue = function(active, index2) {
        let {
          source = "keyboard"
        } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        setAccessibilityIndex(index2);
        if (props2.backfill && props2.mode === "combobox" && active !== null && source === "keyboard") {
          setActiveValue(String(active));
        }
      };
      const triggerSelect = (val, selected) => {
        const getSelectEnt = () => {
          var _a2;
          const option = getMixedOption(val);
          const originLabel = option === null || option === void 0 ? void 0 : option[mergedFieldNames.value.label];
          return [props2.labelInValue ? {
            label: typeof originLabel === "function" ? originLabel() : originLabel,
            originLabel,
            value: val,
            key: (_a2 = option === null || option === void 0 ? void 0 : option.key) !== null && _a2 !== void 0 ? _a2 : val
          } : val, injectPropsWithOption(option)];
        };
        if (selected && props2.onSelect) {
          const [wrappedValue, option] = getSelectEnt();
          props2.onSelect(wrappedValue, option);
        } else if (!selected && props2.onDeselect) {
          const [wrappedValue, option] = getSelectEnt();
          props2.onDeselect(wrappedValue, option);
        }
      };
      const onInternalSelect = (val, info) => {
        let cloneValues;
        const mergedSelect = multiple.value ? info.selected : true;
        if (mergedSelect) {
          cloneValues = multiple.value ? [...mergedValues.value, val] : [val];
        } else {
          cloneValues = mergedValues.value.filter((v2) => v2.value !== val);
        }
        triggerChange(cloneValues);
        triggerSelect(val, mergedSelect);
        if (props2.mode === "combobox") {
          setActiveValue("");
        } else if (!multiple.value || props2.autoClearSearchValue) {
          setSearchValue("");
          setActiveValue("");
        }
      };
      const onDisplayValuesChange = (nextValues, info) => {
        triggerChange(nextValues);
        if (info.type === "remove" || info.type === "clear") {
          info.values.forEach((item) => {
            triggerSelect(item.value, false);
          });
        }
      };
      const onInternalSearch = (searchText, info) => {
        var _a2;
        setSearchValue(searchText);
        setActiveValue(null);
        if (info.source === "submit") {
          const formatted = (searchText || "").trim();
          if (formatted) {
            const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues.value, formatted]));
            triggerChange(newRawValues);
            triggerSelect(formatted, true);
            setSearchValue("");
          }
          return;
        }
        if (info.source !== "blur") {
          if (props2.mode === "combobox") {
            triggerChange(searchText);
          }
          (_a2 = props2.onSearch) === null || _a2 === void 0 ? void 0 : _a2.call(props2, searchText);
        }
      };
      const onInternalSearchSplit = (words) => {
        let patchValues = words;
        if (props2.mode !== "tags") {
          patchValues = words.map((word) => {
            const opt = labelOptions.value.get(word);
            return opt === null || opt === void 0 ? void 0 : opt.value;
          }).filter((val) => val !== void 0);
        }
        const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues.value, ...patchValues]));
        triggerChange(newRawValues);
        newRawValues.forEach((newRawValue) => {
          triggerSelect(newRawValue, true);
        });
      };
      const realVirtual = computed(() => props2.virtual !== false && props2.dropdownMatchSelectWidth !== false);
      useProvideSelectProps(toReactive(_extends$1(_extends$1({}, parsedOptions), {
        flattenOptions: displayOptions,
        onActiveValue,
        defaultActiveFirstOption: mergedDefaultActiveFirstOption,
        onSelect: onInternalSelect,
        menuItemSelectedIcon: toRef(props2, "menuItemSelectedIcon"),
        rawValues,
        fieldNames: mergedFieldNames,
        virtual: realVirtual,
        listHeight: toRef(props2, "listHeight"),
        listItemHeight: toRef(props2, "listItemHeight"),
        childrenAsData
      })));
      const selectRef = ref();
      expose({
        focus() {
          var _a2;
          (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur() {
          var _a2;
          (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        },
        scrollTo(arg) {
          var _a2;
          (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
        }
      });
      const pickProps = computed(() => {
        return omit$1(props2, [
          "id",
          "mode",
          "prefixCls",
          "backfill",
          "fieldNames",
          // Search
          "inputValue",
          "searchValue",
          "onSearch",
          "autoClearSearchValue",
          // Select
          "onSelect",
          "onDeselect",
          "dropdownMatchSelectWidth",
          // Options
          "filterOption",
          "filterSort",
          "optionFilterProp",
          "optionLabelProp",
          "options",
          "children",
          "defaultActiveFirstOption",
          "menuItemSelectedIcon",
          "virtual",
          "listHeight",
          "listItemHeight",
          // Value
          "value",
          "defaultValue",
          "labelInValue",
          "onChange"
        ]);
      });
      return () => {
        return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
          "id": mergedId,
          "prefixCls": props2.prefixCls,
          "ref": selectRef,
          "omitDomProps": OMIT_DOM_PROPS,
          "mode": props2.mode,
          "displayValues": displayValues.value,
          "onDisplayValuesChange": onDisplayValuesChange,
          "searchValue": mergedSearchValue.value,
          "onSearch": onInternalSearch,
          "onSearchSplit": onInternalSearchSplit,
          "dropdownMatchSelectWidth": props2.dropdownMatchSelectWidth,
          "OptionList": OptionList,
          "emptyOptions": !displayOptions.value.length,
          "activeValue": activeValue.value,
          "activeDescendantId": `${mergedId}_list_${accessibilityIndex.value}`
        }), slots);
      };
    }
  });
  const Option = () => null;
  Option.isSelectOption = true;
  Option.displayName = "ASelectOption";
  const OptGroup = () => null;
  OptGroup.isSelectOptGroup = true;
  OptGroup.displayName = "ASelectOptGroup";
  var DownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
  var contextKey = Symbol("iconContext");
  var useInjectIconContext = function useInjectIconContext2() {
    return inject(contextKey, {
      prefixCls: ref("anticon"),
      rootClassName: ref(""),
      csp: ref()
    });
  };
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    return false;
  }
  var APPEND_ORDER = "data-vc-order";
  var MARK_KEY = "vc-icon-key";
  var containerCache = /* @__PURE__ */ new Map();
  function getMark() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
    if (mark) {
      return mark.startsWith("data-") ? mark : "data-".concat(mark);
    }
    return MARK_KEY;
  }
  function getContainer$1(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
      return node2.tagName === "STYLE";
    });
  }
  function injectCSS(css2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) {
      return null;
    }
    var csp = option.csp, prepend = option.prepend;
    var styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
    if (csp && csp.nonce) {
      styleNode.nonce = csp.nonce;
    }
    styleNode.innerHTML = css2;
    var container = getContainer$1(option);
    var firstChild = container.firstChild;
    if (prepend) {
      if (prepend === "queue") {
        var existStyle = findStyles(container).filter(function(node2) {
          return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer$1(option);
    return findStyles(container).find(function(node2) {
      return node2.getAttribute(getMark(option)) === key2;
    });
  }
  function syncRealContainer(container, option) {
    var cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      var placeholderStyle = injectCSS("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css2, key2) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer$1(option);
    syncRealContainer(container, option);
    var existNode = findExistNode(key2, option);
    if (existNode) {
      if (option.csp && option.csp.nonce && existNode.nonce !== option.csp.nonce) {
        existNode.nonce = option.csp.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    var newNode = injectCSS(css2, option);
    newNode.setAttribute(getMark(option), key2);
    return newNode;
  }
  function _objectSpread$x(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$x(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$x(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function warning$1(valid, message) {
  }
  function isIconDefinition(target) {
    return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
  }
  function generate(node2, key2, rootProps) {
    if (!rootProps) {
      return h$1(node2.tag, _objectSpread$x({
        key: key2
      }, node2.attrs), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    return h$1(node2.tag, _objectSpread$x({
      key: key2
    }, rootProps, node2.attrs), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  function getSecondaryColor(primaryColor) {
    return generate$1(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  function getRoot(ele) {
    return ele && ele.getRootNode && ele.getRootNode();
  }
  function inShadow(ele) {
    if (!canUseDom()) {
      return false;
    }
    return getRoot(ele) instanceof ShadowRoot;
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }
  var useInsertStyles = function useInsertStyles2() {
    var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, csp = _useInjectIconContext.csp;
    var instance = getCurrentInstance();
    var mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls.value);
    }
    nextTick(function() {
      if (!canUseDom()) {
        return;
      }
      var ele = instance.vnode.el;
      var shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-vue-icons", {
        prepend: true,
        csp: csp.value,
        attachTo: shadowRoot
      });
    });
  };
  var _excluded$1 = ["icon", "primaryColor", "secondaryColor"];
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$1(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  function _objectSpread$w(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$w(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$w(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var twoToneColorPalette = reactive({
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  });
  function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return _objectSpread$w({}, twoToneColorPalette);
  }
  var IconBase = function IconBase2(props2, context) {
    var _props$context$attrs = _objectSpread$w({}, props2, context.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
    var colors = twoToneColorPalette;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    warning$1(isIconDefinition(icon));
    if (!isIconDefinition(icon)) {
      return null;
    }
    var target = icon;
    if (target && typeof target.icon === "function") {
      target = _objectSpread$w({}, target, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return generate(target.icon, "svg-".concat(target.name), _objectSpread$w({}, restProps, {
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }));
  };
  IconBase.props = {
    icon: Object,
    primaryColor: String,
    secondaryColor: String,
    focusable: String
  };
  IconBase.inheritAttrs = false;
  IconBase.displayName = "IconBase";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  function _slicedToArray$1(arr, i2) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$1(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray$1(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o2, minLen);
  }
  function _arrayLikeToArray$1(arr, len2) {
    if (len2 == null || len2 > arr.length) len2 = arr.length;
    for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit$1(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function setTwoToneColor(twoToneColor) {
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return IconBase.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    var colors = IconBase.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }
  var InsertStyles = /* @__PURE__ */ defineComponent({
    name: "InsertStyles",
    setup: function setup() {
      useInsertStyles();
      return function() {
        return null;
      };
    }
  });
  var _excluded = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len2) {
    if (len2 == null || len2 > arr.length) len2 = arr.length;
    for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _objectSpread$v(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$v(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$v(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  setTwoToneColor(blue.primary);
  var Icon = function Icon2(props2, context) {
    var _classObj;
    var _props$context$attrs = _objectSpread$v({}, props2, context.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate2 = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
    var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, rootClassName = _useInjectIconContext.rootClassName;
    var classObj = (_classObj = {}, _defineProperty$v(_classObj, rootClassName.value, !!rootClassName.value), _defineProperty$v(_classObj, prefixCls.value, true), _defineProperty$v(_classObj, "".concat(prefixCls.value, "-").concat(icon.name), Boolean(icon.name)), _defineProperty$v(_classObj, "".concat(prefixCls.value, "-spin"), !!spin || icon.name === "loading"), _classObj);
    var iconTabIndex = tabindex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate2 ? {
      msTransform: "rotate(".concat(rotate2, "deg)"),
      transform: "rotate(".concat(rotate2, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return createVNode("span", _objectSpread$v({
      "role": "img",
      "aria-label": icon.name
    }, restProps, {
      "onClick": onClick,
      "class": [classObj, cls],
      "tabindex": iconTabIndex
    }), [createVNode(IconBase, {
      "icon": icon,
      "primaryColor": primaryColor,
      "secondaryColor": secondaryColor,
      "style": svgStyle
    }, null), createVNode(InsertStyles, null, null)]);
  };
  Icon.props = {
    spin: Boolean,
    rotate: Number,
    icon: Object,
    twoToneColor: [String, Array]
  };
  Icon.displayName = "AntdIcon";
  Icon.inheritAttrs = false;
  Icon.getTwoToneColor = getTwoToneColor;
  Icon.setTwoToneColor = setTwoToneColor;
  function _objectSpread$u(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$u(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$u(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var DownOutlined = function DownOutlined2(props2, context) {
    var p2 = _objectSpread$u({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$u({}, p2, {
      "icon": DownOutlined$1
    }), null);
  };
  DownOutlined.displayName = "DownOutlined";
  DownOutlined.inheritAttrs = false;
  var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  function _objectSpread$t(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$t(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$t(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var LoadingOutlined = function LoadingOutlined2(props2, context) {
    var p2 = _objectSpread$t({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$t({}, p2, {
      "icon": LoadingOutlined$1
    }), null);
  };
  LoadingOutlined.displayName = "LoadingOutlined";
  LoadingOutlined.inheritAttrs = false;
  var CheckOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
  function _objectSpread$s(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$s(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$s(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CheckOutlined = function CheckOutlined2(props2, context) {
    var p2 = _objectSpread$s({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$s({}, p2, {
      "icon": CheckOutlined$1
    }), null);
  };
  CheckOutlined.displayName = "CheckOutlined";
  CheckOutlined.inheritAttrs = false;
  var CloseOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
  function _objectSpread$r(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$r(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$r(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CloseOutlined = function CloseOutlined2(props2, context) {
    var p2 = _objectSpread$r({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$r({}, p2, {
      "icon": CloseOutlined$1
    }), null);
  };
  CloseOutlined.displayName = "CloseOutlined";
  CloseOutlined.inheritAttrs = false;
  var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
  function _objectSpread$q(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$q(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$q(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CloseCircleFilled = function CloseCircleFilled2(props2, context) {
    var p2 = _objectSpread$q({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$q({}, p2, {
      "icon": CloseCircleFilled$1
    }), null);
  };
  CloseCircleFilled.displayName = "CloseCircleFilled";
  CloseCircleFilled.inheritAttrs = false;
  var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
  function _objectSpread$p(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$p(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$p(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var SearchOutlined = function SearchOutlined2(props2, context) {
    var p2 = _objectSpread$p({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$p({}, p2, {
      "icon": SearchOutlined$1
    }), null);
  };
  SearchOutlined.displayName = "SearchOutlined";
  SearchOutlined.inheritAttrs = false;
  function getIcons(props2) {
    let slots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      loading,
      multiple,
      prefixCls,
      hasFeedback,
      feedbackIcon,
      showArrow
    } = props2;
    const suffixIcon = props2.suffixIcon || slots.suffixIcon && slots.suffixIcon();
    const clearIcon = props2.clearIcon || slots.clearIcon && slots.clearIcon();
    const menuItemSelectedIcon = props2.menuItemSelectedIcon || slots.menuItemSelectedIcon && slots.menuItemSelectedIcon();
    const removeIcon = props2.removeIcon || slots.removeIcon && slots.removeIcon();
    const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : createVNode(CloseCircleFilled, null, null);
    const getSuffixIconNode = (arrowIcon) => createVNode(Fragment, null, [showArrow !== false && arrowIcon, hasFeedback && feedbackIcon]);
    let mergedSuffixIcon = null;
    if (suffixIcon !== void 0) {
      mergedSuffixIcon = getSuffixIconNode(suffixIcon);
    } else if (loading) {
      mergedSuffixIcon = getSuffixIconNode(createVNode(LoadingOutlined, {
        "spin": true
      }, null));
    } else {
      const iconCls = `${prefixCls}-suffix`;
      mergedSuffixIcon = (_ref) => {
        let {
          open: open2,
          showSearch
        } = _ref;
        if (open2 && showSearch) {
          return getSuffixIconNode(createVNode(SearchOutlined, {
            "class": iconCls
          }, null));
        }
        return getSuffixIconNode(createVNode(DownOutlined, {
          "class": iconCls
        }, null));
      };
    }
    let mergedItemIcon = null;
    if (menuItemSelectedIcon !== void 0) {
      mergedItemIcon = menuItemSelectedIcon;
    } else if (multiple) {
      mergedItemIcon = createVNode(CheckOutlined, null, null);
    } else {
      mergedItemIcon = null;
    }
    let mergedRemoveIcon = null;
    if (removeIcon !== void 0) {
      mergedRemoveIcon = removeIcon;
    } else {
      mergedRemoveIcon = createVNode(CloseOutlined, null, null);
    }
    return {
      clearIcon: mergedClearIcon,
      suffixIcon: mergedSuffixIcon,
      itemIcon: mergedItemIcon,
      removeIcon: mergedRemoveIcon
    };
  }
  function createContext(defaultValue) {
    const contextKey2 = Symbol("contextKey");
    const useProvide = (props2, newProps) => {
      const mergedProps = reactive({});
      provide(contextKey2, mergedProps);
      watchEffect(() => {
        _extends$1(mergedProps, props2, newProps || {});
      });
      return mergedProps;
    };
    const useInject = () => {
      return inject(contextKey2, defaultValue) || {};
    };
    return {
      useProvide,
      useInject
    };
  }
  const ContextKey$1 = Symbol("ContextProps");
  const InternalContextKey = Symbol("InternalContextProps");
  const useProvideFormItemContext = function(props2) {
    let useValidation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : computed(() => true);
    const formItemFields = ref(/* @__PURE__ */ new Map());
    const addFormItemField = (key2, type) => {
      formItemFields.value.set(key2, type);
      formItemFields.value = new Map(formItemFields.value);
    };
    const removeFormItemField = (key2) => {
      formItemFields.value.delete(key2);
      formItemFields.value = new Map(formItemFields.value);
    };
    watch([useValidation, formItemFields], () => {
    });
    provide(ContextKey$1, props2);
    provide(InternalContextKey, {
      addFormItemField,
      removeFormItemField
    });
  };
  const defaultContext = {
    id: computed(() => void 0),
    onFieldBlur: () => {
    },
    onFieldChange: () => {
    },
    clearValidate: () => {
    }
  };
  const defaultInternalContext = {
    addFormItemField: () => {
    },
    removeFormItemField: () => {
    }
  };
  const useInjectFormItemContext = () => {
    const internalContext = inject(InternalContextKey, defaultInternalContext);
    const formItemFieldKey = Symbol("FormItemFieldKey");
    const instance = getCurrentInstance();
    internalContext.addFormItemField(formItemFieldKey, instance.type);
    onBeforeUnmount(() => {
      internalContext.removeFormItemField(formItemFieldKey);
    });
    provide(InternalContextKey, defaultInternalContext);
    provide(ContextKey$1, defaultContext);
    return inject(ContextKey$1, defaultContext);
  };
  const FormItemRest = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AFormItemRest",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      provide(InternalContextKey, defaultInternalContext);
      provide(ContextKey$1, defaultContext);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const FormItemInputContext = createContext({});
  const NoFormStatus = /* @__PURE__ */ defineComponent({
    name: "NoFormStatus",
    setup(_2, _ref2) {
      let {
        slots
      } = _ref2;
      FormItemInputContext.useProvide({});
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  function getStatusClassNames(prefixCls, status, hasFeedback) {
    return classNames({
      [`${prefixCls}-status-success`]: status === "success",
      [`${prefixCls}-status-warning`]: status === "warning",
      [`${prefixCls}-status-error`]: status === "error",
      [`${prefixCls}-status-validating`]: status === "validating",
      [`${prefixCls}-has-feedback`]: hasFeedback
    });
  }
  const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
  const genSpaceCompactStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-block": {
          display: "flex",
          width: "100%"
        },
        "&-vertical": {
          flexDirection: "column"
        }
      }
    };
  };
  const genSpaceStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-rtl": {
          direction: "rtl"
        },
        "&-vertical": {
          flexDirection: "column"
        },
        "&-align": {
          flexDirection: "column",
          "&-center": {
            alignItems: "center"
          },
          "&-start": {
            alignItems: "flex-start"
          },
          "&-end": {
            alignItems: "flex-end"
          },
          "&-baseline": {
            alignItems: "baseline"
          }
        },
        [`${componentCls}-item`]: {
          "&:empty": {
            display: "none"
          }
        }
      }
    };
  };
  const useStyle$j = genComponentStyleHook("Space", (token2) => [genSpaceStyle(token2), genSpaceCompactStyle(token2)]);
  var symbolTag$2 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
  }
  function arrayMap(array, iteratee) {
    var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray$2(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace.test(string2.charAt(index2))) {
    }
    return index2;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$5(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$5(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$1 || value === -INFINITY$1) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function identity$1(value) {
    return value;
  }
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto2) {
      if (!isObject$5(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object.prototype = proto2;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function noop$4() {
  }
  function copyArray(source, array) {
    var index2 = -1, length2 = source.length;
    array || (array = Array(length2));
    while (++index2 < length2) {
      array[index2] = source[index2];
    }
    return array;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var baseSetToString = !defineProperty ? identity$1 : function(func, string2) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string2),
      "writable": true
    });
  };
  var setToString = shortOut(baseSetToString);
  function arrayEach(array, iteratee) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length2 = array.length, index2 = fromIndex + -1;
    while (++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function strictIndexOf(array, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array.length;
    while (++index2 < length2) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  function arrayIncludes(array, value) {
    var length2 = array == null ? 0 : array.length;
    return !!length2 && baseIndexOf(array, value, 0) > -1;
  }
  function baseAssignValue(object, key2, value) {
    if (key2 == "__proto__" && defineProperty) {
      defineProperty(object, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key2] = value;
    }
  }
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty$5.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function copyObject(source, props2, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length2 = props2.length;
    while (++index2 < length2) {
      var key2 = props2[index2];
      var newValue = void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object, key2, newValue);
      } else {
        assignValue(object, key2, newValue);
      }
    }
    return object;
  }
  var nativeMax$2 = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax$2(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start2, 0), array = Array(length2);
      while (++index2 < length2) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity$1), func + "");
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key2 in Object(object)) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject$5(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key2 in object) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty$4.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function keysIn(object) {
    return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray$2(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function() {
      var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key2)) {
        return cache2.get(key2);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key2, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key2) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key2;
    });
    var cache2 = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match2, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
    });
    return result;
  });
  function toString$1(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object) {
    if (isArray$2(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString$1(value));
  }
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function baseGet(object, path) {
    path = castPath(path, object);
    var index2 = 0, length2 = path.length;
    while (object != null && index2 < length2) {
      object = object[toKey(path[index2++])];
    }
    return index2 && index2 == length2 ? object : void 0;
  }
  function get$2(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray$2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array[index2];
      if (predicate(value)) {
        {
          arrayPush(result, value);
        }
      } else {
        result[result.length] = value;
      }
    }
    return result;
  }
  function flatten(array) {
    var length2 = array == null ? 0 : array.length;
    return length2 ? baseFlatten(array) : [];
  }
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectTag$1 = "[object Object]";
  var funcProto = Function.prototype, objectProto$2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject$1(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty$3.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function baseSlice(array, start2, end2) {
    var index2 = -1, length2 = array.length;
    if (start2 < 0) {
      start2 = -start2 > length2 ? 0 : length2 + start2;
    }
    end2 = end2 > length2 ? length2 : end2;
    if (end2 < 0) {
      end2 += length2;
    }
    length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
    start2 >>>= 0;
    var result = Array(length2);
    while (++index2 < length2) {
      result[index2] = array[index2 + start2];
    }
    return result;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys$1(source), object);
  }
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer$1 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
    buffer.copy(result);
    return result;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
  function initCloneArray(array) {
    var length2 = array.length, result = new array.constructor(length2);
    if (length2 && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp3) {
    var result = new regexp3.constructor(regexp3.source, reFlags.exec(regexp3));
    result.lastIndex = regexp3.lastIndex;
    return result;
  }
  var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$3 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);
      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);
      case dataViewTag$1:
        return cloneDataView(object, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);
      case mapTag$3:
        return new Ctor();
      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);
      case regexpTag$1:
        return cloneRegExp(object);
      case setTag$3:
        return new Ctor();
      case symbolTag$1:
        return cloneSymbol(object);
    }
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var mapTag$2 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag$2;
  }
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var setTag$2 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag$2;
  }
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag$1] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key2, object, stack2) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) {
      result = object ? customizer(value, key2, object, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject$5(value)) {
      return value;
    }
    var isArr = isArray$2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer$1(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key3) {
        result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;
    var props2 = isArr ? void 0 : keysFunc(value);
    arrayEach(props2 || value, function(subValue, key3) {
      if (props2) {
        key3 = subValue;
        subValue = value[key3];
      }
      assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
    });
    return result;
  }
  var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2;
    if (object == null) {
      return !length2;
    }
    object = Object(object);
    while (index2--) {
      var data = matchData[index2];
      if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data = matchData[index2];
      var key2 = data[0], objValue = object[key2], srcValue = data[1];
      if (data[2]) {
        if (objValue === void 0 && !(key2 in object)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        var result;
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject$5(value);
  }
  function getMatchData(object) {
    var result = keys$1(object), length2 = result.length;
    while (length2--) {
      var key2 = result[length2], value = object[key2];
      result[length2] = [key2, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key2, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseHasIn(object, key2) {
    return object != null && key2 in Object(object);
  }
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index2 = -1, length2 = path.length, result = false;
    while (++index2 < length2) {
      var key2 = toKey(path[index2]);
      if (!(result = object != null && hasFunc(object, key2))) {
        break;
      }
      object = object[key2];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object == null ? 0 : object.length;
    return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray$2(object) || isArguments(object));
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get$2(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key2) {
    return function(object) {
      return object == null ? void 0 : object[key2];
    };
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity$1;
    }
    if (typeof value == "object") {
      return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  var now$2 = function() {
    return root.Date.now();
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
  function debounce$1(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject$5(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax$1(toNumber(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time2) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time2;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time2) {
      lastInvokeTime = time2;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time2) : result;
    }
    function remainingWait(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time2 = now$2();
      if (shouldInvoke(time2)) {
        return trailingEdge(time2);
      }
      timerId = setTimeout(timerExpired, remainingWait(time2));
    }
    function trailingEdge(time2) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time2);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now$2());
    }
    function debounced() {
      var time2 = now$2(), isInvoking = shouldInvoke(time2);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time2;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike$1(value);
  }
  function last(array) {
    var length2 = array == null ? 0 : array.length;
    return length2 ? array[length2 - 1] : void 0;
  }
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike$1(collection)) {
        var iteratee = baseIteratee(predicate);
        collection = keys$1(collection);
        predicate = function(key2) {
          return iteratee(iterable[key2], key2, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  var nativeMax = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length2 = array == null ? 0 : array.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index2);
  }
  var find$1 = createFind(findIndex);
  function fromPairs(pairs) {
    var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result = {};
    while (++index2 < length2) {
      var pair = pairs[index2];
      result[pair[0]] = pair[1];
    }
    return result;
  }
  var nativeMin = Math.min;
  function baseIntersection(arrays, iteratee, comparator) {
    var includes2 = arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = length2 >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : void 0;
    }
    array = arrays[0];
    var index2 = -1, seen2 = caches[0];
    outer:
      while (++index2 < length2 && result.length < maxLength) {
        var value = array[index2], computed2 = value;
        value = value !== 0 ? value : 0;
        if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result, computed2))) {
          othIndex = othLength;
          while (--othIndex) {
            var cache2 = caches[othIndex];
            if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2))) {
              continue outer;
            }
          }
          if (seen2) {
            seen2.push(computed2);
          }
          result.push(value);
        }
      }
    return result;
  }
  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }
  var intersection = baseRest(function(arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });
  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty$1 = objectProto.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike$1(value) && (isArray$2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray$2(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key2 in value) {
      if (hasOwnProperty$1.call(value, key2)) {
        return false;
      }
    }
    return true;
  }
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }
  function customOmitClone(value) {
    return isPlainObject$1(value) ? void 0 : value;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function(object, paths) {
    var result = {};
    if (object == null) {
      return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function(path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length2 = paths.length;
    while (length2--) {
      baseUnset(result, paths[length2]);
    }
    return result;
  });
  var INFINITY = 1 / 0;
  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$4 : function(values) {
    return new Set$1(values);
  };
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen2 = result;
    if (length2 >= LARGE_ARRAY_SIZE) {
      var set2 = createSet(array);
      if (set2) {
        return setToArray(set2);
      }
      isCommon = false;
      includes2 = cacheHas;
      seen2 = new SetCache();
    } else {
      seen2 = result;
    }
    outer:
      while (++index2 < length2) {
        var value = array[index2], computed2 = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed2 === computed2) {
          var seenIndex = seen2.length;
          while (seenIndex--) {
            if (seen2[seenIndex] === computed2) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes2(seen2, computed2, comparator)) {
          if (seen2 !== result) {
            seen2.push(computed2);
          }
          result.push(value);
        }
      }
    return result;
  }
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  const spaceCompactItemProps = () => ({
    compactSize: String,
    compactDirection: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
    isFirstItem: booleanType(),
    isLastItem: booleanType()
  });
  const SpaceCompactItemContext = createContext(null);
  const useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = SpaceCompactItemContext.useInject();
    const compactItemClassnames = computed(() => {
      if (!compactItemContext || isEmpty(compactItemContext)) return "";
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return classNames({
        [`${prefixCls.value}-compact${separator}item`]: true,
        [`${prefixCls.value}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls.value}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls.value}-compact${separator}item-rtl`]: direction.value === "rtl"
      });
    });
    return {
      compactSize: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize),
      compactDirection: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection),
      compactItemClassnames
    };
  };
  const NoCompactStyle = /* @__PURE__ */ defineComponent({
    name: "NoCompactStyle",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      SpaceCompactItemContext.useProvide(null);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const spaceCompactProps = () => ({
    prefixCls: String,
    size: {
      type: String
    },
    direction: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
    align: PropTypes.oneOf(tuple("start", "end", "center", "baseline")),
    block: {
      type: Boolean,
      default: void 0
    }
  });
  const CompactItem = /* @__PURE__ */ defineComponent({
    name: "CompactItem",
    props: spaceCompactItemProps(),
    setup(props2, _ref2) {
      let {
        slots
      } = _ref2;
      SpaceCompactItemContext.useProvide(props2);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  /* @__PURE__ */ defineComponent({
    name: "ASpaceCompact",
    inheritAttrs: false,
    props: spaceCompactProps(),
    setup(props2, _ref3) {
      let {
        attrs,
        slots
      } = _ref3;
      const {
        prefixCls,
        direction: directionConfig
      } = useConfigInject("space-compact", props2);
      const compactItemContext = SpaceCompactItemContext.useInject();
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const clx = computed(() => {
        return classNames(prefixCls.value, hashId.value, {
          [`${prefixCls.value}-rtl`]: directionConfig.value === "rtl",
          [`${prefixCls.value}-block`]: props2.block,
          [`${prefixCls.value}-vertical`]: props2.direction === "vertical"
        });
      });
      return () => {
        var _a2;
        const childNodes = flattenChildren(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || []);
        if (childNodes.length === 0) {
          return null;
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [clx.value, attrs.class]
        }), [childNodes.map((child, i2) => {
          var _a3;
          const key2 = child && child.key || `${prefixCls.value}-item-${i2}`;
          const noCompactItemContext = !compactItemContext || isEmpty(compactItemContext);
          return createVNode(CompactItem, {
            "key": key2,
            "compactSize": (_a3 = props2.size) !== null && _a3 !== void 0 ? _a3 : "middle",
            "compactDirection": props2.direction,
            "isFirstItem": i2 === 0 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
            "isLastItem": i2 === childNodes.length - 1 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
          }, {
            default: () => [child]
          });
        })]));
      };
    }
  });
  const initMotionCommon = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotionCommonLeave = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
    let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: _extends$1(_extends$1({}, initMotionCommon(duration)), {
        animationPlayState: "paused"
      }),
      [`${sameLevelPrefix}${motionCls}-leave`]: _extends$1(_extends$1({}, initMotionCommonLeave(duration)), {
        animationPlayState: "paused"
      }),
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };
  const moveDownIn = new Keyframe("antMoveDownIn", {
    "0%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut = new Keyframe("antMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveLeftIn = new Keyframe("antMoveLeftIn", {
    "0%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveLeftOut = new Keyframe("antMoveLeftOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveRightIn = new Keyframe("antMoveRightIn", {
    "0%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveRightOut = new Keyframe("antMoveRightOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveUpIn = new Keyframe("antMoveUpIn", {
    "0%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveUpOut = new Keyframe("antMoveUpOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveMotion = {
    "move-up": {
      inKeyframes: moveUpIn,
      outKeyframes: moveUpOut
    },
    "move-down": {
      inKeyframes: moveDownIn,
      outKeyframes: moveDownOut
    },
    "move-left": {
      inKeyframes: moveLeftIn,
      outKeyframes: moveLeftOut
    },
    "move-right": {
      inKeyframes: moveRightIn,
      outKeyframes: moveRightOut
    }
  };
  const initMoveMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = moveMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const slideUpIn = new Keyframe("antSlideUpIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideUpOut = new Keyframe("antSlideUpOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideDownIn = new Keyframe("antSlideDownIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    }
  });
  const slideDownOut = new Keyframe("antSlideDownOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    }
  });
  const slideLeftIn = new Keyframe("antSlideLeftIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideLeftOut = new Keyframe("antSlideLeftOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideRightIn = new Keyframe("antSlideRightIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    }
  });
  const slideRightOut = new Keyframe("antSlideRightOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    }
  });
  const slideMotion = {
    "slide-up": {
      inKeyframes: slideUpIn,
      outKeyframes: slideUpOut
    },
    "slide-down": {
      inKeyframes: slideDownIn,
      outKeyframes: slideDownOut
    },
    "slide-left": {
      inKeyframes: slideLeftIn,
      outKeyframes: slideLeftOut
    },
    "slide-right": {
      inKeyframes: slideRightIn,
      outKeyframes: slideRightOut
    }
  };
  const initSlideMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = slideMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
        transform: "scale(0)",
        transformOrigin: "0% 0%",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutQuint
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInQuint
      }
    }];
  };
  const zoomIn = new Keyframe("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomOut = new Keyframe("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  const zoomBigIn = new Keyframe("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomBigOut = new Keyframe("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  const zoomUpIn = new Keyframe("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  const zoomUpOut = new Keyframe("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  const zoomLeftIn = new Keyframe("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  const zoomLeftOut = new Keyframe("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  const zoomRightIn = new Keyframe("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  const zoomRightOut = new Keyframe("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  const zoomDownIn = new Keyframe("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  const zoomDownOut = new Keyframe("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  const zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  const initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const genCollapseMotion = (token2) => ({
    [token2.componentCls]: {
      // For common/openAnimation
      [`${token2.antCls}-motion-collapse-legacy`]: {
        overflow: "hidden",
        "&-active": {
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      },
      [`${token2.antCls}-motion-collapse`]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    }
  });
  const genItemStyle = (token2) => {
    const {
      controlPaddingHorizontal
    } = token2;
    return {
      position: "relative",
      display: "block",
      minHeight: token2.controlHeight,
      padding: `${(token2.controlHeight - token2.fontSize * token2.lineHeight) / 2}px ${controlPaddingHorizontal}px`,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight,
      boxSizing: "border-box"
    };
  };
  const genSingleStyle$1 = (token2) => {
    const {
      antCls,
      componentCls
    } = token2;
    const selectItemCls = `${componentCls}-item`;
    return [
      {
        [`${componentCls}-dropdown`]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          top: -9999,
          zIndex: token2.zIndexPopup,
          boxSizing: "border-box",
          padding: token2.paddingXXS,
          overflow: "hidden",
          fontSize: token2.fontSize,
          // Fix select render lag of long text in chrome
          // https://github.com/ant-design/ant-design/issues/11456
          // https://github.com/ant-design/ant-design/issues/11843
          fontVariant: "initial",
          backgroundColor: token2.colorBgElevated,
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft
          `]: {
            animationName: slideUpIn
          },
          [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft
          `]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft`]: {
            animationName: slideUpOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft`]: {
            animationName: slideDownOut
          },
          "&-hidden": {
            display: "none"
          },
          "&-empty": {
            color: token2.colorTextDisabled
          },
          // ========================= Options =========================
          [`${selectItemCls}-empty`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
            color: token2.colorTextDisabled
          }),
          [`${selectItemCls}`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
            cursor: "pointer",
            transition: `background ${token2.motionDurationSlow} ease`,
            borderRadius: token2.borderRadiusSM,
            // =========== Group ============
            "&-group": {
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeSM,
              cursor: "default"
            },
            // =========== Option ===========
            "&-option": {
              display: "flex",
              "&-content": _extends$1({
                flex: "auto"
              }, textEllipsis),
              "&-state": {
                flex: "none"
              },
              [`&-active:not(${selectItemCls}-option-disabled)`]: {
                backgroundColor: token2.controlItemBgHover
              },
              [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                color: token2.colorText,
                fontWeight: token2.fontWeightStrong,
                backgroundColor: token2.controlItemBgActive,
                [`${selectItemCls}-option-state`]: {
                  color: token2.colorPrimary
                }
              },
              "&-disabled": {
                [`&${selectItemCls}-option-selected`]: {
                  backgroundColor: token2.colorBgContainerDisabled
                },
                color: token2.colorTextDisabled,
                cursor: "not-allowed"
              },
              "&-grouped": {
                paddingInlineStart: token2.controlPaddingHorizontal * 2
              }
            }
          }),
          // =========================== RTL ===========================
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Follow code may reuse in other components
      initSlideMotion(token2, "slide-up"),
      initSlideMotion(token2, "slide-down"),
      initMoveMotion(token2, "move-up"),
      initMoveMotion(token2, "move-down")
    ];
  };
  const FIXED_ITEM_MARGIN = 2;
  function getSelectItemStyle(_ref) {
    let {
      controlHeightSM,
      controlHeight,
      lineWidth: borderWidth
    } = _ref;
    const selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
    const selectItemMargin = Math.ceil(selectItemDist / 2);
    return [selectItemDist, selectItemMargin];
  }
  function genSizeStyle$2(token2, suffix) {
    const {
      componentCls,
      iconCls
    } = token2;
    const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
    const selectItemHeight = token2.controlHeightSM;
    const [selectItemDist] = getSelectItemStyle(token2);
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    return {
      [`${componentCls}-multiple${suffixCls}`]: {
        fontSize: token2.fontSize,
        /**
         * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
         * may update to redesign with its align logic.
         */
        // =========================== Overflow ===========================
        [selectOverflowPrefixCls]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          flexWrap: "wrap",
          maxWidth: "100%",
          "&-item": {
            flex: "none",
            alignSelf: "center",
            maxWidth: "100%",
            display: "inline-flex"
          }
        },
        // ========================= Selector =========================
        [`${componentCls}-selector`]: {
          display: "flex",
          flexWrap: "wrap",
          alignItems: "center",
          // Multiple is little different that horizontal is follow the vertical
          padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${FIXED_ITEM_MARGIN * 2}px`,
          borderRadius: token2.borderRadius,
          [`${componentCls}-show-search&`]: {
            cursor: "text"
          },
          [`${componentCls}-disabled&`]: {
            background: token2.colorBgContainerDisabled,
            cursor: "not-allowed"
          },
          "&:after": {
            display: "inline-block",
            width: 0,
            margin: `${FIXED_ITEM_MARGIN}px 0`,
            lineHeight: `${selectItemHeight}px`,
            content: '"\\a0"'
          }
        },
        [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
          paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
        },
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          position: "relative",
          display: "flex",
          flex: "none",
          boxSizing: "border-box",
          maxWidth: "100%",
          height: selectItemHeight,
          marginTop: FIXED_ITEM_MARGIN,
          marginBottom: FIXED_ITEM_MARGIN,
          lineHeight: `${selectItemHeight - token2.lineWidth * 2}px`,
          background: token2.colorFillSecondary,
          border: `${token2.lineWidth}px solid ${token2.colorSplit}`,
          borderRadius: token2.borderRadiusSM,
          cursor: "default",
          transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          userSelect: "none",
          marginInlineEnd: FIXED_ITEM_MARGIN * 2,
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS / 2,
          [`${componentCls}-disabled&`]: {
            color: token2.colorTextDisabled,
            borderColor: token2.colorBorder,
            cursor: "not-allowed"
          },
          // It's ok not to do this, but 24px makes bottom narrow in view should adjust
          "&-content": {
            display: "inline-block",
            marginInlineEnd: token2.paddingXS / 2,
            overflow: "hidden",
            whiteSpace: "pre",
            textOverflow: "ellipsis"
          },
          "&-remove": _extends$1(_extends$1({}, resetIcon()), {
            display: "inline-block",
            color: token2.colorIcon,
            fontWeight: "bold",
            fontSize: 10,
            lineHeight: "inherit",
            cursor: "pointer",
            [`> ${iconCls}`]: {
              verticalAlign: "-0.2em"
            },
            "&:hover": {
              color: token2.colorIconHover
            }
          })
        },
        // ========================== Input ==========================
        [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
          [`${componentCls}-selection-search`]: {
            marginInlineStart: 0
          }
        },
        [`${componentCls}-selection-search`]: {
          display: "inline-flex",
          position: "relative",
          maxWidth: "100%",
          marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
          [`
          &-input,
          &-mirror
        `]: {
            height: selectItemHeight,
            fontFamily: token2.fontFamily,
            lineHeight: `${selectItemHeight}px`,
            transition: `all ${token2.motionDurationSlow}`
          },
          "&-input": {
            width: "100%",
            minWidth: 4.1
            // fix search cursor missing
          },
          "&-mirror": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            insetInlineEnd: "auto",
            zIndex: 999,
            whiteSpace: "pre",
            visibility: "hidden"
          }
        },
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder `]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: token2.inputPaddingHorizontalBase,
          insetInlineEnd: token2.inputPaddingHorizontalBase,
          transform: "translateY(-50%)",
          transition: `all ${token2.motionDurationSlow}`
        }
      }
    };
  }
  function genMultipleStyle(token2) {
    const {
      componentCls
    } = token2;
    const smallToken = merge$2(token2, {
      controlHeight: token2.controlHeightSM,
      controlHeightSM: token2.controlHeightXS,
      borderRadius: token2.borderRadiusSM,
      borderRadiusSM: token2.borderRadiusXS
    });
    const [, smSelectItemMargin] = getSelectItemStyle(token2);
    return [
      genSizeStyle$2(token2),
      // ======================== Small ========================
      // Shared
      genSizeStyle$2(smallToken, "sm"),
      // Padding
      {
        [`${componentCls}-multiple${componentCls}-sm`]: {
          [`${componentCls}-selection-placeholder`]: {
            insetInlineStart: token2.controlPaddingHorizontalSM - token2.lineWidth,
            insetInlineEnd: "auto"
          },
          // https://github.com/ant-design/ant-design/issues/29559
          [`${componentCls}-selection-search`]: {
            marginInlineStart: smSelectItemMargin
          }
        }
      },
      // ======================== Large ========================
      // Shared
      genSizeStyle$2(merge$2(token2, {
        fontSize: token2.fontSizeLG,
        controlHeight: token2.controlHeightLG,
        controlHeightSM: token2.controlHeight,
        borderRadius: token2.borderRadiusLG,
        borderRadiusSM: token2.borderRadius
      }), "lg")
    ];
  }
  function genSizeStyle$1(token2, suffix) {
    const {
      componentCls,
      inputPaddingHorizontalBase,
      borderRadius
    } = token2;
    const selectHeightWithoutBorder = token2.controlHeight - token2.lineWidth * 2;
    const selectionItemPadding = Math.ceil(token2.fontSize * 1.25);
    const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
    return {
      [`${componentCls}-single${suffixCls}`]: {
        fontSize: token2.fontSize,
        // ========================= Selector =========================
        [`${componentCls}-selector`]: _extends$1(_extends$1({}, resetComponent(token2)), {
          display: "flex",
          borderRadius,
          [`${componentCls}-selection-search`]: {
            position: "absolute",
            top: 0,
            insetInlineStart: inputPaddingHorizontalBase,
            insetInlineEnd: inputPaddingHorizontalBase,
            bottom: 0,
            "&-input": {
              width: "100%"
            }
          },
          [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
            padding: 0,
            lineHeight: `${selectHeightWithoutBorder}px`,
            transition: `all ${token2.motionDurationSlow}`,
            // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
            "@supports (-moz-appearance: meterbar)": {
              lineHeight: `${selectHeightWithoutBorder}px`
            }
          },
          [`${componentCls}-selection-item`]: {
            position: "relative",
            userSelect: "none"
          },
          [`${componentCls}-selection-placeholder`]: {
            transition: "none",
            pointerEvents: "none"
          },
          // For common baseline align
          [[
            "&:after",
            /* For '' value baseline align */
            `${componentCls}-selection-item:after`,
            /* For undefined value baseline align */
            `${componentCls}-selection-placeholder:after`
          ].join(",")]: {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          }
        }),
        [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
          paddingInlineEnd: selectionItemPadding
        },
        // Opacity selection if open
        [`&${componentCls}-open ${componentCls}-selection-item`]: {
          color: token2.colorTextPlaceholder
        },
        // ========================== Input ==========================
        // We only change the style of non-customize input which is only support by `combobox` mode.
        // Not customize
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selector`]: {
            width: "100%",
            height: token2.controlHeight,
            padding: `0 ${inputPaddingHorizontalBase}px`,
            [`${componentCls}-selection-search-input`]: {
              height: selectHeightWithoutBorder
            },
            "&:after": {
              lineHeight: `${selectHeightWithoutBorder}px`
            }
          }
        },
        [`&${componentCls}-customize-input`]: {
          [`${componentCls}-selector`]: {
            "&:after": {
              display: "none"
            },
            [`${componentCls}-selection-search`]: {
              position: "static",
              width: "100%"
            },
            [`${componentCls}-selection-placeholder`]: {
              position: "absolute",
              insetInlineStart: 0,
              insetInlineEnd: 0,
              padding: `0 ${inputPaddingHorizontalBase}px`,
              "&:after": {
                display: "none"
              }
            }
          }
        }
      }
    };
  }
  function genSingleStyle(token2) {
    const {
      componentCls
    } = token2;
    const inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
    return [
      genSizeStyle$1(token2),
      // ======================== Small ========================
      // Shared
      genSizeStyle$1(merge$2(token2, {
        controlHeight: token2.controlHeightSM,
        borderRadius: token2.borderRadiusSM
      }), "sm"),
      // padding
      {
        [`${componentCls}-single${componentCls}-sm`]: {
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selection-search`]: {
              insetInlineStart: inputPaddingHorizontalSM,
              insetInlineEnd: inputPaddingHorizontalSM
            },
            [`${componentCls}-selector`]: {
              padding: `0 ${inputPaddingHorizontalSM}px`
            },
            // With arrow should provides `padding-right` to show the arrow
            [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
              insetInlineEnd: inputPaddingHorizontalSM + token2.fontSize * 1.5
            },
            [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
              paddingInlineEnd: token2.fontSize * 1.5
            }
          }
        }
      },
      // ======================== Large ========================
      // Shared
      genSizeStyle$1(merge$2(token2, {
        controlHeight: token2.controlHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      }), "lg")
    ];
  }
  function compactItemBorder(token2, parentCls, options2) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options2;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: -token2.lineWidth
      },
      "&-item": _extends$1(_extends$1({
        [hoverEffects]: {
          zIndex: 2
        }
      }, focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {}), {
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      })
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options2) {
    const {
      borderElCls
    } = options2;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      focus: true
    };
    const {
      componentCls
    } = token2;
    const compactCls = `${componentCls}-compact`;
    return {
      [compactCls]: _extends$1(_extends$1({}, compactItemBorder(token2, compactCls, options2)), compactItemBorderRadius(componentCls, compactCls, options2))
    };
  }
  const genSelectorStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      position: "relative",
      backgroundColor: token2.colorBgContainer,
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      input: {
        cursor: "pointer"
      },
      [`${componentCls}-show-search&`]: {
        cursor: "text",
        input: {
          cursor: "auto",
          color: "inherit"
        }
      },
      [`${componentCls}-disabled&`]: {
        color: token2.colorTextDisabled,
        background: token2.colorBgContainerDisabled,
        cursor: "not-allowed",
        [`${componentCls}-multiple&`]: {
          background: token2.colorBgContainerDisabled
        },
        input: {
          cursor: "not-allowed"
        }
      }
    };
  };
  const genStatusStyle$2 = function(rootSelectCls, token2) {
    let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const {
      componentCls,
      borderHoverColor,
      outlineColor,
      antCls
    } = token2;
    const overwriteStyle = overwriteDefaultBorder ? {
      [`${componentCls}-selector`]: {
        borderColor: borderHoverColor
      }
    } : {};
    return {
      [rootSelectCls]: {
        [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: _extends$1(_extends$1({}, overwriteStyle), {
          [`${componentCls}-focused& ${componentCls}-selector`]: {
            borderColor: borderHoverColor,
            boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${outlineColor}`,
            borderInlineEndWidth: `${token2.controlLineWidth}px !important`,
            outline: 0
          },
          [`&:hover ${componentCls}-selector`]: {
            borderColor: borderHoverColor,
            borderInlineEndWidth: `${token2.controlLineWidth}px !important`
          }
        })
      }
    };
  };
  const getSearchInputWithoutBorderStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-selection-search-input`]: {
        margin: 0,
        padding: 0,
        background: "transparent",
        border: "none",
        outline: "none",
        appearance: "none",
        "&::-webkit-search-cancel-button": {
          display: "none",
          "-webkit-appearance": "none"
        }
      }
    };
  };
  const genBaseStyle$4 = (token2) => {
    const {
      componentCls,
      inputPaddingHorizontalBase,
      iconCls
    } = token2;
    return {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        cursor: "pointer",
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: _extends$1(_extends$1({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
        // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
        //   ...genHoverStyle(token),
        // },
        // ======================== Selection ========================
        [`${componentCls}-selection-item`]: _extends$1({
          flex: 1,
          fontWeight: "normal"
        }, textEllipsis),
        // ======================= Placeholder =======================
        [`${componentCls}-selection-placeholder`]: _extends$1(_extends$1({}, textEllipsis), {
          flex: 1,
          color: token2.colorTextPlaceholder,
          pointerEvents: "none"
        }),
        // ========================== Arrow ==========================
        [`${componentCls}-arrow`]: _extends$1(_extends$1({}, resetIcon()), {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          height: token2.fontSizeIcon,
          marginTop: -token2.fontSizeIcon / 2,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          textAlign: "center",
          pointerEvents: "none",
          display: "flex",
          alignItems: "center",
          [iconCls]: {
            verticalAlign: "top",
            transition: `transform ${token2.motionDurationSlow}`,
            "> svg": {
              verticalAlign: "top"
            },
            [`&:not(${componentCls}-suffix)`]: {
              pointerEvents: "auto"
            }
          },
          [`${componentCls}-disabled &`]: {
            cursor: "not-allowed"
          },
          "> *:not(:last-child)": {
            marginInlineEnd: 8
            // FIXME: magic
          }
        }),
        // ========================== Clear ==========================
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          zIndex: 1,
          display: "inline-block",
          width: token2.fontSizeIcon,
          height: token2.fontSizeIcon,
          marginTop: -token2.fontSizeIcon / 2,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          fontStyle: "normal",
          lineHeight: 1,
          textAlign: "center",
          textTransform: "none",
          background: token2.colorBgContainer,
          cursor: "pointer",
          opacity: 0,
          transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
          textRendering: "auto",
          "&:before": {
            display: "block"
          },
          "&:hover": {
            color: token2.colorTextTertiary
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          }
        }
      }),
      // ========================= Feedback ==========================
      [`${componentCls}-has-feedback`]: {
        [`${componentCls}-clear`]: {
          insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXXS
        }
      }
    };
  };
  const genSelectStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      {
        [componentCls]: {
          // ==================== BorderLess ====================
          [`&-borderless ${componentCls}-selector`]: {
            backgroundColor: `transparent !important`,
            borderColor: `transparent !important`,
            boxShadow: `none !important`
          },
          // ==================== In Form ====================
          [`&${componentCls}-in-form-item`]: {
            width: "100%"
          }
        }
      },
      // =====================================================
      // ==                       LTR                       ==
      // =====================================================
      // Base
      genBaseStyle$4(token2),
      // Single
      genSingleStyle(token2),
      // Multiple
      genMultipleStyle(token2),
      // Dropdown
      genSingleStyle$1(token2),
      // =====================================================
      // ==                       RTL                       ==
      // =====================================================
      {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      },
      // =====================================================
      // ==                     Status                      ==
      // =====================================================
      genStatusStyle$2(componentCls, merge$2(token2, {
        borderHoverColor: token2.colorPrimaryHover,
        outlineColor: token2.controlOutline
      })),
      genStatusStyle$2(`${componentCls}-status-error`, merge$2(token2, {
        borderHoverColor: token2.colorErrorHover,
        outlineColor: token2.colorErrorOutline
      }), true),
      genStatusStyle$2(`${componentCls}-status-warning`, merge$2(token2, {
        borderHoverColor: token2.colorWarningHover,
        outlineColor: token2.colorWarningOutline
      }), true),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(token2, {
        borderElCls: `${componentCls}-selector`,
        focusElCls: `${componentCls}-focused`
      })
    ];
  };
  const useSelectStyle = genComponentStyleHook("Select", (token2, _ref) => {
    let {
      rootPrefixCls
    } = _ref;
    const selectToken = merge$2(token2, {
      rootPrefixCls,
      inputPaddingHorizontalBase: token2.paddingSM - 1
    });
    return [genSelectStyle(selectToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 50
  }));
  const selectProps = () => _extends$1(_extends$1({}, omit$1(selectProps$1(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
    value: someType([Array, Object, String, Number]),
    defaultValue: someType([Array, Object, String, Number]),
    notFoundContent: PropTypes.any,
    suffixIcon: PropTypes.any,
    itemIcon: PropTypes.any,
    size: stringType(),
    mode: stringType(),
    bordered: booleanType(true),
    transitionName: String,
    choiceTransitionName: stringType(""),
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    placement: stringType(),
    status: stringType(),
    "onUpdate:value": functionType()
  });
  const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
  const Select = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ASelect",
    Option,
    OptGroup,
    inheritAttrs: false,
    props: initDefaultProps(selectProps(), {
      listHeight: 256,
      listItemHeight: 24
    }),
    SECRET_COMBOBOX_MODE_DO_NOT_USE,
    slots: Object,
    setup(props2, _ref) {
      let {
        attrs,
        emit: emit2,
        slots,
        expose
      } = _ref;
      const selectRef = ref();
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
      const focus = () => {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      const scrollTo2 = (arg) => {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      };
      const mode = computed(() => {
        const {
          mode: mode2
        } = props2;
        if (mode2 === "combobox") {
          return void 0;
        }
        if (mode2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
          return "combobox";
        }
        return mode2;
      });
      const {
        prefixCls,
        direction,
        renderEmpty: renderEmpty2,
        size: contextSize,
        getPrefixCls,
        getPopupContainer,
        disabled,
        select
      } = useConfigInject("select", props2);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = computed(() => compactSize.value || contextSize.value);
      const contextDisabled = useInjectDisabled();
      const mergedDisabled = computed(() => {
        var _a2;
        return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value;
      });
      const [wrapSSR, hashId] = useSelectStyle(prefixCls);
      const rootPrefixCls = computed(() => getPrefixCls());
      const placement = computed(() => {
        if (props2.placement !== void 0) {
          return props2.placement;
        }
        return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
      });
      const transitionName2 = computed(() => getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), props2.transitionName));
      const mergedClassName = computed(() => classNames({
        [`${prefixCls.value}-lg`]: mergedSize.value === "large",
        [`${prefixCls.value}-sm`]: mergedSize.value === "small",
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-borderless`]: !props2.bordered,
        [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
      }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, hashId.value));
      const triggerChange = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        emit2("update:value", args[0]);
        emit2("change", ...args);
        formItemContext.onFieldChange();
      };
      const handleBlur = (e2) => {
        emit2("blur", e2);
        formItemContext.onFieldBlur();
      };
      expose({
        blur,
        focus,
        scrollTo: scrollTo2
      });
      const isMultiple2 = computed(() => mode.value === "multiple" || mode.value === "tags");
      const mergedShowArrow = computed(() => props2.showArrow !== void 0 ? props2.showArrow : props2.loading || !(isMultiple2.value || mode.value === "combobox"));
      return () => {
        var _a2, _b2, _c2, _d;
        const {
          notFoundContent,
          listHeight = 256,
          listItemHeight = 24,
          popupClassName,
          dropdownClassName,
          virtual,
          dropdownMatchSelectWidth,
          id = formItemContext.id.value,
          placeholder: placeholder2 = (_a2 = slots.placeholder) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          showArrow
        } = props2;
        const {
          hasFeedback,
          feedbackIcon
        } = formItemInputContext;
        let mergedNotFound;
        if (notFoundContent !== void 0) {
          mergedNotFound = notFoundContent;
        } else if (slots.notFoundContent) {
          mergedNotFound = slots.notFoundContent();
        } else if (mode.value === "combobox") {
          mergedNotFound = null;
        } else {
          mergedNotFound = (renderEmpty2 === null || renderEmpty2 === void 0 ? void 0 : renderEmpty2("Select")) || createVNode(DefaultRenderEmpty, {
            "componentName": "Select"
          }, null);
        }
        const {
          suffixIcon,
          itemIcon,
          removeIcon,
          clearIcon
        } = getIcons(_extends$1(_extends$1({}, props2), {
          multiple: isMultiple2.value,
          prefixCls: prefixCls.value,
          hasFeedback,
          feedbackIcon,
          showArrow: mergedShowArrow.value
        }), slots);
        const selectProps2 = omit$1(props2, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]);
        const rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, {
          [`${prefixCls.value}-dropdown-${direction.value}`]: direction.value === "rtl"
        }, hashId.value);
        return wrapSSR(createVNode(Select$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "ref": selectRef,
          "virtual": virtual,
          "dropdownMatchSelectWidth": dropdownMatchSelectWidth
        }, selectProps2), attrs), {}, {
          "showSearch": (_b2 = props2.showSearch) !== null && _b2 !== void 0 ? _b2 : (_c2 = select === null || select === void 0 ? void 0 : select.value) === null || _c2 === void 0 ? void 0 : _c2.showSearch,
          "placeholder": placeholder2,
          "listHeight": listHeight,
          "listItemHeight": listItemHeight,
          "mode": mode.value,
          "prefixCls": prefixCls.value,
          "direction": direction.value,
          "inputIcon": suffixIcon,
          "menuItemSelectedIcon": itemIcon,
          "removeIcon": removeIcon,
          "clearIcon": clearIcon,
          "notFoundContent": mergedNotFound,
          "class": [mergedClassName.value, attrs.class],
          "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
          "dropdownClassName": rcSelectRtlDropdownClassName,
          "onChange": triggerChange,
          "onBlur": handleBlur,
          "id": id,
          "dropdownRender": selectProps2.dropdownRender || slots.dropdownRender,
          "transitionName": transitionName2.value,
          "children": (_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots),
          "tagRender": props2.tagRender || slots.tagRender,
          "optionLabelRender": slots.optionLabel,
          "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder,
          "showArrow": hasFeedback || showArrow,
          "disabled": mergedDisabled.value
        }), {
          option: slots.option
        }));
      };
    }
  });
  Select.install = function(app2) {
    app2.component(Select.name, Select);
    app2.component(Select.Option.displayName, Select.Option);
    app2.component(Select.OptGroup.displayName, Select.OptGroup);
    return app2;
  };
  Select.Option;
  Select.OptGroup;
  var CheckCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
  function _objectSpread$o(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$o(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$o(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CheckCircleOutlined = function CheckCircleOutlined2(props2, context) {
    var p2 = _objectSpread$o({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$o({}, p2, {
      "icon": CheckCircleOutlined$1
    }), null);
  };
  CheckCircleOutlined.displayName = "CheckCircleOutlined";
  CheckCircleOutlined.inheritAttrs = false;
  var ExclamationCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
  function _objectSpread$n(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$n(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$n(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props2, context) {
    var p2 = _objectSpread$n({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$n({}, p2, {
      "icon": ExclamationCircleOutlined$1
    }), null);
  };
  ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
  ExclamationCircleOutlined.inheritAttrs = false;
  var InfoCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
  function _objectSpread$m(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$m(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$m(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var InfoCircleOutlined = function InfoCircleOutlined2(props2, context) {
    var p2 = _objectSpread$m({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$m({}, p2, {
      "icon": InfoCircleOutlined$1
    }), null);
  };
  InfoCircleOutlined.displayName = "InfoCircleOutlined";
  InfoCircleOutlined.inheritAttrs = false;
  var CloseCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, "name": "close-circle", "theme": "outlined" };
  function _objectSpread$l(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$l(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$l(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CloseCircleOutlined = function CloseCircleOutlined2(props2, context) {
    var p2 = _objectSpread$l({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$l({}, p2, {
      "icon": CloseCircleOutlined$1
    }), null);
  };
  CloseCircleOutlined.displayName = "CloseCircleOutlined";
  CloseCircleOutlined.inheritAttrs = false;
  var CheckCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  function _objectSpread$k(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$k(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$k(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CheckCircleFilled = function CheckCircleFilled2(props2, context) {
    var p2 = _objectSpread$k({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$k({}, p2, {
      "icon": CheckCircleFilled$1
    }), null);
  };
  CheckCircleFilled.displayName = "CheckCircleFilled";
  CheckCircleFilled.inheritAttrs = false;
  var ExclamationCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  function _objectSpread$j(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$j(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$j(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var ExclamationCircleFilled = function ExclamationCircleFilled2(props2, context) {
    var p2 = _objectSpread$j({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$j({}, p2, {
      "icon": ExclamationCircleFilled$1
    }), null);
  };
  ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
  ExclamationCircleFilled.inheritAttrs = false;
  var InfoCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  function _objectSpread$i(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$i(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$i(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var InfoCircleFilled = function InfoCircleFilled2(props2, context) {
    var p2 = _objectSpread$i({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$i({}, p2, {
      "icon": InfoCircleFilled$1
    }), null);
  };
  InfoCircleFilled.displayName = "InfoCircleFilled";
  InfoCircleFilled.inheritAttrs = false;
  const responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
  const getResponsiveMap = (token2) => ({
    xs: `(max-width: ${token2.screenXSMax}px)`,
    sm: `(min-width: ${token2.screenSM}px)`,
    md: `(min-width: ${token2.screenMD}px)`,
    lg: `(min-width: ${token2.screenLG}px)`,
    xl: `(min-width: ${token2.screenXL}px)`,
    xxl: `(min-width: ${token2.screenXXL}px)`,
    xxxl: `{min-width: ${token2.screenXXXL}px}`
  });
  function useResponsiveObserver() {
    const [, token2] = useToken();
    return computed(() => {
      const responsiveMap = getResponsiveMap(token2.value);
      const subscribers = /* @__PURE__ */ new Map();
      let subUid = -1;
      let screens = {};
      return {
        matchHandlers: {},
        dispatch(pointMap) {
          screens = pointMap;
          subscribers.forEach((func) => func(screens));
          return subscribers.size >= 1;
        },
        subscribe(func) {
          if (!subscribers.size) this.register();
          subUid += 1;
          subscribers.set(subUid, func);
          func(screens);
          return subUid;
        },
        unsubscribe(paramToken) {
          subscribers.delete(paramToken);
          if (!subscribers.size) this.unregister();
        },
        unregister() {
          Object.keys(responsiveMap).forEach((screen) => {
            const matchMediaQuery = responsiveMap[screen];
            const handler = this.matchHandlers[matchMediaQuery];
            handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
          });
          subscribers.clear();
        },
        register() {
          Object.keys(responsiveMap).forEach((screen) => {
            const matchMediaQuery = responsiveMap[screen];
            const listener = (_ref) => {
              let {
                matches
              } = _ref;
              this.dispatch(_extends$1(_extends$1({}, screens), {
                [screen]: matches
              }));
            };
            const mql = window.matchMedia(matchMediaQuery);
            mql.addListener(listener);
            this.matchHandlers[matchMediaQuery] = {
              mql,
              listener
            };
            listener(mql);
          });
        },
        responsiveMap
      };
    });
  }
  function useBreakpoint() {
    const screens = shallowRef({});
    let token2 = null;
    const responsiveObserve = useResponsiveObserver();
    onMounted(() => {
      token2 = responsiveObserve.value.subscribe((supportScreens) => {
        screens.value = supportScreens;
      });
    });
    onUnmounted(() => {
      responsiveObserve.value.unsubscribe(token2);
    });
    return screens;
  }
  function eagerComputed(fn) {
    const result = shallowRef();
    watchEffect(() => {
      result.value = fn();
    }, {
      flush: "sync"
      // needed so updates are immediate.
    });
    return result;
  }
  const genBaseStyle$3 = (token2) => {
    const {
      antCls,
      componentCls,
      iconCls,
      avatarBg,
      avatarColor,
      containerSize,
      containerSizeLG,
      containerSizeSM,
      textFontSize,
      textFontSizeLG,
      textFontSizeSM,
      borderRadius,
      borderRadiusLG,
      borderRadiusSM,
      lineWidth,
      lineType
    } = token2;
    const avatarSizeStyle = (size, fontSize, radius) => ({
      width: size,
      height: size,
      lineHeight: `${size - lineWidth * 2}px`,
      borderRadius: "50%",
      [`&${componentCls}-square`]: {
        borderRadius: radius
      },
      [`${componentCls}-string`]: {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transformOrigin: "0 center"
      },
      [`&${componentCls}-icon`]: {
        fontSize,
        [`> ${iconCls}`]: {
          margin: 0
        }
      }
    });
    return {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        overflow: "hidden",
        color: avatarColor,
        whiteSpace: "nowrap",
        textAlign: "center",
        verticalAlign: "middle",
        background: avatarBg,
        border: `${lineWidth}px ${lineType} transparent`,
        [`&-image`]: {
          background: "transparent"
        },
        [`${antCls}-image-img`]: {
          display: "block"
        }
      }), avatarSizeStyle(containerSize, textFontSize, borderRadius)), {
        [`&-lg`]: _extends$1({}, avatarSizeStyle(containerSizeLG, textFontSizeLG, borderRadiusLG)),
        [`&-sm`]: _extends$1({}, avatarSizeStyle(containerSizeSM, textFontSizeSM, borderRadiusSM)),
        "> img": {
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "cover"
        }
      })
    };
  };
  const genGroupStyle$2 = (token2) => {
    const {
      componentCls,
      groupBorderColor,
      groupOverlapping,
      groupSpace
    } = token2;
    return {
      [`${componentCls}-group`]: {
        display: "inline-flex",
        [`${componentCls}`]: {
          borderColor: groupBorderColor
        },
        [`> *:not(:first-child)`]: {
          marginInlineStart: groupOverlapping
        }
      },
      [`${componentCls}-group-popover`]: {
        [`${componentCls} + ${componentCls}`]: {
          marginInlineStart: groupSpace
        }
      }
    };
  };
  const useStyle$i = genComponentStyleHook("Avatar", (token2) => {
    const {
      colorTextLightSolid,
      colorTextPlaceholder
    } = token2;
    const avatarToken = merge$2(token2, {
      avatarBg: colorTextPlaceholder,
      avatarColor: colorTextLightSolid
    });
    return [genBaseStyle$3(avatarToken), genGroupStyle$2(avatarToken)];
  }, (token2) => {
    const {
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      fontSize,
      fontSizeLG,
      fontSizeXL,
      fontSizeHeading3,
      marginXS,
      marginXXS,
      colorBorderBg
    } = token2;
    return {
      containerSize: controlHeight,
      containerSizeLG: controlHeightLG,
      containerSizeSM: controlHeightSM,
      textFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
      textFontSizeLG: fontSizeHeading3,
      textFontSizeSM: fontSize,
      groupSpace: marginXXS,
      groupOverlapping: -marginXS,
      groupBorderColor: colorBorderBg
    };
  });
  const AvatarContextKey = Symbol("AvatarContextKey");
  const useAvatarInjectContext = () => {
    return inject(AvatarContextKey, {});
  };
  const useAvatarProviderContext = (context) => {
    return provide(AvatarContextKey, context);
  };
  const avatarProps = () => ({
    prefixCls: String,
    shape: {
      type: String,
      default: "circle"
    },
    size: {
      type: [Number, String, Object],
      default: () => "default"
    },
    src: String,
    /** Srcset of image avatar */
    srcset: String,
    icon: PropTypes.any,
    alt: String,
    gap: Number,
    draggable: {
      type: Boolean,
      default: void 0
    },
    crossOrigin: String,
    loadError: {
      type: Function
    }
  });
  const Avatar = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AAvatar",
    inheritAttrs: false,
    props: avatarProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const isImgExist = shallowRef(true);
      const isMounted = shallowRef(false);
      const scale2 = shallowRef(1);
      const avatarChildrenRef = shallowRef(null);
      const avatarNodeRef = shallowRef(null);
      const {
        prefixCls
      } = useConfigInject("avatar", props2);
      const [wrapSSR, hashId] = useStyle$i(prefixCls);
      const avatarCtx = useAvatarInjectContext();
      const size = computed(() => {
        return props2.size === "default" ? avatarCtx.size : props2.size;
      });
      const screens = useBreakpoint();
      const responsiveSize = eagerComputed(() => {
        if (typeof props2.size !== "object") {
          return void 0;
        }
        const currentBreakpoint = responsiveArray.find((screen) => screens.value[screen]);
        const currentSize = props2.size[currentBreakpoint];
        return currentSize;
      });
      const responsiveSizeStyle = (hasIcon) => {
        if (responsiveSize.value) {
          return {
            width: `${responsiveSize.value}px`,
            height: `${responsiveSize.value}px`,
            lineHeight: `${responsiveSize.value}px`,
            fontSize: `${hasIcon ? responsiveSize.value / 2 : 18}px`
          };
        }
        return {};
      };
      const setScaleParam = () => {
        if (!avatarChildrenRef.value || !avatarNodeRef.value) {
          return;
        }
        const childrenWidth = avatarChildrenRef.value.offsetWidth;
        const nodeWidth = avatarNodeRef.value.offsetWidth;
        if (childrenWidth !== 0 && nodeWidth !== 0) {
          const {
            gap = 4
          } = props2;
          if (gap * 2 < nodeWidth) {
            scale2.value = nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1;
          }
        }
      };
      const handleImgLoadError = () => {
        const {
          loadError
        } = props2;
        const errorFlag = loadError === null || loadError === void 0 ? void 0 : loadError();
        if (errorFlag !== false) {
          isImgExist.value = false;
        }
      };
      watch(() => props2.src, () => {
        nextTick(() => {
          isImgExist.value = true;
          scale2.value = 1;
        });
      });
      watch(() => props2.gap, () => {
        nextTick(() => {
          setScaleParam();
        });
      });
      onMounted(() => {
        nextTick(() => {
          setScaleParam();
          isMounted.value = true;
        });
      });
      return () => {
        var _a2, _b2;
        const {
          shape,
          src,
          alt,
          srcset,
          draggable,
          crossOrigin
        } = props2;
        const mergeShape = (_a2 = avatarCtx.shape) !== null && _a2 !== void 0 ? _a2 : shape;
        const icon = getPropsSlot(slots, props2, "icon");
        const pre = prefixCls.value;
        const classString = {
          [`${attrs.class}`]: !!attrs.class,
          [pre]: true,
          [`${pre}-lg`]: size.value === "large",
          [`${pre}-sm`]: size.value === "small",
          [`${pre}-${mergeShape}`]: true,
          [`${pre}-image`]: src && isImgExist.value,
          [`${pre}-icon`]: icon,
          [hashId.value]: true
        };
        const sizeStyle = typeof size.value === "number" ? {
          width: `${size.value}px`,
          height: `${size.value}px`,
          lineHeight: `${size.value}px`,
          fontSize: icon ? `${size.value / 2}px` : "18px"
        } : {};
        const children = (_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
        let childrenToRender;
        if (src && isImgExist.value) {
          childrenToRender = createVNode("img", {
            "draggable": draggable,
            "src": src,
            "srcset": srcset,
            "onError": handleImgLoadError,
            "alt": alt,
            "crossorigin": crossOrigin
          }, null);
        } else if (icon) {
          childrenToRender = icon;
        } else if (isMounted.value || scale2.value !== 1) {
          const transformString = `scale(${scale2.value}) translateX(-50%)`;
          const childrenStyle = {
            msTransform: transformString,
            WebkitTransform: transformString,
            transform: transformString
          };
          const sizeChildrenStyle = typeof size.value === "number" ? {
            lineHeight: `${size.value}px`
          } : {};
          childrenToRender = createVNode(ResizeObserver$1, {
            "onResize": setScaleParam
          }, {
            default: () => [createVNode("span", {
              "class": `${pre}-string`,
              "ref": avatarChildrenRef,
              "style": _extends$1(_extends$1({}, sizeChildrenStyle), childrenStyle)
            }, [children])]
          });
        } else {
          childrenToRender = createVNode("span", {
            "class": `${pre}-string`,
            "ref": avatarChildrenRef,
            "style": {
              opacity: 0
            }
          }, [children]);
        }
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "ref": avatarNodeRef,
          "class": classString,
          "style": [sizeStyle, responsiveSizeStyle(!!icon), attrs.style]
        }), [childrenToRender]));
      };
    }
  });
  const autoAdjustOverflow$2 = {
    adjustX: 1,
    adjustY: 1
  };
  const targetOffset$2 = [0, 0];
  const placements$2 = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflow$2,
      offset: [-4, 0],
      targetOffset: targetOffset$2
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflow$2,
      offset: [4, 0],
      targetOffset: targetOffset$2
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow$2,
      offset: [0, -4],
      targetOffset: targetOffset$2
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow$2,
      offset: [0, 4],
      targetOffset: targetOffset$2
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow$2,
      offset: [0, -4],
      targetOffset: targetOffset$2
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow$2,
      offset: [-4, 0],
      targetOffset: targetOffset$2
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow$2,
      offset: [0, -4],
      targetOffset: targetOffset$2
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow$2,
      offset: [4, 0],
      targetOffset: targetOffset$2
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow$2,
      offset: [0, 4],
      targetOffset: targetOffset$2
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow$2,
      offset: [4, 0],
      targetOffset: targetOffset$2
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow$2,
      offset: [0, 4],
      targetOffset: targetOffset$2
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow$2,
      offset: [-4, 0],
      targetOffset: targetOffset$2
    }
  };
  const tooltipContentProps = {
    prefixCls: String,
    id: String,
    overlayInnerStyle: PropTypes.any
  };
  const Content = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "TooltipContent",
    props: tooltipContentProps,
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return createVNode("div", {
          "class": `${props2.prefixCls}-inner`,
          "id": props2.id,
          "role": "tooltip",
          "style": props2.overlayInnerStyle
        }, [(_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
      };
    }
  });
  var __rest$t = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function noop$3() {
  }
  const Tooltip$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Tooltip",
    inheritAttrs: false,
    props: {
      trigger: PropTypes.any.def(["hover"]),
      defaultVisible: {
        type: Boolean,
        default: void 0
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      placement: PropTypes.string.def("right"),
      transitionName: String,
      animation: PropTypes.any,
      afterVisibleChange: PropTypes.func.def(() => {
      }),
      overlayStyle: {
        type: Object,
        default: void 0
      },
      overlayClassName: String,
      prefixCls: PropTypes.string.def("rc-tooltip"),
      mouseEnterDelay: PropTypes.number.def(0.1),
      mouseLeaveDelay: PropTypes.number.def(0.1),
      getPopupContainer: Function,
      destroyTooltipOnHide: {
        type: Boolean,
        default: false
      },
      align: PropTypes.object.def(() => ({})),
      arrowContent: PropTypes.any.def(null),
      tipId: String,
      builtinPlacements: PropTypes.object,
      overlayInnerStyle: {
        type: Object,
        default: void 0
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      onVisibleChange: Function,
      onPopupAlign: Function,
      arrow: {
        type: Boolean,
        default: true
      }
    },
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose
      } = _ref;
      const triggerDOM = shallowRef();
      const getPopupElement = () => {
        const {
          prefixCls,
          tipId,
          overlayInnerStyle
        } = props2;
        return [!!props2.arrow ? createVNode("div", {
          "class": `${prefixCls}-arrow`,
          "key": "arrow"
        }, [getPropsSlot(slots, props2, "arrowContent")]) : null, createVNode(Content, {
          "key": "content",
          "prefixCls": prefixCls,
          "id": tipId,
          "overlayInnerStyle": overlayInnerStyle
        }, {
          overlay: slots.overlay
        })];
      };
      const getPopupDomNode = () => {
        return triggerDOM.value.getPopupDomNode();
      };
      expose({
        getPopupDomNode,
        triggerDOM,
        forcePopupAlign: () => {
          var _a2;
          return (_a2 = triggerDOM.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        }
      });
      const destroyTooltip = shallowRef(false);
      const autoDestroy = shallowRef(false);
      watchEffect(() => {
        const {
          destroyTooltipOnHide
        } = props2;
        if (typeof destroyTooltipOnHide === "boolean") {
          destroyTooltip.value = destroyTooltipOnHide;
        } else if (destroyTooltipOnHide && typeof destroyTooltipOnHide === "object") {
          const {
            keepParent
          } = destroyTooltipOnHide;
          destroyTooltip.value = keepParent === true;
          autoDestroy.value = keepParent === false;
        }
      });
      return () => {
        const {
          overlayClassName,
          trigger: trigger2,
          mouseEnterDelay,
          mouseLeaveDelay,
          overlayStyle,
          prefixCls,
          afterVisibleChange,
          transitionName: transitionName2,
          animation,
          placement,
          align,
          destroyTooltipOnHide,
          defaultVisible
        } = props2, restProps = __rest$t(props2, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]);
        const extraProps = _extends$1({}, restProps);
        if (props2.visible !== void 0) {
          extraProps.popupVisible = props2.visible;
        }
        const triggerProps2 = _extends$1(_extends$1(_extends$1({
          popupClassName: overlayClassName,
          prefixCls,
          action: trigger2,
          builtinPlacements: placements$2,
          popupPlacement: placement,
          popupAlign: align,
          afterPopupVisibleChange: afterVisibleChange,
          popupTransitionName: transitionName2,
          popupAnimation: animation,
          defaultPopupVisible: defaultVisible,
          destroyPopupOnHide: destroyTooltip.value,
          autoDestroy: autoDestroy.value,
          mouseLeaveDelay,
          popupStyle: overlayStyle,
          mouseEnterDelay
        }, extraProps), attrs), {
          onPopupVisibleChange: props2.onVisibleChange || noop$3,
          onPopupAlign: props2.onPopupAlign || noop$3,
          ref: triggerDOM,
          arrow: !!props2.arrow,
          popup: getPopupElement()
        });
        return createVNode(Trigger, triggerProps2, {
          default: slots.default
        });
      };
    }
  });
  const abstractTooltipProps = () => ({
    trigger: [String, Array],
    open: {
      type: Boolean,
      default: void 0
    },
    /** @deprecated Please use `open` instead. */
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: String,
    color: String,
    transitionName: String,
    overlayStyle: objectType(),
    overlayInnerStyle: objectType(),
    overlayClassName: String,
    openClassName: String,
    prefixCls: String,
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    getPopupContainer: Function,
    /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
    arrowPointAtCenter: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: [Boolean, Object],
      default: true
    },
    autoAdjustOverflow: {
      type: [Boolean, Object],
      default: void 0
    },
    destroyTooltipOnHide: {
      type: Boolean,
      default: void 0
    },
    align: objectType(),
    builtinPlacements: objectType(),
    children: Array,
    /** @deprecated Please use `onOpenChange` instead. */
    onVisibleChange: Function,
    /** @deprecated Please use `onUpdate:open` instead. */
    "onUpdate:visible": Function,
    onOpenChange: Function,
    "onUpdate:open": Function
  });
  const autoAdjustOverflowEnabled = {
    adjustX: 1,
    adjustY: 1
  };
  const autoAdjustOverflowDisabled = {
    adjustX: 0,
    adjustY: 0
  };
  const targetOffset$1 = [0, 0];
  function getOverflowOptions(autoAdjustOverflow2) {
    if (typeof autoAdjustOverflow2 === "boolean") {
      return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
    }
    return _extends$1(_extends$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
  }
  function getPlacements(config) {
    const {
      arrowWidth = 4,
      horizontalArrowShift = 16,
      verticalArrowShift = 8,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowPointAtCenter
    } = config;
    const placementMap = {
      left: {
        points: ["cr", "cl"],
        offset: [-4, 0]
      },
      right: {
        points: ["cl", "cr"],
        offset: [4, 0]
      },
      top: {
        points: ["bc", "tc"],
        offset: [0, -4]
      },
      bottom: {
        points: ["tc", "bc"],
        offset: [0, 4]
      },
      topLeft: {
        points: ["bl", "tc"],
        offset: [-(horizontalArrowShift + arrowWidth), -4]
      },
      leftTop: {
        points: ["tr", "cl"],
        offset: [-4, -(verticalArrowShift + arrowWidth)]
      },
      topRight: {
        points: ["br", "tc"],
        offset: [horizontalArrowShift + arrowWidth, -4]
      },
      rightTop: {
        points: ["tl", "cr"],
        offset: [4, -(verticalArrowShift + arrowWidth)]
      },
      bottomRight: {
        points: ["tr", "bc"],
        offset: [horizontalArrowShift + arrowWidth, 4]
      },
      rightBottom: {
        points: ["bl", "cr"],
        offset: [4, verticalArrowShift + arrowWidth]
      },
      bottomLeft: {
        points: ["tl", "bc"],
        offset: [-(horizontalArrowShift + arrowWidth), 4]
      },
      leftBottom: {
        points: ["br", "cl"],
        offset: [-4, verticalArrowShift + arrowWidth]
      }
    };
    Object.keys(placementMap).forEach((key2) => {
      placementMap[key2] = arrowPointAtCenter ? _extends$1(_extends$1({}, placementMap[key2]), {
        overflow: getOverflowOptions(autoAdjustOverflow2),
        targetOffset: targetOffset$1
      }) : _extends$1(_extends$1({}, placements$2[key2]), {
        overflow: getOverflowOptions(autoAdjustOverflow2)
      });
      placementMap[key2].ignoreShake = true;
    });
    return placementMap;
  }
  function firstNotUndefined() {
    let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    for (let i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      if (arr[i2] !== void 0) {
        return arr[i2];
      }
    }
    return void 0;
  }
  const inverseColors = PresetColors.map((color2) => `${color2}-inverse`);
  function isPresetColor(color2) {
    let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (includeInverse) {
      return [...inverseColors, ...PresetColors].includes(color2);
    }
    return PresetColors.includes(color2);
  }
  function parseColor(prefixCls, color2) {
    const isInternalColor = isPresetColor(color2);
    const className = classNames({
      [`${prefixCls}-${color2}`]: color2 && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    if (color2 && !isInternalColor) {
      overlayStyle.background = color2;
      arrowStyle["--antd-arrow-background-color"] = color2;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  }
  function connectArrowCls(classList) {
    let showArrowCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return classList.map((cls) => `${showArrowCls}${cls}`).join(",");
  }
  const MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffset(options2) {
    const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
    const {
      sizePopupArrow,
      contentRadius,
      borderRadiusOuter,
      limitVerticalRadius
    } = options2;
    const arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1));
    const dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
    const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset;
    return {
      dropdownArrowOffset,
      dropdownArrowOffsetVertical
    };
  }
  function getArrowStyle(token2, options2) {
    const {
      componentCls,
      sizePopupArrow,
      marginXXS,
      borderRadiusXS,
      borderRadiusOuter,
      boxShadowPopoverArrow
    } = token2;
    const {
      colorBg,
      showArrowCls,
      contentRadius = token2.borderRadiusLG,
      limitVerticalRadius
    } = options2;
    const {
      dropdownArrowOffsetVertical,
      dropdownArrowOffset
    } = getArrowOffset({
      sizePopupArrow,
      contentRadius,
      borderRadiusOuter,
      limitVerticalRadius
    });
    const dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
    return {
      [componentCls]: {
        // ============================ Basic ============================
        [`${componentCls}-arrow`]: [_extends$1(_extends$1({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
          "&:before": {
            background: colorBg
          }
        })],
        // ========================== Placement ==========================
        // Here handle the arrow position and rotate stuff
        // >>>>> Top
        [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
          bottom: 0,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-topRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        // >>>>> Bottom
        [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
          top: 0,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        [`&-placement-bottomLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-bottomRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        // >>>>> Left
        [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: 0
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-leftBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        },
        // >>>>> Right
        [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: 0
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-rightBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        },
        // =========================== Offset ============================
        // Offset the popover to account for the dropdown arrow
        // >>>>> Top
        [connectArrowCls([`&-placement-topLeft`, `&-placement-top`, `&-placement-topRight`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
          paddingBottom: dropdownArrowDistance
        },
        // >>>>> Bottom
        [connectArrowCls([`&-placement-bottomLeft`, `&-placement-bottom`, `&-placement-bottomRight`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
          paddingTop: dropdownArrowDistance
        },
        // >>>>> Left
        [connectArrowCls([`&-placement-leftTop`, `&-placement-left`, `&-placement-leftBottom`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
          paddingRight: {
            _skip_check_: true,
            value: dropdownArrowDistance
          }
        },
        // >>>>> Right
        [connectArrowCls([`&-placement-rightTop`, `&-placement-right`, `&-placement-rightBottom`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
          paddingLeft: {
            _skip_check_: true,
            value: dropdownArrowDistance
          }
        }
      }
    };
  }
  const genTooltipStyle = (token2) => {
    const {
      componentCls,
      // ant-tooltip
      tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      tooltipRadiusOuter
    } = token2;
    return [
      {
        [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          "&": [{
            width: "max-content"
          }, {
            width: "intrinsic"
          }],
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          "&-hidden": {
            display: "none"
          },
          "--antd-arrow-background-color": tooltipBg,
          // Wrapper for the tooltip content
          [`${componentCls}-inner`]: {
            minWidth: controlHeight,
            minHeight: controlHeight,
            padding: `${paddingSM / 2}px ${paddingXS}px`,
            color: tooltipColor,
            textAlign: "start",
            textDecoration: "none",
            wordWrap: "break-word",
            backgroundColor: tooltipBg,
            borderRadius: tooltipBorderRadius,
            boxShadow: boxShadowSecondary
          },
          // Limit left and right placement radius
          [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          }
        }), genPresetColor(token2, (colorKey, _ref) => {
          let {
            darkColor
          } = _ref;
          return {
            [`&${componentCls}-${colorKey}`]: {
              [`${componentCls}-inner`]: {
                backgroundColor: darkColor
              },
              [`${componentCls}-arrow`]: {
                "--antd-arrow-background-color": darkColor
              }
            }
          };
        })), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Arrow Style
      getArrowStyle(merge$2(token2, {
        borderRadiusOuter: tooltipRadiusOuter
      }), {
        colorBg: "var(--antd-arrow-background-color)",
        showArrowCls: "",
        contentRadius: tooltipBorderRadius,
        limitVerticalRadius: true
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none"
        }
      }
    ];
  };
  const useStyle$h = (prefixCls, injectStyle) => {
    const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
      if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
        return [];
      }
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgDefault,
        borderRadiusOuter
      } = token2;
      const TooltipToken = merge$2(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgDefault,
        tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, (_ref2) => {
      let {
        zIndexPopupBase,
        colorBgSpotlight
      } = _ref2;
      return {
        zIndexPopup: zIndexPopupBase + 70,
        colorBgDefault: colorBgSpotlight
      };
    });
    return useOriginHook(prefixCls);
  };
  const splitObject = (obj2, keys2) => {
    const picked = {};
    const omitted = _extends$1({}, obj2);
    keys2.forEach((key2) => {
      if (obj2 && key2 in obj2) {
        picked[key2] = obj2[key2];
        delete omitted[key2];
      }
    });
    return {
      picked,
      omitted
    };
  };
  const tooltipProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
    title: PropTypes.any
  });
  const tooltipDefaultProps = () => ({
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  });
  const ToolTip = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATooltip",
    inheritAttrs: false,
    props: initDefaultProps(tooltipProps(), {
      trigger: "hover",
      align: {},
      placement: "top",
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      arrowPointAtCenter: false,
      autoAdjustOverflow: true
    }),
    slots: Object,
    // emits: ['update:visible', 'visibleChange'],
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2,
        attrs,
        expose
      } = _ref;
      const {
        prefixCls,
        getPopupContainer,
        direction,
        rootPrefixCls
      } = useConfigInject("tooltip", props2);
      const mergedOpen = computed(() => {
        var _a2;
        return (_a2 = props2.open) !== null && _a2 !== void 0 ? _a2 : props2.visible;
      });
      const innerOpen = ref(firstNotUndefined([props2.open, props2.visible]));
      const tooltip = ref();
      let rafId;
      watch(mergedOpen, (val) => {
        wrapperRaf.cancel(rafId);
        rafId = wrapperRaf(() => {
          innerOpen.value = !!val;
        });
      });
      const isNoTitle = () => {
        var _a2;
        const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : slots.title;
        return !title && title !== 0;
      };
      const handleVisibleChange = (val) => {
        const noTitle = isNoTitle();
        if (mergedOpen.value === void 0) {
          innerOpen.value = noTitle ? false : val;
        }
        if (!noTitle) {
          emit2("update:visible", val);
          emit2("visibleChange", val);
          emit2("update:open", val);
          emit2("openChange", val);
        }
      };
      const getPopupDomNode = () => {
        return tooltip.value.getPopupDomNode();
      };
      expose({
        getPopupDomNode,
        open: innerOpen,
        forcePopupAlign: () => {
          var _a2;
          return (_a2 = tooltip.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        }
      });
      const tooltipPlacements = computed(() => {
        var _a2;
        const {
          builtinPlacements,
          autoAdjustOverflow: autoAdjustOverflow2,
          arrow,
          arrowPointAtCenter
        } = props2;
        let mergedArrowPointAtCenter = arrowPointAtCenter;
        if (typeof arrow === "object") {
          mergedArrowPointAtCenter = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrowPointAtCenter;
        }
        return builtinPlacements || getPlacements({
          arrowPointAtCenter: mergedArrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2
        });
      });
      const isTrueProps = (val) => {
        return val || val === "";
      };
      const getDisabledCompatibleChildren = (ele) => {
        const elementType = ele.type;
        if (typeof elementType === "object" && ele.props) {
          if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading)) || elementType.__ANT_RADIO === true && isTrueProps(ele.props.disabled)) {
            const {
              picked,
              omitted
            } = splitObject(getStyle$3(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
            const spanStyle = _extends$1(_extends$1({
              display: "inline-block"
            }, picked), {
              cursor: "not-allowed",
              lineHeight: 1,
              width: ele.props && ele.props.block ? "100%" : void 0
            });
            const buttonStyle = _extends$1(_extends$1({}, omitted), {
              pointerEvents: "none"
            });
            const child = cloneElement(ele, {
              style: buttonStyle
            }, true);
            return createVNode("span", {
              "style": spanStyle,
              "class": `${prefixCls.value}-disabled-compatible-wrapper`
            }, [child]);
          }
        }
        return ele;
      };
      const getOverlay = () => {
        var _a2, _b2;
        return (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b2 = slots.title) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
      };
      const onPopupAlign = (domNode, align) => {
        const placements2 = tooltipPlacements.value;
        const placement = Object.keys(placements2).find((key2) => {
          var _a2, _b2;
          return placements2[key2].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key2].points[1] === ((_b2 = align.points) === null || _b2 === void 0 ? void 0 : _b2[1]);
        });
        if (placement) {
          const rect = domNode.getBoundingClientRect();
          const transformOrigin = {
            top: "50%",
            left: "50%"
          };
          if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
            transformOrigin.top = `${rect.height - align.offset[1]}px`;
          } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
            transformOrigin.top = `${-align.offset[1]}px`;
          }
          if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
            transformOrigin.left = `${rect.width - align.offset[0]}px`;
          } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
            transformOrigin.left = `${-align.offset[0]}px`;
          }
          domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
        }
      };
      const colorInfo = computed(() => parseColor(prefixCls.value, props2.color));
      const injectFromPopover = computed(() => attrs["data-popover-inject"]);
      const [wrapSSR, hashId] = useStyle$h(prefixCls, computed(() => !injectFromPopover.value));
      return () => {
        var _a2, _b2;
        const {
          openClassName,
          overlayClassName,
          overlayStyle,
          overlayInnerStyle
        } = props2;
        let children = (_b2 = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))) !== null && _b2 !== void 0 ? _b2 : null;
        children = children.length === 1 ? children[0] : children;
        let tempVisible = innerOpen.value;
        if (mergedOpen.value === void 0 && isNoTitle()) {
          tempVisible = false;
        }
        if (!children) {
          return null;
        }
        const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : createVNode("span", null, [children]));
        const childCls = classNames({
          [openClassName || `${prefixCls.value}-open`]: true,
          [child.props && child.props.class]: child.props && child.props.class
        });
        const customOverlayClassName = classNames(overlayClassName, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, colorInfo.value.className, hashId.value);
        const formattedOverlayInnerStyle = _extends$1(_extends$1({}, colorInfo.value.overlayStyle), overlayInnerStyle);
        const arrowContentStyle = colorInfo.value.arrowStyle;
        const vcTooltipProps = _extends$1(_extends$1(_extends$1({}, attrs), props2), {
          prefixCls: prefixCls.value,
          arrow: !!props2.arrow,
          getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
          builtinPlacements: tooltipPlacements.value,
          visible: tempVisible,
          ref: tooltip,
          overlayClassName: customOverlayClassName,
          overlayStyle: _extends$1(_extends$1({}, arrowContentStyle), overlayStyle),
          overlayInnerStyle: formattedOverlayInnerStyle,
          onVisibleChange: handleVisibleChange,
          onPopupAlign,
          transitionName: getTransitionName(rootPrefixCls.value, "zoom-big-fast", props2.transitionName)
        });
        return wrapSSR(createVNode(Tooltip$1, vcTooltipProps, {
          default: () => [innerOpen.value ? cloneElement(child, {
            class: childCls
          }) : child],
          arrowContent: () => createVNode("span", {
            "class": `${prefixCls.value}-arrow-content`
          }, null),
          overlay: getOverlay
        }));
      };
    }
  });
  const Tooltip = withInstall(ToolTip);
  const genBaseStyle$2 = (token2) => {
    const {
      componentCls,
      popoverBg,
      popoverColor,
      width,
      fontWeightStrong,
      popoverPadding,
      boxShadowSecondary,
      colorTextHeading,
      borderRadiusLG: borderRadius,
      zIndexPopup,
      marginXS,
      colorBgElevated
    } = token2;
    return [
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          top: 0,
          // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
          left: {
            _skip_check_: true,
            value: 0
          },
          zIndex: zIndexPopup,
          fontWeight: "normal",
          whiteSpace: "normal",
          textAlign: "start",
          cursor: "auto",
          userSelect: "text",
          "--antd-arrow-background-color": colorBgElevated,
          "&-rtl": {
            direction: "rtl"
          },
          "&-hidden": {
            display: "none"
          },
          [`${componentCls}-content`]: {
            position: "relative"
          },
          [`${componentCls}-inner`]: {
            backgroundColor: popoverBg,
            backgroundClip: "padding-box",
            borderRadius,
            boxShadow: boxShadowSecondary,
            padding: popoverPadding
          },
          [`${componentCls}-title`]: {
            minWidth: width,
            marginBottom: marginXS,
            color: colorTextHeading,
            fontWeight: fontWeightStrong
          },
          [`${componentCls}-inner-content`]: {
            color: popoverColor
          }
        })
      },
      // Arrow Style
      getArrowStyle(token2, {
        colorBg: "var(--antd-arrow-background-color)"
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          [`${componentCls}-content`]: {
            display: "inline-block"
          }
        }
      }
    ];
  };
  const genColorStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: PresetColors.map((colorKey) => {
        const lightColor = token2[`${colorKey}-6`];
        return {
          [`&${componentCls}-${colorKey}`]: {
            "--antd-arrow-background-color": lightColor,
            [`${componentCls}-inner`]: {
              backgroundColor: lightColor
            },
            [`${componentCls}-arrow`]: {
              background: "transparent"
            }
          }
        };
      })
    };
  };
  const genWireframeStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      colorSplit,
      paddingSM,
      controlHeight,
      fontSize,
      lineHeight,
      padding
    } = token2;
    const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
    const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
    const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
    const popoverPaddingHorizontal = padding;
    return {
      [componentCls]: {
        [`${componentCls}-inner`]: {
          padding: 0
        },
        [`${componentCls}-title`]: {
          margin: 0,
          padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
          borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
        },
        [`${componentCls}-inner-content`]: {
          padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
        }
      }
    };
  };
  const useStyle$g = genComponentStyleHook("Popover", (token2) => {
    const {
      colorBgElevated,
      colorText,
      wireframe
    } = token2;
    const popoverToken = merge$2(token2, {
      popoverBg: colorBgElevated,
      popoverColor: colorText,
      popoverPadding: 12
      // Fixed Value
    });
    return [genBaseStyle$2(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
  }, (_ref) => {
    let {
      zIndexPopupBase
    } = _ref;
    return {
      zIndexPopup: zIndexPopupBase + 30,
      width: 177
    };
  });
  const popoverProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
    content: anyType(),
    title: anyType()
  });
  const Popover = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "APopover",
    inheritAttrs: false,
    props: initDefaultProps(popoverProps(), _extends$1(_extends$1({}, tooltipDefaultProps()), {
      trigger: "hover",
      placement: "top",
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1
    })),
    setup(props2, _ref) {
      let {
        expose,
        slots,
        attrs
      } = _ref;
      const tooltipRef = ref();
      warning$2(props2.visible === void 0);
      expose({
        getPopupDomNode: () => {
          var _a2, _b2;
          return (_b2 = (_a2 = tooltipRef.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupDomNode) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      });
      const {
        prefixCls,
        configProvider
      } = useConfigInject("popover", props2);
      const [wrapSSR, hashId] = useStyle$g(prefixCls);
      const rootPrefixCls = computed(() => configProvider.getPrefixCls());
      const getOverlay = () => {
        var _a2, _b2;
        const {
          title = filterEmpty((_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots)),
          content = filterEmpty((_b2 = slots.content) === null || _b2 === void 0 ? void 0 : _b2.call(slots))
        } = props2;
        const hasTitle = !!(Array.isArray(title) ? title.length : title);
        const hasContent = !!(Array.isArray(content) ? content.length : title);
        if (!hasTitle && !hasContent) return null;
        return createVNode(Fragment, null, [hasTitle && createVNode("div", {
          "class": `${prefixCls.value}-title`
        }, [title]), createVNode("div", {
          "class": `${prefixCls.value}-inner-content`
        }, [content])]);
      };
      return () => {
        const overlayCls = classNames(props2.overlayClassName, hashId.value);
        return wrapSSR(createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$1(props2, ["title", "content"])), attrs), {}, {
          "prefixCls": prefixCls.value,
          "ref": tooltipRef,
          "overlayClassName": overlayCls,
          "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props2.transitionName),
          "data-popover-inject": true
        }), {
          title: getOverlay,
          default: slots.default
        }));
      };
    }
  });
  const Popover$1 = withInstall(Popover);
  const groupProps = () => ({
    prefixCls: String,
    maxCount: Number,
    maxStyle: {
      type: Object,
      default: void 0
    },
    maxPopoverPlacement: {
      type: String,
      default: "top"
    },
    maxPopoverTrigger: String,
    /*
     * Size of avatar, options: `large`, `small`, `default`
     * or a custom number size
     * */
    size: {
      type: [Number, String, Object],
      default: "default"
    },
    shape: {
      type: String,
      default: "circle"
    }
  });
  const Group$5 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AAvatarGroup",
    inheritAttrs: false,
    props: groupProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("avatar", props2);
      const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
      const [wrapSSR, hashId] = useStyle$i(prefixCls);
      watchEffect(() => {
        const context = {
          size: props2.size,
          shape: props2.shape
        };
        useAvatarProviderContext(context);
      });
      return () => {
        const {
          maxPopoverPlacement = "top",
          maxCount: maxCount2,
          maxStyle,
          maxPopoverTrigger = "hover",
          shape
        } = props2;
        const cls = {
          [groupPrefixCls.value]: true,
          [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl",
          [`${attrs.class}`]: !!attrs.class,
          [hashId.value]: true
        };
        const children = getPropsSlot(slots, props2);
        const childrenWithProps = flattenChildren(children).map((child, index2) => cloneElement(child, {
          key: `avatar-key-${index2}`
        }));
        const numOfChildren = childrenWithProps.length;
        if (maxCount2 && maxCount2 < numOfChildren) {
          const childrenShow = childrenWithProps.slice(0, maxCount2);
          const childrenHidden = childrenWithProps.slice(maxCount2, numOfChildren);
          childrenShow.push(createVNode(Popover$1, {
            "key": "avatar-popover-key",
            "content": childrenHidden,
            "trigger": maxPopoverTrigger,
            "placement": maxPopoverPlacement,
            "overlayClassName": `${groupPrefixCls.value}-popover`
          }, {
            default: () => [createVNode(Avatar, {
              "style": maxStyle,
              "shape": shape
            }, {
              default: () => [`+${numOfChildren - maxCount2}`]
            })]
          }));
          return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
            "class": cls,
            "style": attrs.style
          }), [childrenShow]));
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": cls,
          "style": attrs.style
        }), [childrenWithProps]));
      };
    }
  });
  Avatar.Group = Group$5;
  Avatar.install = function(app2) {
    app2.component(Avatar.name, Avatar);
    app2.component(Group$5.name, Group$5);
    return app2;
  };
  function UnitNumber(_ref) {
    let {
      prefixCls,
      value,
      current,
      offset: offset2 = 0
    } = _ref;
    let style;
    if (offset2) {
      style = {
        position: "absolute",
        top: `${offset2}00%`,
        left: 0
      };
    }
    return createVNode("p", {
      "style": style,
      "class": classNames(`${prefixCls}-only-unit`, {
        current
      })
    }, [value]);
  }
  function getOffset(start2, end2, unit) {
    let index2 = start2;
    let offset2 = 0;
    while ((index2 + 10) % 10 !== end2) {
      index2 += unit;
      offset2 += unit;
    }
    return offset2;
  }
  const SingleNumber = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "SingleNumber",
    props: {
      prefixCls: String,
      value: String,
      count: Number
    },
    setup(props2) {
      const originValue = computed(() => Number(props2.value));
      const originCount = computed(() => Math.abs(props2.count));
      const state = reactive({
        prevValue: originValue.value,
        prevCount: originCount.value
      });
      const onTransitionEnd = () => {
        state.prevValue = originValue.value;
        state.prevCount = originCount.value;
      };
      const timeout = ref();
      watch(originValue, () => {
        clearTimeout(timeout.value);
        timeout.value = setTimeout(() => {
          onTransitionEnd();
        }, 1e3);
      }, {
        flush: "post"
      });
      onUnmounted(() => {
        clearTimeout(timeout.value);
      });
      return () => {
        let unitNodes;
        let offsetStyle = {};
        const value = originValue.value;
        if (state.prevValue === value || Number.isNaN(value) || Number.isNaN(state.prevValue)) {
          unitNodes = [UnitNumber(_extends$1(_extends$1({}, props2), {
            current: true
          }))];
          offsetStyle = {
            transition: "none"
          };
        } else {
          unitNodes = [];
          const end2 = value + 10;
          const unitNumberList = [];
          for (let index2 = value; index2 <= end2; index2 += 1) {
            unitNumberList.push(index2);
          }
          const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === state.prevValue);
          unitNodes = unitNumberList.map((n2, index2) => {
            const singleUnit = n2 % 10;
            return UnitNumber(_extends$1(_extends$1({}, props2), {
              value: singleUnit,
              offset: index2 - prevIndex,
              current: index2 === prevIndex
            }));
          });
          const unit = state.prevCount < originCount.value ? 1 : -1;
          offsetStyle = {
            transform: `translateY(${-getOffset(state.prevValue, value, unit)}00%)`
          };
        }
        return createVNode("span", {
          "class": `${props2.prefixCls}-only`,
          "style": offsetStyle,
          "onTransitionend": () => onTransitionEnd()
        }, [unitNodes]);
      };
    }
  });
  var __rest$s = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const scrollNumberProps = {
    prefixCls: String,
    count: PropTypes.any,
    component: String,
    title: PropTypes.any,
    show: Boolean
  };
  const ScrollNumber = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ScrollNumber",
    inheritAttrs: false,
    props: scrollNumberProps,
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        prefixCls
      } = useConfigInject("scroll-number", props2);
      return () => {
        var _a2;
        const _b2 = _extends$1(_extends$1({}, props2), attrs), {
          prefixCls: customizePrefixCls,
          count,
          title,
          show,
          component: Tag = "sup",
          class: className,
          style
        } = _b2, restProps = __rest$s(_b2, ["prefixCls", "count", "title", "show", "component", "class", "style"]);
        const newProps = _extends$1(_extends$1({}, restProps), {
          style,
          "data-show": props2.show,
          class: classNames(prefixCls.value, className),
          title
        });
        let numberNodes = count;
        if (count && Number(count) % 1 === 0) {
          const numberList = String(count).split("");
          numberNodes = numberList.map((num, i2) => createVNode(SingleNumber, {
            "prefixCls": prefixCls.value,
            "count": Number(count),
            "value": num,
            "key": numberList.length - i2
          }, null));
        }
        if (style && style.borderColor) {
          newProps.style = _extends$1(_extends$1({}, style), {
            boxShadow: `0 0 0 1px ${style.borderColor} inset`
          });
        }
        const children = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        if (children && children.length) {
          return cloneElement(children, {
            class: classNames(`${prefixCls.value}-custom-component`)
          }, false);
        }
        return createVNode(Tag, newProps, {
          default: () => [numberNodes]
        });
      };
    }
  });
  const antStatusProcessing = new Keyframe("antStatusProcessing", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(2.4)",
      opacity: 0
    }
  });
  const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
    "0%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1) translate(50%, -50%)"
    }
  });
  const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
    "0%": {
      transform: "scale(1) translate(50%, -50%)"
    },
    "100%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    }
  });
  const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
    "0%": {
      transform: "scale(0)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)"
    }
  });
  const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0)",
      opacity: 0
    }
  });
  const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
    "0%": {
      transformOrigin: "50%"
    },
    "100%": {
      transform: "translate(50%, -50%) rotate(360deg)",
      transformOrigin: "50%"
    }
  });
  const genSharedBadgeStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      antCls,
      badgeFontHeight,
      badgeShadowSize,
      badgeHeightSm,
      motionDurationSlow,
      badgeStatusSize,
      marginXS,
      badgeRibbonOffset
    } = token2;
    const numberPrefixCls = `${antCls}-scroll-number`;
    const ribbonPrefixCls = `${antCls}-ribbon`;
    const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
    const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
      let {
        darkColor
      } = _ref;
      return {
        [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
          background: darkColor,
          [`&:not(${componentCls}-count)`]: {
            color: darkColor
          }
        }
      };
    });
    const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref2) => {
      let {
        darkColor
      } = _ref2;
      return {
        [`&${ribbonPrefixCls}-color-${colorKey}`]: {
          background: darkColor,
          color: darkColor
        }
      };
    });
    return {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        width: "fit-content",
        lineHeight: 1,
        [`${componentCls}-count`]: {
          zIndex: token2.badgeZIndex,
          minWidth: token2.badgeHeight,
          height: token2.badgeHeight,
          color: token2.badgeTextColor,
          fontWeight: token2.badgeFontWeight,
          fontSize: token2.badgeFontSize,
          lineHeight: `${token2.badgeHeight}px`,
          whiteSpace: "nowrap",
          textAlign: "center",
          background: token2.badgeColor,
          borderRadius: token2.badgeHeight / 2,
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`,
          transition: `background ${token2.motionDurationMid}`,
          a: {
            color: token2.badgeTextColor
          },
          "a:hover": {
            color: token2.badgeTextColor
          },
          "a:hover &": {
            background: token2.badgeColorHover
          }
        },
        [`${componentCls}-count-sm`]: {
          minWidth: badgeHeightSm,
          height: badgeHeightSm,
          fontSize: token2.badgeFontSizeSm,
          lineHeight: `${badgeHeightSm}px`,
          borderRadius: badgeHeightSm / 2
        },
        [`${componentCls}-multiple-words`]: {
          padding: `0 ${token2.paddingXS}px`
        },
        [`${componentCls}-dot`]: {
          zIndex: token2.badgeZIndex,
          width: token2.badgeDotSize,
          minWidth: token2.badgeDotSize,
          height: token2.badgeDotSize,
          background: token2.badgeColor,
          borderRadius: "100%",
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`
        },
        [`${componentCls}-dot${numberPrefixCls}`]: {
          transition: `background ${motionDurationSlow}`
        },
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          transform: "translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&${iconCls}-spin`]: {
            animationName: antBadgeLoadingCircle,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          }
        },
        [`&${componentCls}-status`]: {
          lineHeight: "inherit",
          verticalAlign: "baseline",
          [`${componentCls}-status-dot`]: {
            position: "relative",
            top: -1,
            display: "inline-block",
            width: badgeStatusSize,
            height: badgeStatusSize,
            verticalAlign: "middle",
            borderRadius: "50%"
          },
          [`${componentCls}-status-success`]: {
            backgroundColor: token2.colorSuccess
          },
          [`${componentCls}-status-processing`]: {
            overflow: "visible",
            color: token2.colorPrimary,
            backgroundColor: token2.colorPrimary,
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: "100%",
              height: "100%",
              borderWidth: badgeShadowSize,
              borderStyle: "solid",
              borderColor: "inherit",
              borderRadius: "50%",
              animationName: antStatusProcessing,
              animationDuration: token2.badgeProcessingDuration,
              animationIterationCount: "infinite",
              animationTimingFunction: "ease-in-out",
              content: '""'
            }
          },
          [`${componentCls}-status-default`]: {
            backgroundColor: token2.colorTextPlaceholder
          },
          [`${componentCls}-status-error`]: {
            backgroundColor: token2.colorError
          },
          [`${componentCls}-status-warning`]: {
            backgroundColor: token2.colorWarning
          },
          [`${componentCls}-status-text`]: {
            marginInlineStart: marginXS,
            color: token2.colorText,
            fontSize: token2.fontSize
          }
        }
      }), colorPreset), {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`&${componentCls}-not-a-wrapper`]: {
          [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
            animationName: antNoWrapperZoomBadgeIn,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`${componentCls}-zoom-leave`]: {
            animationName: antNoWrapperZoomBadgeOut,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`&:not(${componentCls}-status)`]: {
            verticalAlign: "middle"
          },
          [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
            transform: "none"
          },
          [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
            position: "relative",
            top: "auto",
            display: "block",
            transformOrigin: "50% 50%"
          }
        },
        [`${numberPrefixCls}`]: {
          overflow: "hidden",
          [`${numberPrefixCls}-only`]: {
            position: "relative",
            display: "inline-block",
            height: token2.badgeHeight,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden",
            [`> p${numberPrefixCls}-only-unit`]: {
              height: token2.badgeHeight,
              margin: 0,
              WebkitTransformStyle: "preserve-3d",
              WebkitBackfaceVisibility: "hidden"
            }
          },
          [`${numberPrefixCls}-symbol`]: {
            verticalAlign: "top"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
            transform: "translate(-50%, -50%)"
          }
        }
      }),
      [`${ribbonWrapperPrefixCls}`]: {
        position: "relative"
      },
      [`${ribbonPrefixCls}`]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        position: "absolute",
        top: marginXS,
        padding: `0 ${token2.paddingXS}px`,
        color: token2.colorPrimary,
        lineHeight: `${badgeFontHeight}px`,
        whiteSpace: "nowrap",
        backgroundColor: token2.colorPrimary,
        borderRadius: token2.borderRadiusSM,
        [`${ribbonPrefixCls}-text`]: {
          color: token2.colorTextLightSolid
        },
        [`${ribbonPrefixCls}-corner`]: {
          position: "absolute",
          top: "100%",
          width: badgeRibbonOffset,
          height: badgeRibbonOffset,
          color: "currentcolor",
          border: `${badgeRibbonOffset / 2}px solid`,
          transform: token2.badgeRibbonCornerTransform,
          transformOrigin: "top",
          filter: token2.badgeRibbonCornerFilter
        }
      }), statusRibbonPreset), {
        [`&${ribbonPrefixCls}-placement-end`]: {
          insetInlineEnd: -badgeRibbonOffset,
          borderEndEndRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineEnd: 0,
            borderInlineEndColor: "transparent",
            borderBlockEndColor: "transparent"
          }
        },
        [`&${ribbonPrefixCls}-placement-start`]: {
          insetInlineStart: -badgeRibbonOffset,
          borderEndStartRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineStart: 0,
            borderBlockEndColor: "transparent",
            borderInlineStartColor: "transparent"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl"
        }
      })
    };
  };
  const useStyle$f = genComponentStyleHook("Badge", (token2) => {
    const {
      fontSize,
      lineHeight,
      fontSizeSM,
      lineWidth,
      marginXS,
      colorBorderBg
    } = token2;
    const badgeFontHeight = Math.round(fontSize * lineHeight);
    const badgeShadowSize = lineWidth;
    const badgeZIndex = "auto";
    const badgeHeight = badgeFontHeight - 2 * badgeShadowSize;
    const badgeTextColor = token2.colorBgContainer;
    const badgeFontWeight = "normal";
    const badgeFontSize = fontSizeSM;
    const badgeColor = token2.colorError;
    const badgeColorHover = token2.colorErrorHover;
    const badgeHeightSm = fontSize;
    const badgeDotSize = fontSizeSM / 2;
    const badgeFontSizeSm = fontSizeSM;
    const badgeStatusSize = fontSizeSM / 2;
    const badgeToken = merge$2(token2, {
      badgeFontHeight,
      badgeShadowSize,
      badgeZIndex,
      badgeHeight,
      badgeTextColor,
      badgeFontWeight,
      badgeFontSize,
      badgeColor,
      badgeColorHover,
      badgeShadowColor: colorBorderBg,
      badgeHeightSm,
      badgeDotSize,
      badgeFontSizeSm,
      badgeStatusSize,
      badgeProcessingDuration: "1.2s",
      badgeRibbonOffset: marginXS,
      // Follow token just by Design. Not related with token
      badgeRibbonCornerTransform: "scaleY(0.75)",
      badgeRibbonCornerFilter: `brightness(75%)`
    });
    return [genSharedBadgeStyle(badgeToken)];
  });
  var __rest$r = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const ribbonProps = () => ({
    prefix: String,
    color: {
      type: String
    },
    text: PropTypes.any,
    placement: {
      type: String,
      default: "end"
    }
  });
  const Ribbon = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ABadgeRibbon",
    inheritAttrs: false,
    props: ribbonProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("ribbon", props2);
      const [wrapSSR, hashId] = useStyle$f(prefixCls);
      const colorInPreset = computed(() => isPresetColor(props2.color, false));
      const ribbonCls = computed(() => [prefixCls.value, `${prefixCls.value}-placement-${props2.placement}`, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-color-${props2.color}`]: colorInPreset.value
      }]);
      return () => {
        var _a2, _b2;
        const {
          class: className,
          style
        } = attrs, restAttrs = __rest$r(attrs, ["class", "style"]);
        const colorStyle = {};
        const cornerColorStyle = {};
        if (props2.color && !colorInPreset.value) {
          colorStyle.background = props2.color;
          cornerColorStyle.color = props2.color;
        }
        return wrapSSR(createVNode("div", _objectSpread2$1({
          "class": `${prefixCls.value}-wrapper ${hashId.value}`
        }, restAttrs), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots), createVNode("div", {
          "class": [ribbonCls.value, className, hashId.value],
          "style": _extends$1(_extends$1({}, colorStyle), style)
        }, [createVNode("span", {
          "class": `${prefixCls.value}-text`
        }, [props2.text || ((_b2 = slots.text) === null || _b2 === void 0 ? void 0 : _b2.call(slots))]), createVNode("div", {
          "class": `${prefixCls.value}-corner`,
          "style": cornerColorStyle
        }, null)])]));
      };
    }
  });
  const isNumeric$1 = (value) => {
    return !isNaN(parseFloat(value)) && isFinite(value);
  };
  const badgeProps = () => ({
    /** Number to show in badge */
    count: PropTypes.any.def(null),
    showZero: {
      type: Boolean,
      default: void 0
    },
    /** Max count to show */
    overflowCount: {
      type: Number,
      default: 99
    },
    /** whether to show red dot without number */
    dot: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    scrollNumberPrefixCls: String,
    status: {
      type: String
    },
    size: {
      type: String,
      default: "default"
    },
    color: String,
    text: PropTypes.any,
    offset: Array,
    numberStyle: {
      type: Object,
      default: void 0
    },
    title: String
  });
  const Badge = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ABadge",
    Ribbon,
    inheritAttrs: false,
    props: badgeProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("badge", props2);
      const [wrapSSR, hashId] = useStyle$f(prefixCls);
      const numberedDisplayCount = computed(() => {
        return props2.count > props2.overflowCount ? `${props2.overflowCount}+` : props2.count;
      });
      const isZero = computed(() => numberedDisplayCount.value === "0" || numberedDisplayCount.value === 0);
      const ignoreCount = computed(() => props2.count === null || isZero.value && !props2.showZero);
      const hasStatus = computed(() => (props2.status !== null && props2.status !== void 0 || props2.color !== null && props2.color !== void 0) && ignoreCount.value);
      const showAsDot = computed(() => props2.dot && !isZero.value);
      const mergedCount = computed(() => showAsDot.value ? "" : numberedDisplayCount.value);
      const isHidden = computed(() => {
        const isEmpty2 = mergedCount.value === null || mergedCount.value === void 0 || mergedCount.value === "";
        return (isEmpty2 || isZero.value && !props2.showZero) && !showAsDot.value;
      });
      const livingCount = ref(props2.count);
      const displayCount = ref(mergedCount.value);
      const isDotRef = ref(showAsDot.value);
      watch([() => props2.count, mergedCount, showAsDot], () => {
        if (!isHidden.value) {
          livingCount.value = props2.count;
          displayCount.value = mergedCount.value;
          isDotRef.value = showAsDot.value;
        }
      }, {
        immediate: true
      });
      const isInternalColor = computed(() => isPresetColor(props2.color, false));
      const statusCls = computed(() => ({
        [`${prefixCls.value}-status-dot`]: hasStatus.value,
        [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
        [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
      }));
      const statusStyle = computed(() => {
        if (props2.color && !isInternalColor.value) {
          return {
            background: props2.color,
            color: props2.color
          };
        } else {
          return {};
        }
      });
      const scrollNumberCls = computed(() => ({
        [`${prefixCls.value}-dot`]: isDotRef.value,
        [`${prefixCls.value}-count`]: !isDotRef.value,
        [`${prefixCls.value}-count-sm`]: props2.size === "small",
        [`${prefixCls.value}-multiple-words`]: !isDotRef.value && displayCount.value && displayCount.value.toString().length > 1,
        [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
        [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
      }));
      return () => {
        var _a2, _b2;
        const {
          offset: offset2,
          title,
          color: color2
        } = props2;
        const style = attrs.style;
        const text = getPropsSlot(slots, props2, "text");
        const pre = prefixCls.value;
        const count = livingCount.value;
        let children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        children = children.length ? children : null;
        const visible = !!(!isHidden.value || slots.count);
        const mergedStyle = (() => {
          if (!offset2) {
            return _extends$1({}, style);
          }
          const offsetStyle = {
            marginTop: isNumeric$1(offset2[1]) ? `${offset2[1]}px` : offset2[1]
          };
          if (direction.value === "rtl") {
            offsetStyle.left = `${parseInt(offset2[0], 10)}px`;
          } else {
            offsetStyle.right = `${-parseInt(offset2[0], 10)}px`;
          }
          return _extends$1(_extends$1({}, offsetStyle), style);
        })();
        const titleNode = title !== null && title !== void 0 ? title : typeof count === "string" || typeof count === "number" ? count : void 0;
        const statusTextNode = visible || !text ? null : createVNode("span", {
          "class": `${pre}-status-text`
        }, [text]);
        const displayNode = typeof count === "object" || count === void 0 && slots.count ? cloneElement(count !== null && count !== void 0 ? count : (_b2 = slots.count) === null || _b2 === void 0 ? void 0 : _b2.call(slots), {
          style: mergedStyle
        }, false) : null;
        const badgeClassName = classNames(pre, {
          [`${pre}-status`]: hasStatus.value,
          [`${pre}-not-a-wrapper`]: !children,
          [`${pre}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value);
        if (!children && hasStatus.value) {
          const statusTextColor = mergedStyle.color;
          return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
            "class": badgeClassName,
            "style": mergedStyle
          }), [createVNode("span", {
            "class": statusCls.value,
            "style": statusStyle.value
          }, null), createVNode("span", {
            "style": {
              color: statusTextColor
            },
            "class": `${pre}-status-text`
          }, [text])]));
        }
        const transitionProps = getTransitionProps(children ? `${pre}-zoom` : "", {
          appear: false
        });
        let scrollNumberStyle = _extends$1(_extends$1({}, mergedStyle), props2.numberStyle);
        if (color2 && !isInternalColor.value) {
          scrollNumberStyle = scrollNumberStyle || {};
          scrollNumberStyle.background = color2;
        }
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": badgeClassName
        }), [children, createVNode(Transition, transitionProps, {
          default: () => [withDirectives(createVNode(ScrollNumber, {
            "prefixCls": props2.scrollNumberPrefixCls,
            "show": visible,
            "class": scrollNumberCls.value,
            "count": displayCount.value,
            "title": titleNode,
            "style": scrollNumberStyle,
            "key": "scrollNumber"
          }, {
            default: () => [displayNode]
          }), [[vShow, visible]])]
        }), statusTextNode]));
      };
    }
  });
  Badge.install = function(app2) {
    app2.component(Badge.name, Badge);
    app2.component(Ribbon.name, Ribbon);
    return app2;
  };
  const autoAdjustOverflow$1 = {
    adjustX: 1,
    adjustY: 1
  };
  const targetOffset = [0, 0];
  const placements$1 = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    topCenter: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottomCenter: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    }
  };
  var __rest$q = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const Dropdown$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    props: {
      minOverlayWidthMatchTrigger: {
        type: Boolean,
        default: void 0
      },
      arrow: {
        type: Boolean,
        default: false
      },
      prefixCls: PropTypes.string.def("rc-dropdown"),
      transitionName: String,
      overlayClassName: PropTypes.string.def(""),
      openClassName: String,
      animation: PropTypes.any,
      align: PropTypes.object,
      overlayStyle: {
        type: Object,
        default: void 0
      },
      placement: PropTypes.string.def("bottomLeft"),
      overlay: PropTypes.any,
      trigger: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def("hover"),
      alignPoint: {
        type: Boolean,
        default: void 0
      },
      showAction: PropTypes.array,
      hideAction: PropTypes.array,
      getPopupContainer: Function,
      visible: {
        type: Boolean,
        default: void 0
      },
      defaultVisible: {
        type: Boolean,
        default: false
      },
      mouseEnterDelay: PropTypes.number.def(0.15),
      mouseLeaveDelay: PropTypes.number.def(0.1)
    },
    emits: ["visibleChange", "overlayClick"],
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2,
        expose
      } = _ref;
      const triggerVisible = ref(!!props2.visible);
      watch(() => props2.visible, (val) => {
        if (val !== void 0) {
          triggerVisible.value = val;
        }
      });
      const triggerRef2 = ref();
      expose({
        triggerRef: triggerRef2
      });
      const onClick = (e2) => {
        if (props2.visible === void 0) {
          triggerVisible.value = false;
        }
        emit2("overlayClick", e2);
      };
      const onVisibleChange = (visible) => {
        if (props2.visible === void 0) {
          triggerVisible.value = visible;
        }
        emit2("visibleChange", visible);
      };
      const getMenuElement = () => {
        var _a2;
        const overlayElement = (_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        const extraOverlayProps = {
          prefixCls: `${props2.prefixCls}-menu`,
          onClick
        };
        return createVNode(Fragment, {
          "key": skipFlattenKey
        }, [props2.arrow && createVNode("div", {
          "class": `${props2.prefixCls}-arrow`
        }, null), cloneElement(overlayElement, extraOverlayProps, false)]);
      };
      const minOverlayWidthMatchTrigger = computed(() => {
        const {
          minOverlayWidthMatchTrigger: matchTrigger = !props2.alignPoint
        } = props2;
        return matchTrigger;
      });
      const renderChildren2 = () => {
        var _a2;
        const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        return triggerVisible.value && children ? cloneElement(children[0], {
          class: props2.openClassName || `${props2.prefixCls}-open`
        }, false) : children;
      };
      const triggerHideAction = computed(() => {
        if (!props2.hideAction && props2.trigger.indexOf("contextmenu") !== -1) {
          return ["click"];
        }
        return props2.hideAction;
      });
      return () => {
        const {
          prefixCls,
          arrow,
          showAction,
          overlayStyle,
          trigger: trigger2,
          placement,
          align,
          getPopupContainer,
          transitionName: transitionName2,
          animation,
          overlayClassName
        } = props2, otherProps = __rest$q(props2, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
        return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
          "prefixCls": prefixCls,
          "ref": triggerRef2,
          "popupClassName": classNames(overlayClassName, {
            [`${prefixCls}-show-arrow`]: arrow
          }),
          "popupStyle": overlayStyle,
          "builtinPlacements": placements$1,
          "action": trigger2,
          "showAction": showAction,
          "hideAction": triggerHideAction.value || [],
          "popupPlacement": placement,
          "popupAlign": align,
          "popupTransitionName": transitionName2,
          "popupAnimation": animation,
          "popupVisible": triggerVisible.value,
          "stretch": minOverlayWidthMatchTrigger.value ? "minWidth" : "",
          "onPopupVisibleChange": onVisibleChange,
          "getPopupContainer": getPopupContainer
        }), {
          popup: getMenuElement,
          default: renderChildren2
        });
      };
    }
  });
  const genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary
    } = token2;
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${colorPrimary})`,
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
        // =================== Motion ===================
        "&.wave-motion-appear": {
          transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          }
        }
      }
    };
  };
  const useStyle$e = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
  function isNotGrey(color2) {
    const match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
    if (match2 && match2[1] && match2[2] && match2[3]) {
      return !(match2[1] === match2[2] && match2[2] === match2[3]);
    }
    return true;
  }
  function isValidWaveColor(color2) {
    return color2 && color2 !== "#fff" && color2 !== "#ffffff" && color2 !== "rgb(255, 255, 255)" && color2 !== "rgba(255, 255, 255, 1)" && isNotGrey(color2) && !/rgba\((?:\d*, ){3}0\)/.test(color2) && // any transparent rgba color
    color2 !== "transparent";
  }
  function getTargetWaveColor(node2) {
    const {
      borderTopColor,
      borderColor,
      backgroundColor: backgroundColor2
    } = getComputedStyle(node2);
    if (isValidWaveColor(borderTopColor)) {
      return borderTopColor;
    }
    if (isValidWaveColor(borderColor)) {
      return borderColor;
    }
    if (isValidWaveColor(backgroundColor2)) {
      return backgroundColor2;
    }
    return null;
  }
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  const WaveEffect = /* @__PURE__ */ defineComponent({
    props: {
      target: objectType(),
      className: String
    },
    setup(props2) {
      const divRef = shallowRef(null);
      const [color2, setWaveColor] = useState(null);
      const [borderRadius, setBorderRadius] = useState([]);
      const [left, setLeft] = useState(0);
      const [top, setTop] = useState(0);
      const [width, setWidth] = useState(0);
      const [height, setHeight] = useState(0);
      const [enabled, setEnabled] = useState(false);
      function syncPos() {
        const {
          target
        } = props2;
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
      }
      let resizeObserver;
      let rafId;
      let timeoutId;
      const clear2 = () => {
        clearTimeout(timeoutId);
        wrapperRaf.cancel(rafId);
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
      };
      const removeDom = () => {
        var _a2;
        const holder = (_a2 = divRef.value) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        if (holder) {
          render$2(null, holder);
          if (holder.parentElement) {
            holder.parentElement.removeChild(holder);
          }
        }
      };
      onMounted(() => {
        clear2();
        timeoutId = setTimeout(() => {
          removeDom();
        }, 5e3);
        const {
          target
        } = props2;
        if (target) {
          rafId = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver = new ResizeObserver(syncPos);
            resizeObserver.observe(target);
          }
        }
      });
      onBeforeUnmount(() => {
        clear2();
      });
      const onTransitionend = (e2) => {
        if (e2.propertyName === "opacity") {
          removeDom();
        }
      };
      return () => {
        if (!enabled.value) {
          return null;
        }
        const waveStyle = {
          left: `${left.value}px`,
          top: `${top.value}px`,
          width: `${width.value}px`,
          height: `${height.value}px`,
          borderRadius: borderRadius.value.map((radius) => `${radius}px`).join(" ")
        };
        if (color2) {
          waveStyle["--wave-color"] = color2.value;
        }
        return createVNode(Transition, {
          "appear": true,
          "name": "wave-motion",
          "appearFromClass": "wave-motion-appear",
          "appearActiveClass": "wave-motion-appear",
          "appearToClass": "wave-motion-appear wave-motion-appear-active"
        }, {
          default: () => [createVNode("div", {
            "ref": divRef,
            "class": props2.className,
            "style": waveStyle,
            "onTransitionend": onTransitionend
          }, null)]
        });
      };
    }
  });
  function showWaveEffect(node2, className) {
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = `0px`;
    holder.style.top = `0px`;
    node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
    render$2(createVNode(WaveEffect, {
      "target": node2,
      "className": className
    }, null), holder);
    return () => {
      render$2(null, holder);
      if (holder.parentElement) {
        holder.parentElement.removeChild(holder);
      }
    };
  }
  function useWave(className, wave) {
    const instance = getCurrentInstance();
    let stopWave;
    function showWave() {
      var _a2;
      const node2 = findDOMNode(instance);
      stopWave === null || stopWave === void 0 ? void 0 : stopWave();
      if (((_a2 = wave === null || wave === void 0 ? void 0 : wave.value) === null || _a2 === void 0 ? void 0 : _a2.disabled) || !node2) {
        return;
      }
      stopWave = showWaveEffect(node2, className.value);
    }
    onBeforeUnmount(() => {
      stopWave === null || stopWave === void 0 ? void 0 : stopWave();
    });
    return showWave;
  }
  const Wave = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Wave",
    props: {
      disabled: Boolean
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const instance = getCurrentInstance();
      const {
        prefixCls,
        wave
      } = useConfigInject("wave", props2);
      const [, hashId] = useStyle$e(prefixCls);
      const showWave = useWave(computed(() => classNames(prefixCls.value, hashId.value)), wave);
      let onClick;
      const clear2 = () => {
        const node2 = findDOMNode(instance);
        node2.removeEventListener("click", onClick, true);
      };
      onMounted(() => {
        watch(() => props2.disabled, () => {
          clear2();
          nextTick(() => {
            const node2 = findDOMNode(instance);
            node2 === null || node2 === void 0 ? void 0 : node2.removeEventListener("click", onClick, true);
            if (!node2 || node2.nodeType !== 1 || props2.disabled) {
              return;
            }
            onClick = (e2) => {
              if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || // No need wave
              !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
                return;
              }
              showWave();
            };
            node2.addEventListener("click", onClick, true);
          });
        }, {
          immediate: true,
          flush: "post"
        });
      });
      onBeforeUnmount(() => {
        clear2();
      });
      return () => {
        var _a2;
        const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
        return children;
      };
    }
  });
  const buttonProps = () => ({
    prefixCls: String,
    type: String,
    htmlType: {
      type: String,
      default: "button"
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    loading: {
      type: [Boolean, Object],
      default: () => false
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    block: {
      type: Boolean,
      default: void 0
    },
    danger: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes.any,
    href: String,
    target: String,
    title: String,
    onClick: eventType(),
    onMousedown: eventType()
  });
  const getCollapsedWidth = (node2) => {
    if (node2) {
      node2.style.width = "0px";
      node2.style.opacity = "0";
      node2.style.transform = "scale(0)";
    }
  };
  const getRealWidth = (node2) => {
    nextTick(() => {
      if (node2) {
        node2.style.width = `${node2.scrollWidth}px`;
        node2.style.opacity = "1";
        node2.style.transform = "scale(1)";
      }
    });
  };
  const resetStyle = (node2) => {
    if (node2 && node2.style) {
      node2.style.width = null;
      node2.style.opacity = null;
      node2.style.transform = null;
    }
  };
  const LoadingIcon = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "LoadingIcon",
    props: {
      prefixCls: String,
      loading: [Boolean, Object],
      existIcon: Boolean
    },
    setup(props2) {
      return () => {
        const {
          existIcon,
          prefixCls,
          loading
        } = props2;
        if (existIcon) {
          return createVNode("span", {
            "class": `${prefixCls}-loading-icon`
          }, [createVNode(LoadingOutlined, null, null)]);
        }
        const visible = !!loading;
        return createVNode(Transition, {
          "name": `${prefixCls}-loading-icon-motion`,
          "onBeforeEnter": getCollapsedWidth,
          "onEnter": getRealWidth,
          "onAfterEnter": resetStyle,
          "onBeforeLeave": getRealWidth,
          "onLeave": (node2) => {
            setTimeout(() => {
              getCollapsedWidth(node2);
            });
          },
          "onAfterLeave": resetStyle
        }, {
          default: () => [visible ? createVNode("span", {
            "class": `${prefixCls}-loading-icon`
          }, [createVNode(LoadingOutlined, null, null)]) : null]
        });
      };
    }
  });
  const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
    // Border
    [`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  const genGroupStyle$1 = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      colorPrimaryHover,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          // Border
          [`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: -lineWidth,
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            [`&:hover,
          &:focus,
          &:active`]: {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  function compactItemVerticalBorder(token2, parentCls) {
    return {
      // border collapse
      [`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: -token2.lineWidth
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 2
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: _extends$1(_extends$1({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
    };
  }
  const genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight: 400,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        lineHeight: token2.lineHeight,
        color: token2.colorText,
        "> span": {
          display: "inline-block"
        },
        // Leave a space between icon and text.
        [`> ${iconCls} + span, > span + ${iconCls}`]: {
          marginInlineStart: token2.marginXS
        },
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": _extends$1({}, genFocusStyle(token2)),
        // make `btn-icon-only` not too narrow
        [`&-icon-only${componentCls}-compact-item`]: {
          flex: "none"
        },
        // Special styles for Primary Button
        [`&-compact-item${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: token2.lineWidth,
              height: `calc(100% + ${token2.lineWidth * 2}px)`,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        },
        // Special styles for Primary Button
        "&-compact-vertical-item": {
          [`&${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: `calc(100% + ${token2.lineWidth * 2}px)`,
                height: token2.lineWidth,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          }
        }
      }
    };
  };
  const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
    "&:not(:disabled)": {
      "&:hover": hoverStyle,
      "&:active": activeStyle
    }
  });
  const genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%"
  });
  const genRoundButtonStyle = (token2) => ({
    borderRadius: token2.controlHeight,
    paddingInlineStart: token2.controlHeight / 2,
    paddingInlineEnd: token2.controlHeight / 2
  });
  const genDisabledStyle$1 = (token2) => ({
    cursor: "not-allowed",
    borderColor: token2.colorBorder,
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    boxShadow: "none"
  });
  const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
    [`&${btnCls}-background-ghost`]: _extends$1(_extends$1({
      color: textColor || void 0,
      backgroundColor: "transparent",
      borderColor: borderColor || void 0,
      boxShadow: "none"
    }, genHoverActiveButtonStyle(_extends$1({
      backgroundColor: "transparent"
    }, hoverStyle), _extends$1({
      backgroundColor: "transparent"
    }, activeStyle))), {
      "&:disabled": {
        cursor: "not-allowed",
        color: textColorDisabled || void 0,
        borderColor: borderColorDisabled || void 0
      }
    })
  });
  const genSolidDisabledButtonStyle = (token2) => ({
    "&:disabled": _extends$1({}, genDisabledStyle$1(token2))
  });
  const genSolidButtonStyle = (token2) => _extends$1({}, genSolidDisabledButtonStyle(token2));
  const genPureDisabledButtonStyle = (token2) => ({
    "&:disabled": {
      cursor: "not-allowed",
      color: token2.colorTextDisabled
    }
  });
  const genDefaultButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
    backgroundColor: token2.colorBgContainer,
    borderColor: token2.colorBorder,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
      color: token2.colorError,
      borderColor: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorBorderHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
  });
  const genPrimaryButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimary,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryHover
  }, {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
      backgroundColor: token2.colorError,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
    }, genHoverActiveButtonStyle({
      backgroundColor: token2.colorErrorHover
    }, {
      backgroundColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genSolidDisabledButtonStyle(token2))
  });
  const genDashedButtonStyle = (token2) => _extends$1(_extends$1({}, genDefaultButtonStyle(token2)), {
    borderStyle: "dashed"
  });
  const genLinkButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({
    color: token2.colorLink
  }, genHoverActiveButtonStyle({
    color: token2.colorLinkHover
  }, {
    color: token2.colorLinkActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
      color: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive
    })), genPureDisabledButtonStyle(token2))
  });
  const genTextButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({}, genHoverActiveButtonStyle({
    color: token2.colorText,
    backgroundColor: token2.colorBgTextHover
  }, {
    color: token2.colorText,
    backgroundColor: token2.colorBgTextActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
      color: token2.colorError
    }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }, {
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }))
  });
  const genDisabledButtonStyle = (token2) => _extends$1(_extends$1({}, genDisabledStyle$1(token2)), {
    [`&${token2.componentCls}:hover`]: _extends$1({}, genDisabledStyle$1(token2))
  });
  const genTypeButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-default`]: genDefaultButtonStyle(token2),
      [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
      [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
      [`${componentCls}-link`]: genLinkButtonStyle(token2),
      [`${componentCls}-text`]: genTextButtonStyle(token2),
      [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
    };
  };
  const genSizeButtonStyle = function(token2) {
    let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
      componentCls,
      iconCls,
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      borderRadius,
      buttonPaddingHorizontal
    } = token2;
    const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
    const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
    const iconOnlyCls = `${componentCls}-icon-only`;
    return [
      // Size
      {
        [`${componentCls}${sizePrefixCls}`]: {
          fontSize,
          height: controlHeight,
          padding: `${paddingVertical}px ${paddingHorizontal}px`,
          borderRadius,
          [`&${iconOnlyCls}`]: {
            width: controlHeight,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${componentCls}-round`]: {
              width: "auto"
            },
            "> span": {
              transform: "scale(1.143)"
              // 14px -> 16px
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: token2.opacityLoading,
            cursor: "default"
          },
          [`${componentCls}-loading-icon`]: {
            transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          },
          [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
            marginInlineEnd: token2.marginXS
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
      }
    ];
  };
  const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
  const genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge$2(token2, {
      controlHeight: token2.controlHeightSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: 8,
      borderRadius: token2.borderRadiusSM
    });
    return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  const genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge$2(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG
    });
    return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  const genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  const useStyle$d = genComponentStyleHook("Button", (token2) => {
    const {
      controlTmpOutline,
      paddingContentHorizontal
    } = token2;
    const buttonToken = merge$2(token2, {
      colorOutlineDefault: controlTmpOutline,
      buttonPaddingHorizontal: paddingContentHorizontal
    });
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeSmallButtonStyle(buttonToken),
      genSizeBaseButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Group (type, ghost, danger, disabled, loading)
      genTypeButtonStyle(buttonToken),
      // Button Group
      genGroupStyle$1(buttonToken),
      // Space Compact
      genCompactItemStyle(token2, {
        focus: false
      }),
      genCompactItemVerticalStyle(token2)
    ];
  });
  const buttonGroupProps = () => ({
    prefixCls: String,
    size: {
      type: String
    }
  });
  const GroupSizeContext = createContext();
  const ButtonGroup$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AButtonGroup",
    props: buttonGroupProps(),
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("btn-group", props2);
      const [, , hashId] = useToken();
      GroupSizeContext.useProvide(reactive({
        size: computed(() => props2.size)
      }));
      const classes = computed(() => {
        const {
          size
        } = props2;
        let sizeCls = "";
        switch (size) {
          case "large":
            sizeCls = "lg";
            break;
          case "small":
            sizeCls = "sm";
            break;
          case "middle":
          case void 0:
            break;
          default:
            devWarning(!size, "Button.Group", "Invalid prop `size`.");
        }
        return {
          [`${prefixCls.value}`]: true,
          [`${prefixCls.value}-${sizeCls}`]: sizeCls,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [hashId.value]: true
        };
      });
      return () => {
        var _a2;
        return createVNode("div", {
          "class": classes.value
        }, [flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]);
      };
    }
  });
  const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
  const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function isUnBorderedButtonType(type) {
    return type === "text" || type === "link";
  }
  const Button$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AButton",
    inheritAttrs: false,
    __ANT_BUTTON: true,
    props: initDefaultProps(buttonProps(), {
      type: "default"
    }),
    slots: Object,
    // emits: ['click', 'mousedown'],
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const {
        prefixCls,
        autoInsertSpaceInButton,
        direction,
        size
      } = useConfigInject("btn", props2);
      const [wrapSSR, hashId] = useStyle$d(prefixCls);
      const groupSizeContext = GroupSizeContext.useInject();
      const disabledContext = useInjectDisabled();
      const mergedDisabled = computed(() => {
        var _a2;
        return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
      });
      const buttonNodeRef = shallowRef(null);
      const delayTimeoutRef = shallowRef(void 0);
      let isNeedInserted = false;
      const innerLoading = shallowRef(false);
      const hasTwoCNChar = shallowRef(false);
      const autoInsertSpace = computed(() => autoInsertSpaceInButton.value !== false);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const loadingOrDelay = computed(() => typeof props2.loading === "object" && props2.loading.delay ? props2.loading.delay || true : !!props2.loading);
      watch(loadingOrDelay, (val) => {
        clearTimeout(delayTimeoutRef.value);
        if (typeof loadingOrDelay.value === "number") {
          delayTimeoutRef.value = setTimeout(() => {
            innerLoading.value = val;
          }, loadingOrDelay.value);
        } else {
          innerLoading.value = val;
        }
      }, {
        immediate: true
      });
      const classes = computed(() => {
        const {
          type,
          shape = "default",
          ghost,
          block,
          danger
        } = props2;
        const pre = prefixCls.value;
        const sizeClassNameMap = {
          large: "lg",
          small: "sm",
          middle: void 0
        };
        const sizeFullname = compactSize.value || (groupSizeContext === null || groupSizeContext === void 0 ? void 0 : groupSizeContext.size) || size.value;
        const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
        return [compactItemClassnames.value, {
          [hashId.value]: true,
          [`${pre}`]: true,
          [`${pre}-${shape}`]: shape !== "default" && shape,
          [`${pre}-${type}`]: type,
          [`${pre}-${sizeCls}`]: sizeCls,
          [`${pre}-loading`]: innerLoading.value,
          [`${pre}-background-ghost`]: ghost && !isUnBorderedButtonType(type),
          [`${pre}-two-chinese-chars`]: hasTwoCNChar.value && autoInsertSpace.value,
          [`${pre}-block`]: block,
          [`${pre}-dangerous`]: !!danger,
          [`${pre}-rtl`]: direction.value === "rtl"
        }];
      });
      const fixTwoCNChar = () => {
        const node2 = buttonNodeRef.value;
        if (!node2 || autoInsertSpaceInButton.value === false) {
          return;
        }
        const buttonText = node2.textContent;
        if (isNeedInserted && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar.value) {
            hasTwoCNChar.value = true;
          }
        } else if (hasTwoCNChar.value) {
          hasTwoCNChar.value = false;
        }
      };
      const handleClick = (event) => {
        if (innerLoading.value || mergedDisabled.value) {
          event.preventDefault();
          return;
        }
        emit2("click", event);
      };
      const handleMousedown = (event) => {
        emit2("mousedown", event);
      };
      const insertSpace = (child, needInserted) => {
        const SPACE = needInserted ? " " : "";
        if (child.type === Text) {
          let text = child.children.trim();
          if (isTwoCNChar(text)) {
            text = text.split("").join(SPACE);
          }
          return createVNode("span", null, [text]);
        }
        return child;
      };
      watchEffect(() => {
        devWarning(!(props2.ghost && isUnBorderedButtonType(props2.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
      });
      onMounted(fixTwoCNChar);
      onUpdated(fixTwoCNChar);
      onBeforeUnmount(() => {
        delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
      });
      const focus = () => {
        var _a2;
        (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      return () => {
        var _a2, _b2;
        const {
          icon = (_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
        } = props2;
        const children = flattenChildren((_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots));
        isNeedInserted = children.length === 1 && !icon && !isUnBorderedButtonType(props2.type);
        const {
          type,
          htmlType,
          href,
          title,
          target
        } = props2;
        const iconType = innerLoading.value ? "loading" : icon;
        const buttonProps2 = _extends$1(_extends$1({}, attrs), {
          title,
          disabled: mergedDisabled.value,
          class: [classes.value, attrs.class, {
            [`${prefixCls.value}-icon-only`]: children.length === 0 && !!iconType
          }],
          onClick: handleClick,
          onMousedown: handleMousedown
        });
        if (!mergedDisabled.value) {
          delete buttonProps2.disabled;
        }
        const iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon, {
          "existIcon": !!icon,
          "prefixCls": prefixCls.value,
          "loading": !!innerLoading.value
        }, null);
        const kids = children.map((child) => insertSpace(child, isNeedInserted && autoInsertSpace.value));
        if (href !== void 0) {
          return wrapSSR(createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
            "href": href,
            "target": target,
            "ref": buttonNodeRef
          }), [iconNode, kids]));
        }
        let buttonNode = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
          "ref": buttonNodeRef,
          "type": htmlType
        }), [iconNode, kids]);
        if (!isUnBorderedButtonType(type)) {
          const _buttonNode = /* @__PURE__ */ function() {
            return buttonNode;
          }();
          buttonNode = createVNode(Wave, {
            "ref": "wave",
            "disabled": !!innerLoading.value
          }, {
            default: () => [_buttonNode]
          });
        }
        return wrapSSR(buttonNode);
      };
    }
  });
  Button$1.Group = ButtonGroup$1;
  Button$1.install = function(app2) {
    app2.component(Button$1.name, Button$1);
    app2.component(ButtonGroup$1.name, ButtonGroup$1);
    return app2;
  };
  const dropdownProps = () => ({
    arrow: someType([Boolean, Object]),
    trigger: {
      type: [Array, String]
    },
    menu: objectType(),
    overlay: PropTypes.any,
    /** @deprecated Please use `open` instead */
    visible: booleanType(),
    open: booleanType(),
    disabled: booleanType(),
    danger: booleanType(),
    autofocus: booleanType(),
    align: objectType(),
    getPopupContainer: Function,
    prefixCls: String,
    transitionName: String,
    placement: String,
    overlayClassName: String,
    overlayStyle: objectType(),
    forceRender: booleanType(),
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    openClassName: String,
    minOverlayWidthMatchTrigger: booleanType(),
    destroyPopupOnHide: booleanType(),
    /** @deprecated Please use `onOpenChange` instead */
    onVisibleChange: {
      type: Function
    },
    /** @deprecated Please use `onUpdate:open` instead */
    "onUpdate:visible": {
      type: Function
    },
    onOpenChange: {
      type: Function
    },
    "onUpdate:open": {
      type: Function
    }
  });
  const buttonTypesProps = buttonProps();
  const dropdownButtonProps = () => _extends$1(_extends$1({}, dropdownProps()), {
    type: buttonTypesProps.type,
    size: String,
    htmlType: buttonTypesProps.htmlType,
    href: String,
    disabled: booleanType(),
    prefixCls: String,
    icon: PropTypes.any,
    title: String,
    loading: buttonTypesProps.loading,
    onClick: eventType()
  });
  var EllipsisOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
  function _objectSpread$h(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$h(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$h(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var EllipsisOutlined = function EllipsisOutlined2(props2, context) {
    var p2 = _objectSpread$h({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$h({}, p2, {
      "icon": EllipsisOutlined$1
    }), null);
  };
  EllipsisOutlined.displayName = "EllipsisOutlined";
  EllipsisOutlined.inheritAttrs = false;
  const genButtonStyle = (token2) => {
    const {
      componentCls,
      antCls,
      paddingXS,
      opacityLoading
    } = token2;
    return {
      [`${componentCls}-button`]: {
        whiteSpace: "nowrap",
        [`&${antCls}-btn-group > ${antCls}-btn`]: {
          [`&-loading, &-loading + ${antCls}-btn`]: {
            cursor: "default",
            pointerEvents: "none",
            opacity: opacityLoading
          },
          [`&:last-child:not(:first-child):not(${antCls}-btn-icon-only)`]: {
            paddingInline: paddingXS
          }
        }
      }
    };
  };
  const genStatusStyle$1 = (token2) => {
    const {
      componentCls,
      menuCls,
      colorError,
      colorTextLightSolid
    } = token2;
    const itemCls = `${menuCls}-item`;
    return {
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [`${menuCls} ${itemCls}`]: {
          [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
            color: colorError,
            "&:hover": {
              color: colorTextLightSolid,
              backgroundColor: colorError
            }
          }
        }
      }
    };
  };
  const genBaseStyle$1 = (token2) => {
    const {
      componentCls,
      menuCls,
      zIndexPopup,
      dropdownArrowDistance,
      dropdownArrowOffset,
      sizePopupArrow,
      antCls,
      iconCls,
      motionDurationMid,
      dropdownPaddingVertical,
      fontSize,
      dropdownEdgeChildPadding,
      colorTextDisabled,
      fontSizeIcon,
      controlPaddingHorizontal,
      colorBgElevated,
      boxShadowPopoverArrow
    } = token2;
    return [
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          display: "block",
          // A placeholder out of dropdown visible range to avoid close when user moving
          "&::before": {
            position: "absolute",
            insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
            // insetInlineStart: -7, // FIXME: Seems not work for hidden element
            zIndex: -9999,
            opacity: 1e-4,
            content: '""'
          },
          [`${componentCls}-wrap`]: {
            position: "relative",
            [`${antCls}-btn > ${iconCls}-down`]: {
              fontSize: fontSizeIcon
            },
            [`${iconCls}-down::before`]: {
              transition: `transform ${motionDurationMid}`
            }
          },
          [`${componentCls}-wrap-open`]: {
            [`${iconCls}-down::before`]: {
              transform: `rotate(180deg)`
            }
          },
          [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
            display: "none"
          },
          // =============================================================
          // ==                          Arrow                          ==
          // =============================================================
          // Offset the popover to account for the dropdown arrow
          [`
        &-show-arrow${componentCls}-placement-topLeft,
        &-show-arrow${componentCls}-placement-top,
        &-show-arrow${componentCls}-placement-topRight
      `]: {
            paddingBottom: dropdownArrowDistance
          },
          [`
        &-show-arrow${componentCls}-placement-bottomLeft,
        &-show-arrow${componentCls}-placement-bottom,
        &-show-arrow${componentCls}-placement-bottomRight
      `]: {
            paddingTop: dropdownArrowDistance
          },
          // Note: .popover-arrow is outer, .popover-arrow:after is inner
          [`${componentCls}-arrow`]: _extends$1({
            position: "absolute",
            zIndex: 1,
            display: "block"
          }, roundedArrow(sizePopupArrow, token2.borderRadiusXS, token2.borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
          [`
        &-placement-top > ${componentCls}-arrow,
        &-placement-topLeft > ${componentCls}-arrow,
        &-placement-topRight > ${componentCls}-arrow
      `]: {
            bottom: dropdownArrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          [`&-placement-topLeft > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-topRight > ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`
          &-placement-bottom > ${componentCls}-arrow,
          &-placement-bottomLeft > ${componentCls}-arrow,
          &-placement-bottomRight > ${componentCls}-arrow
        `]: {
            top: dropdownArrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateY(-100%) translateX(-50%)`
          },
          [`&-placement-bottomLeft > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-bottomRight > ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          // =============================================================
          // ==                         Motion                          ==
          // =============================================================
          // When position is not enough for dropdown, the placement will revert.
          // We will handle this with revert motion name.
          [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
            animationName: slideDownOut
          }
        })
      },
      {
        // =============================================================
        // ==                          Menu                           ==
        // =============================================================
        [`${componentCls} ${menuCls}`]: {
          position: "relative",
          margin: 0
        },
        [`${menuCls}-submenu-popup`]: {
          position: "absolute",
          zIndex: zIndexPopup,
          background: "transparent",
          boxShadow: "none",
          transformOrigin: "0 0",
          "ul,li": {
            listStyle: "none"
          },
          ul: {
            marginInline: "0.3em"
          }
        },
        [`${componentCls}, ${componentCls}-menu-submenu`]: {
          [menuCls]: _extends$1(_extends$1({
            padding: dropdownEdgeChildPadding,
            listStyleType: "none",
            backgroundColor: colorBgElevated,
            backgroundClip: "padding-box",
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary
          }, genFocusStyle(token2)), {
            [`${menuCls}-item-group-title`]: {
              padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
              color: token2.colorTextDescription,
              transition: `all ${motionDurationMid}`
            },
            // ======================= Item Content =======================
            [`${menuCls}-item`]: {
              position: "relative",
              display: "flex",
              alignItems: "center",
              borderRadius: token2.borderRadiusSM
            },
            [`${menuCls}-item-icon`]: {
              minWidth: fontSize,
              marginInlineEnd: token2.marginXS,
              fontSize: token2.fontSizeSM
            },
            [`${menuCls}-title-content`]: {
              flex: "auto",
              "> a": {
                color: "inherit",
                transition: `all ${motionDurationMid}`,
                "&:hover": {
                  color: "inherit"
                },
                "&::after": {
                  position: "absolute",
                  inset: 0,
                  content: '""'
                }
              }
            },
            // =========================== Item ===========================
            [`${menuCls}-item, ${menuCls}-submenu-title`]: _extends$1(_extends$1({
              clear: "both",
              margin: 0,
              padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize,
              lineHeight: token2.lineHeight,
              cursor: "pointer",
              transition: `all ${motionDurationMid}`,
              [`&:hover, &-active`]: {
                backgroundColor: token2.controlItemBgHover
              }
            }, genFocusStyle(token2)), {
              "&-selected": {
                color: token2.colorPrimary,
                backgroundColor: token2.controlItemBgActive,
                "&:hover, &-active": {
                  backgroundColor: token2.controlItemBgActiveHover
                }
              },
              "&-disabled": {
                color: colorTextDisabled,
                cursor: "not-allowed",
                "&:hover": {
                  color: colorTextDisabled,
                  backgroundColor: colorBgElevated,
                  cursor: "not-allowed"
                },
                a: {
                  pointerEvents: "none"
                }
              },
              "&-divider": {
                height: 1,
                margin: `${token2.marginXXS}px 0`,
                overflow: "hidden",
                lineHeight: 0,
                backgroundColor: token2.colorSplit
              },
              [`${componentCls}-menu-submenu-expand-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                [`${componentCls}-menu-submenu-arrow-icon`]: {
                  marginInlineEnd: "0 !important",
                  color: token2.colorTextDescription,
                  fontSize: fontSizeIcon,
                  fontStyle: "normal"
                }
              }
            }),
            [`${menuCls}-item-group-list`]: {
              margin: `0 ${token2.marginXS}px`,
              padding: 0,
              listStyle: "none"
            },
            [`${menuCls}-submenu-title`]: {
              paddingInlineEnd: controlPaddingHorizontal + token2.fontSizeSM
            },
            [`${menuCls}-submenu-vertical`]: {
              position: "relative"
            },
            [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
              [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              }
            },
            // https://github.com/ant-design/ant-design/issues/19264
            [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
              color: token2.colorPrimary
            }
          })
        }
      },
      // Follow code may reuse in other components
      [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
    ];
  };
  const useStyle$c = genComponentStyleHook("Dropdown", (token2, _ref) => {
    let {
      rootPrefixCls
    } = _ref;
    const {
      marginXXS,
      sizePopupArrow,
      controlHeight,
      fontSize,
      lineHeight,
      paddingXXS,
      componentCls,
      borderRadiusOuter,
      borderRadiusLG
    } = token2;
    const dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
    const {
      dropdownArrowOffset
    } = getArrowOffset({
      sizePopupArrow,
      contentRadius: borderRadiusLG,
      borderRadiusOuter
    });
    const dropdownToken = merge$2(token2, {
      menuCls: `${componentCls}-menu`,
      rootPrefixCls,
      dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
      dropdownArrowOffset,
      dropdownPaddingVertical,
      dropdownEdgeChildPadding: paddingXXS
    });
    return [genBaseStyle$1(dropdownToken), genButtonStyle(dropdownToken), genStatusStyle$1(dropdownToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 50
  }));
  var __rest$p = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const ButtonGroup = Button$1.Group;
  const DropdownButton = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ADropdownButton",
    inheritAttrs: false,
    __ANT_BUTTON: true,
    props: initDefaultProps(dropdownButtonProps(), {
      trigger: "hover",
      placement: "bottomRight",
      type: "default"
    }),
    // emits: ['click', 'visibleChange', 'update:visible'],s
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        emit: emit2
      } = _ref;
      const handleVisibleChange = (val) => {
        emit2("update:visible", val);
        emit2("visibleChange", val);
        emit2("update:open", val);
        emit2("openChange", val);
      };
      const {
        prefixCls,
        direction,
        getPopupContainer
      } = useConfigInject("dropdown", props2);
      const buttonPrefixCls = computed(() => `${prefixCls.value}-button`);
      const [wrapSSR, hashId] = useStyle$c(prefixCls);
      return () => {
        var _a2, _b2;
        const _c2 = _extends$1(_extends$1({}, props2), attrs), {
          type = "default",
          disabled,
          danger,
          loading,
          htmlType,
          class: className = "",
          overlay = (_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          trigger: trigger2,
          align,
          open: open2,
          visible,
          onVisibleChange: _onVisibleChange,
          placement = direction.value === "rtl" ? "bottomLeft" : "bottomRight",
          href,
          title,
          icon = ((_b2 = slots.icon) === null || _b2 === void 0 ? void 0 : _b2.call(slots)) || createVNode(EllipsisOutlined, null, null),
          mouseEnterDelay,
          mouseLeaveDelay,
          overlayClassName,
          overlayStyle,
          destroyPopupOnHide,
          onClick,
          "onUpdate:open": _updateVisible
        } = _c2, restProps = __rest$p(_c2, ["type", "disabled", "danger", "loading", "htmlType", "class", "overlay", "trigger", "align", "open", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:open"]);
        const dropdownProps2 = {
          align,
          disabled,
          trigger: disabled ? [] : trigger2,
          placement,
          getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
          onOpenChange: handleVisibleChange,
          mouseEnterDelay,
          mouseLeaveDelay,
          open: open2 !== null && open2 !== void 0 ? open2 : visible,
          overlayClassName,
          overlayStyle,
          destroyPopupOnHide
        };
        const leftButton = createVNode(Button$1, {
          "danger": danger,
          "type": type,
          "disabled": disabled,
          "loading": loading,
          "onClick": onClick,
          "htmlType": htmlType,
          "href": href,
          "title": title
        }, {
          default: slots.default
        });
        const rightButton = createVNode(Button$1, {
          "danger": danger,
          "type": type,
          "icon": icon
        }, null);
        return wrapSSR(createVNode(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          "class": classNames(buttonPrefixCls.value, className, hashId.value)
        }), {
          default: () => [slots.leftButton ? slots.leftButton({
            button: leftButton
          }) : leftButton, createVNode(Dropdown, dropdownProps2, {
            default: () => [slots.rightButton ? slots.rightButton({
              button: rightButton
            }) : rightButton],
            overlay: () => overlay
          })]
        }));
      };
    }
  });
  var RightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
  function _objectSpread$g(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$g(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$g(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var RightOutlined = function RightOutlined2(props2, context) {
    var p2 = _objectSpread$g({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$g({}, p2, {
      "icon": RightOutlined$1
    }), null);
  };
  RightOutlined.displayName = "RightOutlined";
  RightOutlined.inheritAttrs = false;
  const OverrideContextKey = Symbol("OverrideContextKey");
  const useInjectOverride = () => {
    return inject(OverrideContextKey, void 0);
  };
  const useProvideOverride = (props2) => {
    var _a2, _b2, _c2;
    const {
      prefixCls,
      mode,
      selectable,
      validator: validator2,
      onClick,
      expandIcon
    } = useInjectOverride() || {};
    provide(OverrideContextKey, {
      prefixCls: computed(() => {
        var _a3, _b3;
        return (_b3 = (_a3 = props2.prefixCls) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b3 !== void 0 ? _b3 : prefixCls === null || prefixCls === void 0 ? void 0 : prefixCls.value;
      }),
      mode: computed(() => {
        var _a3, _b3;
        return (_b3 = (_a3 = props2.mode) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b3 !== void 0 ? _b3 : mode === null || mode === void 0 ? void 0 : mode.value;
      }),
      selectable: computed(() => {
        var _a3, _b3;
        return (_b3 = (_a3 = props2.selectable) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b3 !== void 0 ? _b3 : selectable === null || selectable === void 0 ? void 0 : selectable.value;
      }),
      validator: (_a2 = props2.validator) !== null && _a2 !== void 0 ? _a2 : validator2,
      onClick: (_b2 = props2.onClick) !== null && _b2 !== void 0 ? _b2 : onClick,
      expandIcon: (_c2 = props2.expandIcon) !== null && _c2 !== void 0 ? _c2 : expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.value
    });
  };
  const Dropdown = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ADropdown",
    inheritAttrs: false,
    props: initDefaultProps(dropdownProps(), {
      mouseEnterDelay: 0.15,
      mouseLeaveDelay: 0.1,
      placement: "bottomLeft",
      trigger: "hover"
    }),
    // emits: ['visibleChange', 'update:visible'],
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        emit: emit2
      } = _ref;
      const {
        prefixCls,
        rootPrefixCls,
        direction,
        getPopupContainer
      } = useConfigInject("dropdown", props2);
      const [wrapSSR, hashId] = useStyle$c(prefixCls);
      const transitionName2 = computed(() => {
        const {
          placement: placement2 = "",
          transitionName: transitionName22
        } = props2;
        if (transitionName22 !== void 0) {
          return transitionName22;
        }
        if (placement2.includes("top")) {
          return `${rootPrefixCls.value}-slide-down`;
        }
        return `${rootPrefixCls.value}-slide-up`;
      });
      useProvideOverride({
        prefixCls: computed(() => `${prefixCls.value}-menu`),
        expandIcon: computed(() => {
          return createVNode("span", {
            "class": `${prefixCls.value}-menu-submenu-arrow`
          }, [createVNode(RightOutlined, {
            "class": `${prefixCls.value}-menu-submenu-arrow-icon`
          }, null)]);
        }),
        mode: computed(() => "vertical"),
        selectable: computed(() => false),
        onClick: () => {
        },
        validator: (_ref3) => {
          let {
            mode
          } = _ref3;
        }
      });
      const renderOverlay = () => {
        var _a2, _b2, _c2;
        const overlay = props2.overlay || ((_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        const overlayNode = Array.isArray(overlay) ? overlay[0] : overlay;
        if (!overlayNode) return null;
        const overlayProps = overlayNode.props || {};
        devWarning(!overlayProps.mode || overlayProps.mode === "vertical", "Dropdown", `mode="${overlayProps.mode}" is not supported for Dropdown's Menu.`);
        const {
          selectable = false,
          expandIcon = (_c2 = (_b2 = overlayNode.children) === null || _b2 === void 0 ? void 0 : _b2.expandIcon) === null || _c2 === void 0 ? void 0 : _c2.call(_b2)
        } = overlayProps;
        const overlayNodeExpandIcon = typeof expandIcon !== "undefined" && isValidElement(expandIcon) ? expandIcon : createVNode("span", {
          "class": `${prefixCls.value}-menu-submenu-arrow`
        }, [createVNode(RightOutlined, {
          "class": `${prefixCls.value}-menu-submenu-arrow-icon`
        }, null)]);
        const fixedModeOverlay = isValidElement(overlayNode) ? cloneElement(overlayNode, {
          mode: "vertical",
          selectable,
          expandIcon: () => overlayNodeExpandIcon
        }) : overlayNode;
        return fixedModeOverlay;
      };
      const placement = computed(() => {
        const placement2 = props2.placement;
        if (!placement2) {
          return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
        }
        if (placement2.includes("Center")) {
          const newPlacement = placement2.slice(0, placement2.indexOf("Center"));
          devWarning(!placement2.includes("Center"), "Dropdown", `You are using '${placement2}' placement in Dropdown, which is deprecated. Try to use '${newPlacement}' instead.`);
          return newPlacement;
        }
        return placement2;
      });
      const mergedVisible = computed(() => {
        return typeof props2.visible === "boolean" ? props2.visible : props2.open;
      });
      const handleVisibleChange = (val) => {
        emit2("update:visible", val);
        emit2("visibleChange", val);
        emit2("update:open", val);
        emit2("openChange", val);
      };
      return () => {
        var _a2, _b2;
        const {
          arrow,
          trigger: trigger2,
          disabled,
          overlayClassName
        } = props2;
        const child = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
        const dropdownTrigger = cloneElement(child, _extends$1({
          class: classNames((_b2 = child === null || child === void 0 ? void 0 : child.props) === null || _b2 === void 0 ? void 0 : _b2.class, {
            [`${prefixCls.value}-rtl`]: direction.value === "rtl"
          }, `${prefixCls.value}-trigger`)
        }, disabled ? {
          disabled
        } : {}));
        const overlayClassNameCustomized = classNames(overlayClassName, hashId.value, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        });
        const triggerActions = disabled ? [] : trigger2;
        let alignPoint2;
        if (triggerActions && triggerActions.includes("contextmenu")) {
          alignPoint2 = true;
        }
        const builtinPlacements = getPlacements({
          arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
          autoAdjustOverflow: true
        });
        const dropdownProps2 = omit$1(_extends$1(_extends$1(_extends$1({}, props2), attrs), {
          visible: mergedVisible.value,
          builtinPlacements,
          overlayClassName: overlayClassNameCustomized,
          arrow: !!arrow,
          alignPoint: alignPoint2,
          prefixCls: prefixCls.value,
          getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
          transitionName: transitionName2.value,
          trigger: triggerActions,
          onVisibleChange: handleVisibleChange,
          placement: placement.value
        }), ["overlay", "onUpdate:visible"]);
        return wrapSSR(createVNode(Dropdown$1, dropdownProps2, {
          default: () => [dropdownTrigger],
          overlay: renderOverlay
        }));
      };
    }
  });
  Dropdown.Button = DropdownButton;
  function shallowEqual(objA, objB, compare2, compareContext) {
    let ret = void 0;
    if (ret !== void 0) {
      return !!ret;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    for (let idx = 0; idx < keysA.length; idx++) {
      const key2 = keysA[idx];
      if (!bHasOwnProperty(key2)) {
        return false;
      }
      const valueA = objA[key2];
      const valueB = objB[key2];
      ret = void 0;
      if (ret === false || ret === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  }
  function shallowequal(value, other) {
    return shallowEqual(toRaw(value), toRaw(other));
  }
  const MenuContextKey = Symbol("menuContextKey");
  const useProvideMenu = (props2) => {
    provide(MenuContextKey, props2);
  };
  const useInjectMenu = () => {
    return inject(MenuContextKey);
  };
  const ForceRenderKey = Symbol("ForceRenderKey");
  const useProvideForceRender = (forceRender) => {
    provide(ForceRenderKey, forceRender);
  };
  const useInjectForceRender = () => {
    return inject(ForceRenderKey, false);
  };
  const MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey");
  const useProvideFirstLevel = (firstLevel) => {
    provide(MenuFirstLevelContextKey, firstLevel);
  };
  const useInjectFirstLevel = () => {
    return inject(MenuFirstLevelContextKey, true);
  };
  const MenuContextProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "MenuContextProvider",
    inheritAttrs: false,
    props: {
      mode: {
        type: String,
        default: void 0
      },
      overflowDisabled: {
        type: Boolean,
        default: void 0
      }
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const menuContext = useInjectMenu();
      const newContext = _extends$1({}, menuContext);
      if (props2.mode !== void 0) {
        newContext.mode = toRef(props2, "mode");
      }
      if (props2.overflowDisabled !== void 0) {
        newContext.overflowDisabled = toRef(props2, "overflowDisabled");
      }
      useProvideMenu(newContext);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const SiderCollapsedKey = Symbol("siderCollapsed");
  const OVERFLOW_KEY = "$$__vc-menu-more__key";
  const KeyPathContext = Symbol("KeyPathContext");
  const useInjectKeyPath = () => {
    return inject(KeyPathContext, {
      parentEventKeys: computed(() => []),
      parentKeys: computed(() => []),
      parentInfo: {}
    });
  };
  const useProvideKeyPath = (eventKey, key2, menuInfo) => {
    const {
      parentEventKeys,
      parentKeys
    } = useInjectKeyPath();
    const eventKeys = computed(() => [...parentEventKeys.value, eventKey]);
    const keys2 = computed(() => [...parentKeys.value, key2]);
    provide(KeyPathContext, {
      parentEventKeys: eventKeys,
      parentKeys: keys2,
      parentInfo: menuInfo
    });
    return keys2;
  };
  const measure = Symbol("measure");
  const PathContext = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    setup(_props, _ref) {
      let {
        slots
      } = _ref;
      provide(measure, true);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const useMeasure = () => {
    return inject(measure, false);
  };
  function useDirectionStyle(level) {
    const {
      mode,
      rtl: rtl2,
      inlineIndent
    } = useInjectMenu();
    return computed(() => mode.value !== "inline" ? null : rtl2.value ? {
      paddingRight: `${level.value * inlineIndent.value}px`
    } : {
      paddingLeft: `${level.value * inlineIndent.value}px`
    });
  }
  let indexGuid$3 = 0;
  const menuItemProps = () => ({
    id: String,
    role: String,
    disabled: Boolean,
    danger: Boolean,
    title: {
      type: [String, Boolean],
      default: void 0
    },
    icon: PropTypes.any,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function,
    onKeydown: Function,
    onFocus: Function,
    // Internal user prop
    originItemValue: objectType()
  });
  const MenuItem$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AMenuItem",
    inheritAttrs: false,
    props: menuItemProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2,
        attrs
      } = _ref;
      const instance = getCurrentInstance();
      const isMeasure = useMeasure();
      const key2 = typeof instance.vnode.key === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
      devWarning(typeof instance.vnode.key !== "symbol", "MenuItem", `MenuItem \`:key="${String(key2)}"\` not support Symbol type`);
      const eventKey = `menu_item_${++indexGuid$3}_$$_${key2}`;
      const {
        parentEventKeys,
        parentKeys
      } = useInjectKeyPath();
      const {
        prefixCls,
        activeKeys,
        disabled,
        changeActiveKeys,
        rtl: rtl2,
        inlineCollapsed,
        siderCollapsed,
        onItemClick,
        selectedKeys,
        registerMenuInfo,
        unRegisterMenuInfo
      } = useInjectMenu();
      const firstLevel = useInjectFirstLevel();
      const isActive = shallowRef(false);
      const keysPath = computed(() => {
        return [...parentKeys.value, key2];
      });
      const menuInfo = {
        eventKey,
        key: key2,
        parentEventKeys,
        parentKeys,
        isLeaf: true
      };
      registerMenuInfo(eventKey, menuInfo);
      onBeforeUnmount(() => {
        unRegisterMenuInfo(eventKey);
      });
      watch(activeKeys, () => {
        isActive.value = !!activeKeys.value.find((val) => val === key2);
      }, {
        immediate: true
      });
      const mergedDisabled = computed(() => disabled.value || props2.disabled);
      const selected = computed(() => selectedKeys.value.includes(key2));
      const classNames2 = computed(() => {
        const itemCls = `${prefixCls.value}-item`;
        return {
          [`${itemCls}`]: true,
          [`${itemCls}-danger`]: props2.danger,
          [`${itemCls}-active`]: isActive.value,
          [`${itemCls}-selected`]: selected.value,
          [`${itemCls}-disabled`]: mergedDisabled.value
        };
      });
      const getEventInfo = (e2) => {
        return {
          key: key2,
          eventKey,
          keyPath: keysPath.value,
          eventKeyPath: [...parentEventKeys.value, eventKey],
          domEvent: e2,
          item: _extends$1(_extends$1({}, props2), attrs)
        };
      };
      const onInternalClick = (e2) => {
        if (mergedDisabled.value) {
          return;
        }
        const info = getEventInfo(e2);
        emit2("click", e2);
        onItemClick(info);
      };
      const onMouseEnter = (event) => {
        if (!mergedDisabled.value) {
          changeActiveKeys(keysPath.value);
          emit2("mouseenter", event);
        }
      };
      const onMouseLeave = (event) => {
        if (!mergedDisabled.value) {
          changeActiveKeys([]);
          emit2("mouseleave", event);
        }
      };
      const onInternalKeyDown = (e2) => {
        emit2("keydown", e2);
        if (e2.which === KeyCode.ENTER) {
          const info = getEventInfo(e2);
          emit2("click", e2);
          onItemClick(info);
        }
      };
      const onInternalFocus = (e2) => {
        changeActiveKeys(keysPath.value);
        emit2("focus", e2);
      };
      const renderItemChildren = (icon, children) => {
        const wrapNode = createVNode("span", {
          "class": `${prefixCls.value}-title-content`
        }, [children]);
        if (!icon || isValidElement(children) && children.type === "span") {
          if (children && inlineCollapsed.value && firstLevel && typeof children === "string") {
            return createVNode("div", {
              "class": `${prefixCls.value}-inline-collapsed-noicon`
            }, [children.charAt(0)]);
          }
        }
        return wrapNode;
      };
      const directionStyle = useDirectionStyle(computed(() => keysPath.value.length));
      return () => {
        var _a2, _b2, _c2, _d, _e;
        if (isMeasure) return null;
        const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b2 = slots.title) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
        const children = flattenChildren((_c2 = slots.default) === null || _c2 === void 0 ? void 0 : _c2.call(slots));
        const childrenLength = children.length;
        let tooltipTitle = title;
        if (typeof title === "undefined") {
          tooltipTitle = firstLevel && childrenLength ? children : "";
        } else if (title === false) {
          tooltipTitle = "";
        }
        const tooltipProps2 = {
          title: tooltipTitle
        };
        if (!siderCollapsed.value && !inlineCollapsed.value) {
          tooltipProps2.title = null;
          tooltipProps2.open = false;
        }
        const optionRoleProps = {};
        if (props2.role === "option") {
          optionRoleProps["aria-selected"] = selected.value;
        }
        const icon = (_d = props2.icon) !== null && _d !== void 0 ? _d : (_e = slots.icon) === null || _e === void 0 ? void 0 : _e.call(slots, props2);
        return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, tooltipProps2), {}, {
          "placement": rtl2.value ? "left" : "right",
          "overlayClassName": `${prefixCls.value}-inline-collapsed-tooltip`
        }), {
          default: () => [createVNode(Overflow.Item, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "id": props2.id,
            "style": _extends$1(_extends$1({}, attrs.style || {}), directionStyle.value),
            "class": [classNames2.value, {
              [`${attrs.class}`]: !!attrs.class,
              [`${prefixCls.value}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
            }],
            "role": props2.role || "menuitem",
            "tabindex": props2.disabled ? null : -1,
            "data-menu-id": key2,
            "aria-disabled": props2.disabled
          }, optionRoleProps), {}, {
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "onClick": onInternalClick,
            "onKeydown": onInternalKeyDown,
            "onFocus": onInternalFocus,
            "title": typeof title === "string" ? title : void 0
          }), {
            default: () => [cloneElement(typeof icon === "function" ? icon(props2.originItemValue) : icon, {
              class: `${prefixCls.value}-item-icon`
            }, false), renderItemChildren(icon, children)]
          })]
        });
      };
    }
  });
  const autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  const placements = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow,
      offset: [0, -7]
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow,
      offset: [0, 7]
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow,
      offset: [-4, 0]
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow,
      offset: [4, 0]
    }
  };
  const placementsRtl = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow,
      offset: [0, -7]
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow,
      offset: [0, 7]
    },
    rightTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow,
      offset: [-4, 0]
    },
    leftTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow,
      offset: [4, 0]
    }
  };
  const popupPlacementMap = {
    horizontal: "bottomLeft",
    vertical: "rightTop",
    "vertical-left": "rightTop",
    "vertical-right": "leftTop"
  };
  const PopupTrigger = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "PopupTrigger",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      mode: String,
      visible: Boolean,
      // popup: React.ReactNode;
      popupClassName: String,
      popupOffset: Array,
      disabled: Boolean,
      onVisibleChange: Function
    },
    slots: Object,
    emits: ["visibleChange"],
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2
      } = _ref;
      const innerVisible = shallowRef(false);
      const {
        getPopupContainer,
        rtl: rtl2,
        subMenuOpenDelay,
        subMenuCloseDelay,
        builtinPlacements,
        triggerSubMenuAction,
        forceSubMenuRender,
        motion,
        defaultMotions,
        rootClassName
      } = useInjectMenu();
      const forceRender = useInjectForceRender();
      const placement = computed(() => rtl2.value ? _extends$1(_extends$1({}, placementsRtl), builtinPlacements.value) : _extends$1(_extends$1({}, placements), builtinPlacements.value));
      const popupPlacement = computed(() => popupPlacementMap[props2.mode]);
      const visibleRef = shallowRef();
      watch(() => props2.visible, (visible) => {
        wrapperRaf.cancel(visibleRef.value);
        visibleRef.value = wrapperRaf(() => {
          innerVisible.value = visible;
        });
      }, {
        immediate: true
      });
      onBeforeUnmount(() => {
        wrapperRaf.cancel(visibleRef.value);
      });
      const onVisibleChange = (visible) => {
        emit2("visibleChange", visible);
      };
      const mergedMotion = computed(() => {
        var _a2, _b2;
        const m2 = motion.value || ((_a2 = defaultMotions.value) === null || _a2 === void 0 ? void 0 : _a2[props2.mode]) || ((_b2 = defaultMotions.value) === null || _b2 === void 0 ? void 0 : _b2.other);
        const res = typeof m2 === "function" ? m2() : m2;
        return res ? getTransitionProps(res.name, {
          css: true
        }) : void 0;
      });
      return () => {
        const {
          prefixCls,
          popupClassName,
          mode,
          popupOffset,
          disabled
        } = props2;
        return createVNode(Trigger, {
          "prefixCls": prefixCls,
          "popupClassName": classNames(`${prefixCls}-popup`, {
            [`${prefixCls}-rtl`]: rtl2.value
          }, popupClassName, rootClassName.value),
          "stretch": mode === "horizontal" ? "minWidth" : null,
          "getPopupContainer": getPopupContainer.value,
          "builtinPlacements": placement.value,
          "popupPlacement": popupPlacement.value,
          "popupVisible": innerVisible.value,
          "popupAlign": popupOffset && {
            offset: popupOffset
          },
          "action": disabled ? [] : [triggerSubMenuAction.value],
          "mouseEnterDelay": subMenuOpenDelay.value,
          "mouseLeaveDelay": subMenuCloseDelay.value,
          "onPopupVisibleChange": onVisibleChange,
          "forceRender": forceRender || forceSubMenuRender.value,
          "popupAnimation": mergedMotion.value
        }, {
          popup: slots.popup,
          default: slots.default
        });
      };
    }
  });
  const InternalSubMenuList = (_props, _ref) => {
    let {
      slots,
      attrs
    } = _ref;
    var _a2;
    const {
      prefixCls,
      mode
    } = useInjectMenu();
    return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
      "class": classNames(prefixCls.value, `${prefixCls.value}-sub`, `${prefixCls.value}-${mode.value === "inline" ? "inline" : "vertical"}`),
      "data-menu-list": true
    }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
  };
  InternalSubMenuList.displayName = "SubMenuList";
  const InlineSubMenuList = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "InlineSubMenuList",
    inheritAttrs: false,
    props: {
      id: String,
      open: Boolean,
      keyPath: Array
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const fixedMode = computed(() => "inline");
      const {
        motion,
        mode,
        defaultMotions
      } = useInjectMenu();
      const sameModeRef = computed(() => mode.value === fixedMode.value);
      const destroy = ref(!sameModeRef.value);
      const mergedOpen = computed(() => sameModeRef.value ? props2.open : false);
      watch(mode, () => {
        if (sameModeRef.value) {
          destroy.value = false;
        }
      }, {
        flush: "post"
      });
      const mergedMotion = computed(() => {
        var _a2, _b2;
        const m2 = motion.value || ((_a2 = defaultMotions.value) === null || _a2 === void 0 ? void 0 : _a2[fixedMode.value]) || ((_b2 = defaultMotions.value) === null || _b2 === void 0 ? void 0 : _b2.other);
        const res = typeof m2 === "function" ? m2() : m2;
        return _extends$1(_extends$1({}, res), {
          appear: props2.keyPath.length <= 1
        });
      });
      return () => {
        var _a2;
        if (destroy.value) {
          return null;
        }
        return createVNode(MenuContextProvider, {
          "mode": fixedMode.value
        }, {
          default: () => [createVNode(Transition, mergedMotion.value, {
            default: () => [withDirectives(createVNode(InternalSubMenuList, {
              "id": props2.id
            }, {
              default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
            }), [[vShow, mergedOpen.value]])]
          })]
        });
      };
    }
  });
  let indexGuid$2 = 0;
  const subMenuProps = () => ({
    icon: PropTypes.any,
    title: PropTypes.any,
    disabled: Boolean,
    level: Number,
    popupClassName: String,
    popupOffset: Array,
    internalPopupClose: Boolean,
    eventKey: String,
    expandIcon: Function,
    theme: String,
    onMouseenter: Function,
    onMouseleave: Function,
    onTitleClick: Function,
    // Internal user prop
    originItemValue: objectType()
  });
  const SubMenu$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ASubMenu",
    inheritAttrs: false,
    props: subMenuProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        emit: emit2
      } = _ref;
      var _a2, _b2;
      useProvideFirstLevel(false);
      const isMeasure = useMeasure();
      const instance = getCurrentInstance();
      const vnodeKey = typeof instance.vnode.key === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
      devWarning(typeof instance.vnode.key !== "symbol", "SubMenu", `SubMenu \`:key="${String(vnodeKey)}"\` not support Symbol type`);
      const key2 = isValid$2(vnodeKey) ? vnodeKey : `sub_menu_${++indexGuid$2}_$$_not_set_key`;
      const eventKey = (_a2 = props2.eventKey) !== null && _a2 !== void 0 ? _a2 : isValid$2(vnodeKey) ? `sub_menu_${++indexGuid$2}_$$_${vnodeKey}` : key2;
      const {
        parentEventKeys,
        parentInfo,
        parentKeys
      } = useInjectKeyPath();
      const keysPath = computed(() => [...parentKeys.value, key2]);
      const childrenEventKeys = shallowRef([]);
      const menuInfo = {
        eventKey,
        key: key2,
        parentEventKeys,
        childrenEventKeys,
        parentKeys
      };
      (_b2 = parentInfo.childrenEventKeys) === null || _b2 === void 0 ? void 0 : _b2.value.push(eventKey);
      onBeforeUnmount(() => {
        var _a3;
        if (parentInfo.childrenEventKeys) {
          parentInfo.childrenEventKeys.value = (_a3 = parentInfo.childrenEventKeys) === null || _a3 === void 0 ? void 0 : _a3.value.filter((k2) => k2 != eventKey);
        }
      });
      useProvideKeyPath(eventKey, key2, menuInfo);
      const {
        prefixCls,
        activeKeys,
        disabled: contextDisabled,
        changeActiveKeys,
        mode,
        inlineCollapsed,
        openKeys,
        overflowDisabled,
        onOpenChange,
        registerMenuInfo,
        unRegisterMenuInfo,
        selectedSubMenuKeys,
        expandIcon: menuExpandIcon,
        theme: theme2
      } = useInjectMenu();
      const hasKey = vnodeKey !== void 0 && vnodeKey !== null;
      const forceRender = !isMeasure && (useInjectForceRender() || !hasKey);
      useProvideForceRender(forceRender);
      if (isMeasure && hasKey || !isMeasure && !hasKey || forceRender) {
        registerMenuInfo(eventKey, menuInfo);
        onBeforeUnmount(() => {
          unRegisterMenuInfo(eventKey);
        });
      }
      const subMenuPrefixCls = computed(() => `${prefixCls.value}-submenu`);
      const mergedDisabled = computed(() => contextDisabled.value || props2.disabled);
      const elementRef = shallowRef();
      const popupRef = shallowRef();
      const originOpen = computed(() => openKeys.value.includes(key2));
      const open2 = computed(() => !overflowDisabled.value && originOpen.value);
      const childrenSelected = computed(() => {
        return selectedSubMenuKeys.value.includes(key2);
      });
      const isActive = shallowRef(false);
      watch(activeKeys, () => {
        isActive.value = !!activeKeys.value.find((val) => val === key2);
      }, {
        immediate: true
      });
      const onInternalTitleClick = (e2) => {
        if (mergedDisabled.value) {
          return;
        }
        emit2("titleClick", e2, key2);
        if (mode.value === "inline") {
          onOpenChange(key2, !originOpen.value);
        }
      };
      const onMouseEnter = (event) => {
        if (!mergedDisabled.value) {
          changeActiveKeys(keysPath.value);
          emit2("mouseenter", event);
        }
      };
      const onMouseLeave = (event) => {
        if (!mergedDisabled.value) {
          changeActiveKeys([]);
          emit2("mouseleave", event);
        }
      };
      const directionStyle = useDirectionStyle(computed(() => keysPath.value.length));
      const onPopupVisibleChange = (newVisible) => {
        if (mode.value !== "inline") {
          onOpenChange(key2, newVisible);
        }
      };
      const onInternalFocus = () => {
        changeActiveKeys(keysPath.value);
      };
      const popupId = eventKey && `${eventKey}-popup`;
      const popupClassName = computed(() => classNames(prefixCls.value, `${prefixCls.value}-${props2.theme || theme2.value}`, props2.popupClassName));
      const renderTitle = (title, icon) => {
        if (!icon) {
          return inlineCollapsed.value && !parentKeys.value.length && title && typeof title === "string" ? createVNode("div", {
            "class": `${prefixCls.value}-inline-collapsed-noicon`
          }, [title.charAt(0)]) : createVNode("span", {
            "class": `${prefixCls.value}-title-content`
          }, [title]);
        }
        const titleIsSpan = isValidElement(title) && title.type === "span";
        return createVNode(Fragment, null, [cloneElement(typeof icon === "function" ? icon(props2.originItemValue) : icon, {
          class: `${prefixCls.value}-item-icon`
        }, false), titleIsSpan ? title : createVNode("span", {
          "class": `${prefixCls.value}-title-content`
        }, [title])]);
      };
      const triggerModeRef = computed(() => {
        return mode.value !== "inline" && keysPath.value.length > 1 ? "vertical" : mode.value;
      });
      const renderMode = computed(() => mode.value === "horizontal" ? "vertical" : mode.value);
      const subMenuTriggerModeRef = computed(() => triggerModeRef.value === "horizontal" ? "vertical" : triggerModeRef.value);
      const baseTitleNode = () => {
        var _a3, _b3;
        const subMenuPrefixClsValue = subMenuPrefixCls.value;
        const icon = (_a3 = props2.icon) !== null && _a3 !== void 0 ? _a3 : (_b3 = slots.icon) === null || _b3 === void 0 ? void 0 : _b3.call(slots, props2);
        const expandIcon = props2.expandIcon || slots.expandIcon || menuExpandIcon.value;
        const title = renderTitle(getPropsSlot(slots, props2, "title"), icon);
        return createVNode("div", {
          "style": directionStyle.value,
          "class": `${subMenuPrefixClsValue}-title`,
          "tabindex": mergedDisabled.value ? null : -1,
          "ref": elementRef,
          "title": typeof title === "string" ? title : null,
          "data-menu-id": key2,
          "aria-expanded": open2.value,
          "aria-haspopup": true,
          "aria-controls": popupId,
          "aria-disabled": mergedDisabled.value,
          "onClick": onInternalTitleClick,
          "onFocus": onInternalFocus
        }, [title, mode.value !== "horizontal" && expandIcon ? expandIcon(_extends$1(_extends$1({}, props2), {
          isOpen: open2.value
        })) : createVNode("i", {
          "class": `${subMenuPrefixClsValue}-arrow`
        }, null)]);
      };
      return () => {
        var _a3;
        if (isMeasure) {
          if (!hasKey) {
            return null;
          }
          return (_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots);
        }
        const subMenuPrefixClsValue = subMenuPrefixCls.value;
        let titleNode = () => null;
        if (!overflowDisabled.value && mode.value !== "inline") {
          const popupOffset = mode.value === "horizontal" ? [0, 8] : [10, 0];
          titleNode = () => createVNode(PopupTrigger, {
            "mode": triggerModeRef.value,
            "prefixCls": subMenuPrefixClsValue,
            "visible": !props2.internalPopupClose && open2.value,
            "popupClassName": popupClassName.value,
            "popupOffset": props2.popupOffset || popupOffset,
            "disabled": mergedDisabled.value,
            "onVisibleChange": onPopupVisibleChange
          }, {
            default: () => [baseTitleNode()],
            popup: () => createVNode(MenuContextProvider, {
              "mode": subMenuTriggerModeRef.value
            }, {
              default: () => [createVNode(InternalSubMenuList, {
                "id": popupId,
                "ref": popupRef
              }, {
                default: slots.default
              })]
            })
          });
        } else {
          titleNode = () => createVNode(PopupTrigger, null, {
            default: baseTitleNode
          });
        }
        return createVNode(MenuContextProvider, {
          "mode": renderMode.value
        }, {
          default: () => [createVNode(Overflow.Item, _objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "role": "none",
            "class": classNames(subMenuPrefixClsValue, `${subMenuPrefixClsValue}-${mode.value}`, attrs.class, {
              [`${subMenuPrefixClsValue}-open`]: open2.value,
              [`${subMenuPrefixClsValue}-active`]: isActive.value,
              [`${subMenuPrefixClsValue}-selected`]: childrenSelected.value,
              [`${subMenuPrefixClsValue}-disabled`]: mergedDisabled.value
            }),
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "data-submenu-id": key2
          }), {
            default: () => {
              return createVNode(Fragment, null, [titleNode(), !overflowDisabled.value && createVNode(InlineSubMenuList, {
                "id": popupId,
                "open": open2.value,
                "keyPath": keysPath.value
              }, {
                default: slots.default
              })]);
            }
          })]
        });
      };
    }
  });
  function hasClass(node2, className) {
    if (node2.classList) {
      return node2.classList.contains(className);
    }
    const originClass = node2.className;
    return ` ${originClass} `.indexOf(` ${className} `) > -1;
  }
  function addClass(node2, className) {
    if (node2.classList) {
      node2.classList.add(className);
    } else {
      if (!hasClass(node2, className)) {
        node2.className = `${node2.className} ${className}`;
      }
    }
  }
  function removeClass(node2, className) {
    if (node2.classList) {
      node2.classList.remove(className);
    } else {
      if (hasClass(node2, className)) {
        const originClass = node2.className;
        node2.className = ` ${originClass} `.replace(` ${className} `, " ");
      }
    }
  }
  const collapseMotion = function() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
    let appear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return {
      name,
      appear,
      css: true,
      onBeforeEnter: (node2) => {
        node2.style.height = "0px";
        node2.style.opacity = "0";
        addClass(node2, name);
      },
      onEnter: (node2) => {
        nextTick(() => {
          node2.style.height = `${node2.scrollHeight}px`;
          node2.style.opacity = "1";
        });
      },
      onAfterEnter: (node2) => {
        if (node2) {
          removeClass(node2, name);
          node2.style.height = null;
          node2.style.opacity = null;
        }
      },
      onBeforeLeave: (node2) => {
        addClass(node2, name);
        node2.style.height = `${node2.offsetHeight}px`;
        node2.style.opacity = null;
      },
      onLeave: (node2) => {
        setTimeout(() => {
          node2.style.height = "0px";
          node2.style.opacity = "0";
        });
      },
      onAfterLeave: (node2) => {
        if (node2) {
          removeClass(node2, name);
          if (node2.style) {
            node2.style.height = null;
            node2.style.opacity = null;
          }
        }
      }
    };
  };
  const menuItemGroupProps = () => ({
    title: PropTypes.any,
    // Internal user prop
    originItemValue: objectType()
  });
  const ItemGroup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AMenuItemGroup",
    inheritAttrs: false,
    props: menuItemGroupProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls
      } = useInjectMenu();
      const groupPrefixCls = computed(() => `${prefixCls.value}-item-group`);
      const isMeasure = useMeasure();
      return () => {
        var _a2, _b2;
        if (isMeasure) return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        return createVNode("li", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "onClick": (e2) => e2.stopPropagation(),
          "class": groupPrefixCls.value
        }), [createVNode("div", {
          "title": typeof props2.title === "string" ? props2.title : void 0,
          "class": `${groupPrefixCls.value}-title`
        }, [getPropsSlot(slots, props2, "title")]), createVNode("ul", {
          "class": `${groupPrefixCls.value}-list`
        }, [(_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots)])]);
      };
    }
  });
  const menuDividerProps = () => ({
    prefixCls: String,
    dashed: Boolean
  });
  const Divider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AMenuDivider",
    props: menuDividerProps(),
    setup(props2) {
      const {
        prefixCls
      } = useInjectMenu();
      const cls = computed(() => {
        return {
          [`${prefixCls.value}-item-divider`]: true,
          [`${prefixCls.value}-item-divider-dashed`]: !!props2.dashed
        };
      });
      return () => {
        return createVNode("li", {
          "class": cls.value
        }, null);
      };
    }
  });
  var __rest$o = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function convertItemsToNodes(list2, store, parentMenuInfo) {
    return (list2 || []).map((opt, index2) => {
      if (opt && typeof opt === "object") {
        const _a2 = opt, {
          label,
          children,
          key: key2,
          type
        } = _a2, restProps = __rest$o(_a2, ["label", "children", "key", "type"]);
        const mergedKey = key2 !== null && key2 !== void 0 ? key2 : `tmp-${index2}`;
        const parentKeys = parentMenuInfo ? parentMenuInfo.parentKeys.slice() : [];
        const childrenEventKeys = [];
        const menuInfo = {
          eventKey: mergedKey,
          key: mergedKey,
          parentEventKeys: ref(parentKeys),
          parentKeys: ref(parentKeys),
          childrenEventKeys: ref(childrenEventKeys),
          isLeaf: false
        };
        if (children || type === "group") {
          if (type === "group") {
            const childrenNodes2 = convertItemsToNodes(children, store, parentMenuInfo);
            return createVNode(ItemGroup, _objectSpread2$1(_objectSpread2$1({
              "key": mergedKey
            }, restProps), {}, {
              "title": label,
              "originItemValue": opt
            }), {
              default: () => [childrenNodes2]
            });
          }
          store.set(mergedKey, menuInfo);
          if (parentMenuInfo) {
            parentMenuInfo.childrenEventKeys.push(mergedKey);
          }
          const childrenNodes = convertItemsToNodes(children, store, {
            childrenEventKeys,
            parentKeys: [].concat(parentKeys, mergedKey)
          });
          return createVNode(SubMenu$1, _objectSpread2$1(_objectSpread2$1({
            "key": mergedKey
          }, restProps), {}, {
            "title": label,
            "originItemValue": opt
          }), {
            default: () => [childrenNodes]
          });
        }
        if (type === "divider") {
          return createVNode(Divider, _objectSpread2$1({
            "key": mergedKey
          }, restProps), null);
        }
        menuInfo.isLeaf = true;
        store.set(mergedKey, menuInfo);
        return createVNode(MenuItem$1, _objectSpread2$1(_objectSpread2$1({
          "key": mergedKey
        }, restProps), {}, {
          "originItemValue": opt
        }), {
          default: () => [label]
        });
      }
      return null;
    }).filter((opt) => opt);
  }
  function useItems(props2) {
    const itemsNodes = shallowRef([]);
    const hasItmes = shallowRef(false);
    const store = shallowRef(/* @__PURE__ */ new Map());
    watch(() => props2.items, () => {
      const newStore = /* @__PURE__ */ new Map();
      hasItmes.value = false;
      if (props2.items) {
        hasItmes.value = true;
        itemsNodes.value = convertItemsToNodes(props2.items, newStore);
      } else {
        itemsNodes.value = void 0;
      }
      store.value = newStore;
    }, {
      immediate: true,
      deep: true
    });
    return {
      itemsNodes,
      store,
      hasItmes
    };
  }
  const getHorizontalStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      menuHorizontalHeight,
      colorSplit,
      lineWidth,
      lineType,
      menuItemPaddingInline
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        lineHeight: `${menuHorizontalHeight}px`,
        border: 0,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        boxShadow: "none",
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          content: '"\\20"'
        },
        // ======================= Item =======================
        [`${componentCls}-item, ${componentCls}-submenu`]: {
          position: "relative",
          display: "inline-block",
          verticalAlign: "bottom",
          paddingInline: menuItemPaddingInline
        },
        [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
          backgroundColor: "transparent"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
        },
        // ===================== Sub Menu =====================
        [`${componentCls}-submenu-arrow`]: {
          display: "none"
        }
      }
    };
  };
  const getRTLStyle = (_ref) => {
    let {
      componentCls,
      menuArrowOffset
    } = _ref;
    return {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-submenu-rtl`]: {
        transformOrigin: "100% 0"
      },
      // Vertical Arrow
      [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
        [`${componentCls}-submenu-arrow`]: {
          "&::before": {
            transform: `rotate(-45deg) translateY(-${menuArrowOffset})`
          },
          "&::after": {
            transform: `rotate(45deg) translateY(${menuArrowOffset})`
          }
        }
      }
    };
  };
  const accessibilityFocus = (token2) => _extends$1({}, genFocusOutline(token2));
  const getThemeStyle = (token2, themeSuffix) => {
    const {
      componentCls,
      colorItemText,
      colorItemTextSelected,
      colorGroupTitle,
      colorItemBg,
      colorSubItemBg,
      colorItemBgSelected,
      colorActiveBarHeight,
      colorActiveBarWidth,
      colorActiveBarBorderSize,
      motionDurationSlow,
      motionEaseInOut,
      motionEaseOut,
      menuItemPaddingInline,
      motionDurationMid,
      colorItemTextHover,
      lineType,
      colorSplit,
      // Disabled
      colorItemTextDisabled,
      // Danger
      colorDangerItemText,
      colorDangerItemTextHover,
      colorDangerItemTextSelected,
      colorDangerItemBgActive,
      colorDangerItemBgSelected,
      colorItemBgHover,
      menuSubMenuBg,
      // Horizontal
      colorItemTextSelectedHorizontal,
      colorItemBgSelectedHorizontal
    } = token2;
    return {
      [`${componentCls}-${themeSuffix}`]: {
        color: colorItemText,
        background: colorItemBg,
        [`&${componentCls}-root:focus-visible`]: _extends$1({}, accessibilityFocus(token2)),
        // ======================== Item ========================
        [`${componentCls}-item-group-title`]: {
          color: colorGroupTitle
        },
        [`${componentCls}-submenu-selected`]: {
          [`> ${componentCls}-submenu-title`]: {
            color: colorItemTextSelected
          }
        },
        // Disabled
        [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          color: `${colorItemTextDisabled} !important`
        },
        // Hover
        [`${componentCls}-item:hover, ${componentCls}-submenu-title:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: colorItemTextHover
          }
        },
        [`&:not(${componentCls}-horizontal)`]: {
          [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
            "&:hover": {
              backgroundColor: colorItemBgHover
            },
            "&:active": {
              backgroundColor: colorItemBgSelected
            }
          },
          [`${componentCls}-submenu-title`]: {
            "&:hover": {
              backgroundColor: colorItemBgHover
            },
            "&:active": {
              backgroundColor: colorItemBgSelected
            }
          }
        },
        // Danger - only Item has
        [`${componentCls}-item-danger`]: {
          color: colorDangerItemText,
          [`&${componentCls}-item:hover`]: {
            [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
              color: colorDangerItemTextHover
            }
          },
          [`&${componentCls}-item:active`]: {
            background: colorDangerItemBgActive
          }
        },
        [`${componentCls}-item a`]: {
          "&, &:hover": {
            color: "inherit"
          }
        },
        [`${componentCls}-item-selected`]: {
          color: colorItemTextSelected,
          // Danger
          [`&${componentCls}-item-danger`]: {
            color: colorDangerItemTextSelected
          },
          [`a, a:hover`]: {
            color: "inherit"
          }
        },
        [`& ${componentCls}-item-selected`]: {
          backgroundColor: colorItemBgSelected,
          // Danger
          [`&${componentCls}-item-danger`]: {
            backgroundColor: colorDangerItemBgSelected
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          [`&:not(${componentCls}-item-disabled):focus-visible`]: _extends$1({}, accessibilityFocus(token2))
        },
        [`&${componentCls}-submenu > ${componentCls}`]: {
          backgroundColor: menuSubMenuBg
        },
        [`&${componentCls}-popup > ${componentCls}`]: {
          backgroundColor: colorItemBg
        },
        // ====================== Horizontal ======================
        [`&${componentCls}-horizontal`]: _extends$1(_extends$1({}, themeSuffix === "dark" ? {
          borderBottom: 0
        } : {}), {
          [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
            top: colorActiveBarBorderSize,
            marginTop: -colorActiveBarBorderSize,
            marginBottom: 0,
            borderRadius: 0,
            "&::after": {
              position: "absolute",
              insetInline: menuItemPaddingInline,
              bottom: 0,
              borderBottom: `${colorActiveBarHeight}px solid transparent`,
              transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
              content: '""'
            },
            [`&:hover, &-active, &-open`]: {
              "&::after": {
                borderBottomWidth: colorActiveBarHeight,
                borderBottomColor: colorItemTextSelectedHorizontal
              }
            },
            [`&-selected`]: {
              color: colorItemTextSelectedHorizontal,
              backgroundColor: colorItemBgSelectedHorizontal,
              "&::after": {
                borderBottomWidth: colorActiveBarHeight,
                borderBottomColor: colorItemTextSelectedHorizontal
              }
            }
          }
        }),
        // ================== Inline & Vertical ===================
        //
        [`&${componentCls}-root`]: {
          [`&${componentCls}-inline, &${componentCls}-vertical`]: {
            borderInlineEnd: `${colorActiveBarBorderSize}px ${lineType} ${colorSplit}`
          }
        },
        // ======================== Inline ========================
        [`&${componentCls}-inline`]: {
          // Sub
          [`${componentCls}-sub${componentCls}-inline`]: {
            background: colorSubItemBg
          },
          // Item
          [`${componentCls}-item, ${componentCls}-submenu-title`]: colorActiveBarBorderSize && colorActiveBarWidth ? {
            width: `calc(100% + ${colorActiveBarBorderSize}px)`
          } : {},
          [`${componentCls}-item`]: {
            position: "relative",
            "&::after": {
              position: "absolute",
              insetBlock: 0,
              insetInlineEnd: 0,
              borderInlineEnd: `${colorActiveBarWidth}px solid ${colorItemTextSelected}`,
              transform: "scaleY(0.0001)",
              opacity: 0,
              transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
              content: '""'
            },
            // Danger
            [`&${componentCls}-item-danger`]: {
              "&::after": {
                borderInlineEndColor: colorDangerItemTextSelected
              }
            }
          },
          [`${componentCls}-selected, ${componentCls}-item-selected`]: {
            "&::after": {
              transform: "scaleY(1)",
              opacity: 1,
              transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
            }
          }
        }
      }
    };
  };
  const getVerticalInlineStyle = (token2) => {
    const {
      componentCls,
      menuItemHeight,
      itemMarginInline,
      padding,
      menuArrowSize,
      marginXS,
      marginXXS
    } = token2;
    const paddingWithArrow = padding + menuArrowSize + marginXS;
    return {
      [`${componentCls}-item`]: {
        position: "relative"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        height: menuItemHeight,
        lineHeight: `${menuItemHeight}px`,
        paddingInline: padding,
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginInline: itemMarginInline,
        marginBlock: marginXXS,
        width: `calc(100% - ${itemMarginInline * 2}px)`
      },
      // disable margin collapsed
      [`${componentCls}-submenu`]: {
        paddingBottom: 0.02
      },
      [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
        height: menuItemHeight,
        lineHeight: `${menuItemHeight}px`
      },
      [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
        paddingInlineEnd: paddingWithArrow
      }
    };
  };
  const getVerticalStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      menuItemHeight,
      colorTextLightSolid,
      dropdownWidth,
      controlHeightLG,
      motionDurationMid,
      motionEaseOut,
      paddingXL,
      fontSizeSM,
      fontSizeLG,
      motionDurationSlow,
      paddingXS,
      boxShadowSecondary
    } = token2;
    const inlineItemStyle = {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`,
      listStylePosition: "inside",
      listStyleType: "disc"
    };
    return [
      {
        [componentCls]: {
          [`&-inline, &-vertical`]: _extends$1({
            [`&${componentCls}-root`]: {
              boxShadow: "none"
            }
          }, getVerticalInlineStyle(token2))
        },
        [`${componentCls}-submenu-popup`]: {
          [`${componentCls}-vertical`]: _extends$1(_extends$1({}, getVerticalInlineStyle(token2)), {
            boxShadow: boxShadowSecondary
          })
        }
      },
      // Vertical only
      {
        [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
          minWidth: dropdownWidth,
          maxHeight: `calc(100vh - ${controlHeightLG * 2.5}px)`,
          padding: "0",
          overflow: "hidden",
          borderInlineEnd: 0,
          // https://github.com/ant-design/ant-design/issues/22244
          // https://github.com/ant-design/ant-design/issues/26812
          "&:not([class*='-active'])": {
            overflowX: "hidden",
            overflowY: "auto"
          }
        }
      },
      // Inline Only
      {
        [`${componentCls}-inline`]: {
          width: "100%",
          // Motion enhance for first level
          [`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              display: "flex",
              alignItems: "center",
              transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
              [`> ${componentCls}-title-content`]: {
                flex: "auto",
                minWidth: 0,
                overflow: "hidden",
                textOverflow: "ellipsis"
              },
              "> *": {
                flex: "none"
              }
            }
          },
          // >>>>> Sub
          [`${componentCls}-sub${componentCls}-inline`]: {
            padding: 0,
            border: 0,
            borderRadius: 0,
            boxShadow: "none",
            [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
            [`& ${componentCls}-item-group-title`]: {
              paddingInlineStart: paddingXL
            }
          },
          // >>>>> Item
          [`${componentCls}-item`]: inlineItemStyle
        }
      },
      // Inline Collapse Only
      {
        [`${componentCls}-inline-collapsed`]: {
          width: menuItemHeight * 2,
          [`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
              [`> ${componentCls}-inline-collapsed-noicon`]: {
                fontSize: fontSizeLG,
                textAlign: "center"
              }
            }
          },
          [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
            insetInlineStart: 0,
            paddingInline: `calc(50% - ${fontSizeSM}px)`,
            textOverflow: "clip",
            [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
              opacity: 0
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              margin: 0,
              fontSize: fontSizeLG,
              lineHeight: `${menuItemHeight}px`,
              "+ span": {
                display: "inline-block",
                opacity: 0
              }
            }
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "inline-block"
          },
          "&-tooltip": {
            pointerEvents: "none",
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "none"
            },
            "a, a:hover": {
              color: colorTextLightSolid
            }
          },
          [`${componentCls}-item-group-title`]: _extends$1(_extends$1({}, textEllipsis), {
            paddingInline: paddingXS
          })
        }
      }
    ];
  };
  const genMenuItemStyle = (token2) => {
    const {
      componentCls,
      fontSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      motionEaseOut,
      iconCls,
      controlHeightSM
    } = token2;
    return {
      // >>>>> Item
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        position: "relative",
        display: "block",
        margin: 0,
        whiteSpace: "nowrap",
        cursor: "pointer",
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
        [`${componentCls}-item-icon, ${iconCls}`]: {
          minWidth: fontSize,
          fontSize,
          transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
          "+ span": {
            marginInlineStart: controlHeightSM - fontSize,
            opacity: 1,
            transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
          }
        },
        [`${componentCls}-item-icon`]: _extends$1({}, resetIcon()),
        [`&${componentCls}-item-only-child`]: {
          [`> ${iconCls}, > ${componentCls}-item-icon`]: {
            marginInlineEnd: 0
          }
        }
      },
      // Disabled state sets text to gray and nukes hover/tab effects
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        background: "none !important",
        cursor: "not-allowed",
        "&::after": {
          borderColor: "transparent !important"
        },
        a: {
          color: "inherit !important"
        },
        [`> ${componentCls}-submenu-title`]: {
          color: "inherit !important",
          cursor: "not-allowed"
        }
      }
    };
  };
  const genSubMenuArrowStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionEaseInOut,
      borderRadius,
      menuArrowSize,
      menuArrowOffset
    } = token2;
    return {
      [`${componentCls}-submenu`]: {
        [`&-expand-icon, &-arrow`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: token2.margin,
          width: menuArrowSize,
          color: "currentcolor",
          transform: "translateY(-50%)",
          transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
        },
        "&-arrow": {
          // →
          "&::before, &::after": {
            position: "absolute",
            width: menuArrowSize * 0.6,
            height: menuArrowSize * 0.15,
            backgroundColor: "currentcolor",
            borderRadius,
            transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
            content: '""'
          },
          "&::before": {
            transform: `rotate(45deg) translateY(-${menuArrowOffset})`
          },
          "&::after": {
            transform: `rotate(-45deg) translateY(${menuArrowOffset})`
          }
        }
      }
    };
  };
  const getBaseStyle = (token2) => {
    const {
      antCls,
      componentCls,
      fontSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      lineHeight,
      paddingXS,
      padding,
      colorSplit,
      lineWidth,
      zIndexPopup,
      borderRadiusLG,
      radiusSubMenuItem,
      menuArrowSize,
      menuArrowOffset,
      lineType,
      menuPanelMaskInset
    } = token2;
    return [
      // Misc
      {
        "": {
          [`${componentCls}`]: _extends$1(_extends$1({}, clearFix()), {
            // Hidden
            [`&-hidden`]: {
              display: "none"
            }
          })
        },
        [`${componentCls}-submenu-hidden`]: {
          display: "none"
        }
      },
      {
        [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), clearFix()), {
          marginBottom: 0,
          paddingInlineStart: 0,
          // Override default ul/ol
          fontSize,
          lineHeight: 0,
          listStyle: "none",
          outline: "none",
          transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
          [`ul, ol`]: {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          // Overflow ellipsis
          [`&-overflow`]: {
            display: "flex",
            [`${componentCls}-item`]: {
              flex: "none"
            }
          },
          [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
            borderRadius: token2.radiusItem
          },
          [`${componentCls}-item-group-title`]: {
            padding: `${paddingXS}px ${padding}px`,
            fontSize,
            lineHeight,
            transition: `all ${motionDurationSlow}`
          },
          [`&-horizontal ${componentCls}-submenu`]: {
            transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
            transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-submenu ${componentCls}-sub`]: {
            cursor: "initial",
            transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
          },
          [`${componentCls}-title-content`]: {
            transition: `color ${motionDurationSlow}`
          },
          [`${componentCls}-item a`]: {
            "&::before": {
              position: "absolute",
              inset: 0,
              backgroundColor: "transparent",
              content: '""'
            }
          },
          // Removed a Badge related style seems it's safe
          // https://github.com/ant-design/ant-design/issues/19809
          // >>>>> Divider
          [`${componentCls}-item-divider`]: {
            overflow: "hidden",
            lineHeight: 0,
            borderColor: colorSplit,
            borderStyle: lineType,
            borderWidth: 0,
            borderTopWidth: lineWidth,
            marginBlock: lineWidth,
            padding: 0,
            "&-dashed": {
              borderStyle: "dashed"
            }
          }
        }), genMenuItemStyle(token2)), {
          [`${componentCls}-item-group`]: {
            [`${componentCls}-item-group-list`]: {
              margin: 0,
              padding: 0,
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                paddingInline: `${fontSize * 2}px ${padding}px`
              }
            }
          },
          // ======================= Sub Menu =======================
          "&-submenu": {
            "&-popup": {
              position: "absolute",
              zIndex: zIndexPopup,
              background: "transparent",
              borderRadius: borderRadiusLG,
              boxShadow: "none",
              transformOrigin: "0 0",
              // https://github.com/ant-design/ant-design/issues/13955
              "&::before": {
                position: "absolute",
                inset: `${menuPanelMaskInset}px 0 0`,
                zIndex: -1,
                width: "100%",
                height: "100%",
                opacity: 0,
                content: '""'
              }
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&-placement-rightTop::before": {
              top: 0,
              insetInlineStart: menuPanelMaskInset
            },
            [`> ${componentCls}`]: _extends$1(_extends$1(_extends$1({
              borderRadius: borderRadiusLG
            }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
              [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                borderRadius: radiusSubMenuItem
              },
              [`${componentCls}-submenu-title::after`]: {
                transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
              }
            })
          }
        }), genSubMenuArrowStyle(token2)), {
          [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
            // ↓
            "&::before": {
              transform: `rotate(-45deg) translateX(${menuArrowOffset})`
            },
            "&::after": {
              transform: `rotate(45deg) translateX(-${menuArrowOffset})`
            }
          },
          [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
            // ↑
            transform: `translateY(-${menuArrowSize * 0.2}px)`,
            "&::after": {
              transform: `rotate(-45deg) translateX(-${menuArrowOffset})`
            },
            "&::before": {
              transform: `rotate(45deg) translateX(${menuArrowOffset})`
            }
          }
        })
      },
      // Integration with header element so menu items have the same height
      {
        [`${antCls}-layout-header`]: {
          [componentCls]: {
            lineHeight: "inherit"
          }
        }
      }
    ];
  };
  const useStyle$b = (prefixCls, injectStyle) => {
    const useOriginHook = genComponentStyleHook("Menu", (token2, _ref) => {
      let {
        overrideComponentToken
      } = _ref;
      if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
        return [];
      }
      const {
        colorBgElevated,
        colorPrimary,
        colorError,
        colorErrorHover,
        colorTextLightSolid
      } = token2;
      const {
        controlHeightLG,
        fontSize
      } = token2;
      const menuArrowSize = fontSize / 7 * 5;
      const menuToken = merge$2(token2, {
        menuItemHeight: controlHeightLG,
        menuItemPaddingInline: token2.margin,
        menuArrowSize,
        menuHorizontalHeight: controlHeightLG * 1.15,
        menuArrowOffset: `${menuArrowSize * 0.25}px`,
        menuPanelMaskInset: -7,
        menuSubMenuBg: colorBgElevated
      });
      const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
      const menuDarkToken = merge$2(menuToken, {
        colorItemText: colorTextDark,
        colorItemTextHover: colorTextLightSolid,
        colorGroupTitle: colorTextDark,
        colorItemTextSelected: colorTextLightSolid,
        colorItemBg: "#001529",
        colorSubItemBg: "#000c17",
        colorItemBgActive: "transparent",
        colorItemBgSelected: colorPrimary,
        colorActiveBarWidth: 0,
        colorActiveBarHeight: 0,
        colorActiveBarBorderSize: 0,
        // Disabled
        colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
        // Danger
        colorDangerItemText: colorError,
        colorDangerItemTextHover: colorErrorHover,
        colorDangerItemTextSelected: colorTextLightSolid,
        colorDangerItemBgActive: colorError,
        colorDangerItemBgSelected: colorError,
        menuSubMenuBg: "#001529",
        // Horizontal
        colorItemTextSelectedHorizontal: colorTextLightSolid,
        colorItemBgSelectedHorizontal: colorPrimary
      }, _extends$1({}, overrideComponentToken));
      return [
        // Basic
        getBaseStyle(menuToken),
        // Horizontal
        getHorizontalStyle(menuToken),
        // Vertical
        getVerticalStyle(menuToken),
        // Theme
        getThemeStyle(menuToken, "light"),
        getThemeStyle(menuDarkToken, "dark"),
        // RTL
        getRTLStyle(menuToken),
        // Motion
        genCollapseMotion(menuToken),
        initSlideMotion(menuToken, "slide-up"),
        initSlideMotion(menuToken, "slide-down"),
        initZoomMotion(menuToken, "zoom-big")
      ];
    }, (token2) => {
      const {
        colorPrimary,
        colorError,
        colorTextDisabled,
        colorErrorBg,
        colorText,
        colorTextDescription,
        colorBgContainer,
        colorFillAlter,
        colorFillContent,
        lineWidth,
        lineWidthBold,
        controlItemBgActive,
        colorBgTextHover
      } = token2;
      return {
        dropdownWidth: 160,
        zIndexPopup: token2.zIndexPopupBase + 50,
        radiusItem: token2.borderRadiusLG,
        radiusSubMenuItem: token2.borderRadiusSM,
        colorItemText: colorText,
        colorItemTextHover: colorText,
        colorItemTextHoverHorizontal: colorPrimary,
        colorGroupTitle: colorTextDescription,
        colorItemTextSelected: colorPrimary,
        colorItemTextSelectedHorizontal: colorPrimary,
        colorItemBg: colorBgContainer,
        colorItemBgHover: colorBgTextHover,
        colorItemBgActive: colorFillContent,
        colorSubItemBg: colorFillAlter,
        colorItemBgSelected: controlItemBgActive,
        colorItemBgSelectedHorizontal: "transparent",
        colorActiveBarWidth: 0,
        colorActiveBarHeight: lineWidthBold,
        colorActiveBarBorderSize: lineWidth,
        // Disabled
        colorItemTextDisabled: colorTextDisabled,
        // Danger
        colorDangerItemText: colorError,
        colorDangerItemTextHover: colorError,
        colorDangerItemTextSelected: colorError,
        colorDangerItemBgActive: colorErrorBg,
        colorDangerItemBgSelected: colorErrorBg,
        itemMarginInline: token2.marginXXS
      };
    });
    return useOriginHook(prefixCls);
  };
  const menuProps = () => ({
    id: String,
    prefixCls: String,
    // donot use items, now only support inner use
    items: Array,
    disabled: Boolean,
    inlineCollapsed: Boolean,
    disabledOverflow: Boolean,
    forceSubMenuRender: Boolean,
    openKeys: Array,
    selectedKeys: Array,
    activeKey: String,
    selectable: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: [Number, String]
    },
    motion: Object,
    role: String,
    theme: {
      type: String,
      default: "light"
    },
    mode: {
      type: String,
      default: "vertical"
    },
    inlineIndent: {
      type: Number,
      default: 24
    },
    subMenuOpenDelay: {
      type: Number,
      default: 0
    },
    subMenuCloseDelay: {
      type: Number,
      default: 0.1
    },
    builtinPlacements: {
      type: Object
    },
    triggerSubMenuAction: {
      type: String,
      default: "hover"
    },
    getPopupContainer: Function,
    expandIcon: Function,
    onOpenChange: Function,
    onSelect: Function,
    onDeselect: Function,
    onClick: [Function, Array],
    onFocus: Function,
    onBlur: Function,
    onMousedown: Function,
    "onUpdate:openKeys": Function,
    "onUpdate:selectedKeys": Function,
    "onUpdate:activeKey": Function
  });
  const EMPTY_LIST$2 = [];
  const Menu = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AMenu",
    inheritAttrs: false,
    props: menuProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2,
        attrs
      } = _ref;
      const {
        direction,
        getPrefixCls
      } = useConfigInject("menu", props2);
      const override = useInjectOverride();
      const prefixCls = computed(() => {
        var _a2;
        return getPrefixCls("menu", props2.prefixCls || ((_a2 = override === null || override === void 0 ? void 0 : override.prefixCls) === null || _a2 === void 0 ? void 0 : _a2.value));
      });
      const [wrapSSR, hashId] = useStyle$b(prefixCls, computed(() => {
        return !override;
      }));
      const store = shallowRef(/* @__PURE__ */ new Map());
      const siderCollapsed = inject(SiderCollapsedKey, ref(void 0));
      const inlineCollapsed = computed(() => {
        if (siderCollapsed.value !== void 0) {
          return siderCollapsed.value;
        }
        return props2.inlineCollapsed;
      });
      const {
        itemsNodes
      } = useItems(props2);
      const isMounted = shallowRef(false);
      onMounted(() => {
        isMounted.value = true;
      });
      watchEffect(() => {
        devWarning(!(props2.inlineCollapsed === true && props2.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline.");
        devWarning(!(siderCollapsed.value !== void 0 && props2.inlineCollapsed === true), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
      });
      const activeKeys = ref([]);
      const mergedSelectedKeys = ref([]);
      const keyMapStore = ref({});
      watch(store, () => {
        const newKeyMapStore = {};
        for (const menuInfo of store.value.values()) {
          newKeyMapStore[menuInfo.key] = menuInfo;
        }
        keyMapStore.value = newKeyMapStore;
      }, {
        flush: "post"
      });
      watchEffect(() => {
        if (props2.activeKey !== void 0) {
          let keys2 = [];
          const menuInfo = props2.activeKey ? keyMapStore.value[props2.activeKey] : void 0;
          if (menuInfo && props2.activeKey !== void 0) {
            keys2 = uniq([].concat(unref(menuInfo.parentKeys), props2.activeKey));
          } else {
            keys2 = [];
          }
          if (!shallowequal(activeKeys.value, keys2)) {
            activeKeys.value = keys2;
          }
        }
      });
      watch(() => props2.selectedKeys, (selectedKeys) => {
        if (selectedKeys) {
          mergedSelectedKeys.value = selectedKeys.slice();
        }
      }, {
        immediate: true,
        deep: true
      });
      const selectedSubMenuKeys = ref([]);
      watch([keyMapStore, mergedSelectedKeys], () => {
        let subMenuParentKeys = [];
        mergedSelectedKeys.value.forEach((key2) => {
          const menuInfo = keyMapStore.value[key2];
          if (menuInfo) {
            subMenuParentKeys = subMenuParentKeys.concat(unref(menuInfo.parentKeys));
          }
        });
        subMenuParentKeys = uniq(subMenuParentKeys);
        if (!shallowequal(selectedSubMenuKeys.value, subMenuParentKeys)) {
          selectedSubMenuKeys.value = subMenuParentKeys;
        }
      }, {
        immediate: true
      });
      const triggerSelection = (info) => {
        if (props2.selectable) {
          const {
            key: targetKey
          } = info;
          const exist = mergedSelectedKeys.value.includes(targetKey);
          let newSelectedKeys;
          if (props2.multiple) {
            if (exist) {
              newSelectedKeys = mergedSelectedKeys.value.filter((key2) => key2 !== targetKey);
            } else {
              newSelectedKeys = [...mergedSelectedKeys.value, targetKey];
            }
          } else {
            newSelectedKeys = [targetKey];
          }
          const selectInfo = _extends$1(_extends$1({}, info), {
            selectedKeys: newSelectedKeys
          });
          if (!shallowequal(newSelectedKeys, mergedSelectedKeys.value)) {
            if (props2.selectedKeys === void 0) {
              mergedSelectedKeys.value = newSelectedKeys;
            }
            emit2("update:selectedKeys", newSelectedKeys);
            if (exist && props2.multiple) {
              emit2("deselect", selectInfo);
            } else {
              emit2("select", selectInfo);
            }
          }
        }
        if (mergedMode.value !== "inline" && !props2.multiple && mergedOpenKeys.value.length) {
          triggerOpenKeys(EMPTY_LIST$2);
        }
      };
      const mergedOpenKeys = ref([]);
      watch(() => props2.openKeys, function() {
        let openKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mergedOpenKeys.value;
        if (!shallowequal(mergedOpenKeys.value, openKeys)) {
          mergedOpenKeys.value = openKeys.slice();
        }
      }, {
        immediate: true,
        deep: true
      });
      let timeout;
      const changeActiveKeys = (keys2) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          if (props2.activeKey === void 0) {
            activeKeys.value = keys2;
          }
          emit2("update:activeKey", keys2[keys2.length - 1]);
        });
      };
      const disabled = computed(() => !!props2.disabled);
      const isRtl = computed(() => direction.value === "rtl");
      const mergedMode = ref("vertical");
      const mergedInlineCollapsed = shallowRef(false);
      watchEffect(() => {
        var _a2;
        if ((props2.mode === "inline" || props2.mode === "vertical") && inlineCollapsed.value) {
          mergedMode.value = "vertical";
          mergedInlineCollapsed.value = inlineCollapsed.value;
        } else {
          mergedMode.value = props2.mode;
          mergedInlineCollapsed.value = false;
        }
        if ((_a2 = override === null || override === void 0 ? void 0 : override.mode) === null || _a2 === void 0 ? void 0 : _a2.value) {
          mergedMode.value = override.mode.value;
        }
      });
      const isInlineMode = computed(() => mergedMode.value === "inline");
      const triggerOpenKeys = (keys2) => {
        mergedOpenKeys.value = keys2;
        emit2("update:openKeys", keys2);
        emit2("openChange", keys2);
      };
      const inlineCacheOpenKeys = ref(mergedOpenKeys.value);
      const mountRef = shallowRef(false);
      watch(mergedOpenKeys, () => {
        if (isInlineMode.value) {
          inlineCacheOpenKeys.value = mergedOpenKeys.value;
        }
      }, {
        immediate: true
      });
      watch(isInlineMode, () => {
        if (!mountRef.value) {
          mountRef.value = true;
          return;
        }
        if (isInlineMode.value) {
          mergedOpenKeys.value = inlineCacheOpenKeys.value;
        } else {
          triggerOpenKeys(EMPTY_LIST$2);
        }
      }, {
        immediate: true
      });
      const className = computed(() => {
        return {
          [`${prefixCls.value}`]: true,
          [`${prefixCls.value}-root`]: true,
          [`${prefixCls.value}-${mergedMode.value}`]: true,
          [`${prefixCls.value}-inline-collapsed`]: mergedInlineCollapsed.value,
          [`${prefixCls.value}-rtl`]: isRtl.value,
          [`${prefixCls.value}-${props2.theme}`]: true
        };
      });
      const rootPrefixCls = computed(() => getPrefixCls());
      const defaultMotions = computed(() => ({
        horizontal: {
          name: `${rootPrefixCls.value}-slide-up`
        },
        inline: collapseMotion(`${rootPrefixCls.value}-motion-collapse`),
        other: {
          name: `${rootPrefixCls.value}-zoom-big`
        }
      }));
      useProvideFirstLevel(true);
      const getChildrenKeys = function() {
        let eventKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        const keys2 = [];
        const storeValue = store.value;
        eventKeys.forEach((eventKey) => {
          const {
            key: key2,
            childrenEventKeys
          } = storeValue.get(eventKey);
          keys2.push(key2, ...getChildrenKeys(unref(childrenEventKeys)));
        });
        return keys2;
      };
      const onInternalClick = (info) => {
        var _a2;
        emit2("click", info);
        triggerSelection(info);
        (_a2 = override === null || override === void 0 ? void 0 : override.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(override);
      };
      const onInternalOpenChange = (key2, open2) => {
        var _a2;
        const childrenEventKeys = ((_a2 = keyMapStore.value[key2]) === null || _a2 === void 0 ? void 0 : _a2.childrenEventKeys) || [];
        let newOpenKeys = mergedOpenKeys.value.filter((k2) => k2 !== key2);
        if (open2) {
          newOpenKeys.push(key2);
        } else if (mergedMode.value !== "inline") {
          const subPathKeys = getChildrenKeys(unref(childrenEventKeys));
          newOpenKeys = uniq(newOpenKeys.filter((k2) => !subPathKeys.includes(k2)));
        }
        if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
          triggerOpenKeys(newOpenKeys);
        }
      };
      const registerMenuInfo = (key2, info) => {
        store.value.set(key2, info);
        store.value = new Map(store.value);
      };
      const unRegisterMenuInfo = (key2) => {
        store.value.delete(key2);
        store.value = new Map(store.value);
      };
      const lastVisibleIndex = ref(0);
      const expandIcon = computed(() => {
        var _a2;
        return props2.expandIcon || slots.expandIcon || ((_a2 = override === null || override === void 0 ? void 0 : override.expandIcon) === null || _a2 === void 0 ? void 0 : _a2.value) ? (opt) => {
          let icon = props2.expandIcon || slots.expandIcon;
          icon = typeof icon === "function" ? icon(opt) : icon;
          return cloneElement(icon, {
            class: `${prefixCls.value}-submenu-expand-icon`
          }, false);
        } : null;
      });
      useProvideMenu({
        prefixCls,
        activeKeys,
        openKeys: mergedOpenKeys,
        selectedKeys: mergedSelectedKeys,
        changeActiveKeys,
        disabled,
        rtl: isRtl,
        mode: mergedMode,
        inlineIndent: computed(() => props2.inlineIndent),
        subMenuCloseDelay: computed(() => props2.subMenuCloseDelay),
        subMenuOpenDelay: computed(() => props2.subMenuOpenDelay),
        builtinPlacements: computed(() => props2.builtinPlacements),
        triggerSubMenuAction: computed(() => props2.triggerSubMenuAction),
        getPopupContainer: computed(() => props2.getPopupContainer),
        inlineCollapsed: mergedInlineCollapsed,
        theme: computed(() => props2.theme),
        siderCollapsed,
        defaultMotions: computed(() => isMounted.value ? defaultMotions.value : null),
        motion: computed(() => isMounted.value ? props2.motion : null),
        overflowDisabled: shallowRef(void 0),
        onOpenChange: onInternalOpenChange,
        onItemClick: onInternalClick,
        registerMenuInfo,
        unRegisterMenuInfo,
        selectedSubMenuKeys,
        expandIcon,
        forceSubMenuRender: computed(() => props2.forceSubMenuRender),
        rootClassName: hashId
      });
      const getChildrenList = () => {
        var _a2;
        return itemsNodes.value || flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      };
      return () => {
        var _a2;
        const childList = getChildrenList();
        const allVisible = lastVisibleIndex.value >= childList.length - 1 || mergedMode.value !== "horizontal" || props2.disabledOverflow;
        const getWrapperList = (childList2) => {
          return mergedMode.value !== "horizontal" || props2.disabledOverflow ? childList2 : (
            // Need wrap for overflow dropdown that do not response for open
            childList2.map((child, index2) => (
              // Always wrap provider to avoid sub node re-mount
              createVNode(MenuContextProvider, {
                "key": child.key,
                "overflowDisabled": index2 > lastVisibleIndex.value
              }, {
                default: () => child
              })
            ))
          );
        };
        const overflowedIndicator = ((_a2 = slots.overflowedIndicator) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || createVNode(EllipsisOutlined, null, null);
        return wrapSSR(createVNode(Overflow, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "onMousedown": props2.onMousedown,
          "prefixCls": `${prefixCls.value}-overflow`,
          "component": "ul",
          "itemComponent": MenuItem$1,
          "class": [className.value, attrs.class, hashId.value],
          "role": "menu",
          "id": props2.id,
          "data": getWrapperList(childList),
          "renderRawItem": (node2) => node2,
          "renderRawRest": (omitItems) => {
            const len2 = omitItems.length;
            const originOmitItems = len2 ? childList.slice(-len2) : null;
            return createVNode(Fragment, null, [createVNode(SubMenu$1, {
              "eventKey": OVERFLOW_KEY,
              "key": OVERFLOW_KEY,
              "title": overflowedIndicator,
              "disabled": allVisible,
              "internalPopupClose": len2 === 0
            }, {
              default: () => originOmitItems
            }), createVNode(PathContext, null, {
              default: () => [createVNode(SubMenu$1, {
                "eventKey": OVERFLOW_KEY,
                "key": OVERFLOW_KEY,
                "title": overflowedIndicator,
                "disabled": allVisible,
                "internalPopupClose": len2 === 0
              }, {
                default: () => originOmitItems
              })]
            })]);
          },
          "maxCount": mergedMode.value !== "horizontal" || props2.disabledOverflow ? Overflow.INVALIDATE : Overflow.RESPONSIVE,
          "ssr": "full",
          "data-menu-list": true,
          "onVisibleChange": (newLastIndex) => {
            lastVisibleIndex.value = newLastIndex;
          }
        }), {
          default: () => [createVNode(Teleport, {
            "to": "body"
          }, {
            default: () => [createVNode("div", {
              "style": {
                display: "none"
              },
              "aria-hidden": true
            }, [createVNode(PathContext, null, {
              default: () => [getWrapperList(getChildrenList())]
            })])]
          })]
        }));
      };
    }
  });
  Menu.install = function(app2) {
    app2.component(Menu.name, Menu);
    app2.component(MenuItem$1.name, MenuItem$1);
    app2.component(SubMenu$1.name, SubMenu$1);
    app2.component(Divider.name, Divider);
    app2.component(ItemGroup.name, ItemGroup);
    return app2;
  };
  Menu.Item = MenuItem$1;
  Menu.Divider = Divider;
  Menu.SubMenu = SubMenu$1;
  Menu.ItemGroup = ItemGroup;
  var __rest$n = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const checkboxProps$1 = {
    prefixCls: String,
    name: String,
    id: String,
    type: String,
    defaultChecked: {
      type: [Boolean, Number],
      default: void 0
    },
    checked: {
      type: [Boolean, Number],
      default: void 0
    },
    disabled: Boolean,
    tabindex: {
      type: [Number, String]
    },
    readonly: Boolean,
    autofocus: Boolean,
    value: PropTypes.any,
    required: Boolean
  };
  const VcCheckbox = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Checkbox",
    inheritAttrs: false,
    props: initDefaultProps(checkboxProps$1, {
      prefixCls: "rc-checkbox",
      type: "checkbox",
      defaultChecked: false
    }),
    emits: ["click", "change"],
    setup(props2, _ref) {
      let {
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const checked = ref(props2.checked === void 0 ? props2.defaultChecked : props2.checked);
      const inputRef = ref();
      watch(() => props2.checked, () => {
        checked.value = props2.checked;
      });
      expose({
        focus() {
          var _a2;
          (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur() {
          var _a2;
          (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const eventShiftKey = ref();
      const handleChange = (e2) => {
        if (props2.disabled) {
          return;
        }
        if (props2.checked === void 0) {
          checked.value = e2.target.checked;
        }
        e2.shiftKey = eventShiftKey.value;
        const eventObj = {
          target: _extends$1(_extends$1({}, props2), {
            checked: e2.target.checked
          }),
          stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2
        };
        if (props2.checked !== void 0) {
          inputRef.value.checked = !!props2.checked;
        }
        emit2("change", eventObj);
        eventShiftKey.value = false;
      };
      const onClick = (e2) => {
        emit2("click", e2);
        eventShiftKey.value = e2.shiftKey;
      };
      return () => {
        const {
          prefixCls,
          name,
          id,
          type,
          disabled,
          readonly: readonly2,
          tabindex,
          autofocus,
          value,
          required
        } = props2, others = __rest$n(props2, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]);
        const {
          class: className,
          onFocus,
          onBlur,
          onKeydown,
          onKeypress,
          onKeyup
        } = attrs;
        const othersAndAttrs = _extends$1(_extends$1({}, others), attrs);
        const globalProps = Object.keys(othersAndAttrs).reduce((prev2, key2) => {
          if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
            prev2[key2] = othersAndAttrs[key2];
          }
          return prev2;
        }, {});
        const classString = classNames(prefixCls, className, {
          [`${prefixCls}-checked`]: checked.value,
          [`${prefixCls}-disabled`]: disabled
        });
        const inputProps2 = _extends$1(_extends$1({
          name,
          id,
          type,
          readonly: readonly2,
          disabled,
          tabindex,
          class: `${prefixCls}-input`,
          checked: !!checked.value,
          autofocus,
          value
        }, globalProps), {
          onChange: handleChange,
          onClick,
          onFocus,
          onBlur,
          onKeydown,
          onKeypress,
          onKeyup,
          required
        });
        return createVNode("span", {
          "class": classString
        }, [createVNode("input", _objectSpread2$1({
          "ref": inputRef
        }, inputProps2), null), createVNode("span", {
          "class": `${prefixCls}-inner`
        }, null)]);
      };
    }
  });
  const radioGroupContextKey = Symbol("radioGroupContextKey");
  const useProvideRadioGroupContext = (props2) => {
    provide(radioGroupContextKey, props2);
  };
  const useInjectRadioGroupContext = () => {
    return inject(radioGroupContextKey, void 0);
  };
  const radioOptionTypeContextKey = Symbol("radioOptionTypeContextKey");
  const useProvideRadioOptionTypeContext = (props2) => {
    provide(radioOptionTypeContextKey, props2);
  };
  const useInjectRadioOptionTypeContext = () => {
    return inject(radioOptionTypeContextKey, void 0);
  };
  const antRadioEffect = new Keyframe("antRadioEffect", {
    "0%": {
      transform: "scale(1)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(1.6)",
      opacity: 0
    }
  });
  const getGroupRadioStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    return {
      [groupPrefixCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        display: "inline-block",
        fontSize: 0,
        // RTL
        [`&${groupPrefixCls}-rtl`]: {
          direction: "rtl"
        },
        [`${antCls}-badge ${antCls}-badge-count`]: {
          zIndex: 1
        },
        [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
          borderInlineStart: "none"
        }
      })
    };
  };
  const getRadioBasicStyle = (token2) => {
    const {
      componentCls,
      radioWrapperMarginRight,
      radioCheckedColor,
      radioSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      motionEaseInOutCirc,
      radioButtonBg,
      colorBorder,
      lineWidth,
      radioDotSize,
      colorBgContainerDisabled,
      colorTextDisabled,
      paddingXS,
      radioDotDisabledColor,
      lineType,
      radioDotDisabledSize,
      wireframe,
      colorWhite
    } = token2;
    const radioInnerPrefixCls = `${componentCls}-inner`;
    return {
      [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: radioWrapperMarginRight,
        cursor: "pointer",
        // RTL
        [`&${componentCls}-wrapper-rtl`]: {
          direction: "rtl"
        },
        "&-disabled": {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"'
        },
        // hashId 在 wrapper 上，只能铺平
        [`${componentCls}-checked::after`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          border: `${lineWidth}px ${lineType} ${radioCheckedColor}`,
          borderRadius: "50%",
          visibility: "hidden",
          animationName: antRadioEffect,
          animationDuration: motionDurationSlow,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          content: '""'
        },
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-block",
          outline: "none",
          cursor: "pointer",
          alignSelf: "center"
        }),
        [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
          borderColor: radioCheckedColor
        },
        [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: _extends$1({}, genFocusOutline(token2)),
        [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
          visibility: "visible"
        },
        [`${componentCls}-inner`]: {
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: "50%",
            display: "block",
            width: radioSize,
            height: radioSize,
            marginBlockStart: radioSize / -2,
            marginInlineStart: radioSize / -2,
            backgroundColor: wireframe ? radioCheckedColor : colorWhite,
            borderBlockStart: 0,
            borderInlineStart: 0,
            borderRadius: radioSize,
            transform: "scale(0)",
            opacity: 0,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
            content: '""'
          },
          boxSizing: "border-box",
          position: "relative",
          insetBlockStart: 0,
          insetInlineStart: 0,
          display: "block",
          width: radioSize,
          height: radioSize,
          backgroundColor: radioButtonBg,
          borderColor: colorBorder,
          borderStyle: "solid",
          borderWidth: lineWidth,
          borderRadius: "50%",
          transition: `all ${motionDurationMid}`
        },
        [`${componentCls}-input`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          insetBlockEnd: 0,
          insetInlineStart: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0
        },
        // 选中状态
        [`${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            borderColor: radioCheckedColor,
            backgroundColor: wireframe ? radioButtonBg : radioCheckedColor,
            "&::after": {
              transform: `scale(${radioDotSize / radioSize})`,
              opacity: 1,
              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
            }
          }
        },
        [`${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [radioInnerPrefixCls]: {
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder,
            cursor: "not-allowed",
            "&::after": {
              backgroundColor: radioDotDisabledColor
            }
          },
          [`${componentCls}-input`]: {
            cursor: "not-allowed"
          },
          [`${componentCls}-disabled + span`]: {
            color: colorTextDisabled,
            cursor: "not-allowed"
          },
          [`&${componentCls}-checked`]: {
            [radioInnerPrefixCls]: {
              "&::after": {
                transform: `scale(${radioDotDisabledSize / radioSize})`
              }
            }
          }
        },
        [`span${componentCls} + *`]: {
          paddingInlineStart: paddingXS,
          paddingInlineEnd: paddingXS
        }
      })
    };
  };
  const getRadioButtonStyle = (token2) => {
    const {
      radioButtonColor,
      controlHeight,
      componentCls,
      lineWidth,
      lineType,
      colorBorder,
      motionDurationSlow,
      motionDurationMid,
      radioButtonPaddingHorizontal,
      fontSize,
      radioButtonBg,
      fontSizeLG,
      controlHeightLG,
      controlHeightSM,
      paddingXS,
      borderRadius,
      borderRadiusSM,
      borderRadiusLG,
      radioCheckedColor,
      radioButtonCheckedBg,
      radioButtonHoverColor,
      radioButtonActiveColor,
      radioSolidCheckedColor,
      colorTextDisabled,
      colorBgContainerDisabled,
      radioDisabledButtonCheckedColor,
      radioDisabledButtonCheckedBg
    } = token2;
    return {
      [`${componentCls}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: controlHeight,
        margin: 0,
        paddingInline: radioButtonPaddingHorizontal,
        paddingBlock: 0,
        color: radioButtonColor,
        fontSize,
        lineHeight: `${controlHeight - lineWidth * 2}px`,
        background: radioButtonBg,
        border: `${lineWidth}px ${lineType} ${colorBorder}`,
        // strange align fix for chrome but works
        // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
        borderBlockStartWidth: lineWidth + 0.02,
        borderInlineStartWidth: 0,
        borderInlineEndWidth: lineWidth,
        cursor: "pointer",
        transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `border-color ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
        a: {
          color: radioButtonColor
        },
        [`> ${componentCls}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%"
        },
        "&:not(:first-child)": {
          "&::before": {
            position: "absolute",
            insetBlockStart: -lineWidth,
            insetInlineStart: -lineWidth,
            display: "block",
            boxSizing: "content-box",
            width: 1,
            height: "100%",
            paddingBlock: lineWidth,
            paddingInline: 0,
            backgroundColor: colorBorder,
            transition: `background-color ${motionDurationSlow}`,
            content: '""'
          }
        },
        "&:first-child": {
          borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
          borderStartStartRadius: borderRadius,
          borderEndStartRadius: borderRadius
        },
        "&:last-child": {
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius
        },
        "&:first-child:last-child": {
          borderRadius
        },
        [`${componentCls}-group-large &`]: {
          height: controlHeightLG,
          fontSize: fontSizeLG,
          lineHeight: `${controlHeightLG - lineWidth * 2}px`,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderEndStartRadius: borderRadiusLG
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          }
        },
        [`${componentCls}-group-small &`]: {
          height: controlHeightSM,
          paddingInline: paddingXS - lineWidth,
          paddingBlock: 0,
          lineHeight: `${controlHeightSM - lineWidth * 2}px`,
          "&:first-child": {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          }
        },
        "&:hover": {
          position: "relative",
          color: radioCheckedColor
        },
        "&:has(:focus-visible)": _extends$1({}, genFocusOutline(token2)),
        [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        },
        [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: radioCheckedColor,
          background: radioButtonCheckedBg,
          borderColor: radioCheckedColor,
          "&::before": {
            backgroundColor: radioCheckedColor
          },
          "&:first-child": {
            borderColor: radioCheckedColor
          },
          "&:hover": {
            color: radioButtonHoverColor,
            borderColor: radioButtonHoverColor,
            "&::before": {
              backgroundColor: radioButtonHoverColor
            }
          },
          "&:active": {
            color: radioButtonActiveColor,
            borderColor: radioButtonActiveColor,
            "&::before": {
              backgroundColor: radioButtonActiveColor
            }
          }
        },
        [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          color: radioSolidCheckedColor,
          background: radioCheckedColor,
          borderColor: radioCheckedColor,
          "&:hover": {
            color: radioSolidCheckedColor,
            background: radioButtonHoverColor,
            borderColor: radioButtonHoverColor
          },
          "&:active": {
            color: radioSolidCheckedColor,
            background: radioButtonActiveColor,
            borderColor: radioButtonActiveColor
          }
        },
        "&-disabled": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder
          }
        },
        [`&-disabled${componentCls}-button-wrapper-checked`]: {
          color: radioDisabledButtonCheckedColor,
          backgroundColor: radioDisabledButtonCheckedBg,
          borderColor: colorBorder,
          boxShadow: "none"
        }
      }
    };
  };
  const useStyle$a = genComponentStyleHook("Radio", (token2) => {
    const {
      padding,
      lineWidth,
      controlItemBgActiveDisabled,
      colorTextDisabled,
      colorBgContainer,
      fontSizeLG,
      controlOutline,
      colorPrimaryHover,
      colorPrimaryActive,
      colorText,
      colorPrimary,
      marginXS,
      controlOutlineWidth,
      colorTextLightSolid,
      wireframe
    } = token2;
    const radioFocusShadow = `0 0 0 ${controlOutlineWidth}px ${controlOutline}`;
    const radioButtonFocusShadow = radioFocusShadow;
    const radioSize = fontSizeLG;
    const dotPadding = 4;
    const radioDotDisabledSize = radioSize - dotPadding * 2;
    const radioDotSize = wireframe ? radioDotDisabledSize : radioSize - (dotPadding + lineWidth) * 2;
    const radioCheckedColor = colorPrimary;
    const radioButtonColor = colorText;
    const radioButtonHoverColor = colorPrimaryHover;
    const radioButtonActiveColor = colorPrimaryActive;
    const radioButtonPaddingHorizontal = padding - lineWidth;
    const radioDisabledButtonCheckedColor = colorTextDisabled;
    const radioWrapperMarginRight = marginXS;
    const radioToken = merge$2(token2, {
      radioFocusShadow,
      radioButtonFocusShadow,
      radioSize,
      radioDotSize,
      radioDotDisabledSize,
      radioCheckedColor,
      radioDotDisabledColor: colorTextDisabled,
      radioSolidCheckedColor: colorTextLightSolid,
      radioButtonBg: colorBgContainer,
      radioButtonCheckedBg: colorBgContainer,
      radioButtonColor,
      radioButtonHoverColor,
      radioButtonActiveColor,
      radioButtonPaddingHorizontal,
      radioDisabledButtonCheckedBg: controlItemBgActiveDisabled,
      radioDisabledButtonCheckedColor,
      radioWrapperMarginRight
    });
    return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
  });
  var __rest$m = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const radioProps = () => ({
    prefixCls: String,
    checked: booleanType(),
    disabled: booleanType(),
    isGroup: booleanType(),
    value: PropTypes.any,
    name: String,
    id: String,
    autofocus: booleanType(),
    onChange: functionType(),
    onFocus: functionType(),
    onBlur: functionType(),
    onClick: functionType(),
    "onUpdate:checked": functionType(),
    "onUpdate:value": functionType()
  });
  const Radio = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARadio",
    inheritAttrs: false,
    props: radioProps(),
    setup(props2, _ref) {
      let {
        emit: emit2,
        expose,
        slots,
        attrs
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const radioOptionTypeContext = useInjectRadioOptionTypeContext();
      const radioGroupContext = useInjectRadioGroupContext();
      const disabledContext = useInjectDisabled();
      const mergedDisabled = computed(() => {
        var _a2;
        return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
      });
      const vcCheckbox = ref();
      const {
        prefixCls: radioPrefixCls,
        direction,
        disabled
      } = useConfigInject("radio", props2);
      const prefixCls = computed(() => (radioGroupContext === null || radioGroupContext === void 0 ? void 0 : radioGroupContext.optionType.value) === "button" || radioOptionTypeContext === "button" ? `${radioPrefixCls.value}-button` : radioPrefixCls.value);
      const contextDisabled = useInjectDisabled();
      const [wrapSSR, hashId] = useStyle$a(radioPrefixCls);
      const focus = () => {
        vcCheckbox.value.focus();
      };
      const blur = () => {
        vcCheckbox.value.blur();
      };
      expose({
        focus,
        blur
      });
      const handleChange = (event) => {
        const targetChecked = event.target.checked;
        emit2("update:checked", targetChecked);
        emit2("update:value", targetChecked);
        emit2("change", event);
        formItemContext.onFieldChange();
      };
      const onChange = (e2) => {
        emit2("change", e2);
        if (radioGroupContext && radioGroupContext.onChange) {
          radioGroupContext.onChange(e2);
        }
      };
      return () => {
        var _a2;
        const radioGroup = radioGroupContext;
        const {
          prefixCls: customizePrefixCls,
          id = formItemContext.id.value
        } = props2, restProps = __rest$m(props2, ["prefixCls", "id"]);
        const rProps = _extends$1(_extends$1({
          prefixCls: prefixCls.value,
          id
        }, omit$1(restProps, ["onUpdate:checked", "onUpdate:value"])), {
          disabled: (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value
        });
        if (radioGroup) {
          rProps.name = radioGroup.name.value;
          rProps.onChange = onChange;
          rProps.checked = props2.value === radioGroup.value.value;
          rProps.disabled = mergedDisabled.value || radioGroup.disabled.value;
        } else {
          rProps.onChange = handleChange;
        }
        const wrapperClassString = classNames({
          [`${prefixCls.value}-wrapper`]: true,
          [`${prefixCls.value}-wrapper-checked`]: rProps.checked,
          [`${prefixCls.value}-wrapper-disabled`]: rProps.disabled,
          [`${prefixCls.value}-wrapper-rtl`]: direction.value === "rtl",
          [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
        }, attrs.class, hashId.value);
        return wrapSSR(createVNode("label", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": wrapperClassString
        }), [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, rProps), {}, {
          "type": "radio",
          "ref": vcCheckbox
        }), null), slots.default && createVNode("span", null, [slots.default()])]));
      };
    }
  });
  const radioGroupProps = () => ({
    prefixCls: String,
    value: PropTypes.any,
    size: stringType(),
    options: arrayType(),
    disabled: booleanType(),
    name: String,
    buttonStyle: stringType("outline"),
    id: String,
    optionType: stringType("default"),
    onChange: functionType(),
    "onUpdate:value": functionType()
  });
  const Group$4 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARadioGroup",
    inheritAttrs: false,
    props: radioGroupProps(),
    // emits: ['update:value', 'change'],
    setup(props2, _ref) {
      let {
        slots,
        emit: emit2,
        attrs
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const {
        prefixCls,
        direction,
        size
      } = useConfigInject("radio", props2);
      const [wrapSSR, hashId] = useStyle$a(prefixCls);
      const stateValue = ref(props2.value);
      const updatingValue = ref(false);
      watch(() => props2.value, (val) => {
        stateValue.value = val;
        updatingValue.value = false;
      });
      const onRadioChange = (ev) => {
        const lastValue = stateValue.value;
        const {
          value
        } = ev.target;
        if (!("value" in props2)) {
          stateValue.value = value;
        }
        if (!updatingValue.value && value !== lastValue) {
          updatingValue.value = true;
          emit2("update:value", value);
          emit2("change", ev);
          formItemContext.onFieldChange();
        }
        nextTick(() => {
          updatingValue.value = false;
        });
      };
      useProvideRadioGroupContext({
        onChange: onRadioChange,
        value: stateValue,
        disabled: computed(() => props2.disabled),
        name: computed(() => props2.name),
        optionType: computed(() => props2.optionType)
      });
      return () => {
        var _a2;
        const {
          options: options2,
          buttonStyle,
          id = formItemContext.id.value
        } = props2;
        const groupPrefixCls = `${prefixCls.value}-group`;
        const classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
          [`${groupPrefixCls}-${size.value}`]: size.value,
          [`${groupPrefixCls}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value);
        let children = null;
        if (options2 && options2.length > 0) {
          children = options2.map((option) => {
            if (typeof option === "string" || typeof option === "number") {
              return createVNode(Radio, {
                "key": option,
                "prefixCls": prefixCls.value,
                "disabled": props2.disabled,
                "value": option,
                "checked": stateValue.value === option
              }, {
                default: () => [option]
              });
            }
            const {
              value,
              disabled,
              label
            } = option;
            return createVNode(Radio, {
              "key": `radio-group-value-options-${value}`,
              "prefixCls": prefixCls.value,
              "disabled": disabled || props2.disabled,
              "value": value,
              "checked": stateValue.value === value
            }, {
              default: () => [label]
            });
          });
        } else {
          children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classString,
          "id": id
        }), [children]));
      };
    }
  });
  const Button = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARadioButton",
    inheritAttrs: false,
    props: radioProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls
      } = useConfigInject("radio", props2);
      useProvideRadioOptionTypeContext("button");
      return () => {
        var _a2;
        return createVNode(Radio, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props2), {}, {
          "prefixCls": prefixCls.value
        }), {
          default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
        });
      };
    }
  });
  Radio.Group = Group$4;
  Radio.Button = Button;
  Radio.install = function(app2) {
    app2.component(Radio.name, Radio);
    app2.component(Radio.Group.name, Radio.Group);
    app2.component(Radio.Button.name, Radio.Button);
    return app2;
  };
  const genPlaceholderStyle = (color2) => ({
    // Firefox
    "&::-moz-placeholder": {
      opacity: 1
    },
    "&::placeholder": {
      color: color2,
      userSelect: "none"
      // https://github.com/ant-design/ant-design/pull/32639
    },
    "&:placeholder-shown": {
      textOverflow: "ellipsis"
    }
  });
  const genHoverStyle = (token2) => ({
    borderColor: token2.inputBorderHoverColor,
    borderInlineEndWidth: token2.lineWidth
  });
  const genActiveStyle = (token2) => ({
    borderColor: token2.inputBorderHoverColor,
    boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
    borderInlineEndWidth: token2.lineWidth,
    outline: 0
  });
  const genDisabledStyle = (token2) => ({
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    borderColor: token2.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "&:hover": _extends$1({}, genHoverStyle(merge$2(token2, {
      inputBorderHoverColor: token2.colorBorder
    })))
  });
  const genInputLargeStyle = (token2) => {
    const {
      inputPaddingVerticalLG,
      fontSizeLG,
      lineHeightLG,
      borderRadiusLG,
      inputPaddingHorizontalLG
    } = token2;
    return {
      padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
      fontSize: fontSizeLG,
      lineHeight: lineHeightLG,
      borderRadius: borderRadiusLG
    };
  };
  const genInputSmallStyle = (token2) => ({
    padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
    borderRadius: token2.borderRadiusSM
  });
  const genStatusStyle = (token2, parentCls) => {
    const {
      componentCls,
      colorError,
      colorWarning,
      colorErrorOutline,
      colorWarningOutline,
      colorErrorBorderHover,
      colorWarningBorderHover
    } = token2;
    return {
      [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorError,
        "&:hover": {
          borderColor: colorErrorBorderHover
        },
        "&:focus, &-focused": _extends$1({}, genActiveStyle(merge$2(token2, {
          inputBorderActiveColor: colorError,
          inputBorderHoverColor: colorError,
          controlOutline: colorErrorOutline
        }))),
        [`${componentCls}-prefix`]: {
          color: colorError
        }
      },
      [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorWarning,
        "&:hover": {
          borderColor: colorWarningBorderHover
        },
        "&:focus, &-focused": _extends$1({}, genActiveStyle(merge$2(token2, {
          inputBorderActiveColor: colorWarning,
          inputBorderHoverColor: colorWarning,
          controlOutline: colorWarningOutline
        }))),
        [`${componentCls}-prefix`]: {
          color: colorWarning
        }
      }
    };
  };
  const genBasicInputStyle = (token2) => _extends$1(_extends$1({
    position: "relative",
    display: "inline-block",
    width: "100%",
    minWidth: 0,
    padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    backgroundColor: token2.colorBgContainer,
    backgroundImage: "none",
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: token2.colorBorder,
    borderRadius: token2.borderRadius,
    transition: `all ${token2.motionDurationMid}`
  }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
    "&:hover": _extends$1({}, genHoverStyle(token2)),
    "&:focus, &-focused": _extends$1({}, genActiveStyle(token2)),
    "&-disabled, &[disabled]": _extends$1({}, genDisabledStyle(token2)),
    "&-borderless": {
      "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
        backgroundColor: "transparent",
        border: "none",
        boxShadow: "none"
      }
    },
    // Reset height for `textarea`s
    "textarea&": {
      maxWidth: "100%",
      height: "auto",
      minHeight: token2.controlHeight,
      lineHeight: token2.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${token2.motionDurationSlow}, height 0s`,
      resize: "vertical"
    },
    // Size
    "&-lg": _extends$1({}, genInputLargeStyle(token2)),
    "&-sm": _extends$1({}, genInputSmallStyle(token2)),
    // RTL
    "&-rtl": {
      direction: "rtl"
    },
    "&-textarea-rtl": {
      direction: "rtl"
    }
  });
  const genInputGroupStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      // Undo padding and float of grid classes
      [`&[class*='col-']`]: {
        paddingInlineEnd: token2.paddingXS,
        "&:last-child": {
          paddingInlineEnd: 0
        }
      },
      // Sizing options
      [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: _extends$1({}, genInputLargeStyle(token2)),
      [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: _extends$1({}, genInputSmallStyle(token2)),
      [`> ${componentCls}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      [`${componentCls}-group`]: {
        [`&-addon, &-wrap`]: {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        "&-wrap > *": {
          display: "block !important"
        },
        "&-addon": {
          position: "relative",
          padding: `0 ${token2.inputPaddingHorizontal}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          textAlign: "center",
          backgroundColor: token2.colorFillAlter,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`,
          lineHeight: 1,
          // Reset Select's style in addon
          [`${antCls}-select`]: {
            margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
            [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
              [`${antCls}-select-selector`]: {
                backgroundColor: "inherit",
                border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                boxShadow: "none"
              }
            },
            "&-open, &-focused": {
              [`${antCls}-select-selector`]: {
                color: token2.colorPrimary
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/31333
          [`${antCls}-cascader-picker`]: {
            margin: `-9px -${token2.inputPaddingHorizontal}px`,
            backgroundColor: "transparent",
            [`${antCls}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none"
            }
          }
        },
        "&-addon:first-child": {
          borderInlineEnd: 0
        },
        "&-addon:last-child": {
          borderInlineStart: 0
        }
      },
      [`${componentCls}`]: {
        float: "inline-start",
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": {
          zIndex: 1,
          borderInlineEndWidth: 1
        },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }
      },
      // Reset rounded corners
      [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}-affix-wrapper`]: {
        [`&:not(:first-child) ${componentCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        },
        [`&:not(:last-child) ${componentCls}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${componentCls}-search &`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          }
        },
        [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&${componentCls}-group-compact`]: _extends$1(_extends$1({
        display: "block"
      }, clearFix()), {
        [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
          "&:not(:first-child):not(:last-child)": {
            borderInlineEndWidth: token2.lineWidth,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          }
        },
        "& > *": {
          display: "inline-block",
          float: "none",
          verticalAlign: "top",
          borderRadius: 0
        },
        [`& > ${componentCls}-affix-wrapper`]: {
          display: "inline-flex"
        },
        [`& > ${antCls}-picker-range`]: {
          display: "inline-flex"
        },
        "& > *:not(:last-child)": {
          marginInlineEnd: -token2.lineWidth,
          borderInlineEndWidth: token2.lineWidth
        },
        // Undo float for .ant-input-group .ant-input
        [`${componentCls}`]: {
          float: "none"
        },
        // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
        [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderRadius: 0,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        },
        [`& > ${antCls}-select-focused`]: {
          zIndex: 1
        },
        // update z-index for arrow icon
        [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
          zIndex: 1
          // https://github.com/ant-design/ant-design/issues/20371
        },
        [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        },
        [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderStartEndRadius: token2.borderRadius,
          borderEndEndRadius: token2.borderRadius
        },
        // https://github.com/ant-design/ant-design/issues/12493
        [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
          verticalAlign: "top"
        },
        [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
          marginInlineStart: -token2.lineWidth,
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`${componentCls}-group-wrapper:not(:last-child)`]: {
          [`&${componentCls}-search > ${componentCls}-group`]: {
            [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
              borderRadius: 0
            },
            [`& > ${componentCls}`]: {
              borderStartStartRadius: token2.borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: token2.borderRadius
            }
          }
        }
      }),
      [`&&-sm ${antCls}-btn`]: {
        fontSize: token2.fontSizeSM,
        height: token2.controlHeightSM,
        lineHeight: "normal"
      },
      [`&&-lg ${antCls}-btn`]: {
        fontSize: token2.fontSizeLG,
        height: token2.controlHeightLG,
        lineHeight: "normal"
      },
      // Fix https://github.com/ant-design/ant-design/issues/5754
      [`&&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
        height: `${token2.controlHeightLG}px`,
        [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
          // -2 is for the border size & override default
          lineHeight: `${token2.controlHeightLG - 2}px`
        },
        [`${antCls}-select-selection-search-input`]: {
          height: `${token2.controlHeightLG}px`
        }
      },
      [`&&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
        height: `${token2.controlHeightSM}px`,
        [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
          // -2 is for the border size & override default
          lineHeight: `${token2.controlHeightSM - 2}px`
        },
        [`${antCls}-select-selection-search-input`]: {
          height: `${token2.controlHeightSM}px`
        }
      }
    };
  };
  const genInputStyle = (token2) => {
    const {
      componentCls,
      controlHeightSM,
      lineWidth
    } = token2;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
    return {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
        '&[type="color"]': {
          height: token2.controlHeight,
          [`&${componentCls}-lg`]: {
            height: token2.controlHeightLG
          },
          [`&${componentCls}-sm`]: {
            height: controlHeightSM,
            paddingTop: colorSmallPadding,
            paddingBottom: colorSmallPadding
          }
        }
      })
    };
  };
  const genAllowClearStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // ========================= Input =========================
      [`${componentCls}-clear-icon`]: {
        margin: 0,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        verticalAlign: -1,
        // https://github.com/ant-design/ant-design/pull/18151
        // https://codesandbox.io/s/wizardly-sun-u10br
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextTertiary
        },
        "&:active": {
          color: token2.colorText
        },
        "&-hidden": {
          visibility: "hidden"
        },
        "&-has-suffix": {
          margin: `0 ${token2.inputAffixPadding}px`
        }
      },
      // ======================= TextArea ========================
      "&-textarea-with-clear-btn": {
        padding: "0 !important",
        border: "0 !important",
        [`${componentCls}-clear-icon`]: {
          position: "absolute",
          insetBlockStart: token2.paddingXS,
          insetInlineEnd: token2.paddingXS,
          zIndex: 1
        }
      }
    };
  };
  const genAffixStyle = (token2) => {
    const {
      componentCls,
      inputAffixPadding,
      colorTextDescription,
      motionDurationSlow,
      colorIcon,
      colorIconHover,
      iconCls
    } = token2;
    return {
      [`${componentCls}-affix-wrapper`]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genBasicInputStyle(token2)), {
        display: "inline-flex",
        [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: _extends$1(_extends$1({}, genHoverStyle(token2)), {
          zIndex: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }),
        "&-focused, &:focus": {
          zIndex: 1
        },
        "&-disabled": {
          [`${componentCls}[disabled]`]: {
            background: "transparent"
          }
        },
        [`> input${componentCls}`]: {
          padding: 0,
          fontSize: "inherit",
          border: "none",
          borderRadius: 0,
          outline: "none",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        "&::before": {
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [`${componentCls}`]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            "> *:not(:last-child)": {
              marginInlineEnd: token2.paddingXS
            }
          },
          "&-show-count-suffix": {
            color: colorTextDescription
          },
          "&-show-count-has-suffix": {
            marginInlineEnd: token2.paddingXXS
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            marginInlineStart: inputAffixPadding
          }
        }
      }), genAllowClearStyle(token2)), {
        // password
        [`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
    };
  };
  const genGroupStyle = (token2) => {
    const {
      componentCls,
      colorError,
      colorSuccess,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-group`]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genInputGroupStyle(token2)), {
        "&-rtl": {
          direction: "rtl"
        },
        "&-wrapper": {
          display: "inline-block",
          width: "100%",
          textAlign: "start",
          verticalAlign: "top",
          "&-rtl": {
            direction: "rtl"
          },
          // Size
          "&-lg": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG
            }
          },
          "&-sm": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          },
          // Status
          "&-status-error": {
            [`${componentCls}-group-addon`]: {
              color: colorError,
              borderColor: colorError
            }
          },
          "&-status-warning": {
            [`${componentCls}-group-addon:last-child`]: {
              color: colorSuccess,
              borderColor: colorSuccess
            }
          }
        }
      })
    };
  };
  const genSearchInputStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const searchPrefixCls = `${componentCls}-search`;
    return {
      [searchPrefixCls]: {
        [`${componentCls}`]: {
          "&:hover, &:focus": {
            borderColor: token2.colorPrimaryHover,
            [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              borderInlineStartColor: token2.colorPrimaryHover
            }
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        },
        // fix slight height diff in Firefox:
        // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
        [`${componentCls}-lg`]: {
          lineHeight: token2.lineHeightLG - 2e-4
        },
        [`> ${componentCls}-group`]: {
          [`> ${componentCls}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${searchPrefixCls}-button`]: {
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderStartEndRadius: token2.borderRadius,
              borderEndEndRadius: token2.borderRadius,
              borderEndStartRadius: 0
            },
            [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              color: token2.colorTextDescription,
              "&:hover": {
                color: token2.colorPrimaryHover
              },
              "&:active": {
                color: token2.colorPrimaryActive
              },
              [`&${antCls}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0
              }
            }
          }
        },
        [`${searchPrefixCls}-button`]: {
          height: token2.controlHeight,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        [`&-large ${searchPrefixCls}-button`]: {
          height: token2.controlHeightLG
        },
        [`&-small ${searchPrefixCls}-button`]: {
          height: token2.controlHeightSM
        },
        "&-rtl": {
          direction: "rtl"
        },
        // ===================== Compact Item Customized Styles =====================
        [`&${componentCls}-compact-item`]: {
          [`&:not(${componentCls}-compact-last-item)`]: {
            [`${componentCls}-group-addon`]: {
              [`${componentCls}-search-button`]: {
                marginInlineEnd: -token2.lineWidth,
                borderRadius: 0
              }
            }
          },
          [`&:not(${componentCls}-compact-first-item)`]: {
            [`${componentCls},${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
            "&:hover,&:focus,&:active": {
              zIndex: 2
            }
          },
          [`> ${componentCls}-affix-wrapper-focused`]: {
            zIndex: 2
          }
        }
      }
    };
  };
  function initInputToken(token2) {
    return merge$2(token2, {
      inputAffixPadding: token2.paddingXXS,
      inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
      inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
      inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
      inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
      inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
      inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
      inputBorderHoverColor: token2.colorPrimaryHover,
      inputBorderActiveColor: token2.colorPrimaryHover
    });
  }
  const genTextAreaStyle = (token2) => {
    const {
      componentCls,
      inputPaddingHorizontal,
      paddingLG
    } = token2;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
      [textareaPrefixCls]: {
        position: "relative",
        [`${textareaPrefixCls}-suffix`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: inputPaddingHorizontal,
          bottom: 0,
          zIndex: 1,
          display: "inline-flex",
          alignItems: "center",
          margin: "auto"
        },
        [`&-status-error,
        &-status-warning,
        &-status-success,
        &-status-validating`]: {
          [`&${textareaPrefixCls}-has-feedback`]: {
            [`${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          }
        },
        "&-show-count": {
          // https://github.com/ant-design/ant-design/issues/33049
          [`> ${componentCls}`]: {
            height: "100%"
          },
          "&::after": {
            color: token2.colorTextDescription,
            whiteSpace: "nowrap",
            content: "attr(data-count)",
            pointerEvents: "none",
            float: "right"
          }
        },
        "&-rtl": {
          "&::after": {
            float: "left"
          }
        }
      }
    };
  };
  const useStyle$9 = genComponentStyleHook("Input", (token2) => {
    const inputToken = initInputToken(token2);
    return [
      genInputStyle(inputToken),
      genTextAreaStyle(inputToken),
      genAffixStyle(inputToken),
      genGroupStyle(inputToken),
      genSearchInputStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)
    ];
  });
  const TreeContextKey = Symbol("TreeContextKey");
  const TreeContext = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "TreeContext",
    props: {
      value: {
        type: Object
      }
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      provide(TreeContextKey, computed(() => props2.value));
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const useInjectTreeContext = () => {
    return inject(TreeContextKey, computed(() => ({})));
  };
  const KeysStateKey = Symbol("KeysStateKey");
  const useProvideKeysState = (state) => {
    provide(KeysStateKey, state);
  };
  const useInjectKeysState = () => {
    return inject(KeysStateKey, {
      expandedKeys: shallowRef([]),
      selectedKeys: shallowRef([]),
      loadedKeys: shallowRef([]),
      loadingKeys: shallowRef([]),
      checkedKeys: shallowRef([]),
      halfCheckedKeys: shallowRef([]),
      expandedKeysSet: computed(() => /* @__PURE__ */ new Set()),
      selectedKeysSet: computed(() => /* @__PURE__ */ new Set()),
      loadedKeysSet: computed(() => /* @__PURE__ */ new Set()),
      loadingKeysSet: computed(() => /* @__PURE__ */ new Set()),
      checkedKeysSet: computed(() => /* @__PURE__ */ new Set()),
      halfCheckedKeysSet: computed(() => /* @__PURE__ */ new Set()),
      flattenNodes: shallowRef([])
    });
  };
  const Indent = (_ref) => {
    let {
      prefixCls,
      level,
      isStart,
      isEnd
    } = _ref;
    const baseClassName = `${prefixCls}-indent-unit`;
    const list2 = [];
    for (let i2 = 0; i2 < level; i2 += 1) {
      list2.push(createVNode("span", {
        "key": i2,
        "class": {
          [baseClassName]: true,
          [`${baseClassName}-start`]: isStart[i2],
          [`${baseClassName}-end`]: isEnd[i2]
        }
      }, null));
    }
    return createVNode("span", {
      "aria-hidden": "true",
      "class": `${prefixCls}-indent`
    }, [list2]);
  };
  const treeNodeProps = {
    eventKey: [String, Number],
    prefixCls: String,
    // By parent
    // expanded: { type: Boolean, default: undefined },
    // selected: { type: Boolean, default: undefined },
    // checked: { type: Boolean, default: undefined },
    // loaded: { type: Boolean, default: undefined },
    // loading: { type: Boolean, default: undefined },
    // halfChecked: { type: Boolean, default: undefined },
    // dragOver: { type: Boolean, default: undefined },
    // dragOverGapTop: { type: Boolean, default: undefined },
    // dragOverGapBottom: { type: Boolean, default: undefined },
    // pos: String,
    title: PropTypes.any,
    /** New added in Tree for easy data access */
    data: {
      type: Object,
      default: void 0
    },
    parent: {
      type: Object,
      default: void 0
    },
    isStart: {
      type: Array
    },
    isEnd: {
      type: Array
    },
    active: {
      type: Boolean,
      default: void 0
    },
    onMousemove: {
      type: Function
    },
    // By user
    isLeaf: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    selectable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    disableCheckbox: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes.any,
    switcherIcon: PropTypes.any,
    domRef: {
      type: Function
    }
  };
  const nodeListProps = {
    prefixCls: {
      type: String
    },
    // data: { type: Array as PropType<FlattenNode[]> },
    motion: {
      type: Object
    },
    focusable: {
      type: Boolean
    },
    activeItem: {
      type: Object
    },
    focused: {
      type: Boolean
    },
    tabindex: {
      type: Number
    },
    checkable: {
      type: Boolean
    },
    selectable: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    // expandedKeys: { type: Array as PropType<Key[]> },
    // selectedKeys: { type: Array as PropType<Key[]> },
    // checkedKeys: { type: Array as PropType<Key[]> },
    // loadedKeys: { type: Array as PropType<Key[]> },
    // loadingKeys: { type: Array as PropType<Key[]> },
    // halfCheckedKeys: { type: Array as PropType<Key[]> },
    // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
    // dragging: { type: Boolean as PropType<boolean> },
    // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
    // dropPosition: { type: Number as PropType<number> },
    // Virtual list
    height: {
      type: Number
    },
    itemHeight: {
      type: Number
    },
    virtual: {
      type: Boolean
    },
    onScroll: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onActiveChange: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onListChangeStart: {
      type: Function
    },
    onListChangeEnd: {
      type: Function
    }
  };
  const treeProps$1 = () => ({
    prefixCls: String,
    focusable: {
      type: Boolean,
      default: void 0
    },
    activeKey: [Number, String],
    tabindex: Number,
    children: PropTypes.any,
    treeData: {
      type: Array
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes.any,
    selectable: {
      type: Boolean,
      default: void 0
    },
    expandAction: [String, Boolean],
    disabled: {
      type: Boolean,
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    draggable: {
      type: [Function, Boolean]
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Object, Array]
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    allowDrop: {
      type: Function
    },
    dropIndicatorRender: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onDblclick: {
      type: Function
    },
    onScroll: {
      type: Function
    },
    onExpand: {
      type: Function
    },
    onCheck: {
      type: Function
    },
    onSelect: {
      type: Function
    },
    onLoad: {
      type: Function
    },
    loadData: {
      type: Function
    },
    loadedKeys: {
      type: Array
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onRightClick: {
      type: Function
    },
    onDragstart: {
      type: Function
    },
    onDragenter: {
      type: Function
    },
    onDragover: {
      type: Function
    },
    onDragleave: {
      type: Function
    },
    onDragend: {
      type: Function
    },
    onDrop: {
      type: Function
    },
    /**
     * Used for `rc-tree-select` only.
     * Do not use in your production code directly since this will be refactor.
     */
    onActiveChange: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    motion: PropTypes.any,
    switcherIcon: PropTypes.any,
    // Virtual List
    height: Number,
    itemHeight: Number,
    virtual: {
      type: Boolean,
      default: void 0
    },
    // direction for drag logic
    direction: {
      type: String
    },
    rootClassName: String,
    rootStyle: Object
  });
  var __rest$l = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const ICON_OPEN = "open";
  const ICON_CLOSE = "close";
  const defaultTitle = "---";
  const VcTreeNode = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATreeNode",
    inheritAttrs: false,
    props: treeNodeProps,
    isTreeNode: 1,
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        expose
      } = _ref;
      warning$3(!("slots" in props2.data), `treeData slots is deprecated, please use ${Object.keys(props2.data.slots || {}).map((key2) => "`v-slot:" + key2 + "` ")}instead`);
      const dragNodeHighlight = shallowRef(false);
      const context = useInjectTreeContext();
      const {
        expandedKeysSet,
        selectedKeysSet,
        loadedKeysSet,
        loadingKeysSet,
        checkedKeysSet,
        halfCheckedKeysSet
      } = useInjectKeysState();
      const {
        dragOverNodeKey,
        dropPosition,
        keyEntities
      } = context.value;
      const mergedTreeNodeProps = computed(() => {
        return getTreeNodeProps(props2.eventKey, {
          expandedKeysSet: expandedKeysSet.value,
          selectedKeysSet: selectedKeysSet.value,
          loadedKeysSet: loadedKeysSet.value,
          loadingKeysSet: loadingKeysSet.value,
          checkedKeysSet: checkedKeysSet.value,
          halfCheckedKeysSet: halfCheckedKeysSet.value,
          dragOverNodeKey,
          dropPosition,
          keyEntities
        });
      });
      const expanded = eagerComputed(() => mergedTreeNodeProps.value.expanded);
      const selected = eagerComputed(() => mergedTreeNodeProps.value.selected);
      const checked = eagerComputed(() => mergedTreeNodeProps.value.checked);
      const loaded = eagerComputed(() => mergedTreeNodeProps.value.loaded);
      const loading = eagerComputed(() => mergedTreeNodeProps.value.loading);
      const halfChecked = eagerComputed(() => mergedTreeNodeProps.value.halfChecked);
      const dragOver = eagerComputed(() => mergedTreeNodeProps.value.dragOver);
      const dragOverGapTop = eagerComputed(() => mergedTreeNodeProps.value.dragOverGapTop);
      const dragOverGapBottom = eagerComputed(() => mergedTreeNodeProps.value.dragOverGapBottom);
      const pos = eagerComputed(() => mergedTreeNodeProps.value.pos);
      const selectHandle = shallowRef();
      const hasChildren = computed(() => {
        const {
          eventKey
        } = props2;
        const {
          keyEntities: keyEntities2
        } = context.value;
        const {
          children
        } = keyEntities2[eventKey] || {};
        return !!(children || []).length;
      });
      const isLeaf = computed(() => {
        const {
          isLeaf: isLeaf2
        } = props2;
        const {
          loadData
        } = context.value;
        const has = hasChildren.value;
        if (isLeaf2 === false) {
          return false;
        }
        return isLeaf2 || !loadData && !has || loadData && loaded.value && !has;
      });
      const nodeState = computed(() => {
        if (isLeaf.value) {
          return null;
        }
        return expanded.value ? ICON_OPEN : ICON_CLOSE;
      });
      const isDisabled = computed(() => {
        const {
          disabled
        } = props2;
        const {
          disabled: treeDisabled
        } = context.value;
        return !!(treeDisabled || disabled);
      });
      const isCheckable = computed(() => {
        const {
          checkable
        } = props2;
        const {
          checkable: treeCheckable
        } = context.value;
        if (!treeCheckable || checkable === false) return false;
        return treeCheckable;
      });
      const isSelectable = computed(() => {
        const {
          selectable
        } = props2;
        const {
          selectable: treeSelectable
        } = context.value;
        if (typeof selectable === "boolean") {
          return selectable;
        }
        return treeSelectable;
      });
      const renderArgsData = computed(() => {
        const {
          data,
          active,
          checkable,
          disableCheckbox,
          disabled,
          selectable
        } = props2;
        return _extends$1(_extends$1({
          active,
          checkable,
          disableCheckbox,
          disabled,
          selectable
        }, data), {
          dataRef: data,
          data,
          isLeaf: isLeaf.value,
          checked: checked.value,
          expanded: expanded.value,
          loading: loading.value,
          selected: selected.value,
          halfChecked: halfChecked.value
        });
      });
      const instance = getCurrentInstance();
      const eventData = computed(() => {
        const {
          eventKey
        } = props2;
        const {
          keyEntities: keyEntities2
        } = context.value;
        const {
          parent: parent2
        } = keyEntities2[eventKey] || {};
        return _extends$1(_extends$1({}, convertNodePropsToEventData(_extends$1({}, props2, mergedTreeNodeProps.value))), {
          parent: parent2
        });
      });
      const dragNodeEvent = reactive({
        eventData,
        eventKey: computed(() => props2.eventKey),
        selectHandle,
        pos,
        key: instance.vnode.key
      });
      expose(dragNodeEvent);
      const onSelectorDoubleClick = (e2) => {
        const {
          onNodeDoubleClick
        } = context.value;
        onNodeDoubleClick(e2, eventData.value);
      };
      const onSelect = (e2) => {
        if (isDisabled.value) return;
        const {
          onNodeSelect
        } = context.value;
        e2.preventDefault();
        onNodeSelect(e2, eventData.value);
      };
      const onCheck = (e2) => {
        if (isDisabled.value) return;
        const {
          disableCheckbox
        } = props2;
        const {
          onNodeCheck
        } = context.value;
        if (!isCheckable.value || disableCheckbox) return;
        e2.preventDefault();
        const targetChecked = !checked.value;
        onNodeCheck(e2, eventData.value, targetChecked);
      };
      const onSelectorClick = (e2) => {
        const {
          onNodeClick
        } = context.value;
        onNodeClick(e2, eventData.value);
        if (isSelectable.value) {
          onSelect(e2);
        } else {
          onCheck(e2);
        }
      };
      const onMouseEnter = (e2) => {
        const {
          onNodeMouseEnter
        } = context.value;
        onNodeMouseEnter(e2, eventData.value);
      };
      const onMouseLeave = (e2) => {
        const {
          onNodeMouseLeave
        } = context.value;
        onNodeMouseLeave(e2, eventData.value);
      };
      const onContextmenu = (e2) => {
        const {
          onNodeContextMenu
        } = context.value;
        onNodeContextMenu(e2, eventData.value);
      };
      const onDragStart = (e2) => {
        const {
          onNodeDragStart
        } = context.value;
        e2.stopPropagation();
        dragNodeHighlight.value = true;
        onNodeDragStart(e2, dragNodeEvent);
        try {
          e2.dataTransfer.setData("text/plain", "");
        } catch (error) {
        }
      };
      const onDragEnter = (e2) => {
        const {
          onNodeDragEnter
        } = context.value;
        e2.preventDefault();
        e2.stopPropagation();
        onNodeDragEnter(e2, dragNodeEvent);
      };
      const onDragOver = (e2) => {
        const {
          onNodeDragOver
        } = context.value;
        e2.preventDefault();
        e2.stopPropagation();
        onNodeDragOver(e2, dragNodeEvent);
      };
      const onDragLeave = (e2) => {
        const {
          onNodeDragLeave
        } = context.value;
        e2.stopPropagation();
        onNodeDragLeave(e2, dragNodeEvent);
      };
      const onDragEnd = (e2) => {
        const {
          onNodeDragEnd
        } = context.value;
        e2.stopPropagation();
        dragNodeHighlight.value = false;
        onNodeDragEnd(e2, dragNodeEvent);
      };
      const onDrop = (e2) => {
        const {
          onNodeDrop
        } = context.value;
        e2.preventDefault();
        e2.stopPropagation();
        dragNodeHighlight.value = false;
        onNodeDrop(e2, dragNodeEvent);
      };
      const onExpand = (e2) => {
        const {
          onNodeExpand
        } = context.value;
        if (loading.value) return;
        onNodeExpand(e2, eventData.value);
      };
      const isDraggable = () => {
        const {
          data
        } = props2;
        const {
          draggable
        } = context.value;
        return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
      };
      const renderDragHandler = () => {
        const {
          draggable,
          prefixCls
        } = context.value;
        return draggable && (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? createVNode("span", {
          "class": `${prefixCls}-draggable-icon`
        }, [draggable.icon]) : null;
      };
      const renderSwitcherIconDom = () => {
        var _a2, _b2, _c2;
        const {
          switcherIcon: switcherIconFromProps = slots.switcherIcon || ((_a2 = context.value.slots) === null || _a2 === void 0 ? void 0 : _a2[(_c2 = (_b2 = props2.data) === null || _b2 === void 0 ? void 0 : _b2.slots) === null || _c2 === void 0 ? void 0 : _c2.switcherIcon])
        } = props2;
        const {
          switcherIcon: switcherIconFromCtx
        } = context.value;
        const switcherIcon = switcherIconFromProps || switcherIconFromCtx;
        if (typeof switcherIcon === "function") {
          return switcherIcon(renderArgsData.value);
        }
        return switcherIcon;
      };
      const syncLoadData = () => {
        const {
          loadData,
          onNodeLoad
        } = context.value;
        if (loading.value) {
          return;
        }
        if (loadData && expanded.value && !isLeaf.value) {
          if (!hasChildren.value && !loaded.value) {
            onNodeLoad(eventData.value);
          }
        }
      };
      onMounted(() => {
        syncLoadData();
      });
      onUpdated(() => {
        syncLoadData();
      });
      const renderSwitcher = () => {
        const {
          prefixCls
        } = context.value;
        const switcherIconDom = renderSwitcherIconDom();
        if (isLeaf.value) {
          return switcherIconDom !== false ? createVNode("span", {
            "class": classNames(`${prefixCls}-switcher`, `${prefixCls}-switcher-noop`)
          }, [switcherIconDom]) : null;
        }
        const switcherCls = classNames(`${prefixCls}-switcher`, `${prefixCls}-switcher_${expanded.value ? ICON_OPEN : ICON_CLOSE}`);
        return switcherIconDom !== false ? createVNode("span", {
          "onClick": onExpand,
          "class": switcherCls
        }, [switcherIconDom]) : null;
      };
      const renderCheckbox = () => {
        var _a2, _b2;
        const {
          disableCheckbox
        } = props2;
        const {
          prefixCls
        } = context.value;
        const disabled = isDisabled.value;
        const checkable = isCheckable.value;
        if (!checkable) return null;
        return createVNode("span", {
          "class": classNames(`${prefixCls}-checkbox`, checked.value && `${prefixCls}-checkbox-checked`, !checked.value && halfChecked.value && `${prefixCls}-checkbox-indeterminate`, (disabled || disableCheckbox) && `${prefixCls}-checkbox-disabled`),
          "onClick": onCheck
        }, [(_b2 = (_a2 = context.value).customCheckable) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)]);
      };
      const renderIcon = () => {
        const {
          prefixCls
        } = context.value;
        return createVNode("span", {
          "class": classNames(`${prefixCls}-iconEle`, `${prefixCls}-icon__${nodeState.value || "docu"}`, loading.value && `${prefixCls}-icon_loading`)
        }, null);
      };
      const renderDropIndicator = () => {
        const {
          disabled,
          eventKey
        } = props2;
        const {
          draggable,
          dropLevelOffset,
          dropPosition: dropPosition2,
          prefixCls,
          indent,
          dropIndicatorRender: dropIndicatorRender2,
          dragOverNodeKey: dragOverNodeKey2,
          direction
        } = context.value;
        const rootDraggable = draggable !== false;
        const showIndicator = !disabled && rootDraggable && dragOverNodeKey2 === eventKey;
        return showIndicator ? dropIndicatorRender2({
          dropPosition: dropPosition2,
          dropLevelOffset,
          indent,
          prefixCls,
          direction
        }) : null;
      };
      const renderSelector = () => {
        var _a2, _b2, _c2, _d, _e, _f;
        const {
          // title = slots.title ||
          //   context.value.slots?.[props.data?.slots?.title] ||
          //   context.value.slots?.title,
          // selected,
          icon = slots.icon,
          // loading,
          data
        } = props2;
        const title = slots.title || ((_a2 = context.value.slots) === null || _a2 === void 0 ? void 0 : _a2[(_c2 = (_b2 = props2.data) === null || _b2 === void 0 ? void 0 : _b2.slots) === null || _c2 === void 0 ? void 0 : _c2.title]) || ((_d = context.value.slots) === null || _d === void 0 ? void 0 : _d.title) || props2.title;
        const {
          prefixCls,
          showIcon,
          icon: treeIcon,
          loadData
          // slots: contextSlots,
        } = context.value;
        const disabled = isDisabled.value;
        const wrapClass = `${prefixCls}-node-content-wrapper`;
        let $icon;
        if (showIcon) {
          const currentIcon = icon || ((_e = context.value.slots) === null || _e === void 0 ? void 0 : _e[(_f = data === null || data === void 0 ? void 0 : data.slots) === null || _f === void 0 ? void 0 : _f.icon]) || treeIcon;
          $icon = currentIcon ? createVNode("span", {
            "class": classNames(`${prefixCls}-iconEle`, `${prefixCls}-icon__customize`)
          }, [typeof currentIcon === "function" ? currentIcon(renderArgsData.value) : currentIcon]) : renderIcon();
        } else if (loadData && loading.value) {
          $icon = renderIcon();
        }
        let titleNode;
        if (typeof title === "function") {
          titleNode = title(renderArgsData.value);
        } else {
          titleNode = title;
        }
        titleNode = titleNode === void 0 ? defaultTitle : titleNode;
        const $title = createVNode("span", {
          "class": `${prefixCls}-title`
        }, [titleNode]);
        return createVNode("span", {
          "ref": selectHandle,
          "title": typeof title === "string" ? title : "",
          "class": classNames(`${wrapClass}`, `${wrapClass}-${nodeState.value || "normal"}`, !disabled && (selected.value || dragNodeHighlight.value) && `${prefixCls}-node-selected`),
          "onMouseenter": onMouseEnter,
          "onMouseleave": onMouseLeave,
          "onContextmenu": onContextmenu,
          "onClick": onSelectorClick,
          "onDblclick": onSelectorDoubleClick
        }, [$icon, $title, renderDropIndicator()]);
      };
      return () => {
        const _a2 = _extends$1(_extends$1({}, props2), attrs), {
          eventKey,
          isLeaf: isLeaf2,
          isStart,
          isEnd,
          domRef,
          active,
          data,
          onMousemove,
          selectable
        } = _a2, otherProps = __rest$l(_a2, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]);
        const {
          prefixCls,
          filterTreeNode,
          keyEntities: keyEntities2,
          dropContainerKey,
          dropTargetKey,
          draggingNodeKey
        } = context.value;
        const disabled = isDisabled.value;
        const dataOrAriaAttributeProps = pickAttrs(otherProps, {
          aria: true,
          data: true
        });
        const {
          level
        } = keyEntities2[eventKey] || {};
        const isEndNode = isEnd[isEnd.length - 1];
        const mergedDraggable = isDraggable();
        const draggableWithoutDisabled = !disabled && mergedDraggable;
        const dragging = draggingNodeKey === eventKey;
        const ariaSelected = selectable !== void 0 ? {
          "aria-selected": !!selectable
        } : void 0;
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({
          "ref": domRef,
          "class": classNames(attrs.class, `${prefixCls}-treenode`, {
            [`${prefixCls}-treenode-disabled`]: disabled,
            [`${prefixCls}-treenode-switcher-${expanded.value ? "open" : "close"}`]: !isLeaf2,
            [`${prefixCls}-treenode-checkbox-checked`]: checked.value,
            [`${prefixCls}-treenode-checkbox-indeterminate`]: halfChecked.value,
            [`${prefixCls}-treenode-selected`]: selected.value,
            [`${prefixCls}-treenode-loading`]: loading.value,
            [`${prefixCls}-treenode-active`]: active,
            [`${prefixCls}-treenode-leaf-last`]: isEndNode,
            [`${prefixCls}-treenode-draggable`]: draggableWithoutDisabled,
            dragging,
            "drop-target": dropTargetKey === eventKey,
            "drop-container": dropContainerKey === eventKey,
            "drag-over": !disabled && dragOver.value,
            "drag-over-gap-top": !disabled && dragOverGapTop.value,
            "drag-over-gap-bottom": !disabled && dragOverGapBottom.value,
            "filter-node": filterTreeNode && filterTreeNode(eventData.value)
          }),
          "style": attrs.style,
          "draggable": draggableWithoutDisabled,
          "aria-grabbed": dragging,
          "onDragstart": draggableWithoutDisabled ? onDragStart : void 0,
          "onDragenter": mergedDraggable ? onDragEnter : void 0,
          "onDragover": mergedDraggable ? onDragOver : void 0,
          "onDragleave": mergedDraggable ? onDragLeave : void 0,
          "onDrop": mergedDraggable ? onDrop : void 0,
          "onDragend": mergedDraggable ? onDragEnd : void 0,
          "onMousemove": onMousemove
        }, ariaSelected), dataOrAriaAttributeProps), [createVNode(Indent, {
          "prefixCls": prefixCls,
          "level": level,
          "isStart": isStart,
          "isEnd": isEnd
        }, null), renderDragHandler(), renderSwitcher(), renderCheckbox(), renderSelector()]);
      };
    }
  });
  (function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  });
  function arrDel(list2, value) {
    if (!list2) return [];
    const clone2 = list2.slice();
    const index2 = clone2.indexOf(value);
    if (index2 >= 0) {
      clone2.splice(index2, 1);
    }
    return clone2;
  }
  function arrAdd(list2, value) {
    const clone2 = (list2 || []).slice();
    if (clone2.indexOf(value) === -1) {
      clone2.push(value);
    }
    return clone2;
  }
  function posToArr(pos) {
    return pos.split("-");
  }
  function getPosition(level, index2) {
    return `${level}-${index2}`;
  }
  function isTreeNode(node2) {
    return node2 && node2.type && node2.type.isTreeNode;
  }
  function getDragChildrenKeys(dragNodeKey, keyEntities) {
    const dragChildrenKeys = [];
    const entity = keyEntities[dragNodeKey];
    function dig() {
      let list2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      list2.forEach((_ref) => {
        let {
          key: key2,
          children
        } = _ref;
        dragChildrenKeys.push(key2);
        dig(children);
      });
    }
    dig(entity.children);
    return dragChildrenKeys;
  }
  function isLastChild(treeNodeEntity) {
    if (treeNodeEntity.parent) {
      const posArr = posToArr(treeNodeEntity.pos);
      return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
    }
    return false;
  }
  function isFirstChild(treeNodeEntity) {
    const posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === 0;
  }
  function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeysSet, direction) {
    var _a2;
    const {
      clientX,
      clientY
    } = event;
    const {
      top,
      height
    } = event.target.getBoundingClientRect();
    const horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
    const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
    let abstractDropNodeEntity = keyEntities[targetNode.eventKey];
    if (clientY < top + height / 2) {
      const nodeIndex = flattenedNodes.findIndex((flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key);
      const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
      const prevNodeKey = flattenedNodes[prevNodeIndex].key;
      abstractDropNodeEntity = keyEntities[prevNodeKey];
    }
    const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
    const abstractDragOverEntity = abstractDropNodeEntity;
    const dragOverNodeKey = abstractDropNodeEntity.key;
    let dropPosition = 0;
    let dropLevelOffset = 0;
    if (!expandKeysSet.has(initialAbstractDropNodeKey)) {
      for (let i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
        if (isLastChild(abstractDropNodeEntity)) {
          abstractDropNodeEntity = abstractDropNodeEntity.parent;
          dropLevelOffset += 1;
        } else {
          break;
        }
      }
    }
    const abstractDragDataNode = dragNode.eventData;
    const abstractDropDataNode = abstractDropNodeEntity.node;
    let dropAllowed = true;
    if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: -1
    }) && abstractDropNodeEntity.key === targetNode.eventKey) {
      dropPosition = -1;
    } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else {
        dropAllowed = false;
      }
    } else if (dropLevelOffset === 0) {
      if (rawDropLevelOffset > -1.5) {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      } else {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 0
        })) {
          dropPosition = 0;
        } else if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      }
    } else {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
    return {
      dropPosition,
      dropLevelOffset,
      dropTargetKey: abstractDropNodeEntity.key,
      dropTargetPos: abstractDropNodeEntity.pos,
      dragOverNodeKey,
      dropContainerKey: dropPosition === 0 ? null : ((_a2 = abstractDropNodeEntity.parent) === null || _a2 === void 0 ? void 0 : _a2.key) || null,
      dropAllowed
    };
  }
  function calcSelectedKeys(selectedKeys, props2) {
    if (!selectedKeys) return void 0;
    const {
      multiple
    } = props2;
    if (multiple) {
      return selectedKeys.slice();
    }
    if (selectedKeys.length) {
      return [selectedKeys[0]];
    }
    return selectedKeys;
  }
  function parseCheckedKeys(keys2) {
    if (!keys2) {
      return null;
    }
    let keyProps;
    if (Array.isArray(keys2)) {
      keyProps = {
        checkedKeys: keys2,
        halfCheckedKeys: void 0
      };
    } else if (typeof keys2 === "object") {
      keyProps = {
        checkedKeys: keys2.checked || void 0,
        halfCheckedKeys: keys2.halfChecked || void 0
      };
    } else {
      return null;
    }
    return keyProps;
  }
  function conductExpandParent(keyList, keyEntities) {
    const expandedKeys = /* @__PURE__ */ new Set();
    function conductUp(key2) {
      if (expandedKeys.has(key2)) return;
      const entity = keyEntities[key2];
      if (!entity) return;
      expandedKeys.add(key2);
      const {
        parent: parent2,
        node: node2
      } = entity;
      if (node2.disabled) return;
      if (parent2) {
        conductUp(parent2.key);
      }
    }
    (keyList || []).forEach((key2) => {
      conductUp(key2);
    });
    return [...expandedKeys];
  }
  var __rest$k = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function getKey$1(key2, pos) {
    if (key2 !== null && key2 !== void 0) {
      return key2;
    }
    return pos;
  }
  function fillFieldNames(fieldNames) {
    const {
      title,
      _title,
      key: key2,
      children
    } = fieldNames || {};
    const mergedTitle = title || "title";
    return {
      title: mergedTitle,
      _title: _title || [mergedTitle],
      key: key2 || "key",
      children: children || "children"
    };
  }
  function convertTreeToData(rootNodes) {
    function dig() {
      let node2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const treeNodes = filterEmpty(node2);
      return treeNodes.map((treeNode) => {
        var _a2, _b2, _c2, _d;
        if (!isTreeNode(treeNode)) {
          return null;
        }
        const slots = treeNode.children || {};
        const key2 = treeNode.key;
        const props2 = {};
        for (const [k2, v2] of Object.entries(treeNode.props)) {
          props2[camelize(k2)] = v2;
        }
        const {
          isLeaf,
          checkable,
          selectable,
          disabled,
          disableCheckbox
        } = props2;
        const newProps = {
          isLeaf: isLeaf || isLeaf === "" || void 0,
          checkable: checkable || checkable === "" || void 0,
          selectable: selectable || selectable === "" || void 0,
          disabled: disabled || disabled === "" || void 0,
          disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
        };
        const slotsProps = _extends$1(_extends$1({}, props2), newProps);
        const {
          title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots, slotsProps),
          icon = (_b2 = slots.icon) === null || _b2 === void 0 ? void 0 : _b2.call(slots, slotsProps),
          switcherIcon = (_c2 = slots.switcherIcon) === null || _c2 === void 0 ? void 0 : _c2.call(slots, slotsProps)
        } = props2, rest = __rest$k(props2, ["title", "icon", "switcherIcon"]);
        const children = (_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots);
        const dataNode = _extends$1(_extends$1(_extends$1({}, rest), {
          title,
          icon,
          switcherIcon,
          key: key2,
          isLeaf
        }), newProps);
        const parsedChildren = dig(children);
        if (parsedChildren.length) {
          dataNode.children = parsedChildren;
        }
        return dataNode;
      });
    }
    return dig(rootNodes);
  }
  function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
    const {
      _title: fieldTitles,
      key: fieldKey,
      children: fieldChildren
    } = fillFieldNames(fieldNames);
    const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
    const flattenList = [];
    function dig(list2) {
      let parent2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return list2.map((treeNode, index2) => {
        const pos = getPosition(parent2 ? parent2.pos : "0", index2);
        const mergedKey = getKey$1(treeNode[fieldKey], pos);
        let mergedTitle;
        for (let i2 = 0; i2 < fieldTitles.length; i2 += 1) {
          const fieldTitle = fieldTitles[i2];
          if (treeNode[fieldTitle] !== void 0) {
            mergedTitle = treeNode[fieldTitle];
            break;
          }
        }
        const flattenNode = _extends$1(_extends$1({}, omit$1(treeNode, [...fieldTitles, fieldKey, fieldChildren])), {
          title: mergedTitle,
          key: mergedKey,
          parent: parent2,
          pos,
          children: null,
          data: treeNode,
          isStart: [...parent2 ? parent2.isStart : [], index2 === 0],
          isEnd: [...parent2 ? parent2.isEnd : [], index2 === list2.length - 1]
        });
        flattenList.push(flattenNode);
        if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
          flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
        } else {
          flattenNode.children = [];
        }
        return flattenNode;
      });
    }
    dig(treeNodeList);
    return flattenList;
  }
  function traverseDataNodes(dataNodes, callback, config) {
    let mergedConfig = {};
    if (typeof config === "object") {
      mergedConfig = config;
    } else {
      mergedConfig = {
        externalGetKey: config
      };
    }
    mergedConfig = mergedConfig || {};
    const {
      childrenPropName,
      externalGetKey,
      fieldNames
    } = mergedConfig;
    const {
      key: fieldKey,
      children: fieldChildren
    } = fillFieldNames(fieldNames);
    const mergeChildrenPropName = childrenPropName || fieldChildren;
    let syntheticGetKey;
    if (externalGetKey) {
      if (typeof externalGetKey === "string") {
        syntheticGetKey = (node2) => node2[externalGetKey];
      } else if (typeof externalGetKey === "function") {
        syntheticGetKey = (node2) => externalGetKey(node2);
      }
    } else {
      syntheticGetKey = (node2, pos) => getKey$1(node2[fieldKey], pos);
    }
    function processNode(node2, index2, parent2, pathNodes) {
      const children = node2 ? node2[mergeChildrenPropName] : dataNodes;
      const pos = node2 ? getPosition(parent2.pos, index2) : "0";
      const connectNodes = node2 ? [...pathNodes, node2] : [];
      if (node2) {
        const key2 = syntheticGetKey(node2, pos);
        const data = {
          node: node2,
          index: index2,
          pos,
          key: key2,
          parentPos: parent2.node ? parent2.pos : null,
          level: parent2.level + 1,
          nodes: connectNodes
        };
        callback(data);
      }
      if (children) {
        children.forEach((subNode, subIndex) => {
          processNode(subNode, subIndex, {
            node: node2,
            pos,
            level: parent2 ? parent2.level + 1 : -1
          }, connectNodes);
        });
      }
    }
    processNode(null);
  }
  function convertDataToEntities(dataNodes) {
    let {
      initWrapper,
      processEntity,
      onProcessFinished,
      externalGetKey,
      childrenPropName,
      fieldNames
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
    const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
    const posEntities = {};
    const keyEntities = {};
    let wrapper = {
      posEntities,
      keyEntities
    };
    if (initWrapper) {
      wrapper = initWrapper(wrapper) || wrapper;
    }
    traverseDataNodes(dataNodes, (item) => {
      const {
        node: node2,
        index: index2,
        pos,
        key: key2,
        parentPos,
        level,
        nodes
      } = item;
      const entity = {
        node: node2,
        nodes,
        index: index2,
        key: key2,
        pos,
        level
      };
      const mergedKey = getKey$1(key2, pos);
      posEntities[pos] = entity;
      keyEntities[mergedKey] = entity;
      entity.parent = posEntities[parentPos];
      if (entity.parent) {
        entity.parent.children = entity.parent.children || [];
        entity.parent.children.push(entity);
      }
      if (processEntity) {
        processEntity(entity, wrapper);
      }
    }, {
      externalGetKey: mergedExternalGetKey,
      childrenPropName,
      fieldNames
    });
    if (onProcessFinished) {
      onProcessFinished(wrapper);
    }
    return wrapper;
  }
  function getTreeNodeProps(key2, _ref) {
    let {
      expandedKeysSet,
      selectedKeysSet,
      loadedKeysSet,
      loadingKeysSet,
      checkedKeysSet,
      halfCheckedKeysSet,
      dragOverNodeKey,
      dropPosition,
      keyEntities
    } = _ref;
    const entity = keyEntities[key2];
    const treeNodeProps2 = {
      eventKey: key2,
      expanded: expandedKeysSet.has(key2),
      selected: selectedKeysSet.has(key2),
      loaded: loadedKeysSet.has(key2),
      loading: loadingKeysSet.has(key2),
      checked: checkedKeysSet.has(key2),
      halfChecked: halfCheckedKeysSet.has(key2),
      pos: String(entity ? entity.pos : ""),
      parent: entity.parent,
      // [Legacy] Drag props
      // Since the interaction of drag is changed, the semantic of the props are
      // not accuracy, I think it should be finally removed
      dragOver: dragOverNodeKey === key2 && dropPosition === 0,
      dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
      dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
    };
    return treeNodeProps2;
  }
  function convertNodePropsToEventData(props2) {
    const {
      data,
      expanded,
      selected,
      checked,
      loaded,
      loading,
      halfChecked,
      dragOver,
      dragOverGapTop,
      dragOverGapBottom,
      pos,
      active,
      eventKey
    } = props2;
    const eventData = _extends$1(_extends$1({
      dataRef: data
    }, data), {
      expanded,
      selected,
      checked,
      loaded,
      loading,
      halfChecked,
      dragOver,
      dragOverGapTop,
      dragOverGapBottom,
      pos,
      active,
      eventKey,
      key: eventKey
    });
    if (!("props" in eventData)) {
      Object.defineProperty(eventData, "props", {
        get() {
          return props2;
        }
      });
    }
    return eventData;
  }
  function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
    const filteredKeys = /* @__PURE__ */ new Set();
    halfCheckedKeys.forEach((key2) => {
      if (!checkedKeys.has(key2)) {
        filteredKeys.add(key2);
      }
    });
    return filteredKeys;
  }
  function isCheckDisabled(node2) {
    const {
      disabled,
      disableCheckbox,
      checkable
    } = node2 || {};
    return !!(disabled || disableCheckbox) || checkable === false;
  }
  function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    const checkedKeys = new Set(keys2);
    const halfCheckedKeys = /* @__PURE__ */ new Set();
    for (let level = 0; level <= maxLevel; level += 1) {
      const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach((entity) => {
        const {
          key: key2,
          node: node2,
          children = []
        } = entity;
        if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node2)) {
          children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
            checkedKeys.add(childEntity.key);
          });
        }
      });
    }
    const visitedKeys = /* @__PURE__ */ new Set();
    for (let level = maxLevel; level >= 0; level -= 1) {
      const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach((entity) => {
        const {
          parent: parent2,
          node: node2
        } = entity;
        if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
          return;
        }
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent2.key);
          return;
        }
        let allChecked = true;
        let partialChecked = false;
        (parent2.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((_ref) => {
          let {
            key: key2
          } = _ref;
          const checked = checkedKeys.has(key2);
          if (allChecked && !checked) {
            allChecked = false;
          }
          if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
            partialChecked = true;
          }
        });
        if (allChecked) {
          checkedKeys.add(parent2.key);
        }
        if (partialChecked) {
          halfCheckedKeys.add(parent2.key);
        }
        visitedKeys.add(parent2.key);
      });
    }
    return {
      checkedKeys: Array.from(checkedKeys),
      halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
  }
  function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    const checkedKeys = new Set(keys2);
    let halfCheckedKeys = new Set(halfKeys);
    for (let level = 0; level <= maxLevel; level += 1) {
      const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach((entity) => {
        const {
          key: key2,
          node: node2,
          children = []
        } = entity;
        if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node2)) {
          children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
            checkedKeys.delete(childEntity.key);
          });
        }
      });
    }
    halfCheckedKeys = /* @__PURE__ */ new Set();
    const visitedKeys = /* @__PURE__ */ new Set();
    for (let level = maxLevel; level >= 0; level -= 1) {
      const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
      entities.forEach((entity) => {
        const {
          parent: parent2,
          node: node2
        } = entity;
        if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
          return;
        }
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent2.key);
          return;
        }
        let allChecked = true;
        let partialChecked = false;
        (parent2.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((_ref2) => {
          let {
            key: key2
          } = _ref2;
          const checked = checkedKeys.has(key2);
          if (allChecked && !checked) {
            allChecked = false;
          }
          if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
            partialChecked = true;
          }
        });
        if (!allChecked) {
          checkedKeys.delete(parent2.key);
        }
        if (partialChecked) {
          halfCheckedKeys.add(parent2.key);
        }
        visitedKeys.add(parent2.key);
      });
    }
    return {
      checkedKeys: Array.from(checkedKeys),
      halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
  }
  function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {
    let syntheticGetCheckDisabled;
    if (getCheckDisabled) {
      syntheticGetCheckDisabled = getCheckDisabled;
    } else {
      syntheticGetCheckDisabled = isCheckDisabled;
    }
    const keys2 = new Set(keyList.filter((key2) => {
      const hasEntity = !!keyEntities[key2];
      return hasEntity;
    }));
    let result;
    if (checked === true) {
      result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
    } else {
      result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
    }
    return result;
  }
  function useMaxLevel(keyEntities) {
    const maxLevel = ref(0);
    const levelEntities = shallowRef();
    watchEffect(() => {
      const newLevelEntities = /* @__PURE__ */ new Map();
      let newMaxLevel = 0;
      const keyEntitiesValue = keyEntities.value || {};
      for (const key2 in keyEntitiesValue) {
        if (Object.prototype.hasOwnProperty.call(keyEntitiesValue, key2)) {
          const entity = keyEntitiesValue[key2];
          const {
            level
          } = entity;
          let levelSet = newLevelEntities.get(level);
          if (!levelSet) {
            levelSet = /* @__PURE__ */ new Set();
            newLevelEntities.set(level, levelSet);
          }
          levelSet.add(entity);
          newMaxLevel = Math.max(newMaxLevel, level);
        }
      }
      maxLevel.value = newMaxLevel;
      levelEntities.value = newLevelEntities;
    });
    return {
      maxLevel,
      levelEntities
    };
  }
  var LeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
  function _objectSpread$f(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$f(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$f(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var LeftOutlined = function LeftOutlined2(props2, context) {
    var p2 = _objectSpread$f({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$f({}, p2, {
      "icon": LeftOutlined$1
    }), null);
  };
  LeftOutlined.displayName = "LeftOutlined";
  LeftOutlined.inheritAttrs = false;
  const canUseDocElement = () => canUseDom$1() && window.document.documentElement;
  const isStyleNameSupport = (styleName) => {
    if (canUseDom$1() && window.document.documentElement) {
      const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
      const {
        documentElement
      } = window.document;
      return styleNameList.some((name) => name in documentElement.style);
    }
    return false;
  };
  const isStyleValueSupport = (styleName, value) => {
    if (!isStyleNameSupport(styleName)) {
      return false;
    }
    const ele = document.createElement("div");
    const origin2 = ele.style[styleName];
    ele.style[styleName] = value;
    return ele.style[styleName] !== origin2;
  };
  function isStyleSupport(styleName, styleValue) {
    if (!Array.isArray(styleName) && styleValue !== void 0) {
      return isStyleValueSupport(styleName, styleValue);
    }
    return isStyleNameSupport(styleName);
  }
  let flexGapSupported;
  const detectFlexGapSupported = () => {
    if (!canUseDocElement()) {
      return false;
    }
    if (flexGapSupported !== void 0) {
      return flexGapSupported;
    }
    const flex = document.createElement("div");
    flex.style.display = "flex";
    flex.style.flexDirection = "column";
    flex.style.rowGap = "1px";
    flex.appendChild(document.createElement("div"));
    flex.appendChild(document.createElement("div"));
    document.body.appendChild(flex);
    flexGapSupported = flex.scrollHeight === 1;
    document.body.removeChild(flex);
    return flexGapSupported;
  };
  const useFlexGapSupport = () => {
    const flexible = shallowRef(false);
    onMounted(() => {
      flexible.value = detectFlexGapSupported();
    });
    return flexible;
  };
  const RowContextKey = Symbol("rowContextKey");
  const useProvideRow = (state) => {
    provide(RowContextKey, state);
  };
  const useInjectRow = () => {
    return inject(RowContextKey, {
      gutter: computed(() => void 0),
      wrap: computed(() => void 0),
      supportFlexGap: computed(() => void 0)
    });
  };
  const genGridRowStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        display: "flex",
        flexFlow: "row wrap",
        minWidth: 0,
        "&::before, &::after": {
          display: "flex"
        },
        "&-no-wrap": {
          flexWrap: "nowrap"
        },
        // The origin of the X-axis
        "&-start": {
          justifyContent: "flex-start"
        },
        // The center of the X-axis
        "&-center": {
          justifyContent: "center"
        },
        // The opposite of the X-axis
        "&-end": {
          justifyContent: "flex-end"
        },
        "&-space-between": {
          justifyContent: "space-between"
        },
        "&-space-around ": {
          justifyContent: "space-around"
        },
        "&-space-evenly ": {
          justifyContent: "space-evenly"
        },
        // Align at the top
        "&-top": {
          alignItems: "flex-start"
        },
        // Align at the center
        "&-middle": {
          alignItems: "center"
        },
        "&-bottom": {
          alignItems: "flex-end"
        }
      }
    };
  };
  const genGridColStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        position: "relative",
        maxWidth: "100%",
        // Prevent columns from collapsing when empty
        minHeight: 1
      }
    };
  };
  const genLoopGridColumnsStyle = (token2, sizeCls) => {
    const {
      componentCls,
      gridColumns
    } = token2;
    const gridColumnsStyle = {};
    for (let i2 = gridColumns; i2 >= 0; i2--) {
      if (i2 === 0) {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
          display: "none"
        };
        gridColumnsStyle[`${componentCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineEnd: 0
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: 0
        };
      } else {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
          display: "block",
          flex: `0 0 ${i2 / gridColumns * 100}%`,
          maxWidth: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: i2
        };
      }
    }
    return gridColumnsStyle;
  };
  const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
  const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
    [`@media (min-width: ${screenSize}px)`]: _extends$1({}, genGridStyle(token2, sizeCls))
  });
  const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
  const useColStyle = genComponentStyleHook("Grid", (token2) => {
    const gridToken = merge$2(token2, {
      gridColumns: 24
      // Row is divided into 24 parts in Grid
    });
    const gridMediaSizesMap = {
      "-sm": gridToken.screenSMMin,
      "-md": gridToken.screenMDMin,
      "-lg": gridToken.screenLGMin,
      "-xl": gridToken.screenXLMin,
      "-xxl": gridToken.screenXXLMin
    };
    return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key2) => genGridMediaStyle(gridToken, gridMediaSizesMap[key2], key2)).reduce((pre, cur) => _extends$1(_extends$1({}, pre), cur), {})];
  });
  const rowProps = () => ({
    align: someType([String, Object]),
    justify: someType([String, Object]),
    prefixCls: String,
    gutter: someType([Number, Array, Object], 0),
    wrap: {
      type: Boolean,
      default: void 0
    }
  });
  const ARow = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARow",
    inheritAttrs: false,
    props: rowProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("row", props2);
      const [wrapSSR, hashId] = useRowStyle(prefixCls);
      let token2;
      const responsiveObserve = useResponsiveObserver();
      const screens = ref({
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      });
      const curScreens = ref({
        xs: false,
        sm: false,
        md: false,
        lg: false,
        xl: false,
        xxl: false
      });
      const mergePropsByScreen = (oriProp) => {
        return computed(() => {
          if (typeof props2[oriProp] === "string") {
            return props2[oriProp];
          }
          if (typeof props2[oriProp] !== "object") {
            return "";
          }
          for (let i2 = 0; i2 < responsiveArray.length; i2++) {
            const breakpoint = responsiveArray[i2];
            if (!curScreens.value[breakpoint]) continue;
            const curVal = props2[oriProp][breakpoint];
            if (curVal !== void 0) {
              return curVal;
            }
          }
          return "";
        });
      };
      const mergeAlign = mergePropsByScreen("align");
      const mergeJustify = mergePropsByScreen("justify");
      const supportFlexGap = useFlexGapSupport();
      onMounted(() => {
        token2 = responsiveObserve.value.subscribe((screen) => {
          curScreens.value = screen;
          const currentGutter = props2.gutter || 0;
          if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
            screens.value = screen;
          }
        });
      });
      onBeforeUnmount(() => {
        responsiveObserve.value.unsubscribe(token2);
      });
      const gutter = computed(() => {
        const results = [void 0, void 0];
        const {
          gutter: gutter2 = 0
        } = props2;
        const normalizedGutter = Array.isArray(gutter2) ? gutter2 : [gutter2, void 0];
        normalizedGutter.forEach((g2, index2) => {
          if (typeof g2 === "object") {
            for (let i2 = 0; i2 < responsiveArray.length; i2++) {
              const breakpoint = responsiveArray[i2];
              if (screens.value[breakpoint] && g2[breakpoint] !== void 0) {
                results[index2] = g2[breakpoint];
                break;
              }
            }
          } else {
            results[index2] = g2;
          }
        });
        return results;
      });
      useProvideRow({
        gutter,
        supportFlexGap,
        wrap: computed(() => props2.wrap)
      });
      const classes = computed(() => classNames(prefixCls.value, {
        [`${prefixCls.value}-no-wrap`]: props2.wrap === false,
        [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,
        [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value));
      const rowStyle = computed(() => {
        const gt = gutter.value;
        const style = {};
        const horizontalGutter = gt[0] != null && gt[0] > 0 ? `${gt[0] / -2}px` : void 0;
        const verticalGutter = gt[1] != null && gt[1] > 0 ? `${gt[1] / -2}px` : void 0;
        if (horizontalGutter) {
          style.marginLeft = horizontalGutter;
          style.marginRight = horizontalGutter;
        }
        if (supportFlexGap.value) {
          style.rowGap = `${gt[1]}px`;
        } else if (verticalGutter) {
          style.marginTop = verticalGutter;
          style.marginBottom = verticalGutter;
        }
        return style;
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classes.value,
          "style": _extends$1(_extends$1({}, rowStyle.value), attrs.style)
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
      return o22.__proto__ || Object.getPrototypeOf(o22);
    };
    return _getPrototypeOf(o2);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
      o22.__proto__ = p22;
      return o22;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format$2(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i2 = 0;
    var len2 = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x2) {
        if (x2 === "%%") {
          return "%";
        }
        if (i2 >= len2) {
          return x2;
        }
        switch (x2) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_2) {
              return "[Circular]";
            }
            break;
          default:
            return x2;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a2) {
      func(a2, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k2) {
      ret.push.apply(ret, objArr[k2] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve2, reject) {
        var next2 = function next22(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve2, reject) {
      var next2 = function next22(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve2(source);
      }
      objArrKeys.forEach(function(key2) {
        var arr = objArr[key2];
        if (firstFields.indexOf(key2) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj2) {
    return !!(obj2 && obj2.message !== void 0);
  }
  function getValue$1(value, path) {
    var v2 = value;
    for (var i2 = 0; i2 < path.length; i2++) {
      if (v2 == void 0) {
        return v2;
      }
      v2 = v2[path[i2]];
    }
    return v2;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue$1(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s2 in source) {
        if (source.hasOwnProperty(s2)) {
          var value = source[s2];
          if (typeof value === "object" && typeof target[s2] === "object") {
            target[s2] = _extends({}, target[s2], value);
          } else {
            target[s2] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options2, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format$2(options2.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options2) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format$2(options2.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b2 = function b22(options2) {
      return options2 && options2.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options2) {
      return options2 && options2.exact ? v46Exact : new RegExp("(?:" + b2(options2) + v4 + b2(options2) + ")|(?:" + b2(options2) + v6 + b2(options2) + ")", "g");
    };
    ip.v4 = function(options2) {
      return options2 && options2.exact ? v4exact : new RegExp("" + b2(options2) + v4 + b2(options2), "g");
    };
    ip.v6 = function(options2) {
      return options2 && options2.exact ? v6exact : new RegExp("" + b2(options2) + v6 + b2(options2), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp3(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e2) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number3(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options2) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options2);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format$2(options2.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format$2(options2.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options2) {
    var len2 = typeof rule.len === "number";
    var min3 = typeof rule.min === "number";
    var max3 = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key2 = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key2 = "number";
    } else if (str) {
      key2 = "string";
    } else if (arr) {
      key2 = "array";
    }
    if (!key2) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len2) {
      if (val !== rule.len) {
        errors.push(format$2(options2.messages[key2].len, rule.fullField, rule.len));
      }
    } else if (min3 && !max3 && val < rule.min) {
      errors.push(format$2(options2.messages[key2].min, rule.fullField, rule.min));
    } else if (max3 && !min3 && val > rule.max) {
      errors.push(format$2(options2.messages[key2].max, rule.fullField, rule.max));
    } else if (min3 && max3 && (val < rule.min || val > rule.max)) {
      errors.push(format$2(options2.messages[key2].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options2) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format$2(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options2) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format$2(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format$2(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
        rules.pattern(rule, value, source, errors, options2);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options2);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options2) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options2, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options2) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
    }
    callback(errors);
  };
  var validators$2 = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object2,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone2() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define2(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o2, oc) {
      var _this2 = this;
      if (o2 === void 0) {
        o2 = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options2 = o2;
      var callback = oc;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add2(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i2 = 0; i2 < results.length; i2++) {
          add2(results[i2]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options2.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options2.messages);
        options2.messages = messages$1;
      } else {
        options2.messages = this.messages();
      }
      var series = {};
      var keys2 = options2.keys || Object.keys(this.rules);
      keys2.forEach(function(z2) {
        var arr = _this2.rules[z2];
        var value = source[z2];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value = source[z2] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z2;
          rule.fullField = rule.fullField || z2;
          rule.type = _this2.getType(rule);
          series[z2] = series[z2] || [];
          series[z2].push({
            rule,
            value,
            source,
            field: z2
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options2, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key2, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key2,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options2.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options2.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options2.error) {
                filledErrors = [options2.error(rule, format$2(options2.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key2) {
                fieldsSchema[key2] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options2.messages);
            if (data.rule.options) {
              data.rule.options.messages = options2.messages;
              data.rule.options.error = options2.error;
            }
            schema.validate(data.value, data.rule.options || options2, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options2);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options2);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options2.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
        throw new Error(format$2("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validators$2.required;
      }
      return validators$2[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register2(type4, validator2) {
    if (typeof validator2 !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators$2[type4] = validator2;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators$2;
  function toArray$3(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function get$1(entity, path) {
    let current = entity;
    for (let i2 = 0; i2 < path.length; i2 += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path[i2]];
    }
    return current;
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    const [path, ...restPath] = paths;
    let clone2;
    if (!entity && typeof path === "number") {
      clone2 = [];
    } else if (Array.isArray(entity)) {
      clone2 = [...entity];
    } else {
      clone2 = _extends$1({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone2[path][restPath[0]];
    } else {
      clone2[path] = internalSet(clone2[path], restPath, value, removeIfUndefined);
    }
    return clone2;
  }
  function set$2(entity, paths, value) {
    let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get$1(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function getNamePath(path) {
    return toArray$3(path);
  }
  function getValue(store, namePath) {
    const value = get$1(store, namePath);
    return value;
  }
  function setValue(store, namePath, value) {
    let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const newStore = set$2(store, namePath, value, removeIfUndefined);
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    return namePathList && namePathList.some((path) => matchNamePath(path, namePath));
  }
  function isObject$4(obj2) {
    return typeof obj2 === "object" && obj2 !== null && Object.getPrototypeOf(obj2) === Object.prototype;
  }
  function internalSetValues(store, values) {
    const newStore = Array.isArray(store) ? [...store] : _extends$1({}, store);
    if (!values) {
      return newStore;
    }
    Object.keys(values).forEach((key2) => {
      const prevValue = newStore[key2];
      const value = values[key2];
      const recursive = isObject$4(prevValue) && isObject$4(value);
      newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;
    });
    return newStore;
  }
  function setValues(store) {
    for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      restValues[_key - 1] = arguments[_key];
    }
    return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);
  }
  function cloneByNamePathList(store, namePathList) {
    let newStore = {};
    namePathList.forEach((namePath) => {
      const value = getValue(store, namePath);
      newStore = setValue(newStore, namePath, value);
    });
    return newStore;
  }
  function matchNamePath(namePath, changedNamePath) {
    if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
      return false;
    }
    return namePath.every((nameUnit, i2) => changedNamePath[i2] === nameUnit);
  }
  const typeTemplate = "'${name}' is not a valid ${type}";
  const defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  var __awaiter = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, (str) => {
      const key2 = str.slice(2, -1);
      return kv[key2];
    });
  }
  function validateRule(name, value, rule, options2, messageVariables) {
    return __awaiter(this, void 0, void 0, function* () {
      const cloneRule = _extends$1({}, rule);
      delete cloneRule.ruleIndex;
      delete cloneRule.trigger;
      let subRuleField = null;
      if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
        subRuleField = cloneRule.defaultField;
        delete cloneRule.defaultField;
      }
      const validator2 = new AsyncValidator({
        [name]: [cloneRule]
      });
      const messages2 = setValues({}, defaultValidateMessages, options2.validateMessages);
      validator2.messages(messages2);
      let result = [];
      try {
        yield Promise.resolve(validator2.validate({
          [name]: value
        }, _extends$1({}, options2)));
      } catch (errObj) {
        if (errObj.errors) {
          result = errObj.errors.map((_ref, index2) => {
            let {
              message
            } = _ref;
            return (
              // Wrap VueNode with `key`
              isValidElement(message) ? cloneVNode(message, {
                key: `error_${index2}`
              }) : message
            );
          });
        } else {
          console.error(errObj);
          result = [messages2.default()];
        }
      }
      if (!result.length && subRuleField) {
        const subResults = yield Promise.all(value.map((subValue, i2) => validateRule(`${name}.${i2}`, subValue, subRuleField, options2, messageVariables)));
        return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
      }
      const kv = _extends$1(_extends$1(_extends$1({}, rule), {
        name,
        enum: (rule.enum || []).join(", ")
      }), messageVariables);
      const fillVariableResult = result.map((error) => {
        if (typeof error === "string") {
          return replaceMessage(error, kv);
        }
        return error;
      });
      return fillVariableResult;
    });
  }
  function validateRules(namePath, value, rules2, options2, validateFirst, messageVariables) {
    const name = namePath.join(".");
    const filledRules = rules2.map((currentRule, ruleIndex) => {
      const originValidatorFunc = currentRule.validator;
      const cloneRule = _extends$1(_extends$1({}, currentRule), {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = (rule, val, callback) => {
          let hasPromise = false;
          const wrappedCallback = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(() => {
              if (!hasPromise) {
                callback(...args);
              }
            });
          };
          const promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          if (hasPromise) {
            promise.then(() => {
              callback();
            }).catch((err) => {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort((_ref2, _ref3) => {
      let {
        warningOnly: w1,
        ruleIndex: i1
      } = _ref2;
      let {
        warningOnly: w2,
        ruleIndex: i2
      } = _ref3;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    let summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
        for (let i2 = 0; i2 < filledRules.length; i2 += 1) {
          const rule = filledRules[i2];
          const errors = yield validateRule(name, value, rule, options2, messageVariables);
          if (errors.length) {
            reject([{
              errors,
              rule
            }]);
            return;
          }
        }
        resolve2([]);
      }));
    } else {
      const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options2, messageVariables).then((errors) => ({
        errors,
        rule
      })));
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch((e2) => e2);
    return summaryPromise;
  }
  function finishOnAllFailed(rulePromises) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.all(rulePromises).then((errorsList) => {
        const errors = [].concat(...errorsList);
        return errors;
      });
    });
  }
  function finishOnFirstFailed(rulePromises) {
    return __awaiter(this, void 0, void 0, function* () {
      let count = 0;
      return new Promise((resolve2) => {
        rulePromises.forEach((promise) => {
          promise.then((ruleError) => {
            if (ruleError.errors.length) {
              resolve2([ruleError]);
            }
            count += 1;
            if (count === rulePromises.length) {
              resolve2([]);
            }
          });
        });
      });
    });
  }
  const FormContextKey = Symbol("formContextKey");
  const useProvideForm = (state) => {
    provide(FormContextKey, state);
  };
  const useInjectForm = () => {
    return inject(FormContextKey, {
      name: computed(() => void 0),
      labelAlign: computed(() => "right"),
      vertical: computed(() => false),
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addField: (_eventKey, _field) => {
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removeField: (_eventKey) => {
      },
      model: computed(() => void 0),
      rules: computed(() => void 0),
      colon: computed(() => void 0),
      labelWrap: computed(() => void 0),
      labelCol: computed(() => void 0),
      requiredMark: computed(() => false),
      validateTrigger: computed(() => void 0),
      onValidate: () => {
      },
      validateMessages: computed(() => defaultValidateMessages)
    });
  };
  const FormItemPrefixContextKey = Symbol("formItemPrefixContextKey");
  const useProvideFormItemPrefix = (state) => {
    provide(FormItemPrefixContextKey, state);
  };
  const useInjectFormItemPrefix = () => {
    return inject(FormItemPrefixContextKey, {
      prefixCls: computed(() => "")
    });
  };
  function parseFlex(flex) {
    if (typeof flex === "number") {
      return `${flex} ${flex} auto`;
    }
    if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
      return `0 0 ${flex}`;
    }
    return flex;
  }
  const colProps = () => ({
    span: [String, Number],
    order: [String, Number],
    offset: [String, Number],
    push: [String, Number],
    pull: [String, Number],
    xs: {
      type: [String, Number, Object],
      default: void 0
    },
    sm: {
      type: [String, Number, Object],
      default: void 0
    },
    md: {
      type: [String, Number, Object],
      default: void 0
    },
    lg: {
      type: [String, Number, Object],
      default: void 0
    },
    xl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxl: {
      type: [String, Number, Object],
      default: void 0
    },
    prefixCls: String,
    flex: [String, Number]
  });
  const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
  const Col$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACol",
    inheritAttrs: false,
    props: colProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        gutter,
        supportFlexGap,
        wrap
      } = useInjectRow();
      const {
        prefixCls,
        direction
      } = useConfigInject("col", props2);
      const [wrapSSR, hashId] = useColStyle(prefixCls);
      const classes = computed(() => {
        const {
          span,
          order,
          offset: offset2,
          push,
          pull
        } = props2;
        const pre = prefixCls.value;
        let sizeClassObj = {};
        sizes.forEach((size) => {
          let sizeProps = {};
          const propSize = props2[size];
          if (typeof propSize === "number") {
            sizeProps.span = propSize;
          } else if (typeof propSize === "object") {
            sizeProps = propSize || {};
          }
          sizeClassObj = _extends$1(_extends$1({}, sizeClassObj), {
            [`${pre}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
            [`${pre}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
            [`${pre}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
            [`${pre}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
            [`${pre}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
            [`${pre}-rtl`]: direction.value === "rtl"
          });
        });
        return classNames(pre, {
          [`${pre}-${span}`]: span !== void 0,
          [`${pre}-order-${order}`]: order,
          [`${pre}-offset-${offset2}`]: offset2,
          [`${pre}-push-${push}`]: push,
          [`${pre}-pull-${pull}`]: pull
        }, sizeClassObj, attrs.class, hashId.value);
      });
      const mergedStyle = computed(() => {
        const {
          flex
        } = props2;
        const gutterVal = gutter.value;
        const style = {};
        if (gutterVal && gutterVal[0] > 0) {
          const horizontalGutter = `${gutterVal[0] / 2}px`;
          style.paddingLeft = horizontalGutter;
          style.paddingRight = horizontalGutter;
        }
        if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
          const verticalGutter = `${gutterVal[1] / 2}px`;
          style.paddingTop = verticalGutter;
          style.paddingBottom = verticalGutter;
        }
        if (flex) {
          style.flex = parseFlex(flex);
          if (wrap.value === false && !style.minWidth) {
            style.minWidth = 0;
          }
        }
        return style;
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classes.value,
          "style": [mergedStyle.value, attrs.style]
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  var QuestionCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
  function _objectSpread$e(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$e(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$e(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var QuestionCircleOutlined = function QuestionCircleOutlined2(props2, context) {
    var p2 = _objectSpread$e({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$e({}, p2, {
      "icon": QuestionCircleOutlined$1
    }), null);
  };
  QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
  QuestionCircleOutlined.inheritAttrs = false;
  const FormItemLabel = (props2, _ref) => {
    let {
      slots,
      emit: emit2,
      attrs
    } = _ref;
    var _a2, _b2, _c2, _d, _e;
    const {
      prefixCls,
      htmlFor,
      labelCol,
      labelAlign,
      colon,
      required,
      requiredMark
    } = _extends$1(_extends$1({}, props2), attrs);
    const [formLocale] = useLocaleReceiver("Form");
    const label = (_a2 = props2.label) !== null && _a2 !== void 0 ? _a2 : (_b2 = slots.label) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
    if (!label) return null;
    const {
      vertical,
      labelAlign: contextLabelAlign,
      labelCol: contextLabelCol,
      labelWrap,
      colon: contextColon
    } = useInjectForm();
    const mergedLabelCol = labelCol || (contextLabelCol === null || contextLabelCol === void 0 ? void 0 : contextLabelCol.value) || {};
    const mergedLabelAlign = labelAlign || (contextLabelAlign === null || contextLabelAlign === void 0 ? void 0 : contextLabelAlign.value);
    const labelClsBasic = `${prefixCls}-item-label`;
    const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.class, {
      [`${labelClsBasic}-wrap`]: !!labelWrap.value
    });
    let labelChildren = label;
    const computedColon = colon === true || (contextColon === null || contextColon === void 0 ? void 0 : contextColon.value) !== false && colon !== false;
    const haveColon = computedColon && !vertical.value;
    if (haveColon && typeof label === "string" && label.trim() !== "") {
      labelChildren = label.replace(/[:|：]\s*$/, "");
    }
    if (props2.tooltip || slots.tooltip) {
      const tooltipNode = createVNode("span", {
        "class": `${prefixCls}-item-tooltip`
      }, [createVNode(Tooltip, {
        "title": props2.tooltip
      }, {
        default: () => [createVNode(QuestionCircleOutlined, null, null)]
      })]);
      labelChildren = createVNode(Fragment, null, [labelChildren, slots.tooltip ? (_c2 = slots.tooltip) === null || _c2 === void 0 ? void 0 : _c2.call(slots, {
        class: `${prefixCls}-item-tooltip`
      }) : tooltipNode]);
    }
    if (requiredMark === "optional" && !required) {
      labelChildren = createVNode(Fragment, null, [labelChildren, createVNode("span", {
        "class": `${prefixCls}-item-optional`
      }, [((_d = formLocale.value) === null || _d === void 0 ? void 0 : _d.optional) || ((_e = localeValues$1.Form) === null || _e === void 0 ? void 0 : _e.optional)])]);
    }
    const labelClassName = classNames({
      [`${prefixCls}-item-required`]: required,
      [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
      [`${prefixCls}-item-no-colon`]: !computedColon
    });
    return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedLabelCol), {}, {
      "class": labelColClassName
    }), {
      default: () => [createVNode("label", {
        "for": htmlFor,
        "class": labelClassName,
        "title": typeof label === "string" ? label : "",
        "onClick": (e2) => emit2("click", e2)
      }, [labelChildren])]
    });
  };
  FormItemLabel.displayName = "FormItemLabel";
  FormItemLabel.inheritAttrs = false;
  const genFormValidateMotionStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const helpCls = `${componentCls}-show-help`;
    const helpItemCls = `${componentCls}-show-help-item`;
    return {
      [helpCls]: {
        // Explain holder
        transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        "&-appear, &-enter": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        },
        // Explain
        [helpItemCls]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
          [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
            transform: `translateY(-5px)`,
            opacity: 0,
            [`&-active`]: {
              transform: "translateY(0)",
              opacity: 1
            }
          },
          [`&${helpItemCls}-leave-active`]: {
            transform: `translateY(-5px)`
          }
        }
      }
    };
  };
  const resetForm = (token2) => ({
    legend: {
      display: "block",
      width: "100%",
      marginBottom: token2.marginLG,
      padding: 0,
      color: token2.colorTextDescription,
      fontSize: token2.fontSizeLG,
      lineHeight: "inherit",
      border: 0,
      borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
    },
    label: {
      fontSize: token2.fontSize
    },
    'input[type="search"]': {
      boxSizing: "border-box"
    },
    // Position radios and checkboxes better
    'input[type="radio"], input[type="checkbox"]': {
      lineHeight: "normal"
    },
    'input[type="file"]': {
      display: "block"
    },
    // Make range inputs behave like textual form controls
    'input[type="range"]': {
      display: "block",
      width: "100%"
    },
    // Make multiple select elements height not fixed
    "select[multiple], select[size]": {
      height: "auto"
    },
    // Focus for file, radio, and checkbox
    [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
      outline: 0,
      boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
    },
    // Adjust output element
    output: {
      display: "block",
      paddingTop: 15,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight
    }
  });
  const genFormSize = (token2, height) => {
    const {
      formItemCls
    } = token2;
    return {
      [formItemCls]: {
        [`${formItemCls}-label > label`]: {
          height
        },
        [`${formItemCls}-control-input`]: {
          minHeight: height
        }
      }
    };
  };
  const genFormStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [token2.componentCls]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), resetForm(token2)), {
        [`${componentCls}-text`]: {
          display: "inline-block",
          paddingInlineEnd: token2.paddingSM
        },
        // ================================================================
        // =                             Size                             =
        // ================================================================
        "&-small": _extends$1({}, genFormSize(token2, token2.controlHeightSM)),
        "&-large": _extends$1({}, genFormSize(token2, token2.controlHeightLG))
      })
    };
  };
  const genFormItemStyle = (token2) => {
    const {
      formItemCls,
      iconCls,
      componentCls,
      rootPrefixCls
    } = token2;
    return {
      [formItemCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        marginBottom: token2.marginLG,
        verticalAlign: "top",
        "&-with-help": {
          transition: "none"
        },
        [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
          // https://github.com/ant-design/ant-design/issues/26141
          display: "none"
        },
        "&-has-warning": {
          [`${formItemCls}-split`]: {
            color: token2.colorError
          }
        },
        "&-has-error": {
          [`${formItemCls}-split`]: {
            color: token2.colorWarning
          }
        },
        // ==============================================================
        // =                            Label                           =
        // ==============================================================
        [`${formItemCls}-label`]: {
          display: "inline-block",
          flexGrow: 0,
          overflow: "hidden",
          whiteSpace: "nowrap",
          textAlign: "end",
          verticalAlign: "middle",
          "&-left": {
            textAlign: "start"
          },
          "&-wrap": {
            overflow: "unset",
            lineHeight: `${token2.lineHeight} - 0.25em`,
            whiteSpace: "unset"
          },
          "> label": {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            maxWidth: "100%",
            height: token2.controlHeight,
            color: token2.colorTextHeading,
            fontSize: token2.fontSize,
            [`> ${iconCls}`]: {
              fontSize: token2.fontSize,
              verticalAlign: "top"
            },
            // Required mark
            [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
              display: "inline-block",
              marginInlineEnd: token2.marginXXS,
              color: token2.colorError,
              fontSize: token2.fontSize,
              fontFamily: "SimSun, sans-serif",
              lineHeight: 1,
              content: '"*"',
              [`${componentCls}-hide-required-mark &`]: {
                display: "none"
              }
            },
            // Optional mark
            [`${formItemCls}-optional`]: {
              display: "inline-block",
              marginInlineStart: token2.marginXXS,
              color: token2.colorTextDescription,
              [`${componentCls}-hide-required-mark &`]: {
                display: "none"
              }
            },
            // Optional mark
            [`${formItemCls}-tooltip`]: {
              color: token2.colorTextDescription,
              cursor: "help",
              writingMode: "horizontal-tb",
              marginInlineStart: token2.marginXXS
            },
            "&::after": {
              content: '":"',
              position: "relative",
              marginBlock: 0,
              marginInlineStart: token2.marginXXS / 2,
              marginInlineEnd: token2.marginXS
            },
            [`&${formItemCls}-no-colon::after`]: {
              content: '" "'
            }
          }
        },
        // ==============================================================
        // =                            Input                           =
        // ==============================================================
        [`${formItemCls}-control`]: {
          display: "flex",
          flexDirection: "column",
          flexGrow: 1,
          [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
            width: "100%"
          },
          "&-input": {
            position: "relative",
            display: "flex",
            alignItems: "center",
            minHeight: token2.controlHeight,
            "&-content": {
              flex: "auto",
              maxWidth: "100%"
            }
          }
        },
        // ==============================================================
        // =                           Explain                          =
        // ==============================================================
        [formItemCls]: {
          "&-explain, &-extra": {
            clear: "both",
            color: token2.colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          },
          "&-explain-connected": {
            width: "100%"
          },
          "&-extra": {
            minHeight: token2.controlHeightSM,
            transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
            // sync input color transition
          },
          "&-explain": {
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            }
          }
        },
        [`&-with-help ${formItemCls}-explain`]: {
          height: "auto",
          opacity: 1
        },
        // ==============================================================
        // =                        Feedback Icon                       =
        // ==============================================================
        [`${formItemCls}-feedback-icon`]: {
          fontSize: token2.fontSize,
          textAlign: "center",
          visibility: "visible",
          animationName: zoomIn,
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: token2.motionEaseOutBack,
          pointerEvents: "none",
          "&-success": {
            color: token2.colorSuccess
          },
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          },
          "&-validating": {
            color: token2.colorPrimary
          }
        }
      })
    };
  };
  const genHorizontalStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      rootPrefixCls
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        [`${formItemCls}-label`]: {
          flexGrow: 0
        },
        [`${formItemCls}-control`]: {
          flex: "1 1 0",
          // https://github.com/ant-design/ant-design/issues/32777
          // https://github.com/ant-design/ant-design/issues/33773
          minWidth: 0
        },
        // https://github.com/ant-design/ant-design/issues/32980
        [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      }
    };
  };
  const genInlineStyle = (token2) => {
    const {
      componentCls,
      formItemCls
    } = token2;
    return {
      [`${componentCls}-inline`]: {
        display: "flex",
        flexWrap: "wrap",
        [formItemCls]: {
          flex: "none",
          flexWrap: "nowrap",
          marginInlineEnd: token2.margin,
          marginBottom: 0,
          "&-with-help": {
            marginBottom: token2.marginLG
          },
          [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
            display: "inline-block",
            verticalAlign: "top"
          },
          [`> ${formItemCls}-label`]: {
            flex: "none"
          },
          [`${componentCls}-text`]: {
            display: "inline-block"
          },
          [`${formItemCls}-has-feedback`]: {
            display: "inline-block"
          }
        }
      }
    };
  };
  const makeVerticalLayoutLabel = (token2) => ({
    margin: 0,
    padding: `0 0 ${token2.paddingXS}px`,
    whiteSpace: "initial",
    textAlign: "start",
    "> label": {
      margin: 0,
      "&::after": {
        display: "none"
      }
    }
  });
  const makeVerticalLayout = (token2) => {
    const {
      componentCls,
      formItemCls
    } = token2;
    return {
      [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      [componentCls]: {
        [formItemCls]: {
          flexWrap: "wrap",
          [`${formItemCls}-label,
          ${formItemCls}-control`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    };
  };
  const genVerticalStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      rootPrefixCls
    } = token2;
    return {
      [`${componentCls}-vertical`]: {
        [formItemCls]: {
          "&-row": {
            flexDirection: "column"
          },
          "&-label > label": {
            height: "auto"
          },
          [`${componentCls}-item-control`]: {
            width: "100%"
          }
        }
      },
      [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
        [componentCls]: {
          [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }],
      [`@media (max-width: ${token2.screenSMMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${token2.screenMDMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${token2.screenLGMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    };
  };
  const useStyle$8 = genComponentStyleHook("Form", (token2, _ref) => {
    let {
      rootPrefixCls
    } = _ref;
    const formToken = merge$2(token2, {
      formItemCls: `${token2.componentCls}-item`,
      rootPrefixCls
    });
    return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion(formToken), zoomIn];
  });
  const ErrorList = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ErrorList",
    inheritAttrs: false,
    props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
    setup(props2, _ref) {
      let {
        attrs
      } = _ref;
      const {
        prefixCls,
        status
      } = useInjectFormItemPrefix();
      const baseClassName = computed(() => `${prefixCls.value}-item-explain`);
      const visible = computed(() => !!(props2.errors && props2.errors.length));
      const innerStatus = ref(status.value);
      const [, hashId] = useStyle$8(prefixCls);
      watch([visible, status], () => {
        if (visible.value) {
          innerStatus.value = status.value;
        }
      });
      return () => {
        var _a2, _b2;
        const colMItem = collapseMotion(`${prefixCls.value}-show-help-item`);
        const transitionGroupProps = getTransitionGroupProps(`${prefixCls.value}-show-help-item`, colMItem);
        transitionGroupProps.role = "alert";
        transitionGroupProps.class = [hashId.value, baseClassName.value, attrs.class, `${prefixCls.value}-show-help`];
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, getTransitionProps(`${prefixCls.value}-show-help`)), {}, {
          "onAfterEnter": () => props2.onErrorVisibleChanged(true),
          "onAfterLeave": () => props2.onErrorVisibleChanged(false)
        }), {
          default: () => [withDirectives(createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps), {}, {
            "tag": "div"
          }), {
            default: () => [(_b2 = props2.errors) === null || _b2 === void 0 ? void 0 : _b2.map((error, index2) => createVNode("div", {
              "key": index2,
              "class": innerStatus.value ? `${baseClassName.value}-${innerStatus.value}` : ""
            }, [error]))]
          }), [[vShow, !!((_a2 = props2.errors) === null || _a2 === void 0 ? void 0 : _a2.length)]])]
        });
      };
    }
  });
  const FormItemInput = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    slots: Object,
    inheritAttrs: false,
    props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const formContext = useInjectForm();
      const {
        wrapperCol: contextWrapperCol
      } = formContext;
      const subFormContext = _extends$1({}, formContext);
      delete subFormContext.labelCol;
      delete subFormContext.wrapperCol;
      useProvideForm(subFormContext);
      useProvideFormItemPrefix({
        prefixCls: computed(() => props2.prefixCls),
        status: computed(() => props2.status)
      });
      return () => {
        var _a2, _b2, _c2;
        const {
          prefixCls,
          wrapperCol,
          marginBottom,
          onErrorVisibleChanged,
          help = (_a2 = slots.help) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          errors = filterEmpty((_b2 = slots.errors) === null || _b2 === void 0 ? void 0 : _b2.call(slots)),
          // hasFeedback,
          // status,
          extra = (_c2 = slots.extra) === null || _c2 === void 0 ? void 0 : _c2.call(slots)
        } = props2;
        const baseClassName = `${prefixCls}-item`;
        const mergedWrapperCol = wrapperCol || (contextWrapperCol === null || contextWrapperCol === void 0 ? void 0 : contextWrapperCol.value) || {};
        const className = classNames(`${baseClassName}-control`, mergedWrapperCol.class);
        return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedWrapperCol), {}, {
          "class": className
        }), {
          default: () => {
            var _a3;
            return createVNode(Fragment, null, [createVNode("div", {
              "class": `${baseClassName}-control-input`
            }, [createVNode("div", {
              "class": `${baseClassName}-control-input-content`
            }, [(_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)])]), marginBottom !== null || errors.length ? createVNode("div", {
              "style": {
                display: "flex",
                flexWrap: "nowrap"
              }
            }, [createVNode(ErrorList, {
              "errors": errors,
              "help": help,
              "class": `${baseClassName}-explain-connected`,
              "onErrorVisibleChanged": onErrorVisibleChanged
            }, null), !!marginBottom && createVNode("div", {
              "style": {
                width: 0,
                height: `${marginBottom}px`
              }
            }, null)]) : null, extra ? createVNode("div", {
              "class": `${baseClassName}-extra`
            }, [extra]) : null]);
          }
        });
      };
    }
  });
  function useDebounce(value) {
    const cacheValue = shallowRef(value.value.slice());
    let timeout = null;
    watchEffect(() => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        cacheValue.value = value.value;
      }, value.value.length ? 0 : 10);
    });
    return cacheValue;
  }
  tuple("success", "warning", "error", "validating", "");
  const iconMap = {
    success: CheckCircleFilled,
    warning: ExclamationCircleFilled,
    error: CloseCircleFilled,
    validating: LoadingOutlined
  };
  function getPropByPath$1(obj2, namePathList, strict) {
    let tempObj = obj2;
    const keyArr = namePathList;
    let i2 = 0;
    try {
      for (let len2 = keyArr.length; i2 < len2 - 1; ++i2) {
        if (!tempObj && !strict) break;
        const key2 = keyArr[i2];
        if (key2 in tempObj) {
          tempObj = tempObj[key2];
        } else {
          if (strict) {
            throw Error("please transfer a valid name path to form item!");
          }
          break;
        }
      }
      if (strict && !tempObj) {
        throw Error("please transfer a valid name path to form item!");
      }
    } catch (error) {
      console.error("please transfer a valid name path to form item!");
    }
    return {
      o: tempObj,
      k: keyArr[i2],
      v: tempObj ? tempObj[keyArr[i2]] : void 0
    };
  }
  const formItemProps = () => ({
    htmlFor: String,
    prefixCls: String,
    label: PropTypes.any,
    help: PropTypes.any,
    extra: PropTypes.any,
    labelCol: {
      type: Object
    },
    wrapperCol: {
      type: Object
    },
    hasFeedback: {
      type: Boolean,
      default: false
    },
    colon: {
      type: Boolean,
      default: void 0
    },
    labelAlign: String,
    prop: {
      type: [String, Number, Array]
    },
    name: {
      type: [String, Number, Array]
    },
    rules: [Array, Object],
    autoLink: {
      type: Boolean,
      default: true
    },
    required: {
      type: Boolean,
      default: void 0
    },
    validateFirst: {
      type: Boolean,
      default: void 0
    },
    validateStatus: PropTypes.oneOf(tuple("", "success", "warning", "error", "validating")),
    validateTrigger: {
      type: [String, Array]
    },
    messageVariables: {
      type: Object
    },
    hidden: Boolean,
    noStyle: Boolean,
    tooltip: String
  });
  let indexGuid$1 = 0;
  const defaultItemNamePrefixCls = "form_item";
  const FormItem = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AFormItem",
    inheritAttrs: false,
    __ANT_NEW_FORM_ITEM: true,
    props: formItemProps(),
    slots: Object,
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose
      } = _ref;
      warning$3(props2.prop === void 0);
      const eventKey = `form-item-${++indexGuid$1}`;
      const {
        prefixCls
      } = useConfigInject("form", props2);
      const [wrapSSR, hashId] = useStyle$8(prefixCls);
      const itemRef = shallowRef();
      const formContext = useInjectForm();
      const fieldName = computed(() => props2.name || props2.prop);
      const errors = shallowRef([]);
      const validateDisabled = shallowRef(false);
      const inputRef = shallowRef();
      const namePath = computed(() => {
        const val = fieldName.value;
        return getNamePath(val);
      });
      const fieldId = computed(() => {
        if (!namePath.value.length) {
          return void 0;
        } else {
          const formName = formContext.name.value;
          const mergedId = namePath.value.join("_");
          return formName ? `${formName}_${mergedId}` : `${defaultItemNamePrefixCls}_${mergedId}`;
        }
      });
      const getNewFieldValue = () => {
        const model = formContext.model.value;
        if (!model || !fieldName.value) {
          return;
        } else {
          return getPropByPath$1(model, namePath.value, true).v;
        }
      };
      const fieldValue = computed(() => getNewFieldValue());
      const initialValue = shallowRef(cloneDeep(fieldValue.value));
      const mergedValidateTrigger = computed(() => {
        let validateTrigger = props2.validateTrigger !== void 0 ? props2.validateTrigger : formContext.validateTrigger.value;
        validateTrigger = validateTrigger === void 0 ? "change" : validateTrigger;
        return toArray$3(validateTrigger);
      });
      const rulesRef = computed(() => {
        let formRules = formContext.rules.value;
        const selfRules = props2.rules;
        const requiredRule = props2.required !== void 0 ? {
          required: !!props2.required,
          trigger: mergedValidateTrigger.value
        } : [];
        const prop = getPropByPath$1(formRules, namePath.value);
        formRules = formRules ? prop.o[prop.k] || prop.v : [];
        const rules2 = [].concat(selfRules || formRules || []);
        if (find$1(rules2, (rule) => rule.required)) {
          return rules2;
        } else {
          return rules2.concat(requiredRule);
        }
      });
      const isRequired2 = computed(() => {
        const rules2 = rulesRef.value;
        let isRequired3 = false;
        if (rules2 && rules2.length) {
          rules2.every((rule) => {
            if (rule.required) {
              isRequired3 = true;
              return false;
            }
            return true;
          });
        }
        return isRequired3 || props2.required;
      });
      const validateState = shallowRef();
      watchEffect(() => {
        validateState.value = props2.validateStatus;
      });
      const messageVariables = computed(() => {
        let variables = {};
        if (typeof props2.label === "string") {
          variables.label = props2.label;
        } else if (props2.name) {
          variables.label = String(props2.name);
        }
        if (props2.messageVariables) {
          variables = _extends$1(_extends$1({}, variables), props2.messageVariables);
        }
        return variables;
      });
      const validateRules$1 = (options2) => {
        if (namePath.value.length === 0) {
          return;
        }
        const {
          validateFirst = false
        } = props2;
        const {
          triggerName
        } = options2 || {};
        let filteredRules = rulesRef.value;
        if (triggerName) {
          filteredRules = filteredRules.filter((rule) => {
            const {
              trigger: trigger2
            } = rule;
            if (!trigger2 && !mergedValidateTrigger.value.length) {
              return true;
            }
            const triggerList = toArray$3(trigger2 || mergedValidateTrigger.value);
            return triggerList.includes(triggerName);
          });
        }
        if (!filteredRules.length) {
          return Promise.resolve();
        }
        const promise = validateRules(namePath.value, fieldValue.value, filteredRules, _extends$1({
          validateMessages: formContext.validateMessages.value
        }, options2), validateFirst, messageVariables.value);
        validateState.value = "validating";
        errors.value = [];
        promise.catch((e2) => e2).then(function() {
          let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          if (validateState.value === "validating") {
            const res = results.filter((result) => result && result.errors.length);
            validateState.value = res.length ? "error" : "success";
            errors.value = res.map((r2) => r2.errors);
            formContext.onValidate(fieldName.value, !errors.value.length, errors.value.length ? toRaw(errors.value[0]) : null);
          }
        });
        return promise;
      };
      const onFieldBlur = () => {
        validateRules$1({
          triggerName: "blur"
        });
      };
      const onFieldChange = () => {
        if (validateDisabled.value) {
          validateDisabled.value = false;
          return;
        }
        validateRules$1({
          triggerName: "change"
        });
      };
      const clearValidate = () => {
        validateState.value = props2.validateStatus;
        validateDisabled.value = false;
        errors.value = [];
      };
      const resetField = () => {
        var _a2;
        validateState.value = props2.validateStatus;
        validateDisabled.value = true;
        errors.value = [];
        const model = formContext.model.value || {};
        const value = fieldValue.value;
        const prop = getPropByPath$1(model, namePath.value, true);
        if (Array.isArray(value)) {
          prop.o[prop.k] = [].concat((_a2 = initialValue.value) !== null && _a2 !== void 0 ? _a2 : []);
        } else {
          prop.o[prop.k] = initialValue.value;
        }
        nextTick(() => {
          validateDisabled.value = false;
        });
      };
      const htmlFor = computed(() => {
        return props2.htmlFor === void 0 ? fieldId.value : props2.htmlFor;
      });
      const onLabelClick = () => {
        const id = htmlFor.value;
        if (!id || !inputRef.value) {
          return;
        }
        const control = inputRef.value.$el.querySelector(`[id="${id}"]`);
        if (control && control.focus) {
          control.focus();
        }
      };
      expose({
        onFieldBlur,
        onFieldChange,
        clearValidate,
        resetField
      });
      useProvideFormItemContext({
        id: fieldId,
        onFieldBlur: () => {
          if (props2.autoLink) {
            onFieldBlur();
          }
        },
        onFieldChange: () => {
          if (props2.autoLink) {
            onFieldChange();
          }
        },
        clearValidate
      }, computed(() => {
        return !!(props2.autoLink && formContext.model.value && fieldName.value);
      }));
      let registered = false;
      watch(fieldName, (val) => {
        if (val) {
          if (!registered) {
            registered = true;
            formContext.addField(eventKey, {
              fieldValue,
              fieldId,
              fieldName,
              resetField,
              clearValidate,
              namePath,
              validateRules: validateRules$1,
              rules: rulesRef
            });
          }
        } else {
          registered = false;
          formContext.removeField(eventKey);
        }
      }, {
        immediate: true
      });
      onBeforeUnmount(() => {
        formContext.removeField(eventKey);
      });
      const debounceErrors = useDebounce(errors);
      const mergedValidateStatus = computed(() => {
        if (props2.validateStatus !== void 0) {
          return props2.validateStatus;
        } else if (debounceErrors.value.length) {
          return "error";
        }
        return validateState.value;
      });
      const itemClassName = computed(() => ({
        [`${prefixCls.value}-item`]: true,
        [hashId.value]: true,
        // Status
        [`${prefixCls.value}-item-has-feedback`]: mergedValidateStatus.value && props2.hasFeedback,
        [`${prefixCls.value}-item-has-success`]: mergedValidateStatus.value === "success",
        [`${prefixCls.value}-item-has-warning`]: mergedValidateStatus.value === "warning",
        [`${prefixCls.value}-item-has-error`]: mergedValidateStatus.value === "error",
        [`${prefixCls.value}-item-is-validating`]: mergedValidateStatus.value === "validating",
        [`${prefixCls.value}-item-hidden`]: props2.hidden
      }));
      const formItemInputContext = reactive({});
      FormItemInputContext.useProvide(formItemInputContext);
      watchEffect(() => {
        let feedbackIcon;
        if (props2.hasFeedback) {
          const IconNode = mergedValidateStatus.value && iconMap[mergedValidateStatus.value];
          feedbackIcon = IconNode ? createVNode("span", {
            "class": classNames(`${prefixCls.value}-item-feedback-icon`, `${prefixCls.value}-item-feedback-icon-${mergedValidateStatus.value}`)
          }, [createVNode(IconNode, null, null)]) : null;
        }
        _extends$1(formItemInputContext, {
          status: mergedValidateStatus.value,
          hasFeedback: props2.hasFeedback,
          feedbackIcon,
          isFormItemInput: true
        });
      });
      const marginBottom = shallowRef(null);
      const showMarginOffset = shallowRef(false);
      const updateMarginBottom = () => {
        if (itemRef.value) {
          const itemStyle = getComputedStyle(itemRef.value);
          marginBottom.value = parseInt(itemStyle.marginBottom, 10);
        }
      };
      onMounted(() => {
        watch(showMarginOffset, () => {
          if (showMarginOffset.value) {
            updateMarginBottom();
          }
        }, {
          flush: "post",
          immediate: true
        });
      });
      const onErrorVisibleChanged = (nextVisible) => {
        if (!nextVisible) {
          marginBottom.value = null;
        }
      };
      return () => {
        var _a2, _b2;
        if (props2.noStyle) return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        const help = (_b2 = props2.help) !== null && _b2 !== void 0 ? _b2 : slots.help ? filterEmpty(slots.help()) : null;
        const withHelp = !!(help !== void 0 && help !== null && Array.isArray(help) && help.length || debounceErrors.value.length);
        showMarginOffset.value = withHelp;
        return wrapSSR(createVNode("div", {
          "class": [itemClassName.value, withHelp ? `${prefixCls.value}-item-with-help` : "", attrs.class],
          "ref": itemRef
        }, [createVNode(ARow, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": `${prefixCls.value}-item-row`,
          "key": "row"
        }), {
          default: () => {
            var _a3, _b3;
            return createVNode(Fragment, null, [createVNode(FormItemLabel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
              "htmlFor": htmlFor.value,
              "required": isRequired2.value,
              "requiredMark": formContext.requiredMark.value,
              "prefixCls": prefixCls.value,
              "onClick": onLabelClick,
              "label": props2.label
            }), {
              label: slots.label,
              tooltip: slots.tooltip
            }), createVNode(FormItemInput, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
              "errors": help !== void 0 && help !== null ? toArray$3(help) : debounceErrors.value,
              "marginBottom": marginBottom.value,
              "prefixCls": prefixCls.value,
              "status": mergedValidateStatus.value,
              "ref": inputRef,
              "help": help,
              "extra": (_a3 = props2.extra) !== null && _a3 !== void 0 ? _a3 : (_b3 = slots.extra) === null || _b3 === void 0 ? void 0 : _b3.call(slots),
              "onErrorVisibleChanged": onErrorVisibleChanged
            }), {
              default: slots.default
            })]);
          }
        }), !!marginBottom.value && createVNode("div", {
          "class": `${prefixCls.value}-margin-offset`,
          "style": {
            marginBottom: `-${marginBottom.value}px`
          }
        }, null)]));
      };
    }
  });
  function allPromiseFinish(promiseList) {
    let hasError = false;
    let count = promiseList.length;
    const results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise((resolve2, reject) => {
      promiseList.forEach((promise, index2) => {
        promise.catch((e2) => {
          hasError = true;
          return e2;
        }).then((result) => {
          count -= 1;
          results[index2] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve2(results);
        });
      });
    });
  }
  function isRequired(rules2) {
    let isRequired2 = false;
    if (rules2 && rules2.length) {
      rules2.every((rule) => {
        if (rule.required) {
          isRequired2 = true;
          return false;
        }
        return true;
      });
    }
    return isRequired2;
  }
  function toArray$2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function getPropByPath(obj2, path, strict) {
    let tempObj = obj2;
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    const keyArr = path.split(".");
    let i2 = 0;
    for (let len2 = keyArr.length; i2 < len2 - 1; ++i2) {
      if (!tempObj && !strict) break;
      const key2 = keyArr[i2];
      if (key2 in tempObj) {
        tempObj = tempObj[key2];
      } else {
        if (strict) {
          throw new Error("please transfer a valid name path to validate!");
        }
        break;
      }
    }
    return {
      o: tempObj,
      k: keyArr[i2],
      v: tempObj ? tempObj[keyArr[i2]] : null,
      isValid: tempObj && keyArr[i2] in tempObj
    };
  }
  function useForm(modelRef) {
    let rulesRef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ref({});
    let options2 = arguments.length > 2 ? arguments[2] : void 0;
    const initialModel = cloneDeep(unref(modelRef));
    const validateInfos = reactive({});
    const rulesKeys = shallowRef([]);
    const resetFields = (newValues) => {
      _extends$1(unref(modelRef), _extends$1(_extends$1({}, cloneDeep(initialModel)), newValues));
      nextTick(() => {
        Object.keys(validateInfos).forEach((key2) => {
          validateInfos[key2] = {
            autoLink: false,
            required: isRequired(unref(rulesRef)[key2])
          };
        });
      });
    };
    const filterRules = function() {
      let rules2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let trigger2 = arguments.length > 1 ? arguments[1] : void 0;
      if (!trigger2.length) {
        return rules2;
      } else {
        return rules2.filter((rule) => {
          const triggerList = toArray$2(rule.trigger || "change");
          return intersection(triggerList, trigger2).length;
        });
      }
    };
    let lastValidatePromise = null;
    const validateFields = function(names2) {
      let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let strict = arguments.length > 2 ? arguments[2] : void 0;
      const promiseList = [];
      const values = {};
      for (let i2 = 0; i2 < names2.length; i2++) {
        const name = names2[i2];
        const prop = getPropByPath(unref(modelRef), name, strict);
        if (!prop.isValid) continue;
        values[name] = prop.v;
        const rules2 = filterRules(unref(rulesRef)[name], toArray$2(option && option.trigger));
        if (rules2.length) {
          promiseList.push(validateField(name, prop.v, rules2, option || {}).then(() => ({
            name,
            errors: [],
            warnings: []
          })).catch((ruleErrors) => {
            const mergedErrors = [];
            const mergedWarnings = [];
            ruleErrors.forEach((_ref) => {
              let {
                rule: {
                  warningOnly
                },
                errors
              } = _ref;
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      }
      const summaryPromise = allPromiseFinish(promiseList);
      lastValidatePromise = summaryPromise;
      const returnPromise = summaryPromise.then(() => {
        if (lastValidatePromise === summaryPromise) {
          return Promise.resolve(values);
        }
        return Promise.reject([]);
      }).catch((results) => {
        const errorList = results.filter((result) => result && result.errors.length);
        return errorList.length ? Promise.reject({
          values,
          errorFields: errorList,
          outOfDate: lastValidatePromise !== summaryPromise
        }) : Promise.resolve(values);
      });
      returnPromise.catch((e2) => e2);
      return returnPromise;
    };
    const validateField = function(name, value, rules2) {
      let option = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const promise = validateRules([name], value, rules2, _extends$1({
        validateMessages: defaultValidateMessages
      }, option), !!option.validateFirst);
      if (!validateInfos[name]) {
        return promise.catch((e2) => e2);
      }
      validateInfos[name].validateStatus = "validating";
      promise.catch((e2) => e2).then(function() {
        let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var _a2;
        if (validateInfos[name].validateStatus === "validating") {
          const res = results.filter((result) => result && result.errors.length);
          validateInfos[name].validateStatus = res.length ? "error" : "success";
          validateInfos[name].help = res.length ? res.map((r2) => r2.errors) : null;
          (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.onValidate) === null || _a2 === void 0 ? void 0 : _a2.call(options2, name, !res.length, res.length ? toRaw(validateInfos[name].help[0]) : null);
        }
      });
      return promise;
    };
    const validate = (names2, option) => {
      let keys2 = [];
      let strict = true;
      if (!names2) {
        strict = false;
        keys2 = rulesKeys.value;
      } else if (Array.isArray(names2)) {
        keys2 = names2;
      } else {
        keys2 = [names2];
      }
      const promises = validateFields(keys2, option || {}, strict);
      promises.catch((e2) => e2);
      return promises;
    };
    const clearValidate = (names2) => {
      let keys2 = [];
      if (!names2) {
        keys2 = rulesKeys.value;
      } else if (Array.isArray(names2)) {
        keys2 = names2;
      } else {
        keys2 = [names2];
      }
      keys2.forEach((key2) => {
        validateInfos[key2] && _extends$1(validateInfos[key2], {
          validateStatus: "",
          help: null
        });
      });
    };
    const mergeValidateInfo = (items) => {
      const info = {
        autoLink: false
      };
      const help = [];
      const infos = Array.isArray(items) ? items : [items];
      for (let i2 = 0; i2 < infos.length; i2++) {
        const arg = infos[i2];
        if ((arg === null || arg === void 0 ? void 0 : arg.validateStatus) === "error") {
          info.validateStatus = "error";
          arg.help && help.push(arg.help);
        }
        info.required = info.required || (arg === null || arg === void 0 ? void 0 : arg.required);
      }
      info.help = help;
      return info;
    };
    let oldModel = initialModel;
    let isFirstTime = true;
    const modelFn = (model) => {
      const names2 = [];
      rulesKeys.value.forEach((key2) => {
        const prop = getPropByPath(model, key2, false);
        const oldProp = getPropByPath(oldModel, key2, false);
        const isFirstValidation = isFirstTime && (options2 === null || options2 === void 0 ? void 0 : options2.immediate) && prop.isValid;
        if (isFirstValidation || !isEqual$1(prop.v, oldProp.v)) {
          names2.push(key2);
        }
      });
      validate(names2, {
        trigger: "change"
      });
      isFirstTime = false;
      oldModel = cloneDeep(toRaw(model));
    };
    const debounceOptions = options2 === null || options2 === void 0 ? void 0 : options2.debounce;
    let first = true;
    watch(rulesRef, () => {
      rulesKeys.value = rulesRef ? Object.keys(unref(rulesRef)) : [];
      if (!first && options2 && options2.validateOnRuleChange) {
        validate();
      }
      first = false;
    }, {
      deep: true,
      immediate: true
    });
    watch(rulesKeys, () => {
      const newValidateInfos = {};
      rulesKeys.value.forEach((key2) => {
        newValidateInfos[key2] = _extends$1({}, validateInfos[key2], {
          autoLink: false,
          required: isRequired(unref(rulesRef)[key2])
        });
        delete validateInfos[key2];
      });
      for (const key2 in validateInfos) {
        if (Object.prototype.hasOwnProperty.call(validateInfos, key2)) {
          delete validateInfos[key2];
        }
      }
      _extends$1(validateInfos, newValidateInfos);
    }, {
      immediate: true
    });
    watch(modelRef, debounceOptions && debounceOptions.wait ? debounce$1(modelFn, debounceOptions.wait, omit(debounceOptions, ["wait"])) : modelFn, {
      immediate: options2 && !!options2.immediate,
      deep: true
    });
    return {
      modelRef,
      rulesRef,
      initialModel,
      validateInfos,
      resetFields,
      validate,
      validateField,
      mergeValidateInfo,
      clearValidate
    };
  }
  const formProps = () => ({
    layout: PropTypes.oneOf(tuple("horizontal", "inline", "vertical")),
    labelCol: objectType(),
    wrapperCol: objectType(),
    colon: booleanType(),
    labelAlign: stringType(),
    labelWrap: booleanType(),
    prefixCls: String,
    requiredMark: someType([String, Boolean]),
    /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
    hideRequiredMark: booleanType(),
    model: PropTypes.object,
    rules: objectType(),
    validateMessages: objectType(),
    validateOnRuleChange: booleanType(),
    // 提交失败自动滚动到第一个错误字段
    scrollToFirstError: anyType(),
    onSubmit: functionType(),
    name: String,
    validateTrigger: someType([String, Array]),
    size: stringType(),
    disabled: booleanType(),
    onValuesChange: functionType(),
    onFieldsChange: functionType(),
    onFinish: functionType(),
    onFinishFailed: functionType(),
    onValidate: functionType()
  });
  function isEqualName(name1, name2) {
    return isEqual$1(toArray$3(name1), toArray$3(name2));
  }
  const Form = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AForm",
    inheritAttrs: false,
    props: initDefaultProps(formProps(), {
      layout: "horizontal",
      hideRequiredMark: false,
      colon: true
    }),
    Item: FormItem,
    useForm,
    // emits: ['finishFailed', 'submit', 'finish', 'validate'],
    setup(props2, _ref) {
      let {
        emit: emit2,
        slots,
        expose,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction,
        form: contextForm,
        size,
        disabled
      } = useConfigInject("form", props2);
      const requiredMark = computed(() => props2.requiredMark === "" || props2.requiredMark);
      const mergedRequiredMark = computed(() => {
        var _a2;
        if (requiredMark.value !== void 0) {
          return requiredMark.value;
        }
        if (contextForm && ((_a2 = contextForm.value) === null || _a2 === void 0 ? void 0 : _a2.requiredMark) !== void 0) {
          return contextForm.value.requiredMark;
        }
        if (props2.hideRequiredMark) {
          return false;
        }
        return true;
      });
      useProviderSize(size);
      useProviderDisabled(disabled);
      const mergedColon = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.colon) !== null && _a2 !== void 0 ? _a2 : (_b2 = contextForm.value) === null || _b2 === void 0 ? void 0 : _b2.colon;
      });
      const {
        validateMessages: globalValidateMessages
      } = useInjectGlobalForm();
      const validateMessages = computed(() => {
        return _extends$1(_extends$1(_extends$1({}, defaultValidateMessages), globalValidateMessages.value), props2.validateMessages);
      });
      const [wrapSSR, hashId] = useStyle$8(prefixCls);
      const formClassName = computed(() => classNames(prefixCls.value, {
        [`${prefixCls.value}-${props2.layout}`]: true,
        [`${prefixCls.value}-hide-required-mark`]: mergedRequiredMark.value === false,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-${size.value}`]: size.value
      }, hashId.value));
      const lastValidatePromise = ref();
      const fields = {};
      const addField = (eventKey, field) => {
        fields[eventKey] = field;
      };
      const removeField = (eventKey) => {
        delete fields[eventKey];
      };
      const getFieldsByNameList = (nameList) => {
        const provideNameList = !!nameList;
        const namePathList = provideNameList ? toArray$3(nameList).map(getNamePath) : [];
        if (!provideNameList) {
          return Object.values(fields);
        } else {
          return Object.values(fields).filter((field) => namePathList.findIndex((namePath) => isEqualName(namePath, field.fieldName.value)) > -1);
        }
      };
      const resetFields = (name) => {
        if (!props2.model) {
          return;
        }
        getFieldsByNameList(name).forEach((field) => {
          field.resetField();
        });
      };
      const clearValidate = (name) => {
        getFieldsByNameList(name).forEach((field) => {
          field.clearValidate();
        });
      };
      const handleFinishFailed = (errorInfo) => {
        const {
          scrollToFirstError
        } = props2;
        emit2("finishFailed", errorInfo);
        if (scrollToFirstError && errorInfo.errorFields.length) {
          let scrollToFieldOptions = {};
          if (typeof scrollToFirstError === "object") {
            scrollToFieldOptions = scrollToFirstError;
          }
          scrollToField(errorInfo.errorFields[0].name, scrollToFieldOptions);
        }
      };
      const validate = function() {
        return validateField(...arguments);
      };
      const scrollToField = function(name) {
        let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const fields2 = getFieldsByNameList(name ? [name] : void 0);
        if (fields2.length) {
          const fieldId = fields2[0].fieldId.value;
          const node2 = fieldId ? document.getElementById(fieldId) : null;
          if (node2) {
            scrollIntoView(node2, _extends$1({
              scrollMode: "if-needed",
              block: "nearest"
            }, options2));
          }
        }
      };
      const getFieldsValue = function() {
        let nameList = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (nameList === true) {
          const allNameList = [];
          Object.values(fields).forEach((_ref2) => {
            let {
              namePath
            } = _ref2;
            allNameList.push(namePath.value);
          });
          return cloneByNamePathList(props2.model, allNameList);
        } else {
          return cloneByNamePathList(props2.model, nameList);
        }
      };
      const validateFields = (nameList, options2) => {
        if (!props2.model) {
          return Promise.reject("Form `model` is required for validateFields to work.");
        }
        const provideNameList = !!nameList;
        const namePathList = provideNameList ? toArray$3(nameList).map(getNamePath) : [];
        const promiseList = [];
        Object.values(fields).forEach((field) => {
          var _a2;
          if (!provideNameList) {
            namePathList.push(field.namePath.value);
          }
          if (!((_a2 = field.rules) === null || _a2 === void 0 ? void 0 : _a2.value.length)) {
            return;
          }
          const fieldNamePath = field.namePath.value;
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
            const promise = field.validateRules(_extends$1({
              validateMessages: validateMessages.value
            }, options2));
            promiseList.push(promise.then(() => ({
              name: fieldNamePath,
              errors: [],
              warnings: []
            })).catch((ruleErrors) => {
              const mergedErrors = [];
              const mergedWarnings = [];
              ruleErrors.forEach((_ref3) => {
                let {
                  rule: {
                    warningOnly
                  },
                  errors
                } = _ref3;
                if (warningOnly) {
                  mergedWarnings.push(...errors);
                } else {
                  mergedErrors.push(...errors);
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        const summaryPromise = allPromiseFinish(promiseList);
        lastValidatePromise.value = summaryPromise;
        const returnPromise = summaryPromise.then(() => {
          if (lastValidatePromise.value === summaryPromise) {
            return Promise.resolve(getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch((results) => {
          const errorList = results.filter((result) => result && result.errors.length);
          return Promise.reject({
            values: getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: lastValidatePromise.value !== summaryPromise
          });
        });
        returnPromise.catch((e2) => e2);
        return returnPromise;
      };
      const validateField = function() {
        return validateFields(...arguments);
      };
      const handleSubmit = (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        emit2("submit", e2);
        if (props2.model) {
          const res = validateFields();
          res.then((values) => {
            emit2("finish", values);
          }).catch((errors) => {
            handleFinishFailed(errors);
          });
        }
      };
      expose({
        resetFields,
        clearValidate,
        validateFields,
        getFieldsValue,
        validate,
        scrollToField
      });
      useProvideForm({
        model: computed(() => props2.model),
        name: computed(() => props2.name),
        labelAlign: computed(() => props2.labelAlign),
        labelCol: computed(() => props2.labelCol),
        labelWrap: computed(() => props2.labelWrap),
        wrapperCol: computed(() => props2.wrapperCol),
        vertical: computed(() => props2.layout === "vertical"),
        colon: mergedColon,
        requiredMark: mergedRequiredMark,
        validateTrigger: computed(() => props2.validateTrigger),
        rules: computed(() => props2.rules),
        addField,
        removeField,
        onValidate: (name, status, errors) => {
          emit2("validate", name, status, errors);
        },
        validateMessages
      });
      watch(() => props2.rules, () => {
        if (props2.validateOnRuleChange) {
          validateFields();
        }
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("form", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "onSubmit": handleSubmit,
          "class": [formClassName.value, attrs.class]
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  Form.useInjectFormItemContext = useInjectFormItemContext;
  Form.ItemRest = FormItemRest;
  Form.install = function(app2) {
    app2.component(Form.name, Form);
    app2.component(Form.Item.name, Form.Item);
    app2.component(FormItemRest.name, FormItemRest);
    return app2;
  };
  const antCheckboxEffect = new Keyframe("antCheckboxEffect", {
    "0%": {
      transform: "scale(1)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(1.6)",
      opacity: 0
    }
  });
  const genCheckboxStyle = (token2) => {
    const {
      checkboxCls
    } = token2;
    const wrapperCls = `${checkboxCls}-wrapper`;
    return [
      // ===================== Basic =====================
      {
        // Group
        [`${checkboxCls}-group`]: _extends$1(_extends$1({}, resetComponent(token2)), {
          display: "inline-flex",
          flexWrap: "wrap",
          columnGap: token2.marginXS,
          // Group > Grid
          [`> ${token2.antCls}-row`]: {
            flex: 1
          }
        }),
        // Wrapper
        [wrapperCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          display: "inline-flex",
          alignItems: "baseline",
          cursor: "pointer",
          // Fix checkbox & radio in flex align #30260
          "&:after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: "'\\a0'"
          },
          // Checkbox near checkbox
          [`& + ${wrapperCls}`]: {
            marginInlineStart: 0
          },
          [`&${wrapperCls}-in-form-item`]: {
            'input[type="checkbox"]': {
              width: 14,
              height: 14
              // FIXME: magic
            }
          }
        }),
        // Wrapper > Checkbox
        [checkboxCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "relative",
          whiteSpace: "nowrap",
          lineHeight: 1,
          cursor: "pointer",
          // To make alignment right when `controlHeight` is changed
          // Ref: https://github.com/ant-design/ant-design/issues/41564
          alignSelf: "center",
          // Wrapper > Checkbox > input
          [`${checkboxCls}-input`]: {
            position: "absolute",
            // Since baseline align will get additional space offset,
            // we need to move input to top to make it align with text.
            // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0,
            margin: 0,
            [`&:focus-visible + ${checkboxCls}-inner`]: _extends$1({}, genFocusOutline(token2))
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            boxSizing: "border-box",
            position: "relative",
            top: 0,
            insetInlineStart: 0,
            display: "block",
            width: token2.checkboxSize,
            height: token2.checkboxSize,
            direction: "ltr",
            backgroundColor: token2.colorBgContainer,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusSM,
            borderCollapse: "separate",
            transition: `all ${token2.motionDurationSlow}`,
            "&:after": {
              boxSizing: "border-box",
              position: "absolute",
              top: "50%",
              insetInlineStart: "21.5%",
              display: "table",
              width: token2.checkboxSize / 14 * 5,
              height: token2.checkboxSize / 14 * 8,
              border: `${token2.lineWidthBold}px solid ${token2.colorWhite}`,
              borderTop: 0,
              borderInlineStart: 0,
              transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
              opacity: 0,
              content: '""',
              transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
            }
          },
          // Wrapper > Checkbox + Text
          "& + span": {
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.paddingXS
          }
        })
      },
      // ================= Indeterminate =================
      {
        [checkboxCls]: {
          "&-indeterminate": {
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              "&:after": {
                top: "50%",
                insetInlineStart: "50%",
                width: token2.fontSizeLG / 2,
                height: token2.fontSizeLG / 2,
                backgroundColor: token2.colorPrimary,
                border: 0,
                transform: "translate(-50%, -50%) scale(1)",
                opacity: 1,
                content: '""'
              }
            }
          }
        }
      },
      // ===================== Hover =====================
      {
        // Wrapper
        [`${wrapperCls}:hover ${checkboxCls}:after`]: {
          visibility: "visible"
        },
        // Wrapper & Wrapper > Checkbox
        [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            borderColor: token2.colorPrimary
          }
        },
        [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          },
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
            borderColor: token2.colorPrimaryHover
          }
        }
      },
      // ==================== Checked ====================
      {
        // Wrapper > Checkbox
        [`${checkboxCls}-checked`]: {
          [`${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimary,
            borderColor: token2.colorPrimary,
            "&:after": {
              opacity: 1,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            }
          },
          // Checked Effect
          "&:after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderRadius: token2.borderRadiusSM,
            visibility: "hidden",
            border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
            animationName: antCheckboxEffect,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: "ease-in-out",
            animationFillMode: "backwards",
            content: '""',
            transition: `all ${token2.motionDurationSlow}`
          }
        },
        [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          },
          [`&:hover ${checkboxCls}:after`]: {
            borderColor: token2.colorPrimaryHover
          }
        }
      },
      // ==================== Disable ====================
      {
        // Wrapper
        [`${wrapperCls}-disabled`]: {
          cursor: "not-allowed"
        },
        // Wrapper > Checkbox
        [`${checkboxCls}-disabled`]: {
          // Wrapper > Checkbox > input
          [`&, ${checkboxCls}-input`]: {
            cursor: "not-allowed",
            // Disabled for native input to enable Tooltip event handler
            // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
            pointerEvents: "none"
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            background: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            "&:after": {
              borderColor: token2.colorTextDisabled
            }
          },
          "&:after": {
            display: "none"
          },
          "& + span": {
            color: token2.colorTextDisabled
          },
          [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
            background: token2.colorTextDisabled
          }
        }
      }
    ];
  };
  function getStyle$2(prefixCls, token2) {
    const checkboxToken = merge$2(token2, {
      checkboxCls: `.${prefixCls}`,
      checkboxSize: token2.controlInteractiveSize
    });
    return [genCheckboxStyle(checkboxToken)];
  }
  const useStyle$7 = genComponentStyleHook("Checkbox", (token2, _ref) => {
    let {
      prefixCls
    } = _ref;
    return [getStyle$2(prefixCls, token2)];
  });
  const abstractCheckboxGroupProps = () => {
    return {
      name: String,
      prefixCls: String,
      options: arrayType([]),
      disabled: Boolean,
      id: String
    };
  };
  const checkboxGroupProps = () => {
    return _extends$1(_extends$1({}, abstractCheckboxGroupProps()), {
      defaultValue: arrayType(),
      value: arrayType(),
      onChange: functionType(),
      "onUpdate:value": functionType()
    });
  };
  const abstractCheckboxProps = () => {
    return {
      prefixCls: String,
      defaultChecked: booleanType(),
      checked: booleanType(),
      disabled: booleanType(),
      isGroup: booleanType(),
      value: PropTypes.any,
      name: String,
      id: String,
      indeterminate: booleanType(),
      type: stringType("checkbox"),
      autofocus: booleanType(),
      onChange: functionType(),
      "onUpdate:checked": functionType(),
      onClick: functionType(),
      skipGroup: booleanType(false)
    };
  };
  const checkboxProps = () => {
    return _extends$1(_extends$1({}, abstractCheckboxProps()), {
      indeterminate: booleanType(false)
    });
  };
  const CheckboxGroupContextKey = Symbol("CheckboxGroupContext");
  var __rest$j = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const Checkbox = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACheckbox",
    inheritAttrs: false,
    __ANT_CHECKBOX: true,
    props: checkboxProps(),
    // emits: ['change', 'update:checked'],
    setup(props2, _ref) {
      let {
        emit: emit2,
        attrs,
        slots,
        expose
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const {
        prefixCls,
        direction,
        disabled
      } = useConfigInject("checkbox", props2);
      const contextDisabled = useInjectDisabled();
      const [wrapSSR, hashId] = useStyle$7(prefixCls);
      const checkboxGroup = inject(CheckboxGroupContextKey, void 0);
      const uniId = Symbol("checkboxUniId");
      const mergedDisabled = computed(() => {
        return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled.value) || disabled.value;
      });
      watchEffect(() => {
        if (!props2.skipGroup && checkboxGroup) {
          checkboxGroup.registerValue(uniId, props2.value);
        }
      });
      onBeforeUnmount(() => {
        if (checkboxGroup) {
          checkboxGroup.cancelValue(uniId);
        }
      });
      onMounted(() => {
        warning$2(!!(props2.checked !== void 0 || checkboxGroup || props2.value === void 0));
      });
      const handleChange = (event) => {
        const targetChecked = event.target.checked;
        emit2("update:checked", targetChecked);
        emit2("change", event);
        formItemContext.onFieldChange();
      };
      const checkboxRef = ref();
      const focus = () => {
        var _a2;
        (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      return () => {
        var _a2;
        const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        const {
          indeterminate,
          skipGroup,
          id = formItemContext.id.value
        } = props2, restProps = __rest$j(props2, ["indeterminate", "skipGroup", "id"]);
        const {
          onMouseenter,
          onMouseleave,
          onInput,
          class: className,
          style
        } = attrs, restAttrs = __rest$j(attrs, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]);
        const checkboxProps2 = _extends$1(_extends$1(_extends$1(_extends$1({}, restProps), {
          id,
          prefixCls: prefixCls.value
        }), restAttrs), {
          disabled: mergedDisabled.value
        });
        if (checkboxGroup && !skipGroup) {
          checkboxProps2.onChange = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            emit2("change", ...args);
            checkboxGroup.toggleOption({
              label: children,
              value: props2.value
            });
          };
          checkboxProps2.name = checkboxGroup.name.value;
          checkboxProps2.checked = checkboxGroup.mergedValue.value.includes(props2.value);
          checkboxProps2.disabled = mergedDisabled.value || contextDisabled.value;
          checkboxProps2.indeterminate = indeterminate;
        } else {
          checkboxProps2.onChange = handleChange;
        }
        const classString = classNames({
          [`${prefixCls.value}-wrapper`]: true,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [`${prefixCls.value}-wrapper-checked`]: checkboxProps2.checked,
          [`${prefixCls.value}-wrapper-disabled`]: checkboxProps2.disabled,
          [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
        }, className, hashId.value);
        const checkboxClass = classNames({
          [`${prefixCls.value}-indeterminate`]: indeterminate
        }, hashId.value);
        const ariaChecked = indeterminate ? "mixed" : void 0;
        return wrapSSR(createVNode("label", {
          "class": classString,
          "style": style,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave
        }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({
          "aria-checked": ariaChecked
        }, checkboxProps2), {}, {
          "class": checkboxClass,
          "ref": checkboxRef
        }), null), children.length ? createVNode("span", null, [children]) : null]));
      };
    }
  });
  const CheckboxGroup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACheckboxGroup",
    inheritAttrs: false,
    props: checkboxGroupProps(),
    // emits: ['change', 'update:value'],
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const {
        prefixCls,
        direction
      } = useConfigInject("checkbox", props2);
      const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
      const [wrapSSR, hashId] = useStyle$7(groupPrefixCls);
      const mergedValue = ref((props2.value === void 0 ? props2.defaultValue : props2.value) || []);
      watch(() => props2.value, () => {
        mergedValue.value = props2.value || [];
      });
      const options2 = computed(() => {
        return props2.options.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return {
              label: option,
              value: option
            };
          }
          return option;
        });
      });
      const triggerUpdate = ref(Symbol());
      const registeredValuesMap = ref(/* @__PURE__ */ new Map());
      const cancelValue = (id) => {
        registeredValuesMap.value.delete(id);
        triggerUpdate.value = Symbol();
      };
      const registerValue = (id, value) => {
        registeredValuesMap.value.set(id, value);
        triggerUpdate.value = Symbol();
      };
      const registeredValues = ref(/* @__PURE__ */ new Map());
      watch(triggerUpdate, () => {
        const valuseMap = /* @__PURE__ */ new Map();
        for (const value of registeredValuesMap.value.values()) {
          valuseMap.set(value, true);
        }
        registeredValues.value = valuseMap;
      });
      const toggleOption = (option) => {
        const optionIndex = mergedValue.value.indexOf(option.value);
        const value = [...mergedValue.value];
        if (optionIndex === -1) {
          value.push(option.value);
        } else {
          value.splice(optionIndex, 1);
        }
        if (props2.value === void 0) {
          mergedValue.value = value;
        }
        const val = value.filter((val2) => registeredValues.value.has(val2)).sort((a2, b2) => {
          const indexA = options2.value.findIndex((opt) => opt.value === a2);
          const indexB = options2.value.findIndex((opt) => opt.value === b2);
          return indexA - indexB;
        });
        emit2("update:value", val);
        emit2("change", val);
        formItemContext.onFieldChange();
      };
      provide(CheckboxGroupContextKey, {
        cancelValue,
        registerValue,
        toggleOption,
        mergedValue,
        name: computed(() => props2.name),
        disabled: computed(() => props2.disabled)
      });
      expose({
        mergedValue
      });
      return () => {
        var _a2;
        const {
          id = formItemContext.id.value
        } = props2;
        let children = null;
        if (options2.value && options2.value.length > 0) {
          children = options2.value.map((option) => {
            var _a3;
            return createVNode(Checkbox, {
              "prefixCls": prefixCls.value,
              "key": option.value.toString(),
              "disabled": "disabled" in option ? option.disabled : props2.disabled,
              "indeterminate": option.indeterminate,
              "value": option.value,
              "checked": mergedValue.value.indexOf(option.value) !== -1,
              "onChange": option.onChange,
              "class": `${groupPrefixCls.value}-item`
            }, {
              default: () => [slots.label !== void 0 ? (_a3 = slots.label) === null || _a3 === void 0 ? void 0 : _a3.call(slots, option) : option.label]
            });
          });
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [groupPrefixCls.value, {
            [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value],
          "id": id
        }), [children || ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]));
      };
    }
  });
  Checkbox.Group = CheckboxGroup;
  Checkbox.install = function(app2) {
    app2.component(Checkbox.name, Checkbox);
    app2.component(CheckboxGroup.name, CheckboxGroup);
    return app2;
  };
  const Col = withInstall(Col$1);
  let runtimeLocale = _extends$1({}, localeValues$1.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      runtimeLocale = _extends$1(_extends$1({}, runtimeLocale), newLocale);
    } else {
      runtimeLocale = _extends$1({}, localeValues$1.Modal);
    }
  }
  const ANT_MARK = "internalMark";
  const LocaleProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ALocaleProvider",
    props: {
      locale: {
        type: Object
      },
      ANT_MARK__: String
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      warning$2(props2.ANT_MARK__ === ANT_MARK);
      const state = reactive({
        antLocale: _extends$1(_extends$1({}, props2.locale), {
          exist: true
        }),
        ANT_MARK__: ANT_MARK
      });
      provide("localeData", state);
      watch(() => props2.locale, (locale2) => {
        changeConfirmLocale(locale2 && locale2.Modal);
        state.antLocale = _extends$1(_extends$1({}, locale2), {
          exist: true
        });
      }, {
        immediate: true
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  LocaleProvider.install = function(app2) {
    app2.component(LocaleProvider.name, LocaleProvider);
    return app2;
  };
  const locale = withInstall(LocaleProvider);
  const Notice = /* @__PURE__ */ defineComponent({
    name: "Notice",
    inheritAttrs: false,
    props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      let closeTimer;
      let isUnMounted = false;
      const duration = computed(() => props2.duration === void 0 ? 4.5 : props2.duration);
      const startCloseTimer = () => {
        if (duration.value && !isUnMounted) {
          closeTimer = setTimeout(() => {
            close();
          }, duration.value * 1e3);
        }
      };
      const clearCloseTimer = () => {
        if (closeTimer) {
          clearTimeout(closeTimer);
          closeTimer = null;
        }
      };
      const close = (e2) => {
        if (e2) {
          e2.stopPropagation();
        }
        clearCloseTimer();
        const {
          onClose,
          noticeKey
        } = props2;
        if (onClose) {
          onClose(noticeKey);
        }
      };
      const restartCloseTimer = () => {
        clearCloseTimer();
        startCloseTimer();
      };
      onMounted(() => {
        startCloseTimer();
      });
      onUnmounted(() => {
        isUnMounted = true;
        clearCloseTimer();
      });
      watch([duration, () => props2.updateMark, () => props2.visible], (_ref2, _ref3) => {
        let [preDuration, preUpdateMark, preVisible] = _ref2;
        let [newDuration, newUpdateMark, newVisible] = _ref3;
        if (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) {
          restartCloseTimer();
        }
      }, {
        flush: "post"
      });
      return () => {
        var _a2, _b2;
        const {
          prefixCls,
          closable,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          onClick,
          holder
        } = props2;
        const {
          class: className,
          style
        } = attrs;
        const componentClass = `${prefixCls}-notice`;
        const dataOrAriaAttributeProps = Object.keys(attrs).reduce((acc, key2) => {
          if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
            acc[key2] = attrs[key2];
          }
          return acc;
        }, {});
        const node2 = createVNode("div", _objectSpread2$1({
          "class": classNames(componentClass, className, {
            [`${componentClass}-closable`]: closable
          }),
          "style": style,
          "onMouseenter": clearCloseTimer,
          "onMouseleave": startCloseTimer,
          "onClick": onClick
        }, dataOrAriaAttributeProps), [createVNode("div", {
          "class": `${componentClass}-content`
        }, [(_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots)]), closable ? createVNode("a", {
          "tabindex": 0,
          "onClick": close,
          "class": `${componentClass}-close`
        }, [closeIcon || createVNode("span", {
          "class": `${componentClass}-close-x`
        }, null)]) : null]);
        if (holder) {
          return createVNode(Teleport, {
            "to": holder
          }, {
            default: () => node2
          });
        }
        return node2;
      };
    }
  });
  var __rest$i = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  let seed$1 = 0;
  const now$1 = Date.now();
  function getUuid$1() {
    const id = seed$1;
    seed$1 += 1;
    return `rcNotification_${now$1}_${id}`;
  }
  const Notification$1 = /* @__PURE__ */ defineComponent({
    name: "Notification",
    inheritAttrs: false,
    props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
    setup(props2, _ref) {
      let {
        attrs,
        expose,
        slots
      } = _ref;
      const hookRefs = /* @__PURE__ */ new Map();
      const notices = ref([]);
      const transitionProps = computed(() => {
        const {
          prefixCls,
          animation = "fade"
        } = props2;
        let name = props2.transitionName;
        if (!name && animation) {
          name = `${prefixCls}-${animation}`;
        }
        return getTransitionGroupProps(name);
      });
      const add2 = (originNotice, holderCallback) => {
        const key2 = originNotice.key || getUuid$1();
        const notice2 = _extends$1(_extends$1({}, originNotice), {
          key: key2
        });
        const {
          maxCount: maxCount2
        } = props2;
        const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
        const updatedNotices = notices.value.concat();
        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, {
            notice: notice2,
            holderCallback
          });
        } else {
          if (maxCount2 && notices.value.length >= maxCount2) {
            notice2.key = updatedNotices[0].notice.key;
            notice2.updateMark = getUuid$1();
            notice2.userPassKey = key2;
            updatedNotices.shift();
          }
          updatedNotices.push({
            notice: notice2,
            holderCallback
          });
        }
        notices.value = updatedNotices;
      };
      const remove2 = (removeKey) => {
        notices.value = toRaw(notices.value).filter((_ref2) => {
          let {
            notice: {
              key: key2,
              userPassKey
            }
          } = _ref2;
          const mergedKey = userPassKey || key2;
          return mergedKey !== removeKey;
        });
      };
      expose({
        add: add2,
        remove: remove2,
        notices
      });
      return () => {
        var _a2;
        const {
          prefixCls,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
            prefixCls
          })
        } = props2;
        const noticeNodes = notices.value.map((_ref3, index2) => {
          let {
            notice: notice2,
            holderCallback
          } = _ref3;
          const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
          const {
            key: key2,
            userPassKey
          } = notice2;
          const {
            content
          } = notice2;
          const noticeProps = _extends$1(_extends$1(_extends$1({
            prefixCls,
            closeIcon: typeof closeIcon === "function" ? closeIcon({
              prefixCls
            }) : closeIcon
          }, notice2), notice2.props), {
            key: key2,
            noticeKey: userPassKey || key2,
            updateMark,
            onClose: (noticeKey) => {
              var _a3;
              remove2(noticeKey);
              (_a3 = notice2.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(notice2);
            },
            onClick: notice2.onClick
          });
          if (holderCallback) {
            return createVNode("div", {
              "key": key2,
              "class": `${prefixCls}-hook-holder`,
              "ref": (div2) => {
                if (typeof key2 === "undefined") {
                  return;
                }
                if (div2) {
                  hookRefs.set(key2, div2);
                  holderCallback(div2, noticeProps);
                } else {
                  hookRefs.delete(key2);
                }
              }
            }, null);
          }
          return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
            "class": classNames(noticeProps.class, props2.hashId)
          }), {
            default: () => [typeof content === "function" ? content({
              prefixCls
            }) : content]
          });
        });
        const className = {
          [prefixCls]: 1,
          [attrs.class]: !!attrs.class,
          [props2.hashId]: true
        };
        return createVNode("div", {
          "class": className,
          "style": attrs.style || {
            top: "65px",
            left: "50%"
          }
        }, [createVNode(TransitionGroup, _objectSpread2$1({
          "tag": "div"
        }, transitionProps.value), {
          default: () => [noticeNodes]
        })]);
      };
    }
  });
  Notification$1.newInstance = function newNotificationInstance(properties, callback) {
    const _a2 = properties || {}, {
      name = "notification",
      getContainer: getContainer2,
      appContext,
      prefixCls: customizePrefixCls,
      rootPrefixCls: customRootPrefixCls,
      transitionName: customTransitionName,
      hasTransitionName: hasTransitionName2,
      useStyle: useStyle2
    } = _a2, props2 = __rest$i(_a2, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]);
    const div2 = document.createElement("div");
    if (getContainer2) {
      const root2 = getContainer2();
      root2.appendChild(div2);
    } else {
      document.body.appendChild(div2);
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: "NotificationWrapper",
      setup(_props, _ref4) {
        let {
          attrs
        } = _ref4;
        const notiRef = shallowRef();
        const prefixCls = computed(() => globalConfigForApi.getPrefixCls(name, customizePrefixCls));
        const [, hashId] = useStyle2(prefixCls);
        onMounted(() => {
          callback({
            notice(noticeProps) {
              var _a3;
              (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.add(noticeProps);
            },
            removeNotice(key2) {
              var _a3;
              (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.remove(key2);
            },
            destroy() {
              render$2(null, div2);
              if (div2.parentNode) {
                div2.parentNode.removeChild(div2);
              }
            },
            component: notiRef
          });
        });
        return () => {
          const global2 = globalConfigForApi;
          const rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls.value);
          const transitionName2 = hasTransitionName2 ? customTransitionName : `${prefixCls.value}-${customTransitionName}`;
          return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
            "prefixCls": rootPrefixCls
          }), {
            default: () => [createVNode(Notification$1, _objectSpread2$1(_objectSpread2$1({
              "ref": notiRef
            }, attrs), {}, {
              "prefixCls": prefixCls.value,
              "transitionName": transitionName2,
              "hashId": hashId.value
            }), null)]
          });
        };
      }
    });
    const vm = createVNode(Wrapper, props2);
    vm.appContext = appContext || vm.appContext;
    render$2(vm, div2);
  };
  let seed = 0;
  const now = Date.now();
  function getUuid() {
    const id = seed;
    seed += 1;
    return `rcNotification_${now}_${id}`;
  }
  const Notification = /* @__PURE__ */ defineComponent({
    name: "HookNotification",
    inheritAttrs: false,
    props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const hookRefs = /* @__PURE__ */ new Map();
      const notices = computed(() => props2.notices);
      const transitionProps = computed(() => {
        let name = props2.transitionName;
        if (!name && props2.animation) {
          switch (typeof props2.animation) {
            case "string":
              name = props2.animation;
              break;
            case "function":
              name = props2.animation().name;
              break;
            case "object":
              name = props2.animation.name;
              break;
            default:
              name = `${props2.prefixCls}-fade`;
              break;
          }
        }
        return getTransitionGroupProps(name);
      });
      const remove2 = (key2) => props2.remove(key2);
      const placements2 = ref({});
      watch(notices, () => {
        const nextPlacements = {};
        Object.keys(placements2.value).forEach((placement) => {
          nextPlacements[placement] = [];
        });
        props2.notices.forEach((config) => {
          const {
            placement = "topRight"
          } = config.notice;
          if (placement) {
            nextPlacements[placement] = nextPlacements[placement] || [];
            nextPlacements[placement].push(config);
          }
        });
        placements2.value = nextPlacements;
      });
      const placementList = computed(() => Object.keys(placements2.value));
      return () => {
        var _a2;
        const {
          prefixCls,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
            prefixCls
          })
        } = props2;
        const noticeNodes = placementList.value.map((placement) => {
          var _a3, _b2;
          const noticesForPlacement = placements2.value[placement];
          const classes = (_a3 = props2.getClassName) === null || _a3 === void 0 ? void 0 : _a3.call(props2, placement);
          const styles = (_b2 = props2.getStyles) === null || _b2 === void 0 ? void 0 : _b2.call(props2, placement);
          const noticeNodesForPlacement = noticesForPlacement.map((_ref2, index2) => {
            let {
              notice: notice2,
              holderCallback
            } = _ref2;
            const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
            const {
              key: key2,
              userPassKey
            } = notice2;
            const {
              content
            } = notice2;
            const noticeProps = _extends$1(_extends$1(_extends$1({
              prefixCls,
              closeIcon: typeof closeIcon === "function" ? closeIcon({
                prefixCls
              }) : closeIcon
            }, notice2), notice2.props), {
              key: key2,
              noticeKey: userPassKey || key2,
              updateMark,
              onClose: (noticeKey) => {
                var _a4;
                remove2(noticeKey);
                (_a4 = notice2.onClose) === null || _a4 === void 0 ? void 0 : _a4.call(notice2);
              },
              onClick: notice2.onClick
            });
            if (holderCallback) {
              return createVNode("div", {
                "key": key2,
                "class": `${prefixCls}-hook-holder`,
                "ref": (div2) => {
                  if (typeof key2 === "undefined") {
                    return;
                  }
                  if (div2) {
                    hookRefs.set(key2, div2);
                    holderCallback(div2, noticeProps);
                  } else {
                    hookRefs.delete(key2);
                  }
                }
              }, null);
            }
            return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
              "class": classNames(noticeProps.class, props2.hashId)
            }), {
              default: () => [typeof content === "function" ? content({
                prefixCls
              }) : content]
            });
          });
          const className = {
            [prefixCls]: 1,
            [`${prefixCls}-${placement}`]: 1,
            [attrs.class]: !!attrs.class,
            [props2.hashId]: true,
            [classes]: !!classes
          };
          function onAfterLeave() {
            var _a4;
            if (noticesForPlacement.length > 0) {
              return;
            }
            Reflect.deleteProperty(placements2.value, placement);
            (_a4 = props2.onAllRemoved) === null || _a4 === void 0 ? void 0 : _a4.call(props2);
          }
          return createVNode("div", {
            "key": placement,
            "class": className,
            "style": attrs.style || styles || {
              top: "65px",
              left: "50%"
            }
          }, [createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({
            "tag": "div"
          }, transitionProps.value), {}, {
            "onAfterLeave": onAfterLeave
          }), {
            default: () => [noticeNodesForPlacement]
          })]);
        });
        return createVNode(Portal$1, {
          "getContainer": props2.getContainer
        }, {
          default: () => [noticeNodes]
        });
      };
    }
  });
  var __rest$h = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const defaultGetContainer$1 = () => document.body;
  let uniqueKey = 0;
  function mergeConfig$2() {
    const clone2 = {};
    for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
      objList[_key] = arguments[_key];
    }
    objList.forEach((obj2) => {
      if (obj2) {
        Object.keys(obj2).forEach((key2) => {
          const val = obj2[key2];
          if (val !== void 0) {
            clone2[key2] = val;
          }
        });
      }
    });
    return clone2;
  }
  function useNotification$1() {
    let rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      getContainer: getContainer2 = defaultGetContainer$1,
      motion,
      prefixCls,
      maxCount: maxCount2,
      getClassName,
      getStyles,
      onAllRemoved
    } = rootConfig, shareConfig = __rest$h(rootConfig, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]);
    const notices = shallowRef([]);
    const notificationsRef = shallowRef();
    const add2 = (originNotice, holderCallback) => {
      const key2 = originNotice.key || getUuid();
      const notice2 = _extends$1(_extends$1({}, originNotice), {
        key: key2
      });
      const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
      const updatedNotices = notices.value.concat();
      if (noticeIndex !== -1) {
        updatedNotices.splice(noticeIndex, 1, {
          notice: notice2,
          holderCallback
        });
      } else {
        if (maxCount2 && notices.value.length >= maxCount2) {
          notice2.key = updatedNotices[0].notice.key;
          notice2.updateMark = getUuid();
          notice2.userPassKey = key2;
          updatedNotices.shift();
        }
        updatedNotices.push({
          notice: notice2,
          holderCallback
        });
      }
      notices.value = updatedNotices;
    };
    const removeNotice = (removeKey) => {
      notices.value = notices.value.filter((_ref) => {
        let {
          notice: {
            key: key2,
            userPassKey
          }
        } = _ref;
        const mergedKey = userPassKey || key2;
        return mergedKey !== removeKey;
      });
    };
    const destroy = () => {
      notices.value = [];
    };
    const contextHolder = () => createVNode(Notification, {
      "ref": notificationsRef,
      "prefixCls": prefixCls,
      "maxCount": maxCount2,
      "notices": notices.value,
      "remove": removeNotice,
      "getClassName": getClassName,
      "getStyles": getStyles,
      "animation": motion,
      "hashId": rootConfig.hashId,
      "onAllRemoved": onAllRemoved,
      "getContainer": getContainer2
    }, null);
    const taskQueue = shallowRef([]);
    const api2 = {
      open: (config) => {
        const mergedConfig = mergeConfig$2(shareConfig, config);
        if (mergedConfig.key === null || mergedConfig.key === void 0) {
          mergedConfig.key = `vc-notification-${uniqueKey}`;
          uniqueKey += 1;
        }
        taskQueue.value = [...taskQueue.value, {
          type: "open",
          config: mergedConfig
        }];
      },
      close: (key2) => {
        taskQueue.value = [...taskQueue.value, {
          type: "close",
          key: key2
        }];
      },
      destroy: () => {
        taskQueue.value = [...taskQueue.value, {
          type: "destroy"
        }];
      }
    };
    watch(taskQueue, () => {
      if (taskQueue.value.length) {
        taskQueue.value.forEach((task) => {
          switch (task.type) {
            case "open":
              add2(task.config);
              break;
            case "close":
              removeNotice(task.key);
              break;
            case "destroy":
              destroy();
              break;
          }
        });
        taskQueue.value = [];
      }
    });
    return [api2, contextHolder];
  }
  const genMessageStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      boxShadowSecondary,
      colorBgElevated,
      colorSuccess,
      colorError,
      colorWarning,
      colorInfo,
      fontSizeLG,
      motionEaseInOutCirc,
      motionDurationSlow,
      marginXS,
      paddingXS,
      borderRadiusLG,
      zIndexPopup,
      // Custom token
      messageNoticeContentPadding
    } = token2;
    const messageMoveIn = new Keyframe("MessageMoveIn", {
      "0%": {
        padding: 0,
        transform: "translateY(-100%)",
        opacity: 0
      },
      "100%": {
        padding: paddingXS,
        transform: "translateY(0)",
        opacity: 1
      }
    });
    const messageMoveOut = new Keyframe("MessageMoveOut", {
      "0%": {
        maxHeight: token2.height,
        padding: paddingXS,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        padding: 0,
        opacity: 0
      }
    });
    return [
      // ============================ Holder ============================
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "fixed",
          top: marginXS,
          left: "50%",
          transform: "translateX(-50%)",
          width: "100%",
          pointerEvents: "none",
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: "forwards"
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: "running"
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: "running"
          },
          "&-rtl": {
            direction: "rtl",
            span: {
              direction: "rtl"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [`${componentCls}-notice`]: {
          padding: paddingXS,
          textAlign: "center",
          [iconCls]: {
            verticalAlign: "text-bottom",
            marginInlineEnd: marginXS,
            fontSize: fontSizeLG
          },
          [`${componentCls}-notice-content`]: {
            display: "inline-block",
            padding: messageNoticeContentPadding,
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            pointerEvents: "all"
          },
          [`${componentCls}-success ${iconCls}`]: {
            color: colorSuccess
          },
          [`${componentCls}-error ${iconCls}`]: {
            color: colorError
          },
          [`${componentCls}-warning ${iconCls}`]: {
            color: colorWarning
          },
          [`
        ${componentCls}-info ${iconCls},
        ${componentCls}-loading ${iconCls}`]: {
            color: colorInfo
          }
        }
      },
      // ============================= Pure =============================
      {
        [`${componentCls}-notice-pure-panel`]: {
          padding: 0,
          textAlign: "start"
        }
      }
    ];
  };
  const useStyle$6 = genComponentStyleHook("Message", (token2) => {
    const combinedToken = merge$2(token2, {
      messageNoticeContentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
    });
    return [genMessageStyle(combinedToken)];
  }, (token2) => ({
    height: 150,
    zIndexPopup: token2.zIndexPopupBase + 10
  }));
  const TypeIcon = {
    info: createVNode(InfoCircleFilled, null, null),
    success: createVNode(CheckCircleFilled, null, null),
    error: createVNode(CloseCircleFilled, null, null),
    warning: createVNode(ExclamationCircleFilled, null, null),
    loading: createVNode(LoadingOutlined, null, null)
  };
  const PureContent$1 = /* @__PURE__ */ defineComponent({
    name: "PureContent",
    inheritAttrs: false,
    props: ["prefixCls", "type", "icon"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return createVNode("div", {
          "class": classNames(`${props2.prefixCls}-custom-content`, `${props2.prefixCls}-${props2.type}`)
        }, [props2.icon || TypeIcon[props2.type], createVNode("span", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
      };
    }
  });
  var __rest$g = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const DEFAULT_OFFSET$1 = 8;
  const DEFAULT_DURATION$1 = 3;
  const Holder$1 = /* @__PURE__ */ defineComponent({
    name: "Holder",
    inheritAttrs: false,
    props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved", "animation", "staticGetContainer"],
    setup(props2, _ref) {
      let {
        expose
      } = _ref;
      var _a2, _b2;
      const {
        getPrefixCls,
        getPopupContainer
      } = useConfigInject("message", props2);
      const prefixCls = computed(() => getPrefixCls("message", props2.prefixCls));
      const [, hashId] = useStyle$6(prefixCls);
      const getStyles = () => {
        var _a3;
        const top = (_a3 = props2.top) !== null && _a3 !== void 0 ? _a3 : DEFAULT_OFFSET$1;
        return {
          left: "50%",
          transform: "translateX(-50%)",
          top: typeof top === "number" ? `${top}px` : top
        };
      };
      const getClassName = () => classNames(hashId.value, props2.rtl ? `${prefixCls.value}-rtl` : "");
      const getNotificationMotion = () => {
        var _a3;
        return getMotion$1({
          prefixCls: prefixCls.value,
          animation: (_a3 = props2.animation) !== null && _a3 !== void 0 ? _a3 : `move-up`,
          transitionName: props2.transitionName
        });
      };
      const mergedCloseIcon = createVNode("span", {
        "class": `${prefixCls.value}-close-x`
      }, [createVNode(CloseOutlined, {
        "class": `${prefixCls.value}-close-icon`
      }, null)]);
      const [api2, holder] = useNotification$1({
        //@ts-ignore
        getStyles,
        prefixCls: prefixCls.value,
        getClassName,
        motion: getNotificationMotion,
        closable: false,
        closeIcon: mergedCloseIcon,
        duration: (_a2 = props2.duration) !== null && _a2 !== void 0 ? _a2 : DEFAULT_DURATION$1,
        getContainer: (_b2 = props2.staticGetContainer) !== null && _b2 !== void 0 ? _b2 : getPopupContainer.value,
        maxCount: props2.maxCount,
        onAllRemoved: props2.onAllRemoved
      });
      expose(_extends$1(_extends$1({}, api2), {
        prefixCls,
        hashId
      }));
      return holder;
    }
  });
  let keyIndex = 0;
  function useInternalMessage(messageConfig) {
    const holderRef = shallowRef(null);
    const holderKey = Symbol("messageHolderKey");
    const close = (key2) => {
      var _a2;
      (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
    };
    const open2 = (config) => {
      if (!holderRef.value) {
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.value;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type,
        key: key2,
        class: className,
        onClose
      } = config, restConfig = __rest$g(config, ["content", "icon", "type", "key", "class", "onClose"]);
      let mergedKey = key2;
      if (mergedKey === void 0 || mergedKey === null) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      return wrapPromiseFn((resolve2) => {
        originOpen(_extends$1(_extends$1({}, restConfig), {
          key: mergedKey,
          content: () => createVNode(PureContent$1, {
            "prefixCls": prefixCls,
            "type": type,
            "icon": typeof icon === "function" ? icon() : icon
          }, {
            default: () => [typeof content === "function" ? content() : content]
          }),
          placement: "top",
          // @ts-ignore
          class: classNames(type && `${noticePrefixCls}-${type}`, hashId, className),
          onClose: () => {
            onClose === null || onClose === void 0 ? void 0 : onClose();
            resolve2();
          }
        }));
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy = (key2) => {
      var _a2;
      if (key2 !== void 0) {
        close(key2);
      } else {
        (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      }
    };
    const wrapAPI = {
      open: open2,
      destroy
    };
    const keys2 = ["info", "success", "warning", "error", "loading"];
    keys2.forEach((type) => {
      const typeOpen = (jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = _extends$1(_extends$1({
          onClose: mergedOnClose,
          duration: mergedDuration
        }, config), {
          type
        });
        return open2(mergedConfig);
      };
      wrapAPI[type] = typeOpen;
    });
    return [wrapAPI, () => createVNode(Holder$1, _objectSpread2$1(_objectSpread2$1({
      "key": holderKey
    }, messageConfig), {}, {
      "ref": holderRef
    }), null)];
  }
  function useMessage(messageConfig) {
    return useInternalMessage(messageConfig);
  }
  let defaultDuration$1 = 3;
  let defaultTop$1;
  let messageInstance;
  let key = 1;
  let localPrefixCls = "";
  let transitionName = "move-up";
  let hasTransitionName = false;
  let getContainer = () => document.body;
  let maxCount$1;
  let rtl$1 = false;
  function getKeyThenIncreaseKey() {
    return key++;
  }
  function setMessageConfig(options2) {
    if (options2.top !== void 0) {
      defaultTop$1 = options2.top;
      messageInstance = null;
    }
    if (options2.duration !== void 0) {
      defaultDuration$1 = options2.duration;
    }
    if (options2.prefixCls !== void 0) {
      localPrefixCls = options2.prefixCls;
    }
    if (options2.getContainer !== void 0) {
      getContainer = options2.getContainer;
      messageInstance = null;
    }
    if (options2.transitionName !== void 0) {
      transitionName = options2.transitionName;
      messageInstance = null;
      hasTransitionName = true;
    }
    if (options2.maxCount !== void 0) {
      maxCount$1 = options2.maxCount;
      messageInstance = null;
    }
    if (options2.rtl !== void 0) {
      rtl$1 = options2.rtl;
    }
  }
  function getMessageInstance(args, callback) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }
    Notification$1.newInstance({
      appContext: args.appContext,
      prefixCls: args.prefixCls || localPrefixCls,
      rootPrefixCls: args.rootPrefixCls,
      transitionName,
      hasTransitionName,
      style: {
        top: defaultTop$1
      },
      getContainer: getContainer || args.getPopupContainer,
      maxCount: maxCount$1,
      name: "message",
      useStyle: useStyle$6
    }, (instance) => {
      if (messageInstance) {
        callback(messageInstance);
        return;
      }
      messageInstance = instance;
      callback(instance);
    });
  }
  const typeToIcon$2 = {
    info: InfoCircleFilled,
    success: CheckCircleFilled,
    error: CloseCircleFilled,
    warning: ExclamationCircleFilled,
    loading: LoadingOutlined
  };
  const typeList = Object.keys(typeToIcon$2);
  function notice$1(args) {
    const duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
    const target = args.key || getKeyThenIncreaseKey();
    const closePromise = new Promise((resolve2) => {
      const callback = () => {
        if (typeof args.onClose === "function") {
          args.onClose();
        }
        return resolve2(true);
      };
      getMessageInstance(args, (instance) => {
        instance.notice({
          key: target,
          duration,
          style: args.style || {},
          class: args.class,
          content: (_ref) => {
            let {
              prefixCls
            } = _ref;
            const Icon2 = typeToIcon$2[args.type];
            const iconNode = Icon2 ? createVNode(Icon2, null, null) : "";
            const messageClass = classNames(`${prefixCls}-custom-content`, {
              [`${prefixCls}-${args.type}`]: args.type,
              [`${prefixCls}-rtl`]: rtl$1 === true
            });
            return createVNode("div", {
              "class": messageClass
            }, [typeof args.icon === "function" ? args.icon() : args.icon || iconNode, createVNode("span", null, [typeof args.content === "function" ? args.content() : args.content])]);
          },
          onClose: callback,
          onClick: args.onClick
        });
      });
    });
    const result = () => {
      if (messageInstance) {
        messageInstance.removeNotice(target);
      }
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  function isArgsProps(content) {
    return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
  }
  const api$1 = {
    open: notice$1,
    config: setMessageConfig,
    destroy(messageKey) {
      if (messageInstance) {
        if (messageKey) {
          const {
            removeNotice
          } = messageInstance;
          removeNotice(messageKey);
        } else {
          const {
            destroy
          } = messageInstance;
          destroy();
          messageInstance = null;
        }
      }
    }
  };
  function attachTypeApi(originalApi, type) {
    originalApi[type] = (content, duration, onClose) => {
      if (isArgsProps(content)) {
        return originalApi.open(_extends$1(_extends$1({}, content), {
          type
        }));
      }
      if (typeof duration === "function") {
        onClose = duration;
        duration = void 0;
      }
      return originalApi.open({
        content,
        duration,
        type,
        onClose
      });
    };
  }
  typeList.forEach((type) => attachTypeApi(api$1, type));
  api$1.warn = api$1.warning;
  api$1.useMessage = useMessage;
  const genNotificationPlacementStyle = (token2) => {
    const {
      componentCls,
      width,
      notificationMarginEdge
    } = token2;
    const notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
      "0%": {
        marginTop: "-100%",
        opacity: 0
      },
      "100%": {
        marginTop: 0,
        opacity: 1
      }
    });
    const notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
      "0%": {
        marginBottom: "-100%",
        opacity: 0
      },
      "100%": {
        marginBottom: 0,
        opacity: 1
      }
    });
    const notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
      "0%": {
        right: {
          _skip_check_: true,
          value: width
        },
        opacity: 0
      },
      "100%": {
        right: {
          _skip_check_: true,
          value: 0
        },
        opacity: 1
      }
    });
    return {
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        marginInline: 0
      },
      [`&${componentCls}-top`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationTopFadeIn
        }
      },
      [`&${componentCls}-bottom`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationBottomFadeIn
        }
      },
      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
        marginInlineEnd: 0,
        marginInlineStart: notificationMarginEdge,
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationLeftFadeIn
        }
      }
    };
  };
  const genNotificationStyle = (token2) => {
    const {
      iconCls,
      componentCls,
      // .ant-notification
      boxShadowSecondary,
      fontSizeLG,
      notificationMarginBottom,
      borderRadiusLG,
      colorSuccess,
      colorInfo,
      colorWarning,
      colorError,
      colorTextHeading,
      notificationBg,
      notificationPadding,
      notificationMarginEdge,
      motionDurationMid,
      motionEaseInOut,
      fontSize,
      lineHeight,
      width,
      notificationIconSize
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const notificationFadeIn = new Keyframe("antNotificationFadeIn", {
      "0%": {
        left: {
          _skip_check_: true,
          value: width
        },
        opacity: 0
      },
      "100%": {
        left: {
          _skip_check_: true,
          value: 0
        },
        opacity: 1
      }
    });
    const notificationFadeOut = new Keyframe("antNotificationFadeOut", {
      "0%": {
        maxHeight: token2.animationMaxHeight,
        marginBottom: notificationMarginBottom,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    });
    return [
      // ============================ Holder ============================
      {
        [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
          position: "fixed",
          zIndex: token2.zIndexPopup,
          marginInlineEnd: notificationMarginEdge,
          [`${componentCls}-hook-holder`]: {
            position: "relative"
          },
          [`&${componentCls}-top, &${componentCls}-bottom`]: {
            [`${componentCls}-notice`]: {
              marginInline: "auto auto"
            }
          },
          [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
            [`${componentCls}-notice`]: {
              marginInlineEnd: "auto",
              marginInlineStart: 0
            }
          },
          //  animation
          [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            opacity: 0,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-leave`]: {
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            animationDuration: motionDurationMid,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: notificationFadeIn,
            animationPlayState: "running"
          },
          [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
            animationName: notificationFadeOut,
            animationPlayState: "running"
          }
        }), genNotificationPlacementStyle(token2)), {
          // RTL
          "&-rtl": {
            direction: "rtl",
            [`${componentCls}-notice-btn`]: {
              float: "left"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [noticeCls]: {
          position: "relative",
          width,
          maxWidth: `calc(100vw - ${notificationMarginEdge * 2}px)`,
          marginBottom: notificationMarginBottom,
          marginInlineStart: "auto",
          padding: notificationPadding,
          overflow: "hidden",
          lineHeight,
          wordWrap: "break-word",
          background: notificationBg,
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          [`${componentCls}-close-icon`]: {
            fontSize,
            cursor: "pointer"
          },
          [`${noticeCls}-message`]: {
            marginBottom: token2.marginXS,
            color: colorTextHeading,
            fontSize: fontSizeLG,
            lineHeight: token2.lineHeightLG
          },
          [`${noticeCls}-description`]: {
            fontSize
          },
          [`&${noticeCls}-closable ${noticeCls}-message`]: {
            paddingInlineEnd: token2.paddingLG
          },
          [`${noticeCls}-with-icon ${noticeCls}-message`]: {
            marginBottom: token2.marginXS,
            marginInlineStart: token2.marginSM + notificationIconSize,
            fontSize: fontSizeLG
          },
          [`${noticeCls}-with-icon ${noticeCls}-description`]: {
            marginInlineStart: token2.marginSM + notificationIconSize,
            fontSize
          },
          // Icon & color style in different selector level
          // https://github.com/ant-design/ant-design/issues/16503
          // https://github.com/ant-design/ant-design/issues/15512
          [`${noticeCls}-icon`]: {
            position: "absolute",
            fontSize: notificationIconSize,
            lineHeight: 0,
            // icon-font
            [`&-success${iconCls}`]: {
              color: colorSuccess
            },
            [`&-info${iconCls}`]: {
              color: colorInfo
            },
            [`&-warning${iconCls}`]: {
              color: colorWarning
            },
            [`&-error${iconCls}`]: {
              color: colorError
            }
          },
          [`${noticeCls}-close`]: {
            position: "absolute",
            top: token2.notificationPaddingVertical,
            insetInlineEnd: token2.notificationPaddingHorizontal,
            color: token2.colorIcon,
            outline: "none",
            width: token2.notificationCloseButtonSize,
            height: token2.notificationCloseButtonSize,
            borderRadius: token2.borderRadiusSM,
            transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
              color: token2.colorIconHover,
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
            }
          },
          [`${noticeCls}-btn`]: {
            float: "right",
            marginTop: token2.marginSM
          }
        }
      },
      // ============================= Pure =============================
      {
        [`${noticeCls}-pure-panel`]: {
          margin: 0
        }
      }
    ];
  };
  const useStyle$5 = genComponentStyleHook("Notification", (token2) => {
    const notificationPaddingVertical = token2.paddingMD;
    const notificationPaddingHorizontal = token2.paddingLG;
    const notificationToken = merge$2(token2, {
      // default.less variables
      notificationBg: token2.colorBgElevated,
      notificationPaddingVertical,
      notificationPaddingHorizontal,
      // index.less variables
      notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
      notificationMarginBottom: token2.margin,
      notificationMarginEdge: token2.marginLG,
      animationMaxHeight: 150,
      notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
      notificationCloseButtonSize: token2.controlHeightLG * 0.55
    });
    return [genNotificationStyle(notificationToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 50,
    width: 384
  }));
  function getCloseIcon(prefixCls, closeIcon) {
    return closeIcon || createVNode("span", {
      "class": `${prefixCls}-close-x`
    }, [createVNode(CloseOutlined, {
      "class": `${prefixCls}-close-icon`
    }, null)]);
  }
  ({
    info: createVNode(InfoCircleFilled, null, null),
    success: createVNode(CheckCircleFilled, null, null),
    error: createVNode(CloseCircleFilled, null, null),
    warning: createVNode(ExclamationCircleFilled, null, null),
    loading: createVNode(LoadingOutlined, null, null)
  });
  const typeToIcon$1 = {
    success: CheckCircleFilled,
    info: InfoCircleFilled,
    error: CloseCircleFilled,
    warning: ExclamationCircleFilled
  };
  function PureContent(_ref) {
    let {
      prefixCls,
      icon,
      type,
      message,
      description,
      btn: btn2
    } = _ref;
    let iconNode = null;
    if (icon) {
      iconNode = createVNode("span", {
        "class": `${prefixCls}-icon`
      }, [renderHelper(icon)]);
    } else if (type) {
      const Icon2 = typeToIcon$1[type];
      iconNode = createVNode(Icon2, {
        "class": `${prefixCls}-icon ${prefixCls}-icon-${type}`
      }, null);
    }
    return createVNode("div", {
      "class": classNames({
        [`${prefixCls}-with-icon`]: iconNode
      }),
      "role": "alert"
    }, [iconNode, createVNode("div", {
      "class": `${prefixCls}-message`
    }, [message]), createVNode("div", {
      "class": `${prefixCls}-description`
    }, [description]), btn2 && createVNode("div", {
      "class": `${prefixCls}-btn`
    }, [btn2])]);
  }
  function getPlacementStyle(placement, top, bottom) {
    let style;
    top = typeof top === "number" ? `${top}px` : top;
    bottom = typeof bottom === "number" ? `${bottom}px` : bottom;
    switch (placement) {
      case "top":
        style = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top,
          bottom: "auto"
        };
        break;
      case "topLeft":
        style = {
          left: 0,
          top,
          bottom: "auto"
        };
        break;
      case "topRight":
        style = {
          right: 0,
          top,
          bottom: "auto"
        };
        break;
      case "bottom":
        style = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top: "auto",
          bottom
        };
        break;
      case "bottomLeft":
        style = {
          left: 0,
          top: "auto",
          bottom
        };
        break;
      default:
        style = {
          right: 0,
          top: "auto",
          bottom
        };
        break;
    }
    return style;
  }
  function getMotion(prefixCls) {
    return {
      name: `${prefixCls}-fade`
    };
  }
  var __rest$f = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const DEFAULT_OFFSET = 24;
  const DEFAULT_DURATION = 4.5;
  const Holder = /* @__PURE__ */ defineComponent({
    name: "Holder",
    inheritAttrs: false,
    props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
    setup(props2, _ref) {
      let {
        expose
      } = _ref;
      const {
        getPrefixCls,
        getPopupContainer
      } = useConfigInject("notification", props2);
      const prefixCls = computed(() => props2.prefixCls || getPrefixCls("notification"));
      const getStyles = (placement) => {
        var _a2, _b2;
        return getPlacementStyle(placement, (_a2 = props2.top) !== null && _a2 !== void 0 ? _a2 : DEFAULT_OFFSET, (_b2 = props2.bottom) !== null && _b2 !== void 0 ? _b2 : DEFAULT_OFFSET);
      };
      const [, hashId] = useStyle$5(prefixCls);
      const getClassName = () => classNames(hashId.value, {
        [`${prefixCls.value}-rtl`]: props2.rtl
      });
      const getNotificationMotion = () => getMotion(prefixCls.value);
      const [api2, holder] = useNotification$1({
        prefixCls: prefixCls.value,
        getStyles,
        getClassName,
        motion: getNotificationMotion,
        closable: true,
        closeIcon: getCloseIcon(prefixCls.value),
        duration: DEFAULT_DURATION,
        getContainer: () => {
          var _a2, _b2;
          return ((_a2 = props2.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.call(props2)) || ((_b2 = getPopupContainer.value) === null || _b2 === void 0 ? void 0 : _b2.call(getPopupContainer)) || document.body;
        },
        maxCount: props2.maxCount,
        hashId: hashId.value,
        onAllRemoved: props2.onAllRemoved
      });
      expose(_extends$1(_extends$1({}, api2), {
        prefixCls: prefixCls.value,
        hashId
      }));
      return holder;
    }
  });
  function useInternalNotification(notificationConfig) {
    const holderRef = shallowRef(null);
    const holderKey = Symbol("notificationHolderKey");
    const open2 = (config) => {
      if (!holderRef.value) {
        return;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.value;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        message,
        description,
        icon,
        type,
        btn: btn2,
        class: className
      } = config, restConfig = __rest$f(config, ["message", "description", "icon", "type", "btn", "class"]);
      return originOpen(_extends$1(_extends$1({
        placement: "topRight"
      }, restConfig), {
        content: () => createVNode(PureContent, {
          "prefixCls": noticePrefixCls,
          "icon": typeof icon === "function" ? icon() : icon,
          "type": type,
          "message": typeof message === "function" ? message() : message,
          "description": typeof description === "function" ? description() : description,
          "btn": typeof btn2 === "function" ? btn2() : btn2
        }, null),
        // @ts-ignore
        class: classNames(type && `${noticePrefixCls}-${type}`, hashId, className)
      }));
    };
    const destroy = (key2) => {
      var _a2, _b2;
      if (key2 !== void 0) {
        (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
      } else {
        (_b2 = holderRef.value) === null || _b2 === void 0 ? void 0 : _b2.destroy();
      }
    };
    const wrapAPI = {
      open: open2,
      destroy
    };
    const keys2 = ["success", "info", "warning", "error"];
    keys2.forEach((type) => {
      wrapAPI[type] = (config) => open2(_extends$1(_extends$1({}, config), {
        type
      }));
    });
    return [wrapAPI, () => createVNode(Holder, _objectSpread2$1(_objectSpread2$1({
      "key": holderKey
    }, notificationConfig), {}, {
      "ref": holderRef
    }), null)];
  }
  function useNotification(notificationConfig) {
    return useInternalNotification(notificationConfig);
  }
  const notificationInstance = {};
  let defaultDuration = 4.5;
  let defaultTop = "24px";
  let defaultBottom = "24px";
  let defaultPrefixCls$1 = "";
  let defaultPlacement = "topRight";
  let defaultGetContainer = () => document.body;
  let defaultCloseIcon = null;
  let rtl = false;
  let maxCount;
  function setNotificationConfig(options2) {
    const {
      duration,
      placement,
      bottom,
      top,
      getContainer: getContainer2,
      closeIcon,
      prefixCls
    } = options2;
    if (prefixCls !== void 0) {
      defaultPrefixCls$1 = prefixCls;
    }
    if (duration !== void 0) {
      defaultDuration = duration;
    }
    if (placement !== void 0) {
      defaultPlacement = placement;
    }
    if (bottom !== void 0) {
      defaultBottom = typeof bottom === "number" ? `${bottom}px` : bottom;
    }
    if (top !== void 0) {
      defaultTop = typeof top === "number" ? `${top}px` : top;
    }
    if (getContainer2 !== void 0) {
      defaultGetContainer = getContainer2;
    }
    if (closeIcon !== void 0) {
      defaultCloseIcon = closeIcon;
    }
    if (options2.rtl !== void 0) {
      rtl = options2.rtl;
    }
    if (options2.maxCount !== void 0) {
      maxCount = options2.maxCount;
    }
  }
  function getNotificationInstance(_ref, callback) {
    let {
      prefixCls: customizePrefixCls,
      placement = defaultPlacement,
      getContainer: getContainer2 = defaultGetContainer,
      top,
      bottom,
      closeIcon = defaultCloseIcon,
      appContext
    } = _ref;
    const {
      getPrefixCls
    } = globalConfig();
    const prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1);
    const cacheKey = `${prefixCls}-${placement}-${rtl}`;
    const cacheInstance = notificationInstance[cacheKey];
    if (cacheInstance) {
      Promise.resolve(cacheInstance).then((instance) => {
        callback(instance);
      });
      return;
    }
    const notificationClass = classNames(`${prefixCls}-${placement}`, {
      [`${prefixCls}-rtl`]: rtl === true
    });
    Notification$1.newInstance({
      name: "notification",
      prefixCls: customizePrefixCls || defaultPrefixCls$1,
      useStyle: useStyle$5,
      class: notificationClass,
      style: getPlacementStyle(placement, top !== null && top !== void 0 ? top : defaultTop, bottom !== null && bottom !== void 0 ? bottom : defaultBottom),
      appContext,
      getContainer: getContainer2,
      closeIcon: (_ref2) => {
        let {
          prefixCls: prefixCls2
        } = _ref2;
        const closeIconToRender = createVNode("span", {
          "class": `${prefixCls2}-close-x`
        }, [renderHelper(closeIcon, {}, createVNode(CloseOutlined, {
          "class": `${prefixCls2}-close-icon`
        }, null))]);
        return closeIconToRender;
      },
      maxCount,
      hasTransitionName: true
    }, (notification) => {
      notificationInstance[cacheKey] = notification;
      callback(notification);
    });
  }
  const typeToIcon = {
    success: CheckCircleOutlined,
    info: InfoCircleOutlined,
    error: CloseCircleOutlined,
    warning: ExclamationCircleOutlined
  };
  function notice(args) {
    const {
      icon,
      type,
      description,
      message,
      btn: btn2
    } = args;
    const duration = args.duration === void 0 ? defaultDuration : args.duration;
    getNotificationInstance(args, (notification) => {
      notification.notice({
        content: (_ref3) => {
          let {
            prefixCls: outerPrefixCls
          } = _ref3;
          const prefixCls = `${outerPrefixCls}-notice`;
          let iconNode = null;
          if (icon) {
            iconNode = () => createVNode("span", {
              "class": `${prefixCls}-icon`
            }, [renderHelper(icon)]);
          } else if (type) {
            const Icon2 = typeToIcon[type];
            iconNode = () => createVNode(Icon2, {
              "class": `${prefixCls}-icon ${prefixCls}-icon-${type}`
            }, null);
          }
          return createVNode("div", {
            "class": iconNode ? `${prefixCls}-with-icon` : ""
          }, [iconNode && iconNode(), createVNode("div", {
            "class": `${prefixCls}-message`
          }, [!description && iconNode ? createVNode("span", {
            "class": `${prefixCls}-message-single-line-auto-margin`
          }, null) : null, renderHelper(message)]), createVNode("div", {
            "class": `${prefixCls}-description`
          }, [renderHelper(description)]), btn2 ? createVNode("span", {
            "class": `${prefixCls}-btn`
          }, [renderHelper(btn2)]) : null]);
        },
        duration,
        closable: true,
        onClose: args.onClose,
        onClick: args.onClick,
        key: args.key,
        style: args.style || {},
        class: args.class
      });
    });
  }
  const api = {
    open: notice,
    close(key2) {
      Object.keys(notificationInstance).forEach((cacheKey) => Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
        instance.removeNotice(key2);
      }));
    },
    config: setNotificationConfig,
    destroy() {
      Object.keys(notificationInstance).forEach((cacheKey) => {
        Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
          instance.destroy();
        });
        delete notificationInstance[cacheKey];
      });
    }
  };
  const iconTypes = ["success", "info", "warning", "error"];
  iconTypes.forEach((type) => {
    api[type] = (args) => api.open(_extends$1(_extends$1({}, args), {
      type
    }));
  });
  api.warn = api.warning;
  api.useNotification = useNotification;
  const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
  function getStyle$1(globalPrefixCls, theme2) {
    const variables = {};
    const formatColor = (color2, updater) => {
      let clone2 = color2.clone();
      clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
      return clone2.toRgbString();
    };
    const fillColor = (colorVal, type) => {
      const baseColor = new TinyColor(colorVal);
      const colorPalettes = generate$1(baseColor.toRgbString());
      variables[`${type}-color`] = formatColor(baseColor);
      variables[`${type}-color-disabled`] = colorPalettes[1];
      variables[`${type}-color-hover`] = colorPalettes[4];
      variables[`${type}-color-active`] = colorPalettes[6];
      variables[`${type}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
      variables[`${type}-color-deprecated-bg`] = colorPalettes[0];
      variables[`${type}-color-deprecated-border`] = colorPalettes[2];
    };
    if (theme2.primaryColor) {
      fillColor(theme2.primaryColor, "primary");
      const primaryColor = new TinyColor(theme2.primaryColor);
      const primaryColors = generate$1(primaryColor.toRgbString());
      primaryColors.forEach((color2, index2) => {
        variables[`primary-${index2 + 1}`] = color2;
      });
      variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
      const primaryActiveColor = new TinyColor(primaryColors[0]);
      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
    }
    if (theme2.successColor) {
      fillColor(theme2.successColor, "success");
    }
    if (theme2.warningColor) {
      fillColor(theme2.warningColor, "warning");
    }
    if (theme2.errorColor) {
      fillColor(theme2.errorColor, "error");
    }
    if (theme2.infoColor) {
      fillColor(theme2.infoColor, "info");
    }
    const cssList = Object.keys(variables).map((key2) => `--${globalPrefixCls}-${key2}: ${variables[key2]};`);
    return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
  }
  function registerTheme$1(globalPrefixCls, theme2) {
    const style = getStyle$1(globalPrefixCls, theme2);
    if (canUseDom$1()) {
      updateCSS$1(style, `${dynamicStyleMark}-dynamic-theme`);
    }
  }
  const useStyle$4 = (iconPrefixCls) => {
    const [theme2, token2] = useToken();
    return useStyleRegister(computed(() => ({
      theme: theme2.value,
      token: token2.value,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls.value]
    })), () => [{
      [`.${iconPrefixCls.value}`]: _extends$1(_extends$1({}, resetIcon()), {
        [`.${iconPrefixCls.value} .${iconPrefixCls.value}-icon`]: {
          display: "block"
        }
      })
    }]);
  };
  function useTheme(theme2, parentTheme) {
    const themeConfig = computed(() => (theme2 === null || theme2 === void 0 ? void 0 : theme2.value) || {});
    const parentThemeConfig = computed(() => themeConfig.value.inherit === false || !(parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value) ? defaultConfig : parentTheme.value);
    const mergedTheme = computed(() => {
      if (!(theme2 === null || theme2 === void 0 ? void 0 : theme2.value)) {
        return parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value;
      }
      const mergedComponents = _extends$1({}, parentThemeConfig.value.components);
      Object.keys(theme2.value.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = _extends$1(_extends$1({}, mergedComponents[componentName]), theme2.value.components[componentName]);
      });
      return _extends$1(_extends$1(_extends$1({}, parentThemeConfig.value), themeConfig.value), {
        token: _extends$1(_extends$1({}, parentThemeConfig.value.token), themeConfig.value.token),
        components: mergedComponents
      });
    });
    return mergedTheme;
  }
  var __rest$e = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const defaultPrefixCls = "ant";
  function getGlobalPrefixCls() {
    return globalConfigForApi.prefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalConfigForApi.iconPrefixCls || defaultIconPrefixCls;
  }
  const globalConfigBySet = reactive({});
  const globalConfigForApi = reactive({});
  watchEffect(() => {
    _extends$1(globalConfigForApi, globalConfigBySet);
    globalConfigForApi.prefixCls = getGlobalPrefixCls();
    globalConfigForApi.iconPrefixCls = getGlobalIconPrefixCls();
    globalConfigForApi.getPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) return customizePrefixCls;
      return suffixCls ? `${globalConfigForApi.prefixCls}-${suffixCls}` : globalConfigForApi.prefixCls;
    };
    globalConfigForApi.getRootPrefixCls = () => {
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      return getGlobalPrefixCls();
    };
  });
  let stopWatchEffect;
  const setGlobalConfig = (params2) => {
    if (stopWatchEffect) {
      stopWatchEffect();
    }
    stopWatchEffect = watchEffect(() => {
      _extends$1(globalConfigBySet, reactive(params2));
      _extends$1(globalConfigForApi, reactive(params2));
    });
    if (params2.theme) {
      registerTheme$1(getGlobalPrefixCls(), params2.theme);
    }
  };
  const globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) return customizePrefixCls;
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      return getGlobalPrefixCls();
    }
  });
  const ConfigProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AConfigProvider",
    inheritAttrs: false,
    props: configProviderProps(),
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const parentContext = useConfigContextInject();
      const getPrefixCls = (suffixCls, customizePrefixCls) => {
        const {
          prefixCls = "ant"
        } = props2;
        if (customizePrefixCls) return customizePrefixCls;
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      };
      const iconPrefixCls = computed(() => props2.iconPrefixCls || parentContext.iconPrefixCls.value || defaultIconPrefixCls);
      const shouldWrapSSR = computed(() => iconPrefixCls.value !== parentContext.iconPrefixCls.value);
      const csp = computed(() => {
        var _a2;
        return props2.csp || ((_a2 = parentContext.csp) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      const wrapSSR = useStyle$4(iconPrefixCls);
      const mergedTheme = useTheme(computed(() => props2.theme), computed(() => {
        var _a2;
        return (_a2 = parentContext.theme) === null || _a2 === void 0 ? void 0 : _a2.value;
      }));
      const renderEmptyComponent = (name) => {
        const renderEmpty$1 = props2.renderEmpty || slots.renderEmpty || parentContext.renderEmpty || renderEmpty;
        return renderEmpty$1(name);
      };
      const autoInsertSpaceInButton = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.autoInsertSpaceInButton) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.autoInsertSpaceInButton) === null || _b2 === void 0 ? void 0 : _b2.value;
      });
      const locale$12 = computed(() => {
        var _a2;
        return props2.locale || ((_a2 = parentContext.locale) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      watch(locale$12, () => {
        globalConfigBySet.locale = locale$12.value;
      }, {
        immediate: true
      });
      const direction = computed(() => {
        var _a2;
        return props2.direction || ((_a2 = parentContext.direction) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      const space = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.space) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.space) === null || _b2 === void 0 ? void 0 : _b2.value;
      });
      const virtual = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.virtual) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.virtual) === null || _b2 === void 0 ? void 0 : _b2.value;
      });
      const dropdownMatchSelectWidth = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.dropdownMatchSelectWidth) === null || _b2 === void 0 ? void 0 : _b2.value;
      });
      const getTargetContainer = computed(() => {
        var _a2;
        return props2.getTargetContainer !== void 0 ? props2.getTargetContainer : (_a2 = parentContext.getTargetContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const getPopupContainer = computed(() => {
        var _a2;
        return props2.getPopupContainer !== void 0 ? props2.getPopupContainer : (_a2 = parentContext.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const pageHeader = computed(() => {
        var _a2;
        return props2.pageHeader !== void 0 ? props2.pageHeader : (_a2 = parentContext.pageHeader) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const input = computed(() => {
        var _a2;
        return props2.input !== void 0 ? props2.input : (_a2 = parentContext.input) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const pagination = computed(() => {
        var _a2;
        return props2.pagination !== void 0 ? props2.pagination : (_a2 = parentContext.pagination) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const form = computed(() => {
        var _a2;
        return props2.form !== void 0 ? props2.form : (_a2 = parentContext.form) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const select = computed(() => {
        var _a2;
        return props2.select !== void 0 ? props2.select : (_a2 = parentContext.select) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const componentSize = computed(() => props2.componentSize);
      const componentDisabled = computed(() => props2.componentDisabled);
      const wave = computed(() => {
        var _a2, _b2;
        return (_a2 = props2.wave) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.wave) === null || _b2 === void 0 ? void 0 : _b2.value;
      });
      const configProvider = {
        csp,
        autoInsertSpaceInButton,
        locale: locale$12,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        getPrefixCls,
        iconPrefixCls,
        theme: computed(() => {
          var _a2, _b2;
          return (_a2 = mergedTheme.value) !== null && _a2 !== void 0 ? _a2 : (_b2 = parentContext.theme) === null || _b2 === void 0 ? void 0 : _b2.value;
        }),
        renderEmpty: renderEmptyComponent,
        getTargetContainer,
        getPopupContainer,
        pageHeader,
        input,
        pagination,
        form,
        select,
        componentSize,
        componentDisabled,
        transformCellText: computed(() => props2.transformCellText),
        wave
      };
      const memoTheme = computed(() => {
        const _a2 = mergedTheme.value || {}, {
          algorithm,
          token: token2
        } = _a2, rest = __rest$e(_a2, ["algorithm", "token"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
        return _extends$1(_extends$1({}, rest), {
          theme: themeObj,
          token: _extends$1(_extends$1({}, seedToken), token2)
        });
      });
      const validateMessagesRef = computed(() => {
        var _a2, _b2;
        let validateMessages = {};
        if (locale$12.value) {
          validateMessages = ((_a2 = locale$12.value.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || ((_b2 = localeValues$1.Form) === null || _b2 === void 0 ? void 0 : _b2.defaultValidateMessages) || {};
        }
        if (props2.form && props2.form.validateMessages) {
          validateMessages = _extends$1(_extends$1({}, validateMessages), props2.form.validateMessages);
        }
        return validateMessages;
      });
      useConfigContextProvider(configProvider);
      useProvideGlobalForm({
        validateMessages: validateMessagesRef
      });
      useProviderSize(componentSize);
      useProviderDisabled(componentDisabled);
      const renderProvider = (legacyLocale) => {
        var _a2, _b2;
        let childNode = shouldWrapSSR.value ? wrapSSR((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) : (_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
        if (props2.theme) {
          const _childNode = /* @__PURE__ */ function() {
            return childNode;
          }();
          childNode = createVNode(DesignTokenProvider, {
            "value": memoTheme.value
          }, {
            default: () => [_childNode]
          });
        }
        return createVNode(locale, {
          "locale": locale$12.value || legacyLocale,
          "ANT_MARK__": ANT_MARK
        }, {
          default: () => [childNode]
        });
      };
      watchEffect(() => {
        if (direction.value) {
          api$1.config({
            rtl: direction.value === "rtl"
          });
          api.config({
            rtl: direction.value === "rtl"
          });
        }
      });
      return () => createVNode(LocaleReceiver, {
        "children": (_2, __, legacyLocale) => renderProvider(legacyLocale)
      }, null);
    }
  });
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.install = function(app2) {
    app2.component(ConfigProvider.name, ConfigProvider);
  };
  Dropdown.Button = DropdownButton;
  Dropdown.install = function(app2) {
    app2.component(Dropdown.name, Dropdown);
    app2.component(DropdownButton.name, DropdownButton);
    return app2;
  };
  const isValid$1 = (value) => {
    return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
  };
  function hasPrefixSuffix(propsAndSlots) {
    return isValid$1(propsAndSlots.prefix) || isValid$1(propsAndSlots.suffix) || isValid$1(propsAndSlots.allowClear);
  }
  function hasAddon$1(propsAndSlots) {
    return isValid$1(propsAndSlots.addonBefore) || isValid$1(propsAndSlots.addonAfter);
  }
  function fixControlledValue(value) {
    if (typeof value === "undefined" || value === null) {
      return "";
    }
    return String(value);
  }
  function resolveOnChange(target, e2, onChange, targetValue) {
    if (!onChange) {
      return;
    }
    const event = e2;
    if (e2.type === "click") {
      Object.defineProperty(event, "target", {
        writable: true
      });
      Object.defineProperty(event, "currentTarget", {
        writable: true
      });
      const currentTarget = target.cloneNode(true);
      event.target = currentTarget;
      event.currentTarget = currentTarget;
      currentTarget.value = "";
      onChange(event);
      return;
    }
    if (targetValue !== void 0) {
      Object.defineProperty(event, "target", {
        writable: true
      });
      Object.defineProperty(event, "currentTarget", {
        writable: true
      });
      event.target = target;
      event.currentTarget = target;
      target.value = targetValue;
      onChange(event);
      return;
    }
    onChange(event);
  }
  function triggerFocus(element, option) {
    if (!element) return;
    element.focus(option);
    const {
      cursor
    } = option || {};
    if (cursor) {
      const len2 = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len2, len2);
          break;
        default:
          element.setSelectionRange(0, len2);
      }
    }
  }
  const commonInputProps = () => {
    return {
      addonBefore: PropTypes.any,
      addonAfter: PropTypes.any,
      prefix: PropTypes.any,
      suffix: PropTypes.any,
      clearIcon: PropTypes.any,
      affixWrapperClassName: String,
      groupClassName: String,
      wrapperClassName: String,
      inputClassName: String,
      allowClear: {
        type: Boolean,
        default: void 0
      }
    };
  };
  const baseInputProps = () => {
    return _extends$1(_extends$1({}, commonInputProps()), {
      value: {
        type: [String, Number, Symbol],
        default: void 0
      },
      defaultValue: {
        type: [String, Number, Symbol],
        default: void 0
      },
      inputElement: PropTypes.any,
      prefixCls: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      focused: {
        type: Boolean,
        default: void 0
      },
      triggerFocus: Function,
      readonly: {
        type: Boolean,
        default: void 0
      },
      handleReset: Function,
      hidden: {
        type: Boolean,
        default: void 0
      }
    });
  };
  const inputProps$1 = () => _extends$1(_extends$1({}, baseInputProps()), {
    id: String,
    placeholder: {
      type: [String, Number]
    },
    autocomplete: String,
    type: stringType("text"),
    name: String,
    size: {
      type: String
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    lazy: {
      type: Boolean,
      default: true
    },
    maxlength: Number,
    loading: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    showCount: {
      type: [Boolean, Object]
    },
    htmlSize: Number,
    onPressEnter: Function,
    onKeydown: Function,
    onKeyup: Function,
    onFocus: Function,
    onBlur: Function,
    onChange: Function,
    onInput: Function,
    "onUpdate:value": Function,
    onCompositionstart: Function,
    onCompositionend: Function,
    valueModifiers: Object,
    hidden: {
      type: Boolean,
      default: void 0
    },
    status: String
  });
  const BaseInput = /* @__PURE__ */ defineComponent({
    name: "BaseInput",
    inheritAttrs: false,
    props: baseInputProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const containerRef = ref();
      const onInputMouseDown = (e2) => {
        var _a2;
        if ((_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(e2.target)) {
          const {
            triggerFocus: triggerFocus2
          } = props2;
          triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
        }
      };
      const getClearIcon = () => {
        var _a2;
        const {
          allowClear,
          value,
          disabled,
          readonly: readonly2,
          handleReset,
          suffix = slots.suffix,
          prefixCls
        } = props2;
        if (!allowClear) {
          return null;
        }
        const needClear = !disabled && !readonly2 && value;
        const className = `${prefixCls}-clear-icon`;
        const iconNode = ((_a2 = slots.clearIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || "*";
        return createVNode("span", {
          "onClick": handleReset,
          "onMousedown": (e2) => e2.preventDefault(),
          "class": classNames({
            [`${className}-hidden`]: !needClear,
            [`${className}-has-suffix`]: !!suffix
          }, className),
          "role": "button",
          "tabindex": -1
        }, [iconNode]);
      };
      return () => {
        var _a2, _b2;
        const {
          focused,
          value,
          disabled,
          allowClear,
          readonly: readonly2,
          hidden,
          prefixCls,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b2 = slots.suffix) === null || _b2 === void 0 ? void 0 : _b2.call(slots),
          addonAfter = slots.addonAfter,
          addonBefore = slots.addonBefore,
          inputElement,
          affixWrapperClassName,
          wrapperClassName,
          groupClassName
        } = props2;
        let element = cloneElement(inputElement, {
          value,
          hidden
        });
        if (hasPrefixSuffix({
          prefix,
          suffix,
          allowClear
        })) {
          const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
          const affixWrapperCls = classNames(affixWrapperPrefixCls, {
            [`${affixWrapperPrefixCls}-disabled`]: disabled,
            [`${affixWrapperPrefixCls}-focused`]: focused,
            [`${affixWrapperPrefixCls}-readonly`]: readonly2,
            [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
          }, !hasAddon$1({
            addonAfter,
            addonBefore
          }) && attrs.class, affixWrapperClassName);
          const suffixNode = (suffix || allowClear) && createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [getClearIcon(), suffix]);
          element = createVNode("span", {
            "class": affixWrapperCls,
            "style": attrs.style,
            "hidden": !hasAddon$1({
              addonAfter,
              addonBefore
            }) && hidden,
            "onMousedown": onInputMouseDown,
            "ref": containerRef
          }, [prefix && createVNode("span", {
            "class": `${prefixCls}-prefix`
          }, [prefix]), cloneElement(inputElement, {
            style: null,
            value,
            hidden: null
          }), suffixNode]);
        }
        if (hasAddon$1({
          addonAfter,
          addonBefore
        })) {
          const wrapperCls = `${prefixCls}-group`;
          const addonCls = `${wrapperCls}-addon`;
          const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperCls, wrapperClassName);
          const mergedGroupClassName = classNames(`${prefixCls}-group-wrapper`, attrs.class, groupClassName);
          return createVNode("span", {
            "class": mergedGroupClassName,
            "style": attrs.style,
            "hidden": hidden
          }, [createVNode("span", {
            "class": mergedWrapperClassName
          }, [addonBefore && createVNode("span", {
            "class": addonCls
          }, [addonBefore]), cloneElement(element, {
            style: null,
            hidden: null
          }), addonAfter && createVNode("span", {
            "class": addonCls
          }, [addonAfter])])]);
        }
        return element;
      };
    }
  });
  var __rest$d = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const VcInput = /* @__PURE__ */ defineComponent({
    name: "VCInput",
    inheritAttrs: false,
    props: inputProps$1(),
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const stateValue = shallowRef(props2.value === void 0 ? props2.defaultValue : props2.value);
      const focused = shallowRef(false);
      const inputRef = shallowRef();
      const rootRef = shallowRef();
      watch(() => props2.value, () => {
        stateValue.value = props2.value;
      });
      watch(() => props2.disabled, () => {
        if (props2.disabled) {
          focused.value = false;
        }
      });
      const focus = (option) => {
        if (inputRef.value) {
          triggerFocus(inputRef.value.input, option);
        }
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      const setSelectionRange = (start2, end2, direction) => {
        var _a2;
        (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start2, end2, direction);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: computed(() => {
          var _a2;
          return (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.input;
        }),
        stateValue,
        setSelectionRange,
        select
      });
      const triggerChange = (e2) => {
        emit2("change", e2);
      };
      const setValue2 = (value, callback) => {
        if (stateValue.value === value) {
          return;
        }
        if (props2.value === void 0) {
          stateValue.value = value;
        } else {
          nextTick(() => {
            var _a2;
            if (inputRef.value.input.value !== stateValue.value) {
              (_a2 = rootRef.value) === null || _a2 === void 0 ? void 0 : _a2.$forceUpdate();
            }
          });
        }
        nextTick(() => {
          callback && callback();
        });
      };
      const handleChange = (e2) => {
        const {
          value
        } = e2.target;
        if (stateValue.value === value) return;
        const newVal = e2.target.value;
        resolveOnChange(inputRef.value.input, e2, triggerChange);
        setValue2(newVal);
      };
      const handleKeyDown = (e2) => {
        if (e2.keyCode === 13) {
          emit2("pressEnter", e2);
        }
        emit2("keydown", e2);
      };
      const handleFocus = (e2) => {
        focused.value = true;
        emit2("focus", e2);
      };
      const handleBlur = (e2) => {
        focused.value = false;
        emit2("blur", e2);
      };
      const handleReset = (e2) => {
        resolveOnChange(inputRef.value.input, e2, triggerChange);
        setValue2("", () => {
          focus();
        });
      };
      const getInputElement = () => {
        var _a2, _b2;
        const {
          addonBefore = slots.addonBefore,
          addonAfter = slots.addonAfter,
          disabled,
          valueModifiers = {},
          htmlSize,
          autocomplete,
          prefixCls,
          inputClassName,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b2 = slots.suffix) === null || _b2 === void 0 ? void 0 : _b2.call(slots),
          allowClear,
          type = "text"
        } = props2;
        const otherProps = omit$1(props2, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          // Input elements must be either controlled or uncontrolled,
          // specify either the value prop, or the defaultValue prop, but not both.
          "defaultValue",
          "size",
          "bordered",
          "htmlSize",
          "lazy",
          "showCount",
          "valueModifiers",
          "showCount",
          "affixWrapperClassName",
          "groupClassName",
          "inputClassName",
          "wrapperClassName"
        ]);
        const inputProps2 = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
          autocomplete,
          onChange: handleChange,
          onInput: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeydown: handleKeyDown,
          class: classNames(prefixCls, {
            [`${prefixCls}-disabled`]: disabled
          }, inputClassName, !hasAddon$1({
            addonAfter,
            addonBefore
          }) && !hasPrefixSuffix({
            prefix,
            suffix,
            allowClear
          }) && attrs.class),
          ref: inputRef,
          key: "ant-input",
          size: htmlSize,
          type,
          lazy: props2.lazy
        });
        if (valueModifiers.lazy) {
          delete inputProps2.onInput;
        }
        if (!inputProps2.autofocus) {
          delete inputProps2.autofocus;
        }
        const inputNode = createVNode(BaseInput$1, omit$1(inputProps2, ["size"]), null);
        return inputNode;
      };
      const getSuffix = () => {
        var _a2;
        const {
          maxlength,
          suffix = (_a2 = slots.suffix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          showCount,
          prefixCls
        } = props2;
        const hasMaxLength = Number(maxlength) > 0;
        if (suffix || showCount) {
          const valueLength = [...fixControlledValue(stateValue.value)].length;
          const dataCount = typeof showCount === "object" ? showCount.formatter({
            count: valueLength,
            maxlength
          }) : `${valueLength}${hasMaxLength ? ` / ${maxlength}` : ""}`;
          return createVNode(Fragment, null, [!!showCount && createVNode("span", {
            "class": classNames(`${prefixCls}-show-count-suffix`, {
              [`${prefixCls}-show-count-has-suffix`]: !!suffix
            })
          }, [dataCount]), suffix]);
        }
        return null;
      };
      onMounted(() => {
      });
      return () => {
        const {
          prefixCls,
          disabled
        } = props2, rest = __rest$d(props2, ["prefixCls", "disabled"]);
        return createVNode(BaseInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, rest), attrs), {}, {
          "ref": rootRef,
          "prefixCls": prefixCls,
          "inputElement": getInputElement(),
          "handleReset": handleReset,
          "value": fixControlledValue(stateValue.value),
          "focused": focused.value,
          "triggerFocus": focus,
          "suffix": getSuffix(),
          "disabled": disabled
        }), slots);
      };
    }
  });
  const inputProps = () => {
    return omit$1(inputProps$1(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]);
  };
  const textAreaProps = () => _extends$1(_extends$1({}, omit$1(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
    rows: Number,
    autosize: {
      type: [Boolean, Object],
      default: void 0
    },
    autoSize: {
      type: [Boolean, Object],
      default: void 0
    },
    onResize: {
      type: Function
    },
    onCompositionstart: eventType(),
    onCompositionend: eventType(),
    valueModifiers: Object
  });
  var __rest$c = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const Input = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInput",
    inheritAttrs: false,
    props: inputProps(),
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const inputRef = ref();
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
      const {
        direction,
        prefixCls,
        size,
        autocomplete
      } = useConfigInject("input", props2);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = computed(() => {
        return compactSize.value || size.value;
      });
      const [wrapSSR, hashId] = useStyle$9(prefixCls);
      const disabled = useInjectDisabled();
      const focus = (option) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus(option);
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      const setSelectionRange = (start2, end2, direction2) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start2, end2, direction2);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: inputRef,
        setSelectionRange,
        select
      });
      const removePasswordTimeoutRef = ref([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.value.push(setTimeout(() => {
          var _a2, _b2, _c2, _d;
          if (((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) && ((_b2 = inputRef.value) === null || _b2 === void 0 ? void 0 : _b2.input.getAttribute("type")) === "password" && ((_c2 = inputRef.value) === null || _c2 === void 0 ? void 0 : _c2.input.hasAttribute("value"))) {
            (_d = inputRef.value) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
          }
        }));
      };
      onMounted(() => {
        removePasswordTimeout();
      });
      onBeforeUpdate(() => {
        removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
      });
      onBeforeUnmount(() => {
        removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
      });
      const handleBlur = (e2) => {
        removePasswordTimeout();
        emit2("blur", e2);
        formItemContext.onFieldBlur();
      };
      const handleFocus = (e2) => {
        removePasswordTimeout();
        emit2("focus", e2);
      };
      const triggerChange = (e2) => {
        emit2("update:value", e2.target.value);
        emit2("change", e2);
        emit2("input", e2);
        formItemContext.onFieldChange();
      };
      return () => {
        var _a2, _b2, _c2, _d, _e, _f;
        const {
          hasFeedback,
          feedbackIcon
        } = formItemInputContext;
        const {
          allowClear,
          bordered = true,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b2 = slots.suffix) === null || _b2 === void 0 ? void 0 : _b2.call(slots),
          addonAfter = (_c2 = slots.addonAfter) === null || _c2 === void 0 ? void 0 : _c2.call(slots),
          addonBefore = (_d = slots.addonBefore) === null || _d === void 0 ? void 0 : _d.call(slots),
          id = (_e = formItemContext.id) === null || _e === void 0 ? void 0 : _e.value
        } = props2, rest = __rest$c(props2, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]);
        const suffixNode = (hasFeedback || suffix) && createVNode(Fragment, null, [suffix, hasFeedback && feedbackIcon]);
        const prefixClsValue = prefixCls.value;
        const inputHasPrefixSuffix = hasPrefixSuffix({
          prefix,
          suffix
        }) || !!hasFeedback;
        const clearIcon = slots.clearIcon || (() => createVNode(CloseCircleFilled, null, null));
        return wrapSSR(createVNode(VcInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$1(rest, ["onUpdate:value", "onChange", "onInput"])), {}, {
          "onChange": triggerChange,
          "id": id,
          "disabled": (_f = props2.disabled) !== null && _f !== void 0 ? _f : disabled.value,
          "ref": inputRef,
          "prefixCls": prefixClsValue,
          "autocomplete": autocomplete.value,
          "onBlur": handleBlur,
          "onFocus": handleFocus,
          "prefix": prefix,
          "suffix": suffixNode,
          "allowClear": allowClear,
          "addonAfter": addonAfter && createVNode(NoCompactStyle, null, {
            default: () => [createVNode(NoFormStatus, null, {
              default: () => [addonAfter]
            })]
          }),
          "addonBefore": addonBefore && createVNode(NoCompactStyle, null, {
            default: () => [createVNode(NoFormStatus, null, {
              default: () => [addonBefore]
            })]
          }),
          "class": [attrs.class, compactItemClassnames.value],
          "inputClassName": classNames({
            [`${prefixClsValue}-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-rtl`]: direction.value === "rtl",
            [`${prefixClsValue}-borderless`]: !bordered
          }, !inputHasPrefixSuffix && getStatusClassNames(prefixClsValue, mergedStatus.value), hashId.value),
          "affixWrapperClassName": classNames({
            [`${prefixClsValue}-affix-wrapper-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-affix-wrapper-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-affix-wrapper-rtl`]: direction.value === "rtl",
            [`${prefixClsValue}-affix-wrapper-borderless`]: !bordered
          }, getStatusClassNames(`${prefixClsValue}-affix-wrapper`, mergedStatus.value, hasFeedback), hashId.value),
          "wrapperClassName": classNames({
            [`${prefixClsValue}-group-rtl`]: direction.value === "rtl"
          }, hashId.value),
          "groupClassName": classNames({
            [`${prefixClsValue}-group-wrapper-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-group-wrapper-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-group-wrapper-rtl`]: direction.value === "rtl"
          }, getStatusClassNames(`${prefixClsValue}-group-wrapper`, mergedStatus.value, hasFeedback), hashId.value)
        }), _extends$1(_extends$1({}, slots), {
          clearIcon
        })));
      };
    }
  });
  const Group$3 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputGroup",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      size: {
        type: String
      },
      compact: {
        type: Boolean,
        default: void 0
      }
    },
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction,
        getPrefixCls
      } = useConfigInject("input-group", props2);
      const formItemInputContext = FormItemInputContext.useInject();
      FormItemInputContext.useProvide(formItemInputContext, {
        isFormItemInput: false
      });
      const inputPrefixCls = computed(() => getPrefixCls("input"));
      const [wrapSSR, hashId] = useStyle$9(inputPrefixCls);
      const cls = computed(() => {
        const pre = prefixCls.value;
        return {
          [`${pre}`]: true,
          [hashId.value]: true,
          [`${pre}-lg`]: props2.size === "large",
          [`${pre}-sm`]: props2.size === "small",
          [`${pre}-compact`]: props2.compact,
          [`${pre}-rtl`]: direction.value === "rtl"
        };
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(cls.value, attrs.class)
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  var __rest$b = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const Search = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputSearch",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, inputProps()), {
      inputPrefixCls: String,
      // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
      enterButton: PropTypes.any,
      onSearch: {
        type: Function
      }
    }),
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const inputRef = shallowRef();
      const composedRef = shallowRef(false);
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      const onChange = (e2) => {
        emit2("update:value", e2.target.value);
        if (e2 && e2.target && e2.type === "click") {
          emit2("search", e2.target.value, e2);
        }
        emit2("change", e2);
      };
      const onMousedown = (e2) => {
        var _a2;
        if (document.activeElement === ((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input)) {
          e2.preventDefault();
        }
      };
      const onSearch = (e2) => {
        var _a2, _b2;
        emit2("search", (_b2 = (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b2 === void 0 ? void 0 : _b2.stateValue, e2);
      };
      const onPressEnter = (e2) => {
        if (composedRef.value || props2.loading) {
          return;
        }
        onSearch(e2);
      };
      const handleOnCompositionStart = (e2) => {
        composedRef.value = true;
        emit2("compositionstart", e2);
      };
      const handleOnCompositionEnd = (e2) => {
        composedRef.value = false;
        emit2("compositionend", e2);
      };
      const {
        prefixCls,
        getPrefixCls,
        direction,
        size
      } = useConfigInject("input-search", props2);
      const inputPrefixCls = computed(() => getPrefixCls("input", props2.inputPrefixCls));
      return () => {
        var _a2, _b2, _c2, _d;
        const {
          disabled,
          loading,
          addonAfter = (_a2 = slots.addonAfter) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b2 = slots.suffix) === null || _b2 === void 0 ? void 0 : _b2.call(slots)
        } = props2, restProps = __rest$b(props2, ["disabled", "loading", "addonAfter", "suffix"]);
        let {
          enterButton = (_d = (_c2 = slots.enterButton) === null || _c2 === void 0 ? void 0 : _c2.call(slots)) !== null && _d !== void 0 ? _d : false
        } = props2;
        enterButton = enterButton || enterButton === "";
        const searchIcon = typeof enterButton === "boolean" ? createVNode(SearchOutlined, null, null) : null;
        const btnClassName = `${prefixCls.value}-button`;
        const enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
        let button;
        const isAntdButton = enterButtonAsElement.type && isPlainObject$1(enterButtonAsElement.type) && enterButtonAsElement.type.__ANT_BUTTON;
        if (isAntdButton || enterButtonAsElement.tagName === "button") {
          button = cloneElement(enterButtonAsElement, _extends$1({
            onMousedown,
            onClick: onSearch,
            key: "enterButton"
          }, isAntdButton ? {
            class: btnClassName,
            size: size.value
          } : {}), false);
        } else {
          const iconOnly = searchIcon && !enterButton;
          button = createVNode(Button$1, {
            "class": btnClassName,
            "type": enterButton ? "primary" : void 0,
            "size": size.value,
            "disabled": disabled,
            "key": "enterButton",
            "onMousedown": onMousedown,
            "onClick": onSearch,
            "loading": loading,
            "icon": iconOnly ? searchIcon : null
          }, {
            default: () => [iconOnly ? null : searchIcon || enterButton]
          });
        }
        if (addonAfter) {
          button = [button, addonAfter];
        }
        const cls = classNames(prefixCls.value, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [`${prefixCls.value}-${size.value}`]: !!size.value,
          [`${prefixCls.value}-with-button`]: !!enterButton
        }, attrs.class);
        return createVNode(Input, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "ref": inputRef
        }, omit$1(restProps, ["onUpdate:value", "onSearch", "enterButton"])), attrs), {}, {
          "onPressEnter": onPressEnter,
          "onCompositionstart": handleOnCompositionStart,
          "onCompositionend": handleOnCompositionEnd,
          "size": size.value,
          "prefixCls": inputPrefixCls.value,
          "addonAfter": button,
          "suffix": suffix,
          "onChange": onChange,
          "class": cls,
          "disabled": disabled
        }), slots);
      };
    }
  });
  const isValid = (value) => {
    return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
  };
  function hasAddon(propsAndSlots) {
    return isValid(propsAndSlots.addonBefore) || isValid(propsAndSlots.addonAfter);
  }
  const ClearableInputType = ["text", "input"];
  const ClearableLabeledInput = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ClearableLabeledInput",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      inputType: PropTypes.oneOf(tuple("text", "input")),
      value: anyType(),
      defaultValue: anyType(),
      allowClear: {
        type: Boolean,
        default: void 0
      },
      element: anyType(),
      handleReset: Function,
      disabled: {
        type: Boolean,
        default: void 0
      },
      direction: {
        type: String
      },
      size: {
        type: String
      },
      suffix: anyType(),
      prefix: anyType(),
      addonBefore: anyType(),
      addonAfter: anyType(),
      readonly: {
        type: Boolean,
        default: void 0
      },
      focused: {
        type: Boolean,
        default: void 0
      },
      bordered: {
        type: Boolean,
        default: true
      },
      triggerFocus: {
        type: Function
      },
      hidden: Boolean,
      status: String,
      hashId: String
    },
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const statusContext = FormItemInputContext.useInject();
      const renderClearIcon = (prefixCls) => {
        const {
          value,
          disabled,
          readonly: readonly2,
          handleReset,
          suffix = slots.suffix
        } = props2;
        const needClear = !disabled && !readonly2 && value;
        const className = `${prefixCls}-clear-icon`;
        return createVNode(CloseCircleFilled, {
          "onClick": handleReset,
          "onMousedown": (e2) => e2.preventDefault(),
          "class": classNames({
            [`${className}-hidden`]: !needClear,
            [`${className}-has-suffix`]: !!suffix
          }, className),
          "role": "button"
        }, null);
      };
      const renderTextAreaWithClearIcon = (prefixCls, element) => {
        const {
          value,
          allowClear,
          direction,
          bordered,
          hidden,
          status: customStatus,
          addonAfter = slots.addonAfter,
          addonBefore = slots.addonBefore,
          hashId
        } = props2;
        const {
          status: contextStatus,
          hasFeedback
        } = statusContext;
        if (!allowClear) {
          return cloneElement(element, {
            value,
            disabled: props2.disabled
          });
        }
        const affixWrapperCls = classNames(`${prefixCls}-affix-wrapper`, `${prefixCls}-affix-wrapper-textarea-with-clear-btn`, getStatusClassNames(`${prefixCls}-affix-wrapper`, getMergedStatus(contextStatus, customStatus), hasFeedback), {
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
          // className will go to addon wrapper
          [`${attrs.class}`]: !hasAddon({
            addonAfter,
            addonBefore
          }) && attrs.class
        }, hashId);
        return createVNode("span", {
          "class": affixWrapperCls,
          "style": attrs.style,
          "hidden": hidden
        }, [cloneElement(element, {
          style: null,
          value,
          disabled: props2.disabled
        }), renderClearIcon(prefixCls)]);
      };
      return () => {
        var _a2;
        const {
          prefixCls,
          inputType,
          element = (_a2 = slots.element) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
        } = props2;
        if (inputType === ClearableInputType[0]) {
          return renderTextAreaWithClearIcon(prefixCls, element);
        }
        return null;
      };
    }
  });
  const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
  const SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
  const computedStyleCache = {};
  let hiddenTextarea;
  function calculateNodeStyling(node2) {
    let useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
    if (useCache2 && computedStyleCache[nodeRef]) {
      return computedStyleCache[nodeRef];
    }
    const style = window.getComputedStyle(node2);
    const boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
    const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    const sizingStyle = SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
    const nodeInfo = {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
    if (useCache2 && nodeRef) {
      computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
  }
  function calculateAutoSizeStyle(uiTextNode) {
    let useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    let maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      document.body.appendChild(hiddenTextarea);
    }
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
    } else {
      hiddenTextarea.removeAttribute("wrap");
    }
    const {
      paddingSize,
      borderSize,
      boxSizing,
      sizingStyle
    } = calculateNodeStyling(uiTextNode, useCache2);
    hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    let minHeight = void 0;
    let maxHeight = void 0;
    let overflowY;
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      hiddenTextarea.value = " ";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    const style = {
      height: `${height}px`,
      overflowY,
      resize: "none"
    };
    if (minHeight) {
      style.minHeight = `${minHeight}px`;
    }
    if (maxHeight) {
      style.maxHeight = `${maxHeight}px`;
    }
    return style;
  }
  const RESIZE_START = 0;
  const RESIZE_MEASURING = 1;
  const RESIZE_STABLE = 2;
  const ResizableTextArea = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ResizableTextArea",
    inheritAttrs: false,
    props: textAreaProps(),
    setup(props2, _ref) {
      let {
        attrs,
        emit: emit2,
        expose
      } = _ref;
      let nextFrameActionId;
      let resizeFrameId;
      const textAreaRef = ref();
      const textareaStyles = ref({});
      const resizeStatus = ref(RESIZE_STABLE);
      onBeforeUnmount(() => {
        wrapperRaf.cancel(nextFrameActionId);
        wrapperRaf.cancel(resizeFrameId);
      });
      const fixFirefoxAutoScroll = () => {
        try {
          if (textAreaRef.value && document.activeElement === textAreaRef.value.input) {
            const currentStart = textAreaRef.value.getSelectionStart();
            const currentEnd = textAreaRef.value.getSelectionEnd();
            const scrollTop = textAreaRef.value.getScrollTop();
            textAreaRef.value.setSelectionRange(currentStart, currentEnd);
            textAreaRef.value.setScrollTop(scrollTop);
          }
        } catch (e2) {
        }
      };
      const minRows = ref();
      const maxRows = ref();
      watchEffect(() => {
        const autoSize = props2.autoSize || props2.autosize;
        if (autoSize) {
          minRows.value = autoSize.minRows;
          maxRows.value = autoSize.maxRows;
        } else {
          minRows.value = void 0;
          maxRows.value = void 0;
        }
      });
      const needAutoSize = computed(() => !!(props2.autoSize || props2.autosize));
      const startResize = () => {
        resizeStatus.value = RESIZE_START;
      };
      watch([() => props2.value, minRows, maxRows, needAutoSize], () => {
        if (needAutoSize.value) {
          startResize();
        }
      }, {
        immediate: true
      });
      const autoSizeStyle = ref();
      watch([resizeStatus, textAreaRef], () => {
        if (!textAreaRef.value) return;
        if (resizeStatus.value === RESIZE_START) {
          resizeStatus.value = RESIZE_MEASURING;
        } else if (resizeStatus.value === RESIZE_MEASURING) {
          const textareaStyles2 = calculateAutoSizeStyle(textAreaRef.value.input, false, minRows.value, maxRows.value);
          resizeStatus.value = RESIZE_STABLE;
          autoSizeStyle.value = textareaStyles2;
        } else {
          fixFirefoxAutoScroll();
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const instance = getCurrentInstance();
      const resizeRafRef = ref();
      const cleanRaf = () => {
        wrapperRaf.cancel(resizeRafRef.value);
      };
      const onInternalResize = (size) => {
        if (resizeStatus.value === RESIZE_STABLE) {
          emit2("resize", size);
          if (needAutoSize.value) {
            cleanRaf();
            resizeRafRef.value = wrapperRaf(() => {
              startResize();
            });
          }
        }
      };
      onBeforeUnmount(() => {
        cleanRaf();
      });
      const resizeTextarea = () => {
        startResize();
      };
      expose({
        resizeTextarea,
        textArea: computed(() => {
          var _a2;
          return (_a2 = textAreaRef.value) === null || _a2 === void 0 ? void 0 : _a2.input;
        }),
        instance
      });
      warning$2(props2.autosize === void 0);
      const renderTextArea = () => {
        const {
          prefixCls,
          disabled
        } = props2;
        const otherProps = omit$1(props2, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]);
        const cls = classNames(prefixCls, attrs.class, {
          [`${prefixCls}-disabled`]: disabled
        });
        const mergedAutoSizeStyle = needAutoSize.value ? autoSizeStyle.value : null;
        const style = [attrs.style, textareaStyles.value, mergedAutoSizeStyle];
        const textareaProps = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
          style,
          class: cls
        });
        if (resizeStatus.value === RESIZE_START || resizeStatus.value === RESIZE_MEASURING) {
          style.push({
            overflowX: "hidden",
            overflowY: "hidden"
          });
        }
        if (!textareaProps.autofocus) {
          delete textareaProps.autofocus;
        }
        if (textareaProps.rows === 0) {
          delete textareaProps.rows;
        }
        return createVNode(ResizeObserver$1, {
          "onResize": onInternalResize,
          "disabled": !needAutoSize.value
        }, {
          default: () => [createVNode(BaseInput$1, _objectSpread2$1(_objectSpread2$1({}, textareaProps), {}, {
            "ref": textAreaRef,
            "tag": "textarea"
          }), null)]
        });
      };
      return () => {
        return renderTextArea();
      };
    }
  });
  function fixEmojiLength(value, maxLength) {
    return [...value || ""].slice(0, maxLength).join("");
  }
  function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
    let newTriggerValue = triggerValue;
    if (isCursorInEnd) {
      newTriggerValue = fixEmojiLength(triggerValue, maxLength);
    } else if ([...preValue || ""].length < triggerValue.length && [...triggerValue || ""].length > maxLength) {
      newTriggerValue = preValue;
    }
    return newTriggerValue;
  }
  const TextArea = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATextarea",
    inheritAttrs: false,
    props: textAreaProps(),
    setup(props2, _ref) {
      let {
        attrs,
        expose,
        emit: emit2
      } = _ref;
      var _a2;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
      const stateValue = shallowRef((_a2 = props2.value) !== null && _a2 !== void 0 ? _a2 : props2.defaultValue);
      const resizableTextArea = shallowRef();
      const mergedValue = shallowRef("");
      const {
        prefixCls,
        size,
        direction
      } = useConfigInject("input", props2);
      const [wrapSSR, hashId] = useStyle$9(prefixCls);
      const disabled = useInjectDisabled();
      const showCount = computed(() => {
        return props2.showCount === "" || props2.showCount || false;
      });
      const hasMaxLength = computed(() => Number(props2.maxlength) > 0);
      const compositing = shallowRef(false);
      const oldCompositionValueRef = shallowRef();
      const oldSelectionStartRef = shallowRef(0);
      const onInternalCompositionStart = (e2) => {
        compositing.value = true;
        oldCompositionValueRef.value = mergedValue.value;
        oldSelectionStartRef.value = e2.currentTarget.selectionStart;
        emit2("compositionstart", e2);
      };
      const onInternalCompositionEnd = (e2) => {
        var _a3;
        compositing.value = false;
        let triggerValue = e2.currentTarget.value;
        if (hasMaxLength.value) {
          const isCursorInEnd = oldSelectionStartRef.value >= props2.maxlength + 1 || oldSelectionStartRef.value === ((_a3 = oldCompositionValueRef.value) === null || _a3 === void 0 ? void 0 : _a3.length);
          triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.value, triggerValue, props2.maxlength);
        }
        if (triggerValue !== mergedValue.value) {
          setValue2(triggerValue);
          resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
        }
        emit2("compositionend", e2);
      };
      const instance = getCurrentInstance();
      watch(() => props2.value, () => {
        var _a3;
        if ("value" in instance.vnode.props || {}) {
          stateValue.value = (_a3 = props2.value) !== null && _a3 !== void 0 ? _a3 : "";
        }
      });
      const focus = (option) => {
        var _a3;
        triggerFocus((_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : _a3.textArea, option);
      };
      const blur = () => {
        var _a3, _b2;
        (_b2 = (_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : _a3.textArea) === null || _b2 === void 0 ? void 0 : _b2.blur();
      };
      const setValue2 = (value, callback) => {
        if (stateValue.value === value) {
          return;
        }
        if (props2.value === void 0) {
          stateValue.value = value;
        } else {
          nextTick(() => {
            var _a3, _b2, _c2;
            if (resizableTextArea.value.textArea.value !== mergedValue.value) {
              (_c2 = (_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : (_b2 = _a3.instance).update) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
            }
          });
        }
        nextTick(() => {
          callback && callback();
        });
      };
      const handleKeyDown = (e2) => {
        if (e2.keyCode === 13) {
          emit2("pressEnter", e2);
        }
        emit2("keydown", e2);
      };
      const onBlur = (e2) => {
        const {
          onBlur: onBlur2
        } = props2;
        onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
        formItemContext.onFieldBlur();
      };
      const triggerChange = (e2) => {
        emit2("update:value", e2.target.value);
        emit2("change", e2);
        emit2("input", e2);
        formItemContext.onFieldChange();
      };
      const handleReset = (e2) => {
        resolveOnChange(resizableTextArea.value.textArea, e2, triggerChange);
        setValue2("", () => {
          focus();
        });
      };
      const handleChange = (e2) => {
        let triggerValue = e2.target.value;
        if (stateValue.value === triggerValue) return;
        if (hasMaxLength.value) {
          const target = e2.target;
          const isCursorInEnd = target.selectionStart >= props2.maxlength + 1 || target.selectionStart === triggerValue.length || !target.selectionStart;
          triggerValue = setTriggerValue(isCursorInEnd, mergedValue.value, triggerValue, props2.maxlength);
        }
        resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
        setValue2(triggerValue);
      };
      const renderTextArea = () => {
        var _a3, _b2;
        const {
          class: customClass
        } = attrs;
        const {
          bordered = true
        } = props2;
        const resizeProps = _extends$1(_extends$1(_extends$1({}, omit$1(props2, ["allowClear"])), attrs), {
          class: [{
            [`${prefixCls.value}-borderless`]: !bordered,
            [`${customClass}`]: customClass && !showCount.value,
            [`${prefixCls.value}-sm`]: size.value === "small",
            [`${prefixCls.value}-lg`]: size.value === "large"
          }, getStatusClassNames(prefixCls.value, mergedStatus.value), hashId.value],
          disabled: disabled.value,
          showCount: null,
          prefixCls: prefixCls.value,
          onInput: handleChange,
          onChange: handleChange,
          onBlur,
          onKeydown: handleKeyDown,
          onCompositionstart: onInternalCompositionStart,
          onCompositionend: onInternalCompositionEnd
        });
        if ((_a3 = props2.valueModifiers) === null || _a3 === void 0 ? void 0 : _a3.lazy) {
          delete resizeProps.onInput;
        }
        return createVNode(ResizableTextArea, _objectSpread2$1(_objectSpread2$1({}, resizeProps), {}, {
          "id": (_b2 = resizeProps === null || resizeProps === void 0 ? void 0 : resizeProps.id) !== null && _b2 !== void 0 ? _b2 : formItemContext.id.value,
          "ref": resizableTextArea,
          "maxlength": props2.maxlength,
          "lazy": props2.lazy
        }), null);
      };
      expose({
        focus,
        blur,
        resizableTextArea
      });
      watchEffect(() => {
        let val = fixControlledValue(stateValue.value);
        if (!compositing.value && hasMaxLength.value && (props2.value === null || props2.value === void 0)) {
          val = fixEmojiLength(val, props2.maxlength);
        }
        mergedValue.value = val;
      });
      return () => {
        var _a3;
        const {
          maxlength,
          bordered = true,
          hidden
        } = props2;
        const {
          style,
          class: customClass
        } = attrs;
        const inputProps2 = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
          prefixCls: prefixCls.value,
          inputType: "text",
          handleReset,
          direction: direction.value,
          bordered,
          style: showCount.value ? void 0 : style,
          hashId: hashId.value,
          disabled: (_a3 = props2.disabled) !== null && _a3 !== void 0 ? _a3 : disabled.value
        });
        let textareaNode = createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, inputProps2), {}, {
          "value": mergedValue.value,
          "status": props2.status
        }), {
          element: renderTextArea
        });
        if (showCount.value || formItemInputContext.hasFeedback) {
          const valueLength = [...mergedValue.value].length;
          let dataCount = "";
          if (typeof showCount.value === "object") {
            dataCount = showCount.value.formatter({
              value: mergedValue.value,
              count: valueLength,
              maxlength
            });
          } else {
            dataCount = `${valueLength}${hasMaxLength.value ? ` / ${maxlength}` : ""}`;
          }
          textareaNode = createVNode("div", {
            "hidden": hidden,
            "class": classNames(`${prefixCls.value}-textarea`, {
              [`${prefixCls.value}-textarea-rtl`]: direction.value === "rtl",
              [`${prefixCls.value}-textarea-show-count`]: showCount.value,
              [`${prefixCls.value}-textarea-in-form-item`]: formItemInputContext.isFormItemInput
            }, `${prefixCls.value}-textarea-show-count`, customClass, hashId.value),
            "style": style,
            "data-count": typeof dataCount !== "object" ? dataCount : void 0
          }, [textareaNode, formItemInputContext.hasFeedback && createVNode("span", {
            "class": `${prefixCls.value}-textarea-suffix`
          }, [formItemInputContext.feedbackIcon])]);
        }
        return wrapSSR(textareaNode);
      };
    }
  });
  var EyeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
  function _objectSpread$d(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$d(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$d(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var EyeOutlined = function EyeOutlined2(props2, context) {
    var p2 = _objectSpread$d({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$d({}, p2, {
      "icon": EyeOutlined$1
    }), null);
  };
  EyeOutlined.displayName = "EyeOutlined";
  EyeOutlined.inheritAttrs = false;
  var EyeInvisibleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
  function _objectSpread$c(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$c(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$c(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props2, context) {
    var p2 = _objectSpread$c({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$c({}, p2, {
      "icon": EyeInvisibleOutlined$1
    }), null);
  };
  EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
  EyeInvisibleOutlined.inheritAttrs = false;
  var __rest$a = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const ActionMap = {
    click: "onClick",
    hover: "onMouseover"
  };
  const defaultIconRender = (visible) => visible ? createVNode(EyeOutlined, null, null) : createVNode(EyeInvisibleOutlined, null, null);
  const Password = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputPassword",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, inputProps()), {
      prefixCls: String,
      inputPrefixCls: String,
      action: {
        type: String,
        default: "click"
      },
      visibilityToggle: {
        type: Boolean,
        default: true
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:visible": Function,
      iconRender: Function
    }),
    setup(props2, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const visible = shallowRef(false);
      const onVisibleChange = () => {
        const {
          disabled
        } = props2;
        if (disabled) {
          return;
        }
        visible.value = !visible.value;
        emit2("update:visible", visible.value);
      };
      watchEffect(() => {
        if (props2.visible !== void 0) {
          visible.value = !!props2.visible;
        }
      });
      const inputRef = shallowRef();
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      const getIcon2 = (prefixCls2) => {
        const {
          action,
          iconRender = slots.iconRender || defaultIconRender
        } = props2;
        const iconTrigger = ActionMap[action] || "";
        const icon = iconRender(visible.value);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          class: `${prefixCls2}-icon`,
          key: "passwordIcon",
          onMousedown: (e2) => {
            e2.preventDefault();
          },
          onMouseup: (e2) => {
            e2.preventDefault();
          }
        };
        return cloneElement(isValidElement(icon) ? icon : createVNode("span", null, [icon]), iconProps);
      };
      const {
        prefixCls,
        getPrefixCls
      } = useConfigInject("input-password", props2);
      const inputPrefixCls = computed(() => getPrefixCls("input", props2.inputPrefixCls));
      const renderPassword = () => {
        const {
          size,
          visibilityToggle
        } = props2, restProps = __rest$a(props2, ["size", "visibilityToggle"]);
        const suffixIcon = visibilityToggle && getIcon2(prefixCls.value);
        const inputClassName = classNames(prefixCls.value, attrs.class, {
          [`${prefixCls.value}-${size}`]: !!size
        });
        const omittedProps = _extends$1(_extends$1(_extends$1({}, omit$1(restProps, ["suffix", "iconRender", "action"])), attrs), {
          type: visible.value ? "text" : "password",
          class: inputClassName,
          prefixCls: inputPrefixCls.value,
          suffix: suffixIcon
        });
        if (size) {
          omittedProps.size = size;
        }
        return createVNode(Input, _objectSpread2$1({
          "ref": inputRef
        }, omittedProps), slots);
      };
      return () => {
        return renderPassword();
      };
    }
  });
  Input.Group = Group$3;
  Input.Search = Search;
  Input.TextArea = TextArea;
  Input.Password = Password;
  Input.install = function(app2) {
    app2.component(Input.name, Input);
    app2.component(Input.Group.name, Input.Group);
    app2.component(Input.Search.name, Input.Search);
    app2.component(Input.TextArea.name, Input.TextArea);
    app2.component(Input.Password.name, Input.Password);
    return app2;
  };
  var UpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
  function _objectSpread$b(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$b(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$b(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var UpOutlined = function UpOutlined2(props2, context) {
    var p2 = _objectSpread$b({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$b({}, p2, {
      "icon": UpOutlined$1
    }), null);
  };
  UpOutlined.displayName = "UpOutlined";
  UpOutlined.inheritAttrs = false;
  function throttle$2(delay, callback, options2) {
    var _ref = options2 || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel(options3) {
      var _ref2 = options3 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
      clearExistingTimeout();
      cancelled = !upcomingOnly;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear2() {
        timeoutID = void 0;
      }
      if (!noLeading && debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay) {
        if (noLeading) {
          lastExec = Date.now();
          if (!noTrailing) {
            timeoutID = setTimeout(debounceMode ? clear2 : exec, delay);
          }
        } else {
          exec();
        }
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear2 : exec, debounceMode === void 0 ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce(delay, callback, options2) {
    var _ref = {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
    return throttle$2(delay, callback, {
      debounceMode: atBegin !== false
    });
  }
  const antSpinMove = new Keyframe("antSpinMove", {
    to: {
      opacity: 1
    }
  });
  const antRotate = new Keyframe("antRotate", {
    to: {
      transform: "rotate(405deg)"
    }
  });
  const genSpinStyle = (token2) => ({
    [`${token2.componentCls}`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "absolute",
      display: "none",
      color: token2.colorPrimary,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "static",
        display: "inline-block",
        opacity: 1
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${token2.componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token2.contentHeight,
          [`${token2.componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: -token2.spinDotSize / 2
          },
          [`${token2.componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
            textShadow: `0 1px 2px ${token2.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSize / 2) - 10
          },
          "&-sm": {
            [`${token2.componentCls}-dot`]: {
              margin: -token2.spinDotSizeSM / 2
            },
            [`${token2.componentCls}-text`]: {
              paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
            },
            [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
              marginTop: -(token2.spinDotSizeSM / 2) - 10
            }
          },
          "&-lg": {
            [`${token2.componentCls}-dot`]: {
              margin: -(token2.spinDotSizeLG / 2)
            },
            [`${token2.componentCls}-text`]: {
              paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
            },
            [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
              marginTop: -(token2.spinDotSizeLG / 2) - 10
            }
          }
        },
        [`${token2.componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${token2.componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          [`&::after`]: {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      [`&-tip`]: {
        color: token2.spinDotDefault
      },
      // dots
      // ------------------------------
      [`${token2.componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token2.spinDotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
          height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
          backgroundColor: token2.colorPrimary,
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      // Sizes
      // ------------------------------
      // small
      [`&-sm ${token2.componentCls}-dot`]: {
        fontSize: token2.spinDotSizeSM,
        i: {
          width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
          height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
        }
      },
      // large
      [`&-lg ${token2.componentCls}-dot`]: {
        fontSize: token2.spinDotSizeLG,
        i: {
          width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
          height: (token2.spinDotSizeLG - token2.marginXXS) / 2
        }
      },
      [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
        display: "block"
      }
    })
  });
  const useStyle$3 = genComponentStyleHook("Spin", (token2) => {
    const spinToken = merge$2(token2, {
      spinDotDefault: token2.colorTextDescription,
      spinDotSize: token2.controlHeightLG / 2,
      spinDotSizeSM: token2.controlHeightLG * 0.35,
      spinDotSizeLG: token2.controlHeight
    });
    return [genSpinStyle(spinToken)];
  }, {
    contentHeight: 400
  });
  var __rest$9 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const spinProps = () => ({
    prefixCls: String,
    spinning: {
      type: Boolean,
      default: void 0
    },
    size: String,
    wrapperClassName: String,
    tip: PropTypes.any,
    delay: Number,
    indicator: PropTypes.any
  });
  let defaultIndicator = null;
  function shouldDelay(spinning, delay) {
    return !!spinning && !!delay && !isNaN(Number(delay));
  }
  function setDefaultIndicator(Content2) {
    const Indicator = Content2.indicator;
    defaultIndicator = typeof Indicator === "function" ? Indicator : () => createVNode(Indicator, null, null);
  }
  const Spin = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ASpin",
    inheritAttrs: false,
    props: initDefaultProps(spinProps(), {
      size: "default",
      spinning: true,
      wrapperClassName: ""
    }),
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const {
        prefixCls,
        size,
        direction
      } = useConfigInject("spin", props2);
      const [wrapSSR, hashId] = useStyle$3(prefixCls);
      const sSpinning = shallowRef(props2.spinning && !shouldDelay(props2.spinning, props2.delay));
      let updateSpinning;
      watch([() => props2.spinning, () => props2.delay], () => {
        updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning.cancel();
        updateSpinning = debounce(props2.delay, () => {
          sSpinning.value = props2.spinning;
        });
        updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning();
      }, {
        immediate: true,
        flush: "post"
      });
      onBeforeUnmount(() => {
        updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning.cancel();
      });
      return () => {
        var _a2, _b2;
        const {
          class: cls
        } = attrs, divProps = __rest$9(attrs, ["class"]);
        const {
          tip = (_a2 = slots.tip) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
        } = props2;
        const children = (_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
        const spinClassName = {
          [hashId.value]: true,
          [prefixCls.value]: true,
          [`${prefixCls.value}-sm`]: size.value === "small",
          [`${prefixCls.value}-lg`]: size.value === "large",
          [`${prefixCls.value}-spinning`]: sSpinning.value,
          [`${prefixCls.value}-show-text`]: !!tip,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [cls]: !!cls
        };
        function renderIndicator(prefixCls2) {
          const dotClassName = `${prefixCls2}-dot`;
          let indicator = getPropsSlot(slots, props2, "indicator");
          if (indicator === null) {
            return null;
          }
          if (Array.isArray(indicator)) {
            indicator = indicator.length === 1 ? indicator[0] : indicator;
          }
          if (isVNode$1(indicator)) {
            return cloneVNode(indicator, {
              class: dotClassName
            });
          }
          if (defaultIndicator && isVNode$1(defaultIndicator())) {
            return cloneVNode(defaultIndicator(), {
              class: dotClassName
            });
          }
          return createVNode("span", {
            "class": `${dotClassName} ${prefixCls2}-dot-spin`
          }, [createVNode("i", {
            "class": `${prefixCls2}-dot-item`
          }, null), createVNode("i", {
            "class": `${prefixCls2}-dot-item`
          }, null), createVNode("i", {
            "class": `${prefixCls2}-dot-item`
          }, null), createVNode("i", {
            "class": `${prefixCls2}-dot-item`
          }, null)]);
        }
        const spinElement = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
          "class": spinClassName,
          "aria-live": "polite",
          "aria-busy": sSpinning.value
        }), [renderIndicator(prefixCls.value), tip ? createVNode("div", {
          "class": `${prefixCls.value}-text`
        }, [tip]) : null]);
        if (children && filterEmpty(children).length) {
          const containerClassName = {
            [`${prefixCls.value}-container`]: true,
            [`${prefixCls.value}-blur`]: sSpinning.value
          };
          return wrapSSR(createVNode("div", {
            "class": [`${prefixCls.value}-nested-loading`, props2.wrapperClassName, hashId.value]
          }, [sSpinning.value && createVNode("div", {
            "key": "loading"
          }, [spinElement]), createVNode("div", {
            "class": containerClassName,
            "key": "container"
          }, [children])]));
        }
        return wrapSSR(spinElement);
      };
    }
  });
  Spin.setDefaultIndicator = setDefaultIndicator;
  Spin.install = function(app2) {
    app2.component(Spin.name, Spin);
    return app2;
  };
  var DoubleLeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
  function _objectSpread$a(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$a(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$a(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var DoubleLeftOutlined = function DoubleLeftOutlined2(props2, context) {
    var p2 = _objectSpread$a({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$a({}, p2, {
      "icon": DoubleLeftOutlined$1
    }), null);
  };
  DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
  DoubleLeftOutlined.inheritAttrs = false;
  var DoubleRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
  function _objectSpread$9(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$9(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$9(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var DoubleRightOutlined = function DoubleRightOutlined2(props2, context) {
    var p2 = _objectSpread$9({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$9({}, p2, {
      "icon": DoubleRightOutlined$1
    }), null);
  };
  DoubleRightOutlined.displayName = "DoubleRightOutlined";
  DoubleRightOutlined.inheritAttrs = false;
  const MiniSelect = /* @__PURE__ */ defineComponent({
    name: "MiniSelect",
    compatConfig: {
      MODE: 3
    },
    inheritAttrs: false,
    props: selectProps(),
    Option: Select.Option,
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      return () => {
        const selelctProps = _extends$1(_extends$1(_extends$1({}, props2), {
          size: "small"
        }), attrs);
        return createVNode(Select, selelctProps, slots);
      };
    }
  });
  const MiddleSelect = /* @__PURE__ */ defineComponent({
    name: "MiddleSelect",
    inheritAttrs: false,
    props: selectProps(),
    Option: Select.Option,
    setup(props2, _ref2) {
      let {
        attrs,
        slots
      } = _ref2;
      return () => {
        const selelctProps = _extends$1(_extends$1(_extends$1({}, props2), {
          size: "middle"
        }), attrs);
        return createVNode(Select, selelctProps, slots);
      };
    }
  });
  const Pager = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Pager",
    inheritAttrs: false,
    props: {
      rootPrefixCls: String,
      page: Number,
      active: {
        type: Boolean,
        default: void 0
      },
      last: {
        type: Boolean,
        default: void 0
      },
      locale: PropTypes.object,
      showTitle: {
        type: Boolean,
        default: void 0
      },
      itemRender: {
        type: Function,
        default: () => {
        }
      },
      onClick: {
        type: Function
      },
      onKeypress: {
        type: Function
      }
    },
    eimt: ["click", "keypress"],
    setup(props2, _ref) {
      let {
        emit: emit2,
        attrs
      } = _ref;
      const handleClick = () => {
        emit2("click", props2.page);
      };
      const handleKeyPress = (event) => {
        emit2("keypress", event, handleClick, props2.page);
      };
      return () => {
        const {
          showTitle,
          page,
          itemRender
        } = props2;
        const {
          class: _cls,
          style
        } = attrs;
        const prefixCls = `${props2.rootPrefixCls}-item`;
        const cls = classNames(prefixCls, `${prefixCls}-${props2.page}`, {
          [`${prefixCls}-active`]: props2.active,
          [`${prefixCls}-disabled`]: !props2.page
        }, _cls);
        return createVNode("li", {
          "onClick": handleClick,
          "onKeypress": handleKeyPress,
          "title": showTitle ? String(page) : null,
          "tabindex": "0",
          "class": cls,
          "style": style
        }, [itemRender({
          page,
          type: "page",
          originalElement: createVNode("a", {
            "rel": "nofollow"
          }, [page])
        })]);
      };
    }
  });
  const KEYCODE = {
    ENTER: 13,
    ARROW_UP: 38,
    ARROW_DOWN: 40
  };
  const Options = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    props: {
      disabled: {
        type: Boolean,
        default: void 0
      },
      changeSize: Function,
      quickGo: Function,
      selectComponentClass: PropTypes.any,
      current: Number,
      pageSizeOptions: PropTypes.array.def(["10", "20", "50", "100"]),
      pageSize: Number,
      buildOptionText: Function,
      locale: PropTypes.object,
      rootPrefixCls: String,
      selectPrefixCls: String,
      goButton: PropTypes.any
    },
    setup(props2) {
      const goInputText = ref("");
      const validValue = computed(() => {
        return !goInputText.value || isNaN(goInputText.value) ? void 0 : Number(goInputText.value);
      });
      const defaultBuildOptionText = (opt) => {
        return `${opt.value} ${props2.locale.items_per_page}`;
      };
      const handleChange = (e2) => {
        const {
          value
        } = e2.target;
        if (goInputText.value === value) return;
        goInputText.value = value;
      };
      const handleBlur = (e2) => {
        const {
          goButton,
          quickGo,
          rootPrefixCls
        } = props2;
        if (goButton || goInputText.value === "") {
          return;
        }
        if (e2.relatedTarget && (e2.relatedTarget.className.indexOf(`${rootPrefixCls}-item-link`) >= 0 || e2.relatedTarget.className.indexOf(`${rootPrefixCls}-item`) >= 0)) {
          goInputText.value = "";
          return;
        } else {
          quickGo(validValue.value);
          goInputText.value = "";
        }
      };
      const go = (e2) => {
        if (goInputText.value === "") {
          return;
        }
        if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
          props2.quickGo(validValue.value);
          goInputText.value = "";
        }
      };
      const pageSizeOptions = computed(() => {
        const {
          pageSize,
          pageSizeOptions: pageSizeOptions2
        } = props2;
        if (pageSizeOptions2.some((option) => option.toString() === pageSize.toString())) {
          return pageSizeOptions2;
        }
        return pageSizeOptions2.concat([pageSize.toString()]).sort((a2, b2) => {
          const numberA = isNaN(Number(a2)) ? 0 : Number(a2);
          const numberB = isNaN(Number(b2)) ? 0 : Number(b2);
          return numberA - numberB;
        });
      });
      return () => {
        const {
          rootPrefixCls,
          locale: locale2,
          changeSize,
          quickGo,
          goButton,
          selectComponentClass: Select2,
          selectPrefixCls,
          pageSize,
          disabled
        } = props2;
        const prefixCls = `${rootPrefixCls}-options`;
        let changeSelect = null;
        let goInput = null;
        let gotoButton = null;
        if (!changeSize && !quickGo) {
          return null;
        }
        if (changeSize && Select2) {
          const buildOptionText = props2.buildOptionText || defaultBuildOptionText;
          const options2 = pageSizeOptions.value.map((opt, i2) => createVNode(Select2.Option, {
            "key": i2,
            "value": opt
          }, {
            default: () => [buildOptionText({
              value: opt
            })]
          }));
          changeSelect = createVNode(Select2, {
            "disabled": disabled,
            "prefixCls": selectPrefixCls,
            "showSearch": false,
            "class": `${prefixCls}-size-changer`,
            "optionLabelProp": "children",
            "value": (pageSize || pageSizeOptions.value[0]).toString(),
            "onChange": (value) => changeSize(Number(value)),
            "getPopupContainer": (triggerNode) => triggerNode.parentNode
          }, {
            default: () => [options2]
          });
        }
        if (quickGo) {
          if (goButton) {
            gotoButton = typeof goButton === "boolean" ? createVNode("button", {
              "type": "button",
              "onClick": go,
              "onKeyup": go,
              "disabled": disabled,
              "class": `${prefixCls}-quick-jumper-button`
            }, [locale2.jump_to_confirm]) : createVNode("span", {
              "onClick": go,
              "onKeyup": go
            }, [goButton]);
          }
          goInput = createVNode("div", {
            "class": `${prefixCls}-quick-jumper`
          }, [locale2.jump_to, createVNode(BaseInput$1, {
            "disabled": disabled,
            "type": "text",
            "value": goInputText.value,
            "onInput": handleChange,
            "onChange": handleChange,
            "onKeyup": go,
            "onBlur": handleBlur
          }, null), locale2.page, gotoButton]);
        }
        return createVNode("li", {
          "class": `${prefixCls}`
        }, [changeSelect, goInput]);
      };
    }
  });
  var __rest$8 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  }
  function defaultItemRender(_ref) {
    let {
      originalElement
    } = _ref;
    return originalElement;
  }
  function calculatePage(p2, state, props2) {
    const pageSize = typeof p2 === "undefined" ? state.statePageSize : p2;
    return Math.floor((props2.total - 1) / pageSize) + 1;
  }
  const VcPagination = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Pagination",
    mixins: [BaseMixin],
    inheritAttrs: false,
    props: {
      disabled: {
        type: Boolean,
        default: void 0
      },
      prefixCls: PropTypes.string.def("rc-pagination"),
      selectPrefixCls: PropTypes.string.def("rc-select"),
      current: Number,
      defaultCurrent: PropTypes.number.def(1),
      total: PropTypes.number.def(0),
      pageSize: Number,
      defaultPageSize: PropTypes.number.def(10),
      hideOnSinglePage: {
        type: Boolean,
        default: false
      },
      showSizeChanger: {
        type: Boolean,
        default: void 0
      },
      showLessItems: {
        type: Boolean,
        default: false
      },
      // showSizeChange: PropTypes.func.def(noop),
      selectComponentClass: PropTypes.any,
      showPrevNextJumpers: {
        type: Boolean,
        default: true
      },
      showQuickJumper: PropTypes.oneOfType([PropTypes.looseBool, PropTypes.object]).def(false),
      showTitle: {
        type: Boolean,
        default: true
      },
      pageSizeOptions: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),
      buildOptionText: Function,
      showTotal: Function,
      simple: {
        type: Boolean,
        default: void 0
      },
      locale: PropTypes.object.def(LOCALE),
      itemRender: PropTypes.func.def(defaultItemRender),
      prevIcon: PropTypes.any,
      nextIcon: PropTypes.any,
      jumpPrevIcon: PropTypes.any,
      jumpNextIcon: PropTypes.any,
      totalBoundaryShowSizeChanger: PropTypes.number.def(50)
    },
    data() {
      const props2 = this.$props;
      let current = firstNotUndefined([this.current, this.defaultCurrent]);
      const pageSize = firstNotUndefined([this.pageSize, this.defaultPageSize]);
      current = Math.min(current, calculatePage(pageSize, void 0, props2));
      return {
        stateCurrent: current,
        stateCurrentInputValue: current,
        statePageSize: pageSize
      };
    },
    watch: {
      current(val) {
        this.setState({
          stateCurrent: val,
          stateCurrentInputValue: val
        });
      },
      pageSize(val) {
        const newState = {};
        let current = this.stateCurrent;
        const newCurrent = calculatePage(val, this.$data, this.$props);
        current = current > newCurrent ? newCurrent : current;
        if (!hasProp(this, "current")) {
          newState.stateCurrent = current;
          newState.stateCurrentInputValue = current;
        }
        newState.statePageSize = val;
        this.setState(newState);
      },
      stateCurrent(_val, oldValue) {
        this.$nextTick(() => {
          if (this.$refs.paginationNode) {
            const lastCurrentNode = this.$refs.paginationNode.querySelector(`.${this.prefixCls}-item-${oldValue}`);
            if (lastCurrentNode && document.activeElement === lastCurrentNode) {
              lastCurrentNode.blur();
            }
          }
        });
      },
      total() {
        const newState = {};
        const newCurrent = calculatePage(this.pageSize, this.$data, this.$props);
        if (hasProp(this, "current")) {
          const current = Math.min(this.current, newCurrent);
          newState.stateCurrent = current;
          newState.stateCurrentInputValue = current;
        } else {
          let current = this.stateCurrent;
          if (current === 0 && newCurrent > 0) {
            current = 1;
          } else {
            current = Math.min(this.stateCurrent, newCurrent);
          }
          newState.stateCurrent = current;
        }
        this.setState(newState);
      }
    },
    methods: {
      getJumpPrevPage() {
        return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
      },
      getJumpNextPage() {
        return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
      },
      getItemIcon(icon, label) {
        const {
          prefixCls
        } = this.$props;
        const iconNode = getComponent(this, icon, this.$props) || createVNode("button", {
          "type": "button",
          "aria-label": label,
          "class": `${prefixCls}-item-link`
        }, null);
        return iconNode;
      },
      getValidValue(e2) {
        const inputValue = e2.target.value;
        const allPages = calculatePage(void 0, this.$data, this.$props);
        const {
          stateCurrentInputValue
        } = this.$data;
        let value;
        if (inputValue === "") {
          value = inputValue;
        } else if (isNaN(Number(inputValue))) {
          value = stateCurrentInputValue;
        } else if (inputValue >= allPages) {
          value = allPages;
        } else {
          value = Number(inputValue);
        }
        return value;
      },
      isValid(page) {
        return isInteger(page) && page !== this.stateCurrent;
      },
      shouldDisplayQuickJumper() {
        const {
          showQuickJumper,
          pageSize,
          total
        } = this.$props;
        if (total <= pageSize) {
          return false;
        }
        return showQuickJumper;
      },
      // calculatePage (p) {
      //   let pageSize = p
      //   if (typeof pageSize === 'undefined') {
      //     pageSize = this.statePageSize
      //   }
      //   return Math.floor((this.total - 1) / pageSize) + 1
      // },
      handleKeyDown(event) {
        if (event.keyCode === KEYCODE.ARROW_UP || event.keyCode === KEYCODE.ARROW_DOWN) {
          event.preventDefault();
        }
      },
      handleKeyUp(e2) {
        const value = this.getValidValue(e2);
        const stateCurrentInputValue = this.stateCurrentInputValue;
        if (value !== stateCurrentInputValue) {
          this.setState({
            stateCurrentInputValue: value
          });
        }
        if (e2.keyCode === KEYCODE.ENTER) {
          this.handleChange(value);
        } else if (e2.keyCode === KEYCODE.ARROW_UP) {
          this.handleChange(value - 1);
        } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
          this.handleChange(value + 1);
        }
      },
      changePageSize(size) {
        let current = this.stateCurrent;
        const preCurrent = current;
        const newCurrent = calculatePage(size, this.$data, this.$props);
        current = current > newCurrent ? newCurrent : current;
        if (newCurrent === 0) {
          current = this.stateCurrent;
        }
        if (typeof size === "number") {
          if (!hasProp(this, "pageSize")) {
            this.setState({
              statePageSize: size
            });
          }
          if (!hasProp(this, "current")) {
            this.setState({
              stateCurrent: current,
              stateCurrentInputValue: current
            });
          }
        }
        this.__emit("update:pageSize", size);
        if (current !== preCurrent) {
          this.__emit("update:current", current);
        }
        this.__emit("showSizeChange", current, size);
        this.__emit("change", current, size);
      },
      handleChange(p2) {
        const {
          disabled
        } = this.$props;
        let page = p2;
        if (this.isValid(page) && !disabled) {
          const currentPage = calculatePage(void 0, this.$data, this.$props);
          if (page > currentPage) {
            page = currentPage;
          } else if (page < 1) {
            page = 1;
          }
          if (!hasProp(this, "current")) {
            this.setState({
              stateCurrent: page,
              stateCurrentInputValue: page
            });
          }
          this.__emit("update:current", page);
          this.__emit("change", page, this.statePageSize);
          return page;
        }
        return this.stateCurrent;
      },
      prev() {
        if (this.hasPrev()) {
          this.handleChange(this.stateCurrent - 1);
        }
      },
      next() {
        if (this.hasNext()) {
          this.handleChange(this.stateCurrent + 1);
        }
      },
      jumpPrev() {
        this.handleChange(this.getJumpPrevPage());
      },
      jumpNext() {
        this.handleChange(this.getJumpNextPage());
      },
      hasPrev() {
        return this.stateCurrent > 1;
      },
      hasNext() {
        return this.stateCurrent < calculatePage(void 0, this.$data, this.$props);
      },
      getShowSizeChanger() {
        const {
          showSizeChanger,
          total,
          totalBoundaryShowSizeChanger
        } = this.$props;
        if (typeof showSizeChanger !== "undefined") {
          return showSizeChanger;
        }
        return total > totalBoundaryShowSizeChanger;
      },
      runIfEnter(event, callback) {
        if (event.key === "Enter" || event.charCode === 13) {
          event.preventDefault();
          for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            restParams[_key - 2] = arguments[_key];
          }
          callback(...restParams);
        }
      },
      runIfEnterPrev(event) {
        this.runIfEnter(event, this.prev);
      },
      runIfEnterNext(event) {
        this.runIfEnter(event, this.next);
      },
      runIfEnterJumpPrev(event) {
        this.runIfEnter(event, this.jumpPrev);
      },
      runIfEnterJumpNext(event) {
        this.runIfEnter(event, this.jumpNext);
      },
      handleGoTO(event) {
        if (event.keyCode === KEYCODE.ENTER || event.type === "click") {
          this.handleChange(this.stateCurrentInputValue);
        }
      },
      renderPrev(prevPage) {
        const {
          itemRender
        } = this.$props;
        const prevButton = itemRender({
          page: prevPage,
          type: "prev",
          originalElement: this.getItemIcon("prevIcon", "prev page")
        });
        const disabled = !this.hasPrev();
        return isValidElement(prevButton) ? cloneElement(prevButton, disabled ? {
          disabled
        } : {}) : prevButton;
      },
      renderNext(nextPage) {
        const {
          itemRender
        } = this.$props;
        const nextButton = itemRender({
          page: nextPage,
          type: "next",
          originalElement: this.getItemIcon("nextIcon", "next page")
        });
        const disabled = !this.hasNext();
        return isValidElement(nextButton) ? cloneElement(nextButton, disabled ? {
          disabled
        } : {}) : nextButton;
      }
    },
    render() {
      const {
        prefixCls,
        disabled,
        hideOnSinglePage,
        total,
        locale: locale2,
        showQuickJumper,
        showLessItems,
        showTitle,
        showTotal,
        simple,
        itemRender,
        showPrevNextJumpers,
        jumpPrevIcon,
        jumpNextIcon,
        selectComponentClass,
        selectPrefixCls,
        pageSizeOptions
      } = this.$props;
      const {
        stateCurrent,
        statePageSize
      } = this;
      const _a2 = splitAttrs(this.$attrs).extraAttrs, {
        class: className
      } = _a2, restAttrs = __rest$8(_a2, ["class"]);
      if (hideOnSinglePage === true && this.total <= statePageSize) {
        return null;
      }
      const allPages = calculatePage(void 0, this.$data, this.$props);
      const pagerList = [];
      let jumpPrev = null;
      let jumpNext = null;
      let firstPager = null;
      let lastPager = null;
      let gotoButton = null;
      const goButton = showQuickJumper && showQuickJumper.goButton;
      const pageBufferSize = showLessItems ? 1 : 2;
      const prevPage = stateCurrent - 1 > 0 ? stateCurrent - 1 : 0;
      const nextPage = stateCurrent + 1 < allPages ? stateCurrent + 1 : allPages;
      const hasPrev = this.hasPrev();
      const hasNext = this.hasNext();
      if (simple) {
        if (goButton) {
          if (typeof goButton === "boolean") {
            gotoButton = createVNode("button", {
              "type": "button",
              "onClick": this.handleGoTO,
              "onKeyup": this.handleGoTO
            }, [locale2.jump_to_confirm]);
          } else {
            gotoButton = createVNode("span", {
              "onClick": this.handleGoTO,
              "onKeyup": this.handleGoTO
            }, [goButton]);
          }
          gotoButton = createVNode("li", {
            "title": showTitle ? `${locale2.jump_to}${stateCurrent}/${allPages}` : null,
            "class": `${prefixCls}-simple-pager`
          }, [gotoButton]);
        }
        return createVNode("ul", _objectSpread2$1({
          "class": classNames(`${prefixCls} ${prefixCls}-simple`, {
            [`${prefixCls}-disabled`]: disabled
          }, className)
        }, restAttrs), [createVNode("li", {
          "title": showTitle ? locale2.prev_page : null,
          "onClick": this.prev,
          "tabindex": hasPrev ? 0 : null,
          "onKeypress": this.runIfEnterPrev,
          "class": classNames(`${prefixCls}-prev`, {
            [`${prefixCls}-disabled`]: !hasPrev
          }),
          "aria-disabled": !hasPrev
        }, [this.renderPrev(prevPage)]), createVNode("li", {
          "title": showTitle ? `${stateCurrent}/${allPages}` : null,
          "class": `${prefixCls}-simple-pager`
        }, [createVNode(BaseInput$1, {
          "type": "text",
          "value": this.stateCurrentInputValue,
          "disabled": disabled,
          "onKeydown": this.handleKeyDown,
          "onKeyup": this.handleKeyUp,
          "onInput": this.handleKeyUp,
          "onChange": this.handleKeyUp,
          "size": "3"
        }, null), createVNode("span", {
          "class": `${prefixCls}-slash`
        }, [createTextVNode("／")]), allPages]), createVNode("li", {
          "title": showTitle ? locale2.next_page : null,
          "onClick": this.next,
          "tabindex": hasNext ? 0 : null,
          "onKeypress": this.runIfEnterNext,
          "class": classNames(`${prefixCls}-next`, {
            [`${prefixCls}-disabled`]: !hasNext
          }),
          "aria-disabled": !hasNext
        }, [this.renderNext(nextPage)]), gotoButton]);
      }
      if (allPages <= 3 + pageBufferSize * 2) {
        const pagerProps = {
          locale: locale2,
          rootPrefixCls: prefixCls,
          showTitle,
          itemRender,
          onClick: this.handleChange,
          onKeypress: this.runIfEnter
        };
        if (!allPages) {
          pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
            "key": "noPager",
            "page": 1,
            "class": `${prefixCls}-item-disabled`
          }), null));
        }
        for (let i2 = 1; i2 <= allPages; i2 += 1) {
          const active = stateCurrent === i2;
          pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
            "key": i2,
            "page": i2,
            "active": active
          }), null));
        }
      } else {
        const prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
        const nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
        if (showPrevNextJumpers) {
          jumpPrev = createVNode("li", {
            "title": this.showTitle ? prevItemTitle : null,
            "key": "prev",
            "onClick": this.jumpPrev,
            "tabindex": "0",
            "onKeypress": this.runIfEnterJumpPrev,
            "class": classNames(`${prefixCls}-jump-prev`, {
              [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
            })
          }, [itemRender({
            page: this.getJumpPrevPage(),
            type: "jump-prev",
            originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
          })]);
          jumpNext = createVNode("li", {
            "title": this.showTitle ? nextItemTitle : null,
            "key": "next",
            "tabindex": "0",
            "onClick": this.jumpNext,
            "onKeypress": this.runIfEnterJumpNext,
            "class": classNames(`${prefixCls}-jump-next`, {
              [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
            })
          }, [itemRender({
            page: this.getJumpNextPage(),
            type: "jump-next",
            originalElement: this.getItemIcon("jumpNextIcon", "next page")
          })]);
        }
        lastPager = createVNode(Pager, {
          "locale": locale2,
          "last": true,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": allPages,
          "page": allPages,
          "active": false,
          "showTitle": showTitle,
          "itemRender": itemRender
        }, null);
        firstPager = createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": 1,
          "page": 1,
          "active": false,
          "showTitle": showTitle,
          "itemRender": itemRender
        }, null);
        let left = Math.max(1, stateCurrent - pageBufferSize);
        let right = Math.min(stateCurrent + pageBufferSize, allPages);
        if (stateCurrent - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - stateCurrent <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (let i2 = left; i2 <= right; i2 += 1) {
          const active = stateCurrent === i2;
          pagerList.push(createVNode(Pager, {
            "locale": locale2,
            "rootPrefixCls": prefixCls,
            "onClick": this.handleChange,
            "onKeypress": this.runIfEnter,
            "key": i2,
            "page": i2,
            "active": active,
            "showTitle": showTitle,
            "itemRender": itemRender
          }, null));
        }
        if (stateCurrent - 1 >= pageBufferSize * 2 && stateCurrent !== 1 + 2) {
          pagerList[0] = createVNode(Pager, {
            "locale": locale2,
            "rootPrefixCls": prefixCls,
            "onClick": this.handleChange,
            "onKeypress": this.runIfEnter,
            "key": left,
            "page": left,
            "class": `${prefixCls}-item-after-jump-prev`,
            "active": false,
            "showTitle": this.showTitle,
            "itemRender": itemRender
          }, null);
          pagerList.unshift(jumpPrev);
        }
        if (allPages - stateCurrent >= pageBufferSize * 2 && stateCurrent !== allPages - 2) {
          pagerList[pagerList.length - 1] = createVNode(Pager, {
            "locale": locale2,
            "rootPrefixCls": prefixCls,
            "onClick": this.handleChange,
            "onKeypress": this.runIfEnter,
            "key": right,
            "page": right,
            "class": `${prefixCls}-item-before-jump-next`,
            "active": false,
            "showTitle": this.showTitle,
            "itemRender": itemRender
          }, null);
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(firstPager);
        }
        if (right !== allPages) {
          pagerList.push(lastPager);
        }
      }
      let totalText = null;
      if (showTotal) {
        totalText = createVNode("li", {
          "class": `${prefixCls}-total-text`
        }, [showTotal(total, [total === 0 ? 0 : (stateCurrent - 1) * statePageSize + 1, stateCurrent * statePageSize > total ? total : stateCurrent * statePageSize])]);
      }
      const prevDisabled = !hasPrev || !allPages;
      const nextDisabled = !hasNext || !allPages;
      const buildOptionText = this.buildOptionText || this.$slots.buildOptionText;
      return createVNode("ul", _objectSpread2$1(_objectSpread2$1({
        "unselectable": "on",
        "ref": "paginationNode"
      }, restAttrs), {}, {
        "class": classNames({
          [`${prefixCls}`]: true,
          [`${prefixCls}-disabled`]: disabled
        }, className)
      }), [totalText, createVNode("li", {
        "title": showTitle ? locale2.prev_page : null,
        "onClick": this.prev,
        "tabindex": prevDisabled ? null : 0,
        "onKeypress": this.runIfEnterPrev,
        "class": classNames(`${prefixCls}-prev`, {
          [`${prefixCls}-disabled`]: prevDisabled
        }),
        "aria-disabled": prevDisabled
      }, [this.renderPrev(prevPage)]), pagerList, createVNode("li", {
        "title": showTitle ? locale2.next_page : null,
        "onClick": this.next,
        "tabindex": nextDisabled ? null : 0,
        "onKeypress": this.runIfEnterNext,
        "class": classNames(`${prefixCls}-next`, {
          [`${prefixCls}-disabled`]: nextDisabled
        }),
        "aria-disabled": nextDisabled
      }, [this.renderNext(nextPage)]), createVNode(Options, {
        "disabled": disabled,
        "locale": locale2,
        "rootPrefixCls": prefixCls,
        "selectComponentClass": selectComponentClass,
        "selectPrefixCls": selectPrefixCls,
        "changeSize": this.getShowSizeChanger() ? this.changePageSize : null,
        "current": stateCurrent,
        "pageSize": statePageSize,
        "pageSizeOptions": pageSizeOptions,
        "buildOptionText": buildOptionText || null,
        "quickGo": this.shouldDisplayQuickJumper() ? this.handleChange : null,
        "goButton": goButton
      }, null)]);
    }
  });
  const genPaginationDisabledStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-disabled`]: {
        "&, &:hover": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        },
        "&:focus-visible": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`&${componentCls}-mini`]: {
          [`
          &:hover ${componentCls}-item:not(${componentCls}-item-active),
          &:active ${componentCls}-item:not(${componentCls}-item-active),
          &:hover ${componentCls}-item-link,
          &:active ${componentCls}-item-link
        `]: {
            backgroundColor: "transparent"
          }
        },
        [`${componentCls}-item`]: {
          cursor: "not-allowed",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          a: {
            color: token2.colorTextDisabled,
            backgroundColor: "transparent",
            border: "none",
            cursor: "not-allowed"
          },
          "&-active": {
            borderColor: token2.colorBorder,
            backgroundColor: token2.paginationItemDisabledBgActive,
            "&:hover, &:active": {
              backgroundColor: token2.paginationItemDisabledBgActive
            },
            a: {
              color: token2.paginationItemDisabledColorActive
            }
          }
        },
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          [`${componentCls}-simple&`]: {
            backgroundColor: "transparent",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          color: token2.colorTextDisabled
        },
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          [`${componentCls}-item-link-icon`]: {
            opacity: 0
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 1
          }
        }
      },
      [`&${componentCls}-simple`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`&${componentCls}-disabled ${componentCls}-item-link`]: {
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        }
      }
    };
  };
  const genPaginationMiniStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`
      },
      [`&${componentCls}-mini ${componentCls}-item`]: {
        minWidth: token2.paginationItemSizeSM,
        height: token2.paginationItemSizeSM,
        margin: 0,
        lineHeight: `${token2.paginationItemSizeSM - 2}px`
      },
      [`&${componentCls}-mini ${componentCls}-item:not(${componentCls}-item-active)`]: {
        backgroundColor: "transparent",
        borderColor: "transparent",
        "&:hover": {
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      },
      [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
        minWidth: token2.paginationItemSizeSM,
        height: token2.paginationItemSizeSM,
        margin: 0,
        lineHeight: `${token2.paginationItemSizeSM}px`,
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      },
      [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
        backgroundColor: "transparent",
        borderColor: "transparent",
        "&::after": {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`
        }
      },
      [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
        height: token2.paginationItemSizeSM,
        marginInlineEnd: 0,
        lineHeight: `${token2.paginationItemSizeSM}px`
      },
      [`&${componentCls}-mini ${componentCls}-options`]: {
        marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
        [`&-size-changer`]: {
          top: token2.paginationMiniOptionsSizeChangerTop
        },
        [`&-quick-jumper`]: {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`,
          input: _extends$1(_extends$1({}, genInputSmallStyle(token2)), {
            width: token2.paginationMiniQuickJumperInputWidth,
            height: token2.controlHeightSM
          })
        }
      }
    };
  };
  const genPaginationSimpleStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`,
        verticalAlign: "top",
        [`${componentCls}-item-link`]: {
          height: token2.paginationItemSizeSM,
          backgroundColor: "transparent",
          border: 0,
          "&:hover": {
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          },
          "&::after": {
            height: token2.paginationItemSizeSM,
            lineHeight: `${token2.paginationItemSizeSM}px`
          }
        }
      },
      [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
        display: "inline-block",
        height: token2.paginationItemSizeSM,
        marginInlineEnd: token2.marginXS,
        input: {
          boxSizing: "border-box",
          height: "100%",
          marginInlineEnd: token2.marginXS,
          padding: `0 ${token2.paginationItemPaddingInline}px`,
          textAlign: "center",
          backgroundColor: token2.paginationItemInputBg,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `border-color ${token2.motionDurationMid}`,
          color: "inherit",
          "&:hover": {
            borderColor: token2.colorPrimary
          },
          "&:focus": {
            borderColor: token2.colorPrimaryHover,
            boxShadow: `${token2.inputOutlineOffset}px 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
          },
          "&[disabled]": {
            color: token2.colorTextDisabled,
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            cursor: "not-allowed"
          }
        }
      }
    };
  };
  const genPaginationJumpStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        outline: 0,
        [`${componentCls}-item-container`]: {
          position: "relative",
          [`${componentCls}-item-link-icon`]: {
            color: token2.colorPrimary,
            fontSize: token2.fontSizeSM,
            opacity: 0,
            transition: `all ${token2.motionDurationMid}`,
            "&-svg": {
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              margin: "auto"
            }
          },
          [`${componentCls}-item-ellipsis`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            display: "block",
            margin: "auto",
            color: token2.colorTextDisabled,
            fontFamily: "Arial, Helvetica, sans-serif",
            letterSpacing: token2.paginationEllipsisLetterSpacing,
            textAlign: "center",
            textIndent: token2.paginationEllipsisTextIndent,
            opacity: 1,
            transition: `all ${token2.motionDurationMid}`
          }
        },
        "&:hover": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          }
        },
        "&:focus-visible": _extends$1({
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          }
        }, genFocusOutline(token2))
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        marginInlineEnd: token2.marginXS
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        display: "inline-block",
        minWidth: token2.paginationItemSize,
        height: token2.paginationItemSize,
        color: token2.colorText,
        fontFamily: token2.paginationFontFamily,
        lineHeight: `${token2.paginationItemSize}px`,
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        fontFamily: "Arial, Helvetica, sans-serif",
        outline: 0,
        button: {
          color: token2.colorText,
          cursor: "pointer",
          userSelect: "none"
        },
        [`${componentCls}-item-link`]: {
          display: "block",
          width: "100%",
          height: "100%",
          padding: 0,
          fontSize: token2.fontSizeSM,
          textAlign: "center",
          backgroundColor: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `all ${token2.motionDurationMid}`
        },
        [`&:focus-visible ${componentCls}-item-link`]: _extends$1({}, genFocusOutline(token2)),
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover`]: {
          [`${componentCls}-item-link`]: {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-slash`]: {
        marginInlineEnd: token2.paginationSlashMarginInlineEnd,
        marginInlineStart: token2.paginationSlashMarginInlineStart
      },
      [`${componentCls}-options`]: {
        display: "inline-block",
        marginInlineStart: token2.margin,
        verticalAlign: "middle",
        "&-size-changer.-select": {
          display: "inline-block",
          width: "auto"
        },
        "&-quick-jumper": {
          display: "inline-block",
          height: token2.controlHeight,
          marginInlineStart: token2.marginXS,
          lineHeight: `${token2.controlHeight}px`,
          verticalAlign: "top",
          input: _extends$1(_extends$1({}, genBasicInputStyle(token2)), {
            width: token2.controlHeightLG * 1.25,
            height: token2.controlHeight,
            boxSizing: "border-box",
            margin: 0,
            marginInlineStart: token2.marginXS,
            marginInlineEnd: token2.marginXS
          })
        }
      }
    };
  };
  const genPaginationItemStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-item`]: _extends$1(_extends$1({
        display: "inline-block",
        minWidth: token2.paginationItemSize,
        height: token2.paginationItemSize,
        marginInlineEnd: token2.marginXS,
        fontFamily: token2.paginationFontFamily,
        lineHeight: `${token2.paginationItemSize - 2}px`,
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: 0,
        cursor: "pointer",
        userSelect: "none",
        a: {
          display: "block",
          padding: `0 ${token2.paginationItemPaddingInline}px`,
          color: token2.colorText,
          transition: "none",
          "&:hover": {
            textDecoration: "none"
          }
        },
        [`&:not(${componentCls}-item-active)`]: {
          "&:hover": {
            transition: `all ${token2.motionDurationMid}`,
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          }
        }
      }, genFocusStyle(token2)), {
        "&-active": {
          fontWeight: token2.paginationFontWeightActive,
          backgroundColor: token2.paginationItemBgActive,
          borderColor: token2.colorPrimary,
          a: {
            color: token2.colorPrimary
          },
          "&:hover": {
            borderColor: token2.colorPrimaryHover
          },
          "&:hover a": {
            color: token2.colorPrimaryHover
          }
        }
      })
    };
  };
  const genPaginationStyle$1 = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          overflow: "hidden",
          visibility: "hidden",
          content: '""'
        },
        [`${componentCls}-total-text`]: {
          display: "inline-block",
          height: token2.paginationItemSize,
          marginInlineEnd: token2.marginXS,
          lineHeight: `${token2.paginationItemSize - 2}px`,
          verticalAlign: "middle"
        }
      }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
        // media query style
        [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
          [`${componentCls}-item`]: {
            "&-after-jump-prev, &-before-jump-next": {
              display: "none"
            }
          }
        },
        [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
          [`${componentCls}-options`]: {
            display: "none"
          }
        }
      }),
      // rtl style
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  const genBorderedStyle$1 = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}${componentCls}-disabled`]: {
        "&, &:hover": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        "&:focus-visible": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        [`${componentCls}-item, ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          [`&:hover:not(${componentCls}-item-active)`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            a: {
              color: token2.colorTextDisabled
            }
          },
          [`&${componentCls}-item-active`]: {
            backgroundColor: token2.paginationItemDisabledBgActive
          }
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder
          }
        }
      },
      [componentCls]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            borderColor: token2.colorPrimaryHover,
            backgroundColor: token2.paginationItemBg
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.paginationItemLinkBg,
            borderColor: token2.colorBorder
          },
          [`&:hover ${componentCls}-item-link`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.paginationItemBg,
            color: token2.colorPrimary
          },
          [`&${componentCls}-disabled`]: {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            }
          }
        },
        [`${componentCls}-item`]: {
          backgroundColor: token2.paginationItemBg,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          [`&:hover:not(${componentCls}-item-active)`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.paginationItemBg,
            a: {
              color: token2.colorPrimary
            }
          },
          "&-active": {
            borderColor: token2.colorPrimary
          }
        }
      }
    };
  };
  const useStyle$2 = genComponentStyleHook("Pagination", (token2) => {
    const paginationToken = merge$2(token2, {
      paginationItemSize: token2.controlHeight,
      paginationFontFamily: token2.fontFamily,
      paginationItemBg: token2.colorBgContainer,
      paginationItemBgActive: token2.colorBgContainer,
      paginationFontWeightActive: token2.fontWeightStrong,
      paginationItemSizeSM: token2.controlHeightSM,
      paginationItemInputBg: token2.colorBgContainer,
      paginationMiniOptionsSizeChangerTop: 0,
      paginationItemDisabledBgActive: token2.controlItemBgActiveDisabled,
      paginationItemDisabledColorActive: token2.colorTextDisabled,
      paginationItemLinkBg: token2.colorBgContainer,
      inputOutlineOffset: "0 0",
      paginationMiniOptionsMarginInlineStart: token2.marginXXS / 2,
      paginationMiniQuickJumperInputWidth: token2.controlHeightLG * 1.1,
      paginationItemPaddingInline: token2.marginXXS * 1.5,
      paginationEllipsisLetterSpacing: token2.marginXXS / 2,
      paginationSlashMarginInlineStart: token2.marginXXS,
      paginationSlashMarginInlineEnd: token2.marginSM,
      paginationEllipsisTextIndent: "0.13em"
      // magic for ui experience
    }, initInputToken(token2));
    return [genPaginationStyle$1(paginationToken), token2.wireframe && genBorderedStyle$1(paginationToken)];
  });
  var __rest$7 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const paginationProps = () => ({
    total: Number,
    defaultCurrent: Number,
    disabled: booleanType(),
    current: Number,
    defaultPageSize: Number,
    pageSize: Number,
    hideOnSinglePage: booleanType(),
    showSizeChanger: booleanType(),
    pageSizeOptions: arrayType(),
    buildOptionText: functionType(),
    showQuickJumper: someType([Boolean, Object]),
    showTotal: functionType(),
    size: stringType(),
    simple: booleanType(),
    locale: Object,
    prefixCls: String,
    selectPrefixCls: String,
    totalBoundaryShowSizeChanger: Number,
    selectComponentClass: String,
    itemRender: functionType(),
    role: String,
    responsive: Boolean,
    showLessItems: booleanType(),
    onChange: functionType(),
    onShowSizeChange: functionType(),
    "onUpdate:current": functionType(),
    "onUpdate:pageSize": functionType()
  });
  const Pagination$2 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "APagination",
    inheritAttrs: false,
    props: paginationProps(),
    // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        configProvider,
        direction,
        size
      } = useConfigInject("pagination", props2);
      const [wrapSSR, hashId] = useStyle$2(prefixCls);
      const selectPrefixCls = computed(() => configProvider.getPrefixCls("select", props2.selectPrefixCls));
      const breakpoint = useBreakpoint();
      const [locale2] = useLocaleReceiver("Pagination", enUS, toRef(props2, "locale"));
      const getIconsProps = (pre) => {
        const ellipsis = createVNode("span", {
          "class": `${pre}-item-ellipsis`
        }, [createTextVNode("•••")]);
        const prevIcon = createVNode("button", {
          "class": `${pre}-item-link`,
          "type": "button",
          "tabindex": -1
        }, [direction.value === "rtl" ? createVNode(RightOutlined, null, null) : createVNode(LeftOutlined, null, null)]);
        const nextIcon = createVNode("button", {
          "class": `${pre}-item-link`,
          "type": "button",
          "tabindex": -1
        }, [direction.value === "rtl" ? createVNode(LeftOutlined, null, null) : createVNode(RightOutlined, null, null)]);
        const jumpPrevIcon = createVNode("a", {
          "rel": "nofollow",
          "class": `${pre}-item-link`
        }, [createVNode("div", {
          "class": `${pre}-item-container`
        }, [direction.value === "rtl" ? createVNode(DoubleRightOutlined, {
          "class": `${pre}-item-link-icon`
        }, null) : createVNode(DoubleLeftOutlined, {
          "class": `${pre}-item-link-icon`
        }, null), ellipsis])]);
        const jumpNextIcon = createVNode("a", {
          "rel": "nofollow",
          "class": `${pre}-item-link`
        }, [createVNode("div", {
          "class": `${pre}-item-container`
        }, [direction.value === "rtl" ? createVNode(DoubleLeftOutlined, {
          "class": `${pre}-item-link-icon`
        }, null) : createVNode(DoubleRightOutlined, {
          "class": `${pre}-item-link-icon`
        }, null), ellipsis])]);
        return {
          prevIcon,
          nextIcon,
          jumpPrevIcon,
          jumpNextIcon
        };
      };
      return () => {
        var _a2;
        const {
          itemRender = slots.itemRender,
          buildOptionText = slots.buildOptionText,
          selectComponentClass,
          responsive
        } = props2, restProps = __rest$7(props2, ["itemRender", "buildOptionText", "selectComponentClass", "responsive"]);
        const isSmall = size.value === "small" || !!(((_a2 = breakpoint.value) === null || _a2 === void 0 ? void 0 : _a2.xs) && !size.value && responsive);
        const paginationProps2 = _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, restProps), getIconsProps(prefixCls.value)), {
          prefixCls: prefixCls.value,
          selectPrefixCls: selectPrefixCls.value,
          selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
          locale: locale2.value,
          buildOptionText
        }), attrs), {
          class: classNames({
            [`${prefixCls.value}-mini`]: isSmall,
            [`${prefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value),
          itemRender
        });
        return wrapSSR(createVNode(VcPagination, paginationProps2, null));
      };
    }
  });
  const Pagination$1 = withInstall(Pagination$2);
  const Row = withInstall(ARow);
  const TableContextKey = Symbol("TableContextProps");
  const useProvideTable = (props2) => {
    provide(TableContextKey, props2);
  };
  const useInjectTable = () => {
    return inject(TableContextKey, {});
  };
  const INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
  function toArray$1(arr) {
    if (arr === void 0 || arr === null) {
      return [];
    }
    return Array.isArray(arr) ? arr : [arr];
  }
  function getPathValue(record, path) {
    if (!path && typeof path !== "number") {
      return record;
    }
    const pathList = toArray$1(path);
    let current = record;
    for (let i2 = 0; i2 < pathList.length; i2 += 1) {
      if (!current) {
        return null;
      }
      const prop = pathList[i2];
      current = current[prop];
    }
    return current;
  }
  function getColumnsKey(columns) {
    const columnKeys = [];
    const keys2 = {};
    columns.forEach((column2) => {
      const {
        key: key2,
        dataIndex
      } = column2 || {};
      let mergedKey = key2 || toArray$1(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
      while (keys2[mergedKey]) {
        mergedKey = `${mergedKey}_next`;
      }
      keys2[mergedKey] = true;
      columnKeys.push(mergedKey);
    });
    return columnKeys;
  }
  function mergeObject() {
    const merged = {};
    function fillProps(obj2, clone2) {
      if (clone2) {
        Object.keys(clone2).forEach((key2) => {
          const value = clone2[key2];
          if (value && typeof value === "object") {
            obj2[key2] = obj2[key2] || {};
            fillProps(obj2[key2], value);
          } else {
            obj2[key2] = value;
          }
        });
      }
    }
    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }
    objects.forEach((clone2) => {
      fillProps(merged, clone2);
    });
    return merged;
  }
  function validateValue(val) {
    return val !== null && val !== void 0;
  }
  const SlotsContextKey = Symbol("SlotsContextProps");
  const useProvideSlots = (props2) => {
    provide(SlotsContextKey, props2);
  };
  const useInjectSlots = () => {
    return inject(SlotsContextKey, computed(() => ({})));
  };
  const ContextKey = Symbol("ContextProps");
  const useProvideTableContext = (props2) => {
    provide(ContextKey, props2);
  };
  const useInjectTableContext = () => {
    return inject(ContextKey, {
      onResizeColumn: () => {
      }
    });
  };
  const INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
  const HoverContextKey = Symbol("HoverContextProps");
  const useProvideHover = (props2) => {
    provide(HoverContextKey, props2);
  };
  const useInjectHover = () => {
    return inject(HoverContextKey, {
      startRow: shallowRef(-1),
      endRow: shallowRef(-1),
      onHover() {
      }
    });
  };
  const supportSticky = shallowRef(false);
  const useProvideSticky = () => {
    onMounted(() => {
      supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky");
    });
  };
  const useInjectSticky = () => {
    return supportSticky;
  };
  var __rest$6 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
    const cellEndRow = cellStartRow + cellRowSpan - 1;
    return cellStartRow <= endRow && cellEndRow >= startRow;
  }
  function isRenderCell(data) {
    return data && typeof data === "object" && !Array.isArray(data) && !isVNode$1(data);
  }
  const Cell = /* @__PURE__ */ defineComponent({
    name: "Cell",
    props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const contextSlots = useInjectSlots();
      const {
        onHover,
        startRow,
        endRow
      } = useInjectHover();
      const colSpan = computed(() => {
        var _a2, _b2, _c2, _d;
        return (_c2 = (_a2 = props2.colSpan) !== null && _a2 !== void 0 ? _a2 : (_b2 = props2.additionalProps) === null || _b2 === void 0 ? void 0 : _b2.colSpan) !== null && _c2 !== void 0 ? _c2 : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.colspan;
      });
      const rowSpan = computed(() => {
        var _a2, _b2, _c2, _d;
        return (_c2 = (_a2 = props2.rowSpan) !== null && _a2 !== void 0 ? _a2 : (_b2 = props2.additionalProps) === null || _b2 === void 0 ? void 0 : _b2.rowSpan) !== null && _c2 !== void 0 ? _c2 : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.rowspan;
      });
      const hovering = eagerComputed(() => {
        const {
          index: index2
        } = props2;
        return inHoverRange(index2, rowSpan.value || 1, startRow.value, endRow.value);
      });
      const supportSticky2 = useInjectSticky();
      const onMouseenter = (event, mergedRowSpan) => {
        var _a2;
        const {
          record,
          index: index2,
          additionalProps
        } = props2;
        if (record) {
          onHover(index2, index2 + mergedRowSpan - 1);
        }
        (_a2 = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseenter) === null || _a2 === void 0 ? void 0 : _a2.call(additionalProps, event);
      };
      const onMouseleave = (event) => {
        var _a2;
        const {
          record,
          additionalProps
        } = props2;
        if (record) {
          onHover(-1, -1);
        }
        (_a2 = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseleave) === null || _a2 === void 0 ? void 0 : _a2.call(additionalProps, event);
      };
      const getTitle = (vnodes) => {
        const vnode = filterEmpty(vnodes)[0];
        if (isVNode$1(vnode)) {
          if (vnode.type === Text) {
            return vnode.children;
          } else {
            return Array.isArray(vnode.children) ? getTitle(vnode.children) : void 0;
          }
        } else {
          return vnode;
        }
      };
      const hoverRef = shallowRef(null);
      watch([hovering, () => props2.prefixCls, hoverRef], () => {
        const cellDom = findDOMNode(hoverRef.value);
        if (!cellDom) return;
        if (hovering.value) {
          addClass(cellDom, `${props2.prefixCls}-cell-row-hover`);
        } else {
          removeClass(cellDom, `${props2.prefixCls}-cell-row-hover`);
        }
      });
      return () => {
        var _a2, _b2, _c2, _d, _e, _f;
        const {
          prefixCls,
          record,
          index: index2,
          renderIndex,
          dataIndex,
          customRender,
          component: Component = "td",
          fixLeft,
          fixRight,
          firstFixLeft,
          lastFixLeft,
          firstFixRight,
          lastFixRight,
          appendNode = (_a2 = slots.appendNode) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          additionalProps = {},
          ellipsis,
          align,
          rowType,
          isSticky,
          column: column2 = {},
          cellType
        } = props2;
        const cellPrefixCls = `${prefixCls}-cell`;
        let cellProps;
        let childNode;
        const children = (_b2 = slots.default) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
        if (validateValue(children) || cellType === "header") {
          childNode = children;
        } else {
          const value = getPathValue(record, dataIndex);
          childNode = value;
          if (customRender) {
            const renderData = customRender({
              text: value,
              value,
              record,
              index: index2,
              renderIndex,
              column: column2.__originColumn__
            });
            if (isRenderCell(renderData)) {
              childNode = renderData.children;
              cellProps = renderData.props;
            } else {
              childNode = renderData;
            }
          }
          if (!(INTERNAL_COL_DEFINE in column2) && cellType === "body" && contextSlots.value.bodyCell && !((_c2 = column2.slots) === null || _c2 === void 0 ? void 0 : _c2.customRender)) {
            const child = customRenderSlot(contextSlots.value, "bodyCell", {
              text: value,
              value,
              record,
              index: index2,
              column: column2.__originColumn__
            }, () => {
              const fallback = childNode === void 0 ? value : childNode;
              return [typeof fallback === "object" && isValidElement(fallback) || typeof fallback !== "object" ? fallback : null];
            });
            childNode = flattenChildren(child);
          }
          if (props2.transformCellText) {
            childNode = props2.transformCellText({
              text: childNode,
              record,
              index: index2,
              column: column2.__originColumn__
            });
          }
        }
        if (typeof childNode === "object" && !Array.isArray(childNode) && !isVNode$1(childNode)) {
          childNode = null;
        }
        if (ellipsis && (lastFixLeft || firstFixRight)) {
          childNode = createVNode("span", {
            "class": `${cellPrefixCls}-content`
          }, [childNode]);
        }
        if (Array.isArray(childNode) && childNode.length === 1) {
          childNode = childNode[0];
        }
        const _g = cellProps || {}, {
          colSpan: cellColSpan,
          rowSpan: cellRowSpan,
          style: cellStyle,
          class: cellClassName
        } = _g, restCellProps = __rest$6(_g, ["colSpan", "rowSpan", "style", "class"]);
        const mergedColSpan = (_d = cellColSpan !== void 0 ? cellColSpan : colSpan.value) !== null && _d !== void 0 ? _d : 1;
        const mergedRowSpan = (_e = cellRowSpan !== void 0 ? cellRowSpan : rowSpan.value) !== null && _e !== void 0 ? _e : 1;
        if (mergedColSpan === 0 || mergedRowSpan === 0) {
          return null;
        }
        const fixedStyle = {};
        const isFixLeft = typeof fixLeft === "number" && supportSticky2.value;
        const isFixRight = typeof fixRight === "number" && supportSticky2.value;
        if (isFixLeft) {
          fixedStyle.position = "sticky";
          fixedStyle.left = `${fixLeft}px`;
        }
        if (isFixRight) {
          fixedStyle.position = "sticky";
          fixedStyle.right = `${fixRight}px`;
        }
        const alignStyle = {};
        if (align) {
          alignStyle.textAlign = align;
        }
        let title;
        const ellipsisConfig = ellipsis === true ? {
          showTitle: true
        } : ellipsis;
        if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
          if (typeof childNode === "string" || typeof childNode === "number") {
            title = childNode.toString();
          } else if (isVNode$1(childNode)) {
            title = getTitle([childNode]);
          }
        }
        const componentProps = _extends$1(_extends$1(_extends$1({
          title
        }, restCellProps), additionalProps), {
          colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
          rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
          class: classNames(cellPrefixCls, {
            [`${cellPrefixCls}-fix-left`]: isFixLeft && supportSticky2.value,
            [`${cellPrefixCls}-fix-left-first`]: firstFixLeft && supportSticky2.value,
            [`${cellPrefixCls}-fix-left-last`]: lastFixLeft && supportSticky2.value,
            [`${cellPrefixCls}-fix-right`]: isFixRight && supportSticky2.value,
            [`${cellPrefixCls}-fix-right-first`]: firstFixRight && supportSticky2.value,
            [`${cellPrefixCls}-fix-right-last`]: lastFixRight && supportSticky2.value,
            [`${cellPrefixCls}-ellipsis`]: ellipsis,
            [`${cellPrefixCls}-with-append`]: appendNode,
            [`${cellPrefixCls}-fix-sticky`]: (isFixLeft || isFixRight) && isSticky && supportSticky2.value
          }, additionalProps.class, cellClassName),
          onMouseenter: (e2) => {
            onMouseenter(e2, mergedRowSpan);
          },
          onMouseleave,
          style: [additionalProps.style, alignStyle, fixedStyle, cellStyle]
        });
        return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, componentProps), {}, {
          "ref": hoverRef
        }), {
          default: () => [appendNode, childNode, (_f = slots.dragHandle) === null || _f === void 0 ? void 0 : _f.call(slots)]
        });
      };
    }
  });
  function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
    const startColumn = columns[colStart] || {};
    const endColumn = columns[colEnd] || {};
    let fixLeft;
    let fixRight;
    if (startColumn.fixed === "left") {
      fixLeft = stickyOffsets.left[colStart];
    } else if (endColumn.fixed === "right") {
      fixRight = stickyOffsets.right[colEnd];
    }
    let lastFixLeft = false;
    let firstFixRight = false;
    let lastFixRight = false;
    let firstFixLeft = false;
    const nextColumn = columns[colEnd + 1];
    const prevColumn = columns[colStart - 1];
    if (direction === "rtl") {
      if (fixLeft !== void 0) {
        const prevFixLeft = prevColumn && prevColumn.fixed === "left";
        firstFixLeft = !prevFixLeft;
      } else if (fixRight !== void 0) {
        const nextFixRight = nextColumn && nextColumn.fixed === "right";
        lastFixRight = !nextFixRight;
      }
    } else if (fixLeft !== void 0) {
      const nextFixLeft = nextColumn && nextColumn.fixed === "left";
      lastFixLeft = !nextFixLeft;
    } else if (fixRight !== void 0) {
      const prevFixRight = prevColumn && prevColumn.fixed === "right";
      firstFixRight = !prevFixRight;
    }
    return {
      fixLeft,
      fixRight,
      lastFixLeft,
      firstFixRight,
      lastFixRight,
      firstFixLeft,
      isSticky: stickyOffsets.isSticky
    };
  }
  const events = {
    mouse: {
      move: "mousemove",
      stop: "mouseup"
    },
    touch: {
      move: "touchmove",
      stop: "touchend"
    }
  };
  const defaultMinWidth = 50;
  const DragHandleVue = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "DragHandle",
    props: {
      prefixCls: String,
      width: {
        type: Number,
        required: true
      },
      minWidth: {
        type: Number,
        default: defaultMinWidth
      },
      maxWidth: {
        type: Number,
        default: Infinity
      },
      column: {
        type: Object,
        default: void 0
      }
    },
    setup(props2) {
      let startX = 0;
      let moveEvent = {
        remove: () => {
        }
      };
      let stopEvent2 = {
        remove: () => {
        }
      };
      const removeEvents = () => {
        moveEvent.remove();
        stopEvent2.remove();
      };
      onUnmounted(() => {
        removeEvents();
      });
      watchEffect(() => {
        devWarning(!isNaN(props2.width), "Table", "width must be a number when use resizable");
      });
      const {
        onResizeColumn
      } = useInjectTableContext();
      const minWidth = computed(() => {
        return typeof props2.minWidth === "number" && !isNaN(props2.minWidth) ? props2.minWidth : defaultMinWidth;
      });
      const maxWidth = computed(() => {
        return typeof props2.maxWidth === "number" && !isNaN(props2.maxWidth) ? props2.maxWidth : Infinity;
      });
      const instance = getCurrentInstance();
      let baseWidth = 0;
      const dragging = shallowRef(false);
      let rafId;
      const updateWidth = (e2) => {
        let pageX = 0;
        if (e2.touches) {
          if (e2.touches.length) {
            pageX = e2.touches[0].pageX;
          } else {
            pageX = e2.changedTouches[0].pageX;
          }
        } else {
          pageX = e2.pageX;
        }
        const tmpDeltaX = startX - pageX;
        let w2 = Math.max(baseWidth - tmpDeltaX, minWidth.value);
        w2 = Math.min(w2, maxWidth.value);
        wrapperRaf.cancel(rafId);
        rafId = wrapperRaf(() => {
          onResizeColumn(w2, props2.column.__originColumn__);
        });
      };
      const handleMove = (e2) => {
        updateWidth(e2);
      };
      const handleStop = (e2) => {
        dragging.value = false;
        updateWidth(e2);
        removeEvents();
      };
      const handleStart = (e2, eventsFor) => {
        dragging.value = true;
        removeEvents();
        baseWidth = instance.vnode.el.parentNode.getBoundingClientRect().width;
        if (e2 instanceof MouseEvent && e2.which !== 1) {
          return;
        }
        if (e2.stopPropagation) e2.stopPropagation();
        startX = e2.touches ? e2.touches[0].pageX : e2.pageX;
        moveEvent = addEventListenerWrap(document.documentElement, eventsFor.move, handleMove);
        stopEvent2 = addEventListenerWrap(document.documentElement, eventsFor.stop, handleStop);
      };
      const handleDown = (e2) => {
        e2.stopPropagation();
        e2.preventDefault();
        handleStart(e2, events.mouse);
      };
      const handleTouchDown = (e2) => {
        e2.stopPropagation();
        e2.preventDefault();
        handleStart(e2, events.touch);
      };
      const handleClick = (e2) => {
        e2.stopPropagation();
        e2.preventDefault();
      };
      return () => {
        const {
          prefixCls
        } = props2;
        const touchEvents = {
          [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: (e2) => handleTouchDown(e2)
        };
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({
          "class": `${prefixCls}-resize-handle ${dragging.value ? "dragging" : ""}`,
          "onMousedown": handleDown
        }, touchEvents), {}, {
          "onClick": handleClick
        }), [createVNode("div", {
          "class": `${prefixCls}-resize-handle-line`
        }, null)]);
      };
    }
  });
  const HeaderRow = /* @__PURE__ */ defineComponent({
    name: "HeaderRow",
    props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
    setup(props2) {
      const tableContext = useInjectTable();
      return () => {
        const {
          prefixCls,
          direction
        } = tableContext;
        const {
          cells,
          stickyOffsets,
          flattenColumns,
          rowComponent: RowComponent,
          cellComponent: CellComponent,
          customHeaderRow,
          index: index2
        } = props2;
        let rowProps2;
        if (customHeaderRow) {
          rowProps2 = customHeaderRow(cells.map((cell) => cell.column), index2);
        }
        const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
        return createVNode(RowComponent, rowProps2, {
          default: () => [cells.map((cell, cellIndex) => {
            const {
              column: column2
            } = cell;
            const fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
            let additionalProps;
            if (column2 && column2.customHeaderCell) {
              additionalProps = cell.column.customHeaderCell(column2);
            }
            const col = column2;
            return createVNode(Cell, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, cell), {}, {
              "cellType": "header",
              "ellipsis": column2.ellipsis,
              "align": column2.align,
              "component": CellComponent,
              "prefixCls": prefixCls,
              "key": columnsKey[cellIndex]
            }, fixedInfo), {}, {
              "additionalProps": additionalProps,
              "rowType": "header",
              "column": column2
            }), {
              default: () => column2.title,
              dragHandle: () => col.resizable ? createVNode(DragHandleVue, {
                "prefixCls": prefixCls,
                "width": col.width,
                "minWidth": col.minWidth,
                "maxWidth": col.maxWidth,
                "column": col
              }, null) : null
            });
          })]
        });
      };
    }
  });
  function parseHeaderRows(rootColumns) {
    const rows = [];
    function fillRowCells(columns, colIndex) {
      let rowIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      rows[rowIndex] = rows[rowIndex] || [];
      let currentColIndex = colIndex;
      const colSpans = columns.filter(Boolean).map((column2) => {
        const cell = {
          key: column2.key,
          class: classNames(column2.className, column2.class),
          // children: column.title,
          column: column2,
          colStart: currentColIndex
        };
        let colSpan = 1;
        const subColumns = column2.children;
        if (subColumns && subColumns.length > 0) {
          colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total, count) => total + count, 0);
          cell.hasSubColumns = true;
        }
        if ("colSpan" in column2) {
          ({
            colSpan
          } = column2);
        }
        if ("rowSpan" in column2) {
          cell.rowSpan = column2.rowSpan;
        }
        cell.colSpan = colSpan;
        cell.colEnd = cell.colStart + colSpan - 1;
        rows[rowIndex].push(cell);
        currentColIndex += colSpan;
        return colSpan;
      });
      return colSpans;
    }
    fillRowCells(rootColumns, 0);
    const rowCount = rows.length;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      rows[rowIndex].forEach((cell) => {
        if (!("rowSpan" in cell) && !cell.hasSubColumns) {
          cell.rowSpan = rowCount - rowIndex;
        }
      });
    }
    return rows;
  }
  const Header = /* @__PURE__ */ defineComponent({
    name: "TableHeader",
    inheritAttrs: false,
    props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
    setup(props2) {
      const tableContext = useInjectTable();
      const rows = computed(() => parseHeaderRows(props2.columns));
      return () => {
        const {
          prefixCls,
          getComponent: getComponent2
        } = tableContext;
        const {
          stickyOffsets,
          flattenColumns,
          customHeaderRow
        } = props2;
        const WrapperComponent = getComponent2(["header", "wrapper"], "thead");
        const trComponent = getComponent2(["header", "row"], "tr");
        const thComponent = getComponent2(["header", "cell"], "th");
        return createVNode(WrapperComponent, {
          "class": `${prefixCls}-thead`
        }, {
          default: () => [rows.value.map((row, rowIndex) => {
            const rowNode = createVNode(HeaderRow, {
              "key": rowIndex,
              "flattenColumns": flattenColumns,
              "cells": row,
              "stickyOffsets": stickyOffsets,
              "rowComponent": trComponent,
              "cellComponent": thComponent,
              "customHeaderRow": customHeaderRow,
              "index": rowIndex
            }, null);
            return rowNode;
          })]
        });
      };
    }
  });
  const ExpandedRowContextKey = Symbol("ExpandedRowProps");
  const useProvideExpandedRow = (props2) => {
    provide(ExpandedRowContextKey, props2);
  };
  const useInjectExpandedRow = () => {
    return inject(ExpandedRowContextKey, {});
  };
  const ExpandedRow = /* @__PURE__ */ defineComponent({
    name: "ExpandedRow",
    inheritAttrs: false,
    props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
    setup(props2, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const tableContext = useInjectTable();
      const expandedRowContext = useInjectExpandedRow();
      const {
        fixHeader,
        fixColumn,
        componentWidth,
        horizonScroll
      } = expandedRowContext;
      return () => {
        const {
          prefixCls,
          component: Component,
          cellComponent,
          expanded,
          colSpan,
          isEmpty: isEmpty2
        } = props2;
        return createVNode(Component, {
          "class": attrs.class,
          "style": {
            display: expanded ? null : "none"
          }
        }, {
          default: () => [createVNode(Cell, {
            "component": cellComponent,
            "prefixCls": prefixCls,
            "colSpan": colSpan
          }, {
            default: () => {
              var _a2;
              let contentNode = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
              if (isEmpty2 ? horizonScroll.value : fixColumn.value) {
                contentNode = createVNode("div", {
                  "style": {
                    width: `${componentWidth.value - (fixHeader.value ? tableContext.scrollbarSize : 0)}px`,
                    position: "sticky",
                    left: 0,
                    overflow: "hidden"
                  },
                  "class": `${prefixCls}-expanded-row-fixed`
                }, [contentNode]);
              }
              return contentNode;
            }
          })]
        });
      };
    }
  });
  const MeasureCell = /* @__PURE__ */ defineComponent({
    name: "MeasureCell",
    props: ["columnKey"],
    setup(props2, _ref) {
      let {
        emit: emit2
      } = _ref;
      const tdRef = ref();
      onMounted(() => {
        if (tdRef.value) {
          emit2("columnResize", props2.columnKey, tdRef.value.offsetWidth);
        }
      });
      return () => {
        return createVNode(ResizeObserver$1, {
          "onResize": (_ref2) => {
            let {
              offsetWidth
            } = _ref2;
            emit2("columnResize", props2.columnKey, offsetWidth);
          }
        }, {
          default: () => [createVNode("td", {
            "ref": tdRef,
            "style": {
              padding: 0,
              border: 0,
              height: 0
            }
          }, [createVNode("div", {
            "style": {
              height: 0,
              overflow: "hidden"
            }
          }, [createTextVNode(" ")])])]
        });
      };
    }
  });
  const BodyContextKey = Symbol("BodyContextProps");
  const useProvideBody = (props2) => {
    provide(BodyContextKey, props2);
  };
  const useInjectBody = () => {
    return inject(BodyContextKey, {});
  };
  const BodyRow = /* @__PURE__ */ defineComponent({
    name: "BodyRow",
    inheritAttrs: false,
    props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
    setup(props2, _ref) {
      let {
        attrs
      } = _ref;
      const tableContext = useInjectTable();
      const bodyContext = useInjectBody();
      const expandRended = shallowRef(false);
      const expanded = computed(() => props2.expandedKeys && props2.expandedKeys.has(props2.recordKey));
      watchEffect(() => {
        if (expanded.value) {
          expandRended.value = true;
        }
      });
      const rowSupportExpand = computed(() => bodyContext.expandableType === "row" && (!props2.rowExpandable || props2.rowExpandable(props2.record)));
      const nestExpandable = computed(() => bodyContext.expandableType === "nest");
      const hasNestChildren = computed(() => props2.childrenColumnName && props2.record && props2.record[props2.childrenColumnName]);
      const mergedExpandable = computed(() => rowSupportExpand.value || nestExpandable.value);
      const onInternalTriggerExpand = (record, event) => {
        bodyContext.onTriggerExpand(record, event);
      };
      const additionalProps = computed(() => {
        var _a2;
        return ((_a2 = props2.customRow) === null || _a2 === void 0 ? void 0 : _a2.call(props2, props2.record, props2.index)) || {};
      });
      const onClick = function(event) {
        var _a2, _b2;
        if (bodyContext.expandRowByClick && mergedExpandable.value) {
          onInternalTriggerExpand(props2.record, event);
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        (_b2 = (_a2 = additionalProps.value) === null || _a2 === void 0 ? void 0 : _a2.onClick) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, ...args);
      };
      const computeRowClassName = computed(() => {
        const {
          record,
          index: index2,
          indent
        } = props2;
        const {
          rowClassName
        } = bodyContext;
        if (typeof rowClassName === "string") {
          return rowClassName;
        } else if (typeof rowClassName === "function") {
          return rowClassName(record, index2, indent);
        }
        return "";
      });
      const columnsKey = computed(() => getColumnsKey(bodyContext.flattenColumns));
      return () => {
        const {
          class: className,
          style
        } = attrs;
        const {
          record,
          index: index2,
          rowKey,
          indent = 0,
          rowComponent: RowComponent,
          cellComponent
        } = props2;
        const {
          prefixCls,
          fixedInfoList,
          transformCellText
        } = tableContext;
        const {
          flattenColumns,
          expandedRowClassName,
          indentSize,
          expandIcon,
          expandedRowRender,
          expandIconColumnIndex
        } = bodyContext;
        const baseRowNode = createVNode(RowComponent, _objectSpread2$1(_objectSpread2$1({}, additionalProps.value), {}, {
          "data-row-key": rowKey,
          "class": classNames(className, `${prefixCls}-row`, `${prefixCls}-row-level-${indent}`, computeRowClassName.value, additionalProps.value.class),
          "style": [style, additionalProps.value.style],
          "onClick": onClick
        }), {
          default: () => [flattenColumns.map((column2, colIndex) => {
            const {
              customRender,
              dataIndex,
              className: columnClassName
            } = column2;
            const key2 = columnsKey[colIndex];
            const fixedInfo = fixedInfoList[colIndex];
            let additionalCellProps;
            if (column2.customCell) {
              additionalCellProps = column2.customCell(record, index2, column2);
            }
            const appendNode = colIndex === (expandIconColumnIndex || 0) && nestExpandable.value ? createVNode(Fragment, null, [createVNode("span", {
              "style": {
                paddingLeft: `${indentSize * indent}px`
              },
              "class": `${prefixCls}-row-indent indent-level-${indent}`
            }, null), expandIcon({
              prefixCls,
              expanded: expanded.value,
              expandable: hasNestChildren.value,
              record,
              onExpand: onInternalTriggerExpand
            })]) : null;
            return createVNode(Cell, _objectSpread2$1(_objectSpread2$1({
              "cellType": "body",
              "class": columnClassName,
              "ellipsis": column2.ellipsis,
              "align": column2.align,
              "component": cellComponent,
              "prefixCls": prefixCls,
              "key": key2,
              "record": record,
              "index": index2,
              "renderIndex": props2.renderIndex,
              "dataIndex": dataIndex,
              "customRender": customRender
            }, fixedInfo), {}, {
              "additionalProps": additionalCellProps,
              "column": column2,
              "transformCellText": transformCellText,
              "appendNode": appendNode
            }), null);
          })]
        });
        let expandRowNode;
        if (rowSupportExpand.value && (expandRended.value || expanded.value)) {
          const expandContent = expandedRowRender({
            record,
            index: index2,
            indent: indent + 1,
            expanded: expanded.value
          });
          const computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
          expandRowNode = createVNode(ExpandedRow, {
            "expanded": expanded.value,
            "class": classNames(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, computedExpandedRowClassName),
            "prefixCls": prefixCls,
            "component": RowComponent,
            "cellComponent": cellComponent,
            "colSpan": flattenColumns.length,
            "isEmpty": false
          }, {
            default: () => [expandContent]
          });
        }
        return createVNode(Fragment, null, [baseRowNode, expandRowNode]);
      };
    }
  });
  function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
    const arr = [];
    arr.push({
      record,
      indent,
      index: index2
    });
    const key2 = getRowKey(record);
    const expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
    if (record && Array.isArray(record[childrenColumnName]) && expanded) {
      for (let i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
        const tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
        arr.push(...tempArr);
      }
    }
    return arr;
  }
  function useFlattenRecords(dataRef, childrenColumnNameRef, expandedKeysRef, getRowKey) {
    const arr = computed(() => {
      const childrenColumnName = childrenColumnNameRef.value;
      const expandedKeys = expandedKeysRef.value;
      const data = dataRef.value;
      if (expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.size) {
        const temp = [];
        for (let i2 = 0; i2 < (data === null || data === void 0 ? void 0 : data.length); i2 += 1) {
          const record = data[i2];
          temp.push(...flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey.value, i2));
        }
        return temp;
      }
      return data === null || data === void 0 ? void 0 : data.map((item, index2) => {
        return {
          record: item,
          indent: 0,
          index: index2
        };
      });
    });
    return arr;
  }
  const ResizeContextKey = Symbol("ResizeContextProps");
  const useProvideResize = (props2) => {
    provide(ResizeContextKey, props2);
  };
  const useInjectResize = () => {
    return inject(ResizeContextKey, {
      onColumnResize: () => {
      }
    });
  };
  const Body = /* @__PURE__ */ defineComponent({
    name: "TableBody",
    props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const resizeContext = useInjectResize();
      const tableContext = useInjectTable();
      const bodyContext = useInjectBody();
      const flattenData2 = useFlattenRecords(toRef(props2, "data"), toRef(props2, "childrenColumnName"), toRef(props2, "expandedKeys"), toRef(props2, "getRowKey"));
      const startRow = shallowRef(-1);
      const endRow = shallowRef(-1);
      let timeoutId;
      useProvideHover({
        startRow,
        endRow,
        onHover: (start2, end2) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            startRow.value = start2;
            endRow.value = end2;
          }, 100);
        }
      });
      return () => {
        var _a2;
        const {
          data,
          getRowKey,
          measureColumnWidth,
          expandedKeys,
          customRow,
          rowExpandable,
          childrenColumnName
        } = props2;
        const {
          onColumnResize
        } = resizeContext;
        const {
          prefixCls,
          getComponent: getComponent2
        } = tableContext;
        const {
          flattenColumns
        } = bodyContext;
        const WrapperComponent = getComponent2(["body", "wrapper"], "tbody");
        const trComponent = getComponent2(["body", "row"], "tr");
        const tdComponent = getComponent2(["body", "cell"], "td");
        let rows;
        if (data.length) {
          rows = flattenData2.value.map((item, idx) => {
            const {
              record,
              indent,
              index: renderIndex
            } = item;
            const key2 = getRowKey(record, idx);
            return createVNode(BodyRow, {
              "key": key2,
              "rowKey": key2,
              "record": record,
              "recordKey": key2,
              "index": idx,
              "renderIndex": renderIndex,
              "rowComponent": trComponent,
              "cellComponent": tdComponent,
              "expandedKeys": expandedKeys,
              "customRow": customRow,
              "getRowKey": getRowKey,
              "rowExpandable": rowExpandable,
              "childrenColumnName": childrenColumnName,
              "indent": indent
            }, null);
          });
        } else {
          rows = createVNode(ExpandedRow, {
            "expanded": true,
            "class": `${prefixCls}-placeholder`,
            "prefixCls": prefixCls,
            "component": trComponent,
            "cellComponent": tdComponent,
            "colSpan": flattenColumns.length,
            "isEmpty": true
          }, {
            default: () => [(_a2 = slots.emptyNode) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
          });
        }
        const columnsKey = getColumnsKey(flattenColumns);
        return createVNode(WrapperComponent, {
          "class": `${prefixCls}-tbody`
        }, {
          default: () => [measureColumnWidth && createVNode("tr", {
            "aria-hidden": "true",
            "class": `${prefixCls}-measure-row`,
            "style": {
              height: 0,
              fontSize: 0
            }
          }, [columnsKey.map((columnKey) => createVNode(MeasureCell, {
            "key": columnKey,
            "columnKey": columnKey,
            "onColumnResize": onColumnResize
          }, null))]), rows]
        });
      };
    }
  });
  const EXPAND_COLUMN = {};
  var __rest$5 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function flatColumns(columns) {
    return columns.reduce((list2, column2) => {
      const {
        fixed
      } = column2;
      const parsedFixed = fixed === true ? "left" : fixed;
      const subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        return [...list2, ...flatColumns(subColumns).map((subColum) => _extends$1({
          fixed: parsedFixed
        }, subColum))];
      }
      return [...list2, _extends$1(_extends$1({}, column2), {
        fixed: parsedFixed
      })];
    }, []);
  }
  function revertForRtl(columns) {
    return columns.map((column2) => {
      const {
        fixed
      } = column2, restProps = __rest$5(column2, ["fixed"]);
      let parsedFixed = fixed;
      if (fixed === "left") {
        parsedFixed = "right";
      } else if (fixed === "right") {
        parsedFixed = "left";
      }
      return _extends$1({
        fixed: parsedFixed
      }, restProps);
    });
  }
  function useColumns$1(_ref, transformColumns) {
    let {
      prefixCls,
      columns: baseColumns,
      // children,
      expandable,
      expandedKeys,
      getRowKey,
      onTriggerExpand,
      expandIcon,
      rowExpandable,
      expandIconColumnIndex,
      direction,
      expandRowByClick,
      expandColumnWidth,
      expandFixed
    } = _ref;
    const contextSlots = useInjectSlots();
    const withExpandColumns = computed(() => {
      if (expandable.value) {
        let cloneColumns = baseColumns.value.slice();
        if (!cloneColumns.includes(EXPAND_COLUMN)) {
          const expandColIndex = expandIconColumnIndex.value || 0;
          if (expandColIndex >= 0) {
            cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
          }
        }
        const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
        cloneColumns = cloneColumns.filter((column2, index2) => column2 !== EXPAND_COLUMN || index2 === expandColumnIndex);
        const prevColumn = baseColumns.value[expandColumnIndex];
        let fixedColumn;
        if ((expandFixed.value === "left" || expandFixed.value) && !expandIconColumnIndex.value) {
          fixedColumn = "left";
        } else if ((expandFixed.value === "right" || expandFixed.value) && expandIconColumnIndex.value === baseColumns.value.length) {
          fixedColumn = "right";
        } else {
          fixedColumn = prevColumn ? prevColumn.fixed : null;
        }
        const expandedKeysValue = expandedKeys.value;
        const rowExpandableValue = rowExpandable.value;
        const expandIconValue = expandIcon.value;
        const prefixClsValue = prefixCls.value;
        const expandRowByClickValue = expandRowByClick.value;
        const expandColumn = {
          [INTERNAL_COL_DEFINE]: {
            class: `${prefixCls.value}-expand-icon-col`,
            columnType: "EXPAND_COLUMN"
          },
          title: customRenderSlot(contextSlots.value, "expandColumnTitle", {}, () => [""]),
          fixed: fixedColumn,
          class: `${prefixCls.value}-row-expand-icon-cell`,
          width: expandColumnWidth.value,
          customRender: (_ref2) => {
            let {
              record,
              index: index2
            } = _ref2;
            const rowKey = getRowKey.value(record, index2);
            const expanded = expandedKeysValue.has(rowKey);
            const recordExpandable = rowExpandableValue ? rowExpandableValue(record) : true;
            const icon = expandIconValue({
              prefixCls: prefixClsValue,
              expanded,
              expandable: recordExpandable,
              record,
              onExpand: onTriggerExpand
            });
            if (expandRowByClickValue) {
              return createVNode("span", {
                "onClick": (e2) => e2.stopPropagation()
              }, [icon]);
            }
            return icon;
          }
        };
        return cloneColumns.map((col) => col === EXPAND_COLUMN ? expandColumn : col);
      }
      return baseColumns.value.filter((col) => col !== EXPAND_COLUMN);
    });
    const mergedColumns = computed(() => {
      let finalColumns = withExpandColumns.value;
      if (transformColumns.value) {
        finalColumns = transformColumns.value(finalColumns);
      }
      if (!finalColumns.length) {
        finalColumns = [{
          customRender: () => null
        }];
      }
      return finalColumns;
    });
    const flattenColumns = computed(() => {
      if (direction.value === "rtl") {
        return revertForRtl(flatColumns(mergedColumns.value));
      }
      return flatColumns(mergedColumns.value);
    });
    return [mergedColumns, flattenColumns];
  }
  function useLayoutState(defaultState) {
    const stateRef = shallowRef(defaultState);
    let rafId;
    const updateBatchRef = shallowRef([]);
    function setFrameState(updater) {
      updateBatchRef.value.push(updater);
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(() => {
        const prevBatch = updateBatchRef.value;
        updateBatchRef.value = [];
        prevBatch.forEach((batchUpdater) => {
          stateRef.value = batchUpdater(stateRef.value);
        });
      });
    }
    onBeforeUnmount(() => {
      wrapperRaf.cancel(rafId);
    });
    return [stateRef, setFrameState];
  }
  function useTimeoutLock(defaultState) {
    const frameRef = ref(null);
    const timeoutRef = ref();
    function cleanUp() {
      clearTimeout(timeoutRef.value);
    }
    function setState(newState) {
      frameRef.value = newState;
      cleanUp();
      timeoutRef.value = setTimeout(() => {
        frameRef.value = null;
        timeoutRef.value = void 0;
      }, 100);
    }
    function getState() {
      return frameRef.value;
    }
    onBeforeUnmount(() => {
      cleanUp();
    });
    return [setState, getState];
  }
  function useStickyOffsets(colWidthsRef, columnCountRef, directionRef) {
    const stickyOffsets = computed(() => {
      const leftOffsets = [];
      const rightOffsets = [];
      let left = 0;
      let right = 0;
      const colWidths = colWidthsRef.value;
      const columnCount = columnCountRef.value;
      const direction = directionRef.value;
      for (let start2 = 0; start2 < columnCount; start2 += 1) {
        if (direction === "rtl") {
          rightOffsets[start2] = right;
          right += colWidths[start2] || 0;
          const end2 = columnCount - start2 - 1;
          leftOffsets[end2] = left;
          left += colWidths[end2] || 0;
        } else {
          leftOffsets[start2] = left;
          left += colWidths[start2] || 0;
          const end2 = columnCount - start2 - 1;
          rightOffsets[end2] = right;
          right += colWidths[end2] || 0;
        }
      }
      return {
        left: leftOffsets,
        right: rightOffsets
      };
    });
    return stickyOffsets;
  }
  var __rest$4 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function ColGroup(_ref) {
    let {
      colWidths,
      columns,
      columCount
    } = _ref;
    const cols = [];
    const len2 = columCount || columns.length;
    let mustInsert = false;
    for (let i2 = len2 - 1; i2 >= 0; i2 -= 1) {
      const width = colWidths[i2];
      const column2 = columns && columns[i2];
      const additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
      if (width || additionalProps || mustInsert) {
        const _a2 = additionalProps || {}, {
          columnType
        } = _a2, restAdditionalProps = __rest$4(_a2, ["columnType"]);
        cols.unshift(createVNode("col", _objectSpread2$1({
          "key": i2,
          "style": {
            width: typeof width === "number" ? `${width}px` : width
          }
        }, restAdditionalProps), null));
        mustInsert = true;
      }
    }
    return createVNode("colgroup", null, [cols]);
  }
  function Panel(_2, _ref) {
    let {
      slots
    } = _ref;
    var _a2;
    return createVNode("div", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
  }
  Panel.displayName = "Panel";
  let indexGuid = 0;
  const Summary = /* @__PURE__ */ defineComponent({
    name: "TableSummary",
    props: ["fixed"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const tableContext = useInjectTable();
      const uniKey = `table-summary-uni-key-${++indexGuid}`;
      const fixed = computed(() => props2.fixed === "" || props2.fixed);
      watchEffect(() => {
        tableContext.summaryCollect(uniKey, fixed.value);
      });
      onBeforeUnmount(() => {
        tableContext.summaryCollect(uniKey, false);
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const SummaryRow = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATableSummaryRow",
    setup(_props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return createVNode("tr", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
      };
    }
  });
  const SummaryContextKey = Symbol("SummaryContextProps");
  const useProvideSummary = (props2) => {
    provide(SummaryContextKey, props2);
  };
  const useInjectSummary = () => {
    return inject(SummaryContextKey, {});
  };
  const SummaryCell = /* @__PURE__ */ defineComponent({
    name: "ATableSummaryCell",
    props: ["index", "colSpan", "rowSpan", "align"],
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const tableContext = useInjectTable();
      const summaryContext = useInjectSummary();
      return () => {
        const {
          index: index2,
          colSpan = 1,
          rowSpan,
          align
        } = props2;
        const {
          prefixCls,
          direction
        } = tableContext;
        const {
          scrollColumnIndex,
          stickyOffsets,
          flattenColumns
        } = summaryContext;
        const lastIndex = index2 + colSpan - 1;
        const mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
        const fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
        return createVNode(Cell, _objectSpread2$1({
          "class": attrs.class,
          "index": index2,
          "component": "td",
          "prefixCls": prefixCls,
          "record": null,
          "dataIndex": null,
          "align": align,
          "colSpan": mergedColSpan,
          "rowSpan": rowSpan,
          "customRender": () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
          }
        }, fixedInfo), null);
      };
    }
  });
  const Footer = /* @__PURE__ */ defineComponent({
    name: "TableFooter",
    inheritAttrs: false,
    props: ["stickyOffsets", "flattenColumns"],
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const tableContext = useInjectTable();
      useProvideSummary(reactive({
        stickyOffsets: toRef(props2, "stickyOffsets"),
        flattenColumns: toRef(props2, "flattenColumns"),
        scrollColumnIndex: computed(() => {
          const lastColumnIndex = props2.flattenColumns.length - 1;
          const scrollColumn = props2.flattenColumns[lastColumnIndex];
          return (scrollColumn === null || scrollColumn === void 0 ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null;
        })
      }));
      return () => {
        var _a2;
        const {
          prefixCls
        } = tableContext;
        return createVNode("tfoot", {
          "class": `${prefixCls}-summary`
        }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
      };
    }
  });
  const FooterComponents = Summary;
  function renderExpandIcon$1(_ref) {
    let {
      prefixCls,
      record,
      onExpand,
      expanded,
      expandable
    } = _ref;
    const expandClassName = `${prefixCls}-row-expand-icon`;
    if (!expandable) {
      return createVNode("span", {
        "class": [expandClassName, `${prefixCls}-row-spaced`]
      }, null);
    }
    const onClick = (event) => {
      onExpand(record, event);
      event.stopPropagation();
    };
    return createVNode("span", {
      "class": {
        [expandClassName]: true,
        [`${prefixCls}-row-expanded`]: expanded,
        [`${prefixCls}-row-collapsed`]: !expanded
      },
      "onClick": onClick
    }, null);
  }
  function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
    const keys2 = [];
    function dig(list2) {
      (list2 || []).forEach((item, index2) => {
        keys2.push(getRowKey(item, index2));
        dig(item[childrenColumnName]);
      });
    }
    dig(data);
    return keys2;
  }
  const StickyScrollBar = /* @__PURE__ */ defineComponent({
    name: "StickyScrollBar",
    inheritAttrs: false,
    props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
    emits: ["scroll"],
    setup(props2, _ref) {
      let {
        emit: emit2,
        expose
      } = _ref;
      const tableContext = useInjectTable();
      const bodyScrollWidth = shallowRef(0);
      const bodyWidth = shallowRef(0);
      const scrollBarWidth = shallowRef(0);
      watchEffect(() => {
        bodyScrollWidth.value = props2.scrollBodySizeInfo.scrollWidth || 0;
        bodyWidth.value = props2.scrollBodySizeInfo.clientWidth || 0;
        scrollBarWidth.value = bodyScrollWidth.value && bodyWidth.value * (bodyWidth.value / bodyScrollWidth.value);
      }, {
        flush: "post"
      });
      const scrollBarRef = shallowRef();
      const [scrollState, setScrollState] = useLayoutState({
        scrollLeft: 0,
        isHiddenScrollBar: true
      });
      const refState = ref({
        delta: 0,
        x: 0
      });
      const isActive = shallowRef(false);
      const onMouseUp = () => {
        isActive.value = false;
      };
      const onMouseDown = (event) => {
        refState.value = {
          delta: event.pageX - scrollState.value.scrollLeft,
          x: 0
        };
        isActive.value = true;
        event.preventDefault();
      };
      const onMouseMove = (event) => {
        const {
          buttons
        } = event || (window === null || window === void 0 ? void 0 : window.event);
        if (!isActive.value || buttons === 0) {
          if (isActive.value) {
            isActive.value = false;
          }
          return;
        }
        let left = refState.value.x + event.pageX - refState.value.x - refState.value.delta;
        if (left <= 0) {
          left = 0;
        }
        if (left + scrollBarWidth.value >= bodyWidth.value) {
          left = bodyWidth.value - scrollBarWidth.value;
        }
        emit2("scroll", {
          scrollLeft: left / bodyWidth.value * (bodyScrollWidth.value + 2)
        });
        refState.value.x = event.pageX;
      };
      const onContainerScroll = () => {
        if (!props2.scrollBodyRef.value) {
          return;
        }
        const tableOffsetTop = getOffset$1(props2.scrollBodyRef.value).top;
        const tableBottomOffset = tableOffsetTop + props2.scrollBodyRef.value.offsetHeight;
        const currentClientOffset = props2.container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset$1(props2.container).top + props2.container.clientHeight;
        if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - props2.offsetScroll) {
          setScrollState((state) => _extends$1(_extends$1({}, state), {
            isHiddenScrollBar: true
          }));
        } else {
          setScrollState((state) => _extends$1(_extends$1({}, state), {
            isHiddenScrollBar: false
          }));
        }
      };
      const setScrollLeft = (left) => {
        setScrollState((state) => {
          return _extends$1(_extends$1({}, state), {
            scrollLeft: left / bodyScrollWidth.value * bodyWidth.value || 0
          });
        });
      };
      expose({
        setScrollLeft
      });
      let onMouseUpListener = null;
      let onMouseMoveListener = null;
      let onResizeListener = null;
      let onScrollListener = null;
      onMounted(() => {
        onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
        onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
        onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
      });
      onActivated(() => {
        nextTick(() => {
          onContainerScroll();
        });
      });
      onMounted(() => {
        setTimeout(() => {
          watch([scrollBarWidth, isActive], () => {
            onContainerScroll();
          }, {
            immediate: true,
            flush: "post"
          });
        });
      });
      watch(() => props2.container, () => {
        onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
        onScrollListener = addEventListenerWrap(props2.container, "scroll", onContainerScroll, false);
      }, {
        immediate: true,
        flush: "post"
      });
      onBeforeUnmount(() => {
        onMouseUpListener === null || onMouseUpListener === void 0 ? void 0 : onMouseUpListener.remove();
        onMouseMoveListener === null || onMouseMoveListener === void 0 ? void 0 : onMouseMoveListener.remove();
        onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
        onResizeListener === null || onResizeListener === void 0 ? void 0 : onResizeListener.remove();
      });
      watch(() => _extends$1({}, scrollState.value), (newState, preState) => {
        if (newState.isHiddenScrollBar !== (preState === null || preState === void 0 ? void 0 : preState.isHiddenScrollBar) && !newState.isHiddenScrollBar) {
          setScrollState((state) => {
            const bodyNode = props2.scrollBodyRef.value;
            if (!bodyNode) {
              return state;
            }
            return _extends$1(_extends$1({}, state), {
              scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
            });
          });
        }
      }, {
        immediate: true
      });
      const scrollbarSize = getScrollBarSize();
      return () => {
        if (bodyScrollWidth.value <= bodyWidth.value || !scrollBarWidth.value || scrollState.value.isHiddenScrollBar) {
          return null;
        }
        const {
          prefixCls
        } = tableContext;
        return createVNode("div", {
          "style": {
            height: `${scrollbarSize}px`,
            width: `${bodyWidth.value}px`,
            bottom: `${props2.offsetScroll}px`
          },
          "class": `${prefixCls}-sticky-scroll`
        }, [createVNode("div", {
          "onMousedown": onMouseDown,
          "ref": scrollBarRef,
          "class": classNames(`${prefixCls}-sticky-scroll-bar`, {
            [`${prefixCls}-sticky-scroll-bar-active`]: isActive.value
          }),
          "style": {
            width: `${scrollBarWidth.value}px`,
            transform: `translate3d(${scrollState.value.scrollLeft}px, 0, 0)`
          }
        }, null)]);
      };
    }
  });
  const defaultContainer = canUseDom$1() ? window : null;
  function useSticky(stickyRef, prefixClsRef) {
    return computed(() => {
      const {
        offsetHeader = 0,
        offsetSummary = 0,
        offsetScroll = 0,
        getContainer: getContainer2 = () => defaultContainer
      } = typeof stickyRef.value === "object" ? stickyRef.value : {};
      const container = getContainer2() || defaultContainer;
      const isSticky = !!stickyRef.value;
      return {
        isSticky,
        stickyClassName: isSticky ? `${prefixClsRef.value}-sticky-holder` : "",
        offsetHeader,
        offsetSummary,
        offsetScroll,
        container
      };
    });
  }
  function useColumnWidth(colWidthsRef, columCountRef) {
    return computed(() => {
      const cloneColumns = [];
      const colWidths = colWidthsRef.value;
      const columCount = columCountRef.value;
      for (let i2 = 0; i2 < columCount; i2 += 1) {
        const val = colWidths[i2];
        if (val !== void 0) {
          cloneColumns[i2] = val;
        } else {
          return null;
        }
      }
      return cloneColumns;
    });
  }
  const FixedHolder = /* @__PURE__ */ defineComponent({
    name: "FixedHolder",
    inheritAttrs: false,
    props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
    emits: ["scroll"],
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const tableContext = useInjectTable();
      const combinationScrollBarSize = computed(() => tableContext.isSticky && !props2.fixHeader ? 0 : tableContext.scrollbarSize);
      const scrollRef = ref();
      const onWheel = (e2) => {
        const {
          currentTarget,
          deltaX
        } = e2;
        if (deltaX) {
          emit2("scroll", {
            currentTarget,
            scrollLeft: currentTarget.scrollLeft + deltaX
          });
          e2.preventDefault();
        }
      };
      const wheelEvent = ref();
      onMounted(() => {
        nextTick(() => {
          wheelEvent.value = addEventListenerWrap(scrollRef.value, "wheel", onWheel);
        });
      });
      onBeforeUnmount(() => {
        var _a2;
        (_a2 = wheelEvent.value) === null || _a2 === void 0 ? void 0 : _a2.remove();
      });
      const allFlattenColumnsWithWidth = computed(() => props2.flattenColumns.every((column2) => column2.width && column2.width !== 0 && column2.width !== "0px"));
      const columnsWithScrollbar = ref([]);
      const flattenColumnsWithScrollbar = ref([]);
      watchEffect(() => {
        const lastColumn = props2.flattenColumns[props2.flattenColumns.length - 1];
        const ScrollBarColumn = {
          fixed: lastColumn ? lastColumn.fixed : null,
          scrollbar: true,
          customHeaderCell: () => ({
            class: `${tableContext.prefixCls}-cell-scrollbar`
          })
        };
        columnsWithScrollbar.value = combinationScrollBarSize.value ? [...props2.columns, ScrollBarColumn] : props2.columns;
        flattenColumnsWithScrollbar.value = combinationScrollBarSize.value ? [...props2.flattenColumns, ScrollBarColumn] : props2.flattenColumns;
      });
      const headerStickyOffsets = computed(() => {
        const {
          stickyOffsets,
          direction
        } = props2;
        const {
          right,
          left
        } = stickyOffsets;
        return _extends$1(_extends$1({}, stickyOffsets), {
          left: direction === "rtl" ? [...left.map((width) => width + combinationScrollBarSize.value), 0] : left,
          right: direction === "rtl" ? right : [...right.map((width) => width + combinationScrollBarSize.value), 0],
          isSticky: tableContext.isSticky
        });
      });
      const mergedColumnWidth = useColumnWidth(toRef(props2, "colWidths"), toRef(props2, "columCount"));
      return () => {
        var _a2;
        const {
          noData,
          columCount,
          stickyTopOffset,
          stickyBottomOffset,
          stickyClassName,
          maxContentScroll
        } = props2;
        const {
          isSticky
        } = tableContext;
        return createVNode("div", {
          "style": _extends$1({
            overflow: "hidden"
          }, isSticky ? {
            top: `${stickyTopOffset}px`,
            bottom: `${stickyBottomOffset}px`
          } : {}),
          "ref": scrollRef,
          "class": classNames(attrs.class, {
            [stickyClassName]: !!stickyClassName
          })
        }, [createVNode("table", {
          "style": {
            tableLayout: "fixed",
            visibility: noData || mergedColumnWidth.value ? null : "hidden"
          }
        }, [(!noData || !maxContentScroll || allFlattenColumnsWithWidth.value) && createVNode(ColGroup, {
          "colWidths": mergedColumnWidth.value ? [...mergedColumnWidth.value, combinationScrollBarSize.value] : [],
          "columCount": columCount + 1,
          "columns": flattenColumnsWithScrollbar.value
        }, null), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, _extends$1(_extends$1({}, props2), {
          stickyOffsets: headerStickyOffsets.value,
          columns: columnsWithScrollbar.value,
          flattenColumns: flattenColumnsWithScrollbar.value
        }))])]);
      };
    }
  });
  function reactivePick(obj2) {
    for (var _len = arguments.length, keys2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      keys2[_key - 1] = arguments[_key];
    }
    return reactive(fromPairs(keys2.map((k2) => [k2, toRef(obj2, k2)])));
  }
  const EMPTY_DATA = [];
  const EMPTY_SCROLL_TARGET = {};
  const INTERNAL_HOOKS = "rc-table-internal-hook";
  const Table$2 = /* @__PURE__ */ defineComponent({
    name: "VcTable",
    inheritAttrs: false,
    props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
    emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        emit: emit2
      } = _ref;
      const mergedData = computed(() => props2.data || EMPTY_DATA);
      const hasData = computed(() => !!mergedData.value.length);
      const mergedComponents = computed(() => mergeObject(props2.components, {}));
      const getComponent2 = (path, defaultComponent) => getPathValue(mergedComponents.value, path) || defaultComponent;
      const getRowKey = computed(() => {
        const rowKey = props2.rowKey;
        if (typeof rowKey === "function") {
          return rowKey;
        }
        return (record) => {
          const key2 = record && record[rowKey];
          return key2;
        };
      });
      const mergedExpandIcon = computed(() => props2.expandIcon || renderExpandIcon$1);
      const mergedChildrenColumnName = computed(() => props2.childrenColumnName || "children");
      const expandableType = computed(() => {
        if (props2.expandedRowRender) {
          return "row";
        }
        if (props2.canExpandable || mergedData.value.some((record) => record && typeof record === "object" && record[mergedChildrenColumnName.value])) {
          return "nest";
        }
        return false;
      });
      const innerExpandedKeys = shallowRef([]);
      const stop2 = watchEffect(() => {
        if (props2.defaultExpandedRowKeys) {
          innerExpandedKeys.value = props2.defaultExpandedRowKeys;
        }
        if (props2.defaultExpandAllRows) {
          innerExpandedKeys.value = findAllChildrenKeys(mergedData.value, getRowKey.value, mergedChildrenColumnName.value);
        }
      });
      stop2();
      const mergedExpandedKeys = computed(() => new Set(props2.expandedRowKeys || innerExpandedKeys.value || []));
      const onTriggerExpand = (record) => {
        const key2 = getRowKey.value(record, mergedData.value.indexOf(record));
        let newExpandedKeys;
        const hasKey = mergedExpandedKeys.value.has(key2);
        if (hasKey) {
          mergedExpandedKeys.value.delete(key2);
          newExpandedKeys = [...mergedExpandedKeys.value];
        } else {
          newExpandedKeys = [...mergedExpandedKeys.value, key2];
        }
        innerExpandedKeys.value = newExpandedKeys;
        emit2("expand", !hasKey, record);
        emit2("update:expandedRowKeys", newExpandedKeys);
        emit2("expandedRowsChange", newExpandedKeys);
      };
      const componentWidth = ref(0);
      const [columns, flattenColumns] = useColumns$1(_extends$1(_extends$1({}, toRefs(props2)), {
        // children,
        expandable: computed(() => !!props2.expandedRowRender),
        expandedKeys: mergedExpandedKeys,
        getRowKey,
        onTriggerExpand,
        expandIcon: mergedExpandIcon
      }), computed(() => props2.internalHooks === INTERNAL_HOOKS ? props2.transformColumns : null));
      const columnContext = computed(() => ({
        columns: columns.value,
        flattenColumns: flattenColumns.value
      }));
      const fullTableRef = ref();
      const scrollHeaderRef = ref();
      const scrollBodyRef = ref();
      const scrollBodySizeInfo = ref({
        scrollWidth: 0,
        clientWidth: 0
      });
      const scrollSummaryRef = ref();
      const [pingedLeft, setPingedLeft] = useState(false);
      const [pingedRight, setPingedRight] = useState(false);
      const [colsWidths, updateColsWidths] = useLayoutState(/* @__PURE__ */ new Map());
      const colsKeys = computed(() => getColumnsKey(flattenColumns.value));
      const colWidths = computed(() => colsKeys.value.map((columnKey) => colsWidths.value.get(columnKey)));
      const columnCount = computed(() => flattenColumns.value.length);
      const stickyOffsets = useStickyOffsets(colWidths, columnCount, toRef(props2, "direction"));
      const fixHeader = computed(() => props2.scroll && validateValue(props2.scroll.y));
      const horizonScroll = computed(() => props2.scroll && validateValue(props2.scroll.x) || Boolean(props2.expandFixed));
      const fixColumn = computed(() => horizonScroll.value && flattenColumns.value.some((_ref2) => {
        let {
          fixed
        } = _ref2;
        return fixed;
      }));
      const stickyRef = ref();
      const stickyState = useSticky(toRef(props2, "sticky"), toRef(props2, "prefixCls"));
      const summaryFixedInfos = reactive({});
      const fixFooter = computed(() => {
        const info = Object.values(summaryFixedInfos)[0];
        return (fixHeader.value || stickyState.value.isSticky) && info;
      });
      const summaryCollect = (uniKey, fixed) => {
        if (fixed) {
          summaryFixedInfos[uniKey] = fixed;
        } else {
          delete summaryFixedInfos[uniKey];
        }
      };
      const scrollXStyle = ref({});
      const scrollYStyle = ref({});
      const scrollTableStyle = ref({});
      watchEffect(() => {
        if (fixHeader.value) {
          scrollYStyle.value = {
            overflowY: "scroll",
            maxHeight: toPx(props2.scroll.y)
          };
        }
        if (horizonScroll.value) {
          scrollXStyle.value = {
            overflowX: "auto"
          };
          if (!fixHeader.value) {
            scrollYStyle.value = {
              overflowY: "hidden"
            };
          }
          scrollTableStyle.value = {
            width: props2.scroll.x === true ? "auto" : toPx(props2.scroll.x),
            minWidth: "100%"
          };
        }
      });
      const onColumnResize = (columnKey, width) => {
        if (isVisible(fullTableRef.value)) {
          updateColsWidths((widths) => {
            if (widths.get(columnKey) !== width) {
              const newWidths = new Map(widths);
              newWidths.set(columnKey, width);
              return newWidths;
            }
            return widths;
          });
        }
      };
      const [setScrollTarget, getScrollTarget] = useTimeoutLock();
      function forceScroll(scrollLeft, target) {
        if (!target) {
          return;
        }
        if (typeof target === "function") {
          target(scrollLeft);
          return;
        }
        const domTarget = target.$el || target;
        if (domTarget.scrollLeft !== scrollLeft) {
          domTarget.scrollLeft = scrollLeft;
        }
      }
      const onScroll = (_ref3) => {
        let {
          currentTarget,
          scrollLeft
        } = _ref3;
        var _a2;
        const isRTL = props2.direction === "rtl";
        const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
        const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
        if (!getScrollTarget() || getScrollTarget() === compareTarget) {
          setScrollTarget(compareTarget);
          forceScroll(mergedScrollLeft, scrollHeaderRef.value);
          forceScroll(mergedScrollLeft, scrollBodyRef.value);
          forceScroll(mergedScrollLeft, scrollSummaryRef.value);
          forceScroll(mergedScrollLeft, (_a2 = stickyRef.value) === null || _a2 === void 0 ? void 0 : _a2.setScrollLeft);
        }
        if (currentTarget) {
          const {
            scrollWidth,
            clientWidth
          } = currentTarget;
          if (isRTL) {
            setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
            setPingedRight(-mergedScrollLeft > 0);
          } else {
            setPingedLeft(mergedScrollLeft > 0);
            setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
          }
        }
      };
      const triggerOnScroll = () => {
        if (horizonScroll.value && scrollBodyRef.value) {
          onScroll({
            currentTarget: scrollBodyRef.value
          });
        } else {
          setPingedLeft(false);
          setPingedRight(false);
        }
      };
      let timtout;
      const updateWidth = (width) => {
        if (width !== componentWidth.value) {
          triggerOnScroll();
          componentWidth.value = fullTableRef.value ? fullTableRef.value.offsetWidth : width;
        }
      };
      const onFullTableResize = (_ref4) => {
        let {
          width
        } = _ref4;
        clearTimeout(timtout);
        if (componentWidth.value === 0) {
          updateWidth(width);
          return;
        }
        timtout = setTimeout(() => {
          updateWidth(width);
        }, 100);
      };
      watch([horizonScroll, () => props2.data, () => props2.columns], () => {
        if (horizonScroll.value) {
          triggerOnScroll();
        }
      }, {
        flush: "post"
      });
      const [scrollbarSize, setScrollbarSize] = useState(0);
      useProvideSticky();
      onMounted(() => {
        nextTick(() => {
          var _a2, _b2;
          triggerOnScroll();
          setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.value).width);
          scrollBodySizeInfo.value = {
            scrollWidth: ((_a2 = scrollBodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollWidth) || 0,
            clientWidth: ((_b2 = scrollBodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.clientWidth) || 0
          };
        });
      });
      onUpdated(() => {
        nextTick(() => {
          var _a2, _b2;
          const scrollWidth = ((_a2 = scrollBodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollWidth) || 0;
          const clientWidth = ((_b2 = scrollBodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.clientWidth) || 0;
          if (scrollBodySizeInfo.value.scrollWidth !== scrollWidth || scrollBodySizeInfo.value.clientWidth !== clientWidth) {
            scrollBodySizeInfo.value = {
              scrollWidth,
              clientWidth
            };
          }
        });
      });
      watchEffect(() => {
        if (props2.internalHooks === INTERNAL_HOOKS && props2.internalRefs) {
          props2.onUpdateInternalRefs({
            body: scrollBodyRef.value ? scrollBodyRef.value.$el || scrollBodyRef.value : null
          });
        }
      }, {
        flush: "post"
      });
      const mergedTableLayout = computed(() => {
        if (props2.tableLayout) {
          return props2.tableLayout;
        }
        if (fixColumn.value) {
          return props2.scroll.x === "max-content" ? "auto" : "fixed";
        }
        if (fixHeader.value || stickyState.value.isSticky || flattenColumns.value.some((_ref5) => {
          let {
            ellipsis
          } = _ref5;
          return ellipsis;
        })) {
          return "fixed";
        }
        return "auto";
      });
      const emptyNode = () => {
        var _a2;
        return hasData.value ? null : ((_a2 = slots.emptyText) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || "No Data";
      };
      useProvideTable(reactive(_extends$1(_extends$1({}, toRefs(reactivePick(props2, "prefixCls", "direction", "transformCellText"))), {
        getComponent: getComponent2,
        scrollbarSize,
        fixedInfoList: computed(() => flattenColumns.value.map((_2, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns.value, stickyOffsets.value, props2.direction))),
        isSticky: computed(() => stickyState.value.isSticky),
        summaryCollect
      })));
      useProvideBody(reactive(_extends$1(_extends$1({}, toRefs(reactivePick(props2, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {
        columns,
        flattenColumns,
        tableLayout: mergedTableLayout,
        expandIcon: mergedExpandIcon,
        expandableType,
        onTriggerExpand
      })));
      useProvideResize({
        onColumnResize
      });
      useProvideExpandedRow({
        componentWidth,
        fixHeader,
        fixColumn,
        horizonScroll
      });
      const bodyTable = () => createVNode(Body, {
        "data": mergedData.value,
        "measureColumnWidth": fixHeader.value || horizonScroll.value || stickyState.value.isSticky,
        "expandedKeys": mergedExpandedKeys.value,
        "rowExpandable": props2.rowExpandable,
        "getRowKey": getRowKey.value,
        "customRow": props2.customRow,
        "childrenColumnName": mergedChildrenColumnName.value
      }, {
        emptyNode
      });
      const bodyColGroup = () => createVNode(ColGroup, {
        "colWidths": flattenColumns.value.map((_ref6) => {
          let {
            width
          } = _ref6;
          return width;
        }),
        "columns": flattenColumns.value
      }, null);
      return () => {
        var _a2;
        const {
          prefixCls,
          scroll,
          tableLayout,
          direction,
          // Additional Part
          title = slots.title,
          footer = slots.footer,
          // Customize
          id,
          showHeader,
          customHeaderRow
        } = props2;
        const {
          isSticky,
          offsetHeader,
          offsetSummary,
          offsetScroll,
          stickyClassName,
          container
        } = stickyState.value;
        const TableComponent = getComponent2(["table"], "table");
        const customizeScrollBody = getComponent2(["body"]);
        const summaryNode = (_a2 = slots.summary) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
          pageData: mergedData.value
        });
        let groupTableNode = () => null;
        const headerProps = {
          colWidths: colWidths.value,
          columCount: flattenColumns.value.length,
          stickyOffsets: stickyOffsets.value,
          customHeaderRow,
          fixHeader: fixHeader.value,
          scroll
        };
        if (fixHeader.value || isSticky) {
          let bodyContent = () => null;
          if (typeof customizeScrollBody === "function") {
            bodyContent = () => customizeScrollBody(mergedData.value, {
              scrollbarSize: scrollbarSize.value,
              ref: scrollBodyRef,
              onScroll
            });
            headerProps.colWidths = flattenColumns.value.map((_ref7, index2) => {
              let {
                width
              } = _ref7;
              const colWidth = index2 === columns.value.length - 1 ? width - scrollbarSize.value : width;
              if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
                return colWidth;
              }
              return 0;
            });
          } else {
            bodyContent = () => createVNode("div", {
              "style": _extends$1(_extends$1({}, scrollXStyle.value), scrollYStyle.value),
              "onScroll": onScroll,
              "ref": scrollBodyRef,
              "class": classNames(`${prefixCls}-body`)
            }, [createVNode(TableComponent, {
              "style": _extends$1(_extends$1({}, scrollTableStyle.value), {
                tableLayout: mergedTableLayout.value
              })
            }, {
              default: () => [bodyColGroup(), bodyTable(), !fixFooter.value && summaryNode && createVNode(Footer, {
                "stickyOffsets": stickyOffsets.value,
                "flattenColumns": flattenColumns.value
              }, {
                default: () => [summaryNode]
              })]
            })]);
          }
          const fixedHolderProps = _extends$1(_extends$1(_extends$1({
            noData: !mergedData.value.length,
            maxContentScroll: horizonScroll.value && scroll.x === "max-content"
          }, headerProps), columnContext.value), {
            direction,
            stickyClassName,
            onScroll
          });
          groupTableNode = () => createVNode(Fragment, null, [showHeader !== false && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyTopOffset": offsetHeader,
            "class": `${prefixCls}-header`,
            "ref": scrollHeaderRef
          }), {
            default: (fixedHolderPassProps) => createVNode(Fragment, null, [createVNode(Header, fixedHolderPassProps, null), fixFooter.value === "top" && createVNode(Footer, fixedHolderPassProps, {
              default: () => [summaryNode]
            })])
          }), bodyContent(), fixFooter.value && fixFooter.value !== "top" && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyBottomOffset": offsetSummary,
            "class": `${prefixCls}-summary`,
            "ref": scrollSummaryRef
          }), {
            default: (fixedHolderPassProps) => createVNode(Footer, fixedHolderPassProps, {
              default: () => [summaryNode]
            })
          }), isSticky && scrollBodyRef.value && createVNode(StickyScrollBar, {
            "ref": stickyRef,
            "offsetScroll": offsetScroll,
            "scrollBodyRef": scrollBodyRef,
            "onScroll": onScroll,
            "container": container,
            "scrollBodySizeInfo": scrollBodySizeInfo.value
          }, null)]);
        } else {
          groupTableNode = () => createVNode("div", {
            "style": _extends$1(_extends$1({}, scrollXStyle.value), scrollYStyle.value),
            "class": classNames(`${prefixCls}-content`),
            "onScroll": onScroll,
            "ref": scrollBodyRef
          }, [createVNode(TableComponent, {
            "style": _extends$1(_extends$1({}, scrollTableStyle.value), {
              tableLayout: mergedTableLayout.value
            })
          }, {
            default: () => [bodyColGroup(), showHeader !== false && createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, headerProps), columnContext.value), null), bodyTable(), summaryNode && createVNode(Footer, {
              "stickyOffsets": stickyOffsets.value,
              "flattenColumns": flattenColumns.value
            }, {
              default: () => [summaryNode]
            })]
          })]);
        }
        const ariaProps = pickAttrs(attrs, {
          aria: true,
          data: true
        });
        const fullTable = () => createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ariaProps), {}, {
          "class": classNames(prefixCls, {
            [`${prefixCls}-rtl`]: direction === "rtl",
            [`${prefixCls}-ping-left`]: pingedLeft.value,
            [`${prefixCls}-ping-right`]: pingedRight.value,
            [`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
            [`${prefixCls}-fixed-header`]: fixHeader.value,
            /** No used but for compatible */
            [`${prefixCls}-fixed-column`]: fixColumn.value,
            [`${prefixCls}-scroll-horizontal`]: horizonScroll.value,
            [`${prefixCls}-has-fix-left`]: flattenColumns.value[0] && flattenColumns.value[0].fixed,
            [`${prefixCls}-has-fix-right`]: flattenColumns.value[columnCount.value - 1] && flattenColumns.value[columnCount.value - 1].fixed === "right",
            [attrs.class]: attrs.class
          }),
          "style": attrs.style,
          "id": id,
          "ref": fullTableRef
        }), [title && createVNode(Panel, {
          "class": `${prefixCls}-title`
        }, {
          default: () => [title(mergedData.value)]
        }), createVNode("div", {
          "class": `${prefixCls}-container`
        }, [groupTableNode()]), footer && createVNode(Panel, {
          "class": `${prefixCls}-footer`
        }, {
          default: () => [footer(mergedData.value)]
        })]);
        if (horizonScroll.value) {
          return createVNode(ResizeObserver$1, {
            "onResize": onFullTableResize
          }, {
            default: fullTable
          });
        }
        return fullTable();
      };
    }
  });
  function extendsObject() {
    const result = _extends$1({}, arguments.length <= 0 ? void 0 : arguments[0]);
    for (let i2 = 1; i2 < arguments.length; i2++) {
      const obj2 = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
      if (obj2) {
        Object.keys(obj2).forEach((key2) => {
          const val = obj2[key2];
          if (val !== void 0) {
            result[key2] = val;
          }
        });
      }
    }
    return result;
  }
  const DEFAULT_PAGE_SIZE = 10;
  function getPaginationParam(mergedPagination, pagination) {
    const param = {
      current: mergedPagination.current,
      pageSize: mergedPagination.pageSize
    };
    const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
    Object.keys(paginationObj).forEach((pageProp) => {
      const value = mergedPagination[pageProp];
      if (typeof value !== "function") {
        param[pageProp] = value;
      }
    });
    return param;
  }
  function usePagination(totalRef, paginationRef, onChange) {
    const pagination = computed(() => paginationRef.value && typeof paginationRef.value === "object" ? paginationRef.value : {});
    const paginationTotal = computed(() => pagination.value.total || 0);
    const [innerPagination, setInnerPagination] = useState(() => ({
      current: "defaultCurrent" in pagination.value ? pagination.value.defaultCurrent : 1,
      pageSize: "defaultPageSize" in pagination.value ? pagination.value.defaultPageSize : DEFAULT_PAGE_SIZE
    }));
    const mergedPagination = computed(() => {
      const mP = extendsObject(innerPagination.value, pagination.value, {
        total: paginationTotal.value > 0 ? paginationTotal.value : totalRef.value
      });
      const maxPage = Math.ceil((paginationTotal.value || totalRef.value) / mP.pageSize);
      if (mP.current > maxPage) {
        mP.current = maxPage || 1;
      }
      return mP;
    });
    const refreshPagination = (current, pageSize) => {
      if (paginationRef.value === false) return;
      setInnerPagination({
        current: current !== null && current !== void 0 ? current : 1,
        pageSize: pageSize || mergedPagination.value.pageSize
      });
    };
    const onInternalChange = (current, pageSize) => {
      var _a2, _b2;
      if (paginationRef.value) {
        (_b2 = (_a2 = pagination.value).onChange) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, current, pageSize);
      }
      refreshPagination(current, pageSize);
      onChange(current, pageSize || mergedPagination.value.pageSize);
    };
    return [computed(() => {
      return paginationRef.value === false ? {} : _extends$1(_extends$1({}, mergedPagination.value), {
        onChange: onInternalChange
      });
    }), refreshPagination];
  }
  function useLazyKVMap(dataRef, childrenColumnNameRef, getRowKeyRef) {
    const mapCacheRef = shallowRef({});
    watch([dataRef, childrenColumnNameRef, getRowKeyRef], () => {
      const kvMap = /* @__PURE__ */ new Map();
      const getRowKey = getRowKeyRef.value;
      const childrenColumnName = childrenColumnNameRef.value;
      function dig(records) {
        records.forEach((record, index2) => {
          const rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record);
          if (record && typeof record === "object" && childrenColumnName in record) {
            dig(record[childrenColumnName] || []);
          }
        });
      }
      dig(dataRef.value);
      mapCacheRef.value = {
        kvMap
      };
    }, {
      deep: true,
      immediate: true
    });
    function getRecordByKey(key2) {
      return mapCacheRef.value.kvMap.get(key2);
    }
    return [getRecordByKey];
  }
  const SELECTION_COLUMN = {};
  const SELECTION_ALL = "SELECT_ALL";
  const SELECTION_INVERT = "SELECT_INVERT";
  const SELECTION_NONE = "SELECT_NONE";
  const EMPTY_LIST$1 = [];
  function flattenData(childrenColumnName, data) {
    let list2 = [];
    (data || []).forEach((record) => {
      list2.push(record);
      if (record && typeof record === "object" && childrenColumnName in record) {
        list2 = [...list2, ...flattenData(childrenColumnName, record[childrenColumnName])];
      }
    });
    return list2;
  }
  function useSelection(rowSelectionRef, configRef) {
    const mergedRowSelection = computed(() => {
      const temp = rowSelectionRef.value || {};
      const {
        checkStrictly = true
      } = temp;
      return _extends$1(_extends$1({}, temp), {
        checkStrictly
      });
    });
    const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(mergedRowSelection.value.selectedRowKeys || mergedRowSelection.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
      value: computed(() => mergedRowSelection.value.selectedRowKeys)
    });
    const preserveRecordsRef = shallowRef(/* @__PURE__ */ new Map());
    const updatePreserveRecordsCache = (keys2) => {
      if (mergedRowSelection.value.preserveSelectedRowKeys) {
        const newCache = /* @__PURE__ */ new Map();
        keys2.forEach((key2) => {
          let record = configRef.getRecordByKey(key2);
          if (!record && preserveRecordsRef.value.has(key2)) {
            record = preserveRecordsRef.value.get(key2);
          }
          newCache.set(key2, record);
        });
        preserveRecordsRef.value = newCache;
      }
    };
    watchEffect(() => {
      updatePreserveRecordsCache(mergedSelectedKeys.value);
    });
    const keyEntities = computed(() => mergedRowSelection.value.checkStrictly ? null : convertDataToEntities(configRef.data.value, {
      externalGetKey: configRef.getRowKey.value,
      childrenPropName: configRef.childrenColumnName.value
    }).keyEntities);
    const flattedData = computed(() => flattenData(configRef.childrenColumnName.value, configRef.pageData.value));
    const checkboxPropsMap = computed(() => {
      const map2 = /* @__PURE__ */ new Map();
      const getRowKey = configRef.getRowKey.value;
      const getCheckboxProps = mergedRowSelection.value.getCheckboxProps;
      flattedData.value.forEach((record, index2) => {
        const key2 = getRowKey(record, index2);
        const checkboxProps2 = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
        map2.set(key2, checkboxProps2);
      });
      return map2;
    });
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(keyEntities);
    const isCheckboxDisabled = (r2) => {
      var _a2;
      return !!((_a2 = checkboxPropsMap.value.get(configRef.getRowKey.value(r2))) === null || _a2 === void 0 ? void 0 : _a2.disabled);
    };
    const selectKeysState = computed(() => {
      if (mergedRowSelection.value.checkStrictly) {
        return [mergedSelectedKeys.value || [], []];
      }
      const {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(mergedSelectedKeys.value, true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
      return [checkedKeys || [], halfCheckedKeys];
    });
    const derivedSelectedKeys = computed(() => selectKeysState.value[0]);
    const derivedHalfSelectedKeys = computed(() => selectKeysState.value[1]);
    const derivedSelectedKeySet = computed(() => {
      const keys2 = mergedRowSelection.value.type === "radio" ? derivedSelectedKeys.value.slice(0, 1) : derivedSelectedKeys.value;
      return new Set(keys2);
    });
    const derivedHalfSelectedKeySet = computed(() => mergedRowSelection.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys.value));
    const [lastSelectedKey, setLastSelectedKey] = useState(null);
    const setSelectedKeys = (keys2) => {
      let availableKeys;
      let records;
      updatePreserveRecordsCache(keys2);
      const {
        preserveSelectedRowKeys,
        onChange: onSelectionChange
      } = mergedRowSelection.value;
      const {
        getRecordByKey
      } = configRef;
      if (preserveSelectedRowKeys) {
        availableKeys = keys2;
        records = keys2.map((key2) => preserveRecordsRef.value.get(key2));
      } else {
        availableKeys = [];
        records = [];
        keys2.forEach((key2) => {
          const record = getRecordByKey(key2);
          if (record !== void 0) {
            availableKeys.push(key2);
            records.push(record);
          }
        });
      }
      setMergedSelectedKeys(availableKeys);
      onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records);
    };
    const triggerSingleSelection = (key2, selected, keys2, event) => {
      const {
        onSelect
      } = mergedRowSelection.value;
      const {
        getRecordByKey
      } = configRef || {};
      if (onSelect) {
        const rows = keys2.map((k2) => getRecordByKey(k2));
        onSelect(getRecordByKey(key2), selected, rows, event);
      }
      setSelectedKeys(keys2);
    };
    const mergedSelections = computed(() => {
      const {
        onSelectInvert,
        onSelectNone,
        selections,
        hideSelectAll
      } = mergedRowSelection.value;
      const {
        data,
        pageData,
        getRowKey,
        locale: tableLocale
      } = configRef;
      if (!selections || hideSelectAll) {
        return null;
      }
      const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
      return selectionList.map((selection) => {
        if (selection === SELECTION_ALL) {
          return {
            key: "all",
            text: tableLocale.value.selectionAll,
            onSelect() {
              setSelectedKeys(data.value.map((record, index2) => getRowKey.value(record, index2)).filter((key2) => {
                const checkProps = checkboxPropsMap.value.get(key2);
                return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.value.has(key2);
              }));
            }
          };
        }
        if (selection === SELECTION_INVERT) {
          return {
            key: "invert",
            text: tableLocale.value.selectInvert,
            onSelect() {
              const keySet = new Set(derivedSelectedKeySet.value);
              pageData.value.forEach((record, index2) => {
                const key2 = getRowKey.value(record, index2);
                const checkProps = checkboxPropsMap.value.get(key2);
                if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                  if (keySet.has(key2)) {
                    keySet.delete(key2);
                  } else {
                    keySet.add(key2);
                  }
                }
              });
              const keys2 = Array.from(keySet);
              if (onSelectInvert) {
                devWarning(false, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead.");
                onSelectInvert(keys2);
              }
              setSelectedKeys(keys2);
            }
          };
        }
        if (selection === SELECTION_NONE) {
          return {
            key: "none",
            text: tableLocale.value.selectNone,
            onSelect() {
              onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
              setSelectedKeys(Array.from(derivedSelectedKeySet.value).filter((key2) => {
                const checkProps = checkboxPropsMap.value.get(key2);
                return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
              }));
            }
          };
        }
        return selection;
      });
    });
    const flattedDataLength = computed(() => flattedData.value.length);
    const transformColumns = (columns) => {
      var _a2;
      const {
        onSelectAll,
        onSelectMultiple,
        columnWidth: selectionColWidth,
        type: selectionType,
        fixed,
        renderCell: customizeRenderCell,
        hideSelectAll,
        checkStrictly
      } = mergedRowSelection.value;
      const {
        prefixCls,
        getRecordByKey,
        getRowKey,
        expandType,
        getPopupContainer
      } = configRef;
      if (!rowSelectionRef.value) {
        return columns.filter((col) => col !== SELECTION_COLUMN);
      }
      let cloneColumns = columns.slice();
      const keySet = new Set(derivedSelectedKeySet.value);
      const recordKeys = flattedData.value.map(getRowKey.value).filter((key2) => !checkboxPropsMap.value.get(key2).disabled);
      const checkedCurrentAll = recordKeys.every((key2) => keySet.has(key2));
      const checkedCurrentSome = recordKeys.some((key2) => keySet.has(key2));
      const onSelectAllChange = () => {
        const changeKeys = [];
        if (checkedCurrentAll) {
          recordKeys.forEach((key2) => {
            keySet.delete(key2);
            changeKeys.push(key2);
          });
        } else {
          recordKeys.forEach((key2) => {
            if (!keySet.has(key2)) {
              keySet.add(key2);
              changeKeys.push(key2);
            }
          });
        }
        const keys2 = Array.from(keySet);
        onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k2) => getRecordByKey(k2)), changeKeys.map((k2) => getRecordByKey(k2)));
        setSelectedKeys(keys2);
      };
      let title;
      if (selectionType !== "radio") {
        let customizeSelections;
        if (mergedSelections.value) {
          const menu = createVNode(Menu, {
            "getPopupContainer": getPopupContainer.value
          }, {
            default: () => [mergedSelections.value.map((selection, index2) => {
              const {
                key: key2,
                text,
                onSelect: onSelectionClick
              } = selection;
              return createVNode(Menu.Item, {
                "key": key2 || index2,
                "onClick": () => {
                  onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                }
              }, {
                default: () => [text]
              });
            })]
          });
          customizeSelections = createVNode("div", {
            "class": `${prefixCls.value}-selection-extra`
          }, [createVNode(Dropdown, {
            "overlay": menu,
            "getPopupContainer": getPopupContainer.value
          }, {
            default: () => [createVNode("span", null, [createVNode(DownOutlined, null, null)])]
          })]);
        }
        const allDisabledData = flattedData.value.map((record, index2) => {
          const key2 = getRowKey.value(record, index2);
          const checkboxProps2 = checkboxPropsMap.value.get(key2) || {};
          return _extends$1({
            checked: keySet.has(key2)
          }, checkboxProps2);
        }).filter((_ref) => {
          let {
            disabled
          } = _ref;
          return disabled;
        });
        const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedDataLength.value;
        const allDisabledAndChecked = allDisabled && allDisabledData.every((_ref2) => {
          let {
            checked
          } = _ref2;
          return checked;
        });
        const allDisabledSomeChecked = allDisabled && allDisabledData.some((_ref3) => {
          let {
            checked
          } = _ref3;
          return checked;
        });
        title = !hideSelectAll && createVNode("div", {
          "class": `${prefixCls.value}-selection`
        }, [createVNode(Checkbox, {
          "checked": !allDisabled ? !!flattedDataLength.value && checkedCurrentAll : allDisabledAndChecked,
          "indeterminate": !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
          "onChange": onSelectAllChange,
          "disabled": flattedDataLength.value === 0 || allDisabled,
          "aria-label": customizeSelections ? "Custom selection" : "Select all",
          "skipGroup": true
        }, null), customizeSelections]);
      }
      let renderCell;
      if (selectionType === "radio") {
        renderCell = (_ref4) => {
          let {
            record,
            index: index2
          } = _ref4;
          const key2 = getRowKey.value(record, index2);
          const checked = keySet.has(key2);
          return {
            node: createVNode(Radio, _objectSpread2$1(_objectSpread2$1({}, checkboxPropsMap.value.get(key2)), {}, {
              "checked": checked,
              "onClick": (e2) => e2.stopPropagation(),
              "onChange": (event) => {
                if (!keySet.has(key2)) {
                  triggerSingleSelection(key2, true, [key2], event.nativeEvent);
                }
              }
            }), null),
            checked
          };
        };
      } else {
        renderCell = (_ref5) => {
          let {
            record,
            index: index2
          } = _ref5;
          var _a22;
          const key2 = getRowKey.value(record, index2);
          const checked = keySet.has(key2);
          const indeterminate = derivedHalfSelectedKeySet.value.has(key2);
          const checkboxProps2 = checkboxPropsMap.value.get(key2);
          let mergedIndeterminate;
          if (expandType.value === "nest") {
            mergedIndeterminate = indeterminate;
            devWarning(typeof (checkboxProps2 === null || checkboxProps2 === void 0 ? void 0 : checkboxProps2.indeterminate) !== "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
          } else {
            mergedIndeterminate = (_a22 = checkboxProps2 === null || checkboxProps2 === void 0 ? void 0 : checkboxProps2.indeterminate) !== null && _a22 !== void 0 ? _a22 : indeterminate;
          }
          return {
            node: createVNode(Checkbox, _objectSpread2$1(_objectSpread2$1({}, checkboxProps2), {}, {
              "indeterminate": mergedIndeterminate,
              "checked": checked,
              "skipGroup": true,
              "onClick": (e2) => e2.stopPropagation(),
              "onChange": (_ref6) => {
                let {
                  nativeEvent
                } = _ref6;
                const {
                  shiftKey
                } = nativeEvent;
                let startIndex = -1;
                let endIndex = -1;
                if (shiftKey && checkStrictly) {
                  const pointKeys = /* @__PURE__ */ new Set([lastSelectedKey.value, key2]);
                  recordKeys.some((recordKey, recordIndex) => {
                    if (pointKeys.has(recordKey)) {
                      if (startIndex === -1) {
                        startIndex = recordIndex;
                      } else {
                        endIndex = recordIndex;
                        return true;
                      }
                    }
                    return false;
                  });
                }
                if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                  const rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                  const changedKeys = [];
                  if (checked) {
                    rangeKeys.forEach((recordKey) => {
                      if (keySet.has(recordKey)) {
                        changedKeys.push(recordKey);
                        keySet.delete(recordKey);
                      }
                    });
                  } else {
                    rangeKeys.forEach((recordKey) => {
                      if (!keySet.has(recordKey)) {
                        changedKeys.push(recordKey);
                        keySet.add(recordKey);
                      }
                    });
                  }
                  const keys2 = Array.from(keySet);
                  onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                  setSelectedKeys(keys2);
                } else {
                  const originCheckedKeys = derivedSelectedKeys.value;
                  if (checkStrictly) {
                    const checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                    triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                  } else {
                    const result = conductCheck([...originCheckedKeys, key2], true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
                    const {
                      checkedKeys,
                      halfCheckedKeys
                    } = result;
                    let nextCheckedKeys = checkedKeys;
                    if (checked) {
                      const tempKeySet = new Set(checkedKeys);
                      tempKeySet.delete(key2);
                      nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                        halfCheckedKeys
                      }, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled).checkedKeys;
                    }
                    triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                  }
                }
                setLastSelectedKey(key2);
              }
            }), null),
            checked
          };
        };
      }
      const renderSelectionCell = (_ref7) => {
        let {
          record,
          index: index2
        } = _ref7;
        const {
          node: node2,
          checked
        } = renderCell({
          record,
          index: index2
        });
        if (customizeRenderCell) {
          return customizeRenderCell(checked, record, index2, node2);
        }
        return node2;
      };
      if (!cloneColumns.includes(SELECTION_COLUMN)) {
        if (cloneColumns.findIndex((col) => {
          var _a22;
          return ((_a22 = col[INTERNAL_COL_DEFINE]) === null || _a22 === void 0 ? void 0 : _a22.columnType) === "EXPAND_COLUMN";
        }) === 0) {
          const [expandColumn, ...restColumns] = cloneColumns;
          cloneColumns = [expandColumn, SELECTION_COLUMN, ...restColumns];
        } else {
          cloneColumns = [SELECTION_COLUMN, ...cloneColumns];
        }
      }
      const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
      cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
      const prevCol = cloneColumns[selectionColumnIndex - 1];
      const nextCol = cloneColumns[selectionColumnIndex + 1];
      let mergedFixed = fixed;
      if (mergedFixed === void 0) {
        if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
          mergedFixed = nextCol.fixed;
        } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
          mergedFixed = prevCol.fixed;
        }
      }
      if (mergedFixed && prevCol && ((_a2 = prevCol[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
        prevCol.fixed = mergedFixed;
      }
      const selectionColumn = {
        fixed: mergedFixed,
        width: selectionColWidth,
        className: `${prefixCls.value}-selection-column`,
        title: mergedRowSelection.value.columnTitle || title,
        customRender: renderSelectionCell,
        [INTERNAL_COL_DEFINE]: {
          class: `${prefixCls.value}-selection-col`
        }
      };
      return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
    };
    return [transformColumns, derivedSelectedKeySet];
  }
  var CaretDownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
  function _objectSpread$8(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$8(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$8(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CaretDownOutlined = function CaretDownOutlined2(props2, context) {
    var p2 = _objectSpread$8({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$8({}, p2, {
      "icon": CaretDownOutlined$1
    }), null);
  };
  CaretDownOutlined.displayName = "CaretDownOutlined";
  CaretDownOutlined.inheritAttrs = false;
  var CaretUpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
  function _objectSpread$7(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$7(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$7(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CaretUpOutlined = function CaretUpOutlined2(props2, context) {
    var p2 = _objectSpread$7({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$7({}, p2, {
      "icon": CaretUpOutlined$1
    }), null);
  };
  CaretUpOutlined.displayName = "CaretUpOutlined";
  CaretUpOutlined.inheritAttrs = false;
  var __rest$3 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  function getColumnKey(column2, defaultKey) {
    if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
      return column2.key;
    }
    if (column2.dataIndex) {
      return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
    }
    return defaultKey;
  }
  function getColumnPos(index2, pos) {
    return pos ? `${pos}-${index2}` : `${index2}`;
  }
  function renderColumnTitle(title, props2) {
    if (typeof title === "function") {
      return title(props2);
    }
    return title;
  }
  function convertChildrenToColumns() {
    let elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const flattenElements = flattenChildren(elements);
    const columns = [];
    flattenElements.forEach((element) => {
      var _a2, _b2, _c2, _d;
      if (!element) {
        return;
      }
      const key2 = element.key;
      const style = ((_a2 = element.props) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
      const cls = ((_b2 = element.props) === null || _b2 === void 0 ? void 0 : _b2.class) || "";
      const props2 = element.props || {};
      for (const [k2, v2] of Object.entries(props2)) {
        props2[camelize(k2)] = v2;
      }
      const _e = element.children || {}, {
        default: children
      } = _e, restSlots = __rest$3(_e, ["default"]);
      const column2 = _extends$1(_extends$1(_extends$1({}, restSlots), props2), {
        style,
        class: cls
      });
      if (key2) {
        column2.key = key2;
      }
      if ((_c2 = element.type) === null || _c2 === void 0 ? void 0 : _c2.__ANT_TABLE_COLUMN_GROUP) {
        column2.children = convertChildrenToColumns(typeof children === "function" ? children() : children);
      } else {
        const customRender = (_d = element.children) === null || _d === void 0 ? void 0 : _d.default;
        column2.customRender = column2.customRender || customRender;
      }
      columns.push(column2);
    });
    return columns;
  }
  const ASCEND = "ascend";
  const DESCEND = "descend";
  function getMultiplePriority(column2) {
    if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
      return column2.sorter.multiple;
    }
    return false;
  }
  function getSortFunction(sorter) {
    if (typeof sorter === "function") {
      return sorter;
    }
    if (sorter && typeof sorter === "object" && sorter.compare) {
      return sorter.compare;
    }
    return false;
  }
  function nextSortDirection(sortDirections, current) {
    if (!current) {
      return sortDirections[0];
    }
    return sortDirections[sortDirections.indexOf(current) + 1];
  }
  function collectSortStates(columns, init2, pos) {
    let sortStates = [];
    function pushState(column2, columnPos) {
      sortStates.push({
        column: column2,
        key: getColumnKey(column2, columnPos),
        multiplePriority: getMultiplePriority(column2),
        sortOrder: column2.sortOrder
      });
    }
    (columns || []).forEach((column2, index2) => {
      const columnPos = getColumnPos(index2, pos);
      if (column2.children) {
        if ("sortOrder" in column2) {
          pushState(column2, columnPos);
        }
        sortStates = [...sortStates, ...collectSortStates(column2.children, init2, columnPos)];
      } else if (column2.sorter) {
        if ("sortOrder" in column2) {
          pushState(column2, columnPos);
        } else if (init2 && column2.defaultSortOrder) {
          sortStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            multiplePriority: getMultiplePriority(column2),
            sortOrder: column2.defaultSortOrder
          });
        }
      }
    });
    return sortStates;
  }
  function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
    return (columns || []).map((column2, index2) => {
      const columnPos = getColumnPos(index2, pos);
      let newColumn = column2;
      if (newColumn.sorter) {
        const sortDirections = newColumn.sortDirections || defaultSortDirections;
        const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
        const columnKey = getColumnKey(newColumn, columnPos);
        const sorterState = sorterStates.find((_ref) => {
          let {
            key: key2
          } = _ref;
          return key2 === columnKey;
        });
        const sorterOrder = sorterState ? sorterState.sortOrder : null;
        const nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
        const upNode = sortDirections.includes(ASCEND) && createVNode(CaretUpOutlined, {
          "class": classNames(`${prefixCls}-column-sorter-up`, {
            active: sorterOrder === ASCEND
          }),
          "role": "presentation"
        }, null);
        const downNode = sortDirections.includes(DESCEND) && createVNode(CaretDownOutlined, {
          "role": "presentation",
          "class": classNames(`${prefixCls}-column-sorter-down`, {
            active: sorterOrder === DESCEND
          })
        }, null);
        const {
          cancelSort,
          triggerAsc,
          triggerDesc
        } = tableLocale || {};
        let sortTip = cancelSort;
        if (nextSortOrder === DESCEND) {
          sortTip = triggerDesc;
        } else if (nextSortOrder === ASCEND) {
          sortTip = triggerAsc;
        }
        const tooltipProps2 = typeof showSorterTooltip === "object" ? showSorterTooltip : {
          title: sortTip
        };
        newColumn = _extends$1(_extends$1({}, newColumn), {
          className: classNames(newColumn.className, {
            [`${prefixCls}-column-sort`]: sorterOrder
          }),
          title: (renderProps) => {
            const renderSortTitle = createVNode("div", {
              "class": `${prefixCls}-column-sorters`
            }, [createVNode("span", {
              "class": `${prefixCls}-column-title`
            }, [renderColumnTitle(column2.title, renderProps)]), createVNode("span", {
              "class": classNames(`${prefixCls}-column-sorter`, {
                [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
              })
            }, [createVNode("span", {
              "class": `${prefixCls}-column-sorter-inner`
            }, [upNode, downNode])])]);
            return showSorterTooltip ? createVNode(Tooltip, tooltipProps2, {
              default: () => [renderSortTitle]
            }) : renderSortTitle;
          },
          customHeaderCell: (col) => {
            const cell = column2.customHeaderCell && column2.customHeaderCell(col) || {};
            const originOnClick = cell.onClick;
            const originOKeyDown = cell.onKeydown;
            cell.onClick = (event) => {
              triggerSorter({
                column: column2,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column2)
              });
              if (originOnClick) {
                originOnClick(event);
              }
            };
            cell.onKeydown = (event) => {
              if (event.keyCode === KeyCode.ENTER) {
                triggerSorter({
                  column: column2,
                  key: columnKey,
                  sortOrder: nextSortOrder,
                  multiplePriority: getMultiplePriority(column2)
                });
                originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
              }
            };
            if (sorterOrder) {
              cell["aria-sort"] = sorterOrder === "ascend" ? "ascending" : "descending";
            }
            cell.class = classNames(cell.class, `${prefixCls}-column-has-sorters`);
            cell.tabindex = 0;
            return cell;
          }
        });
      }
      if ("children" in newColumn) {
        newColumn = _extends$1(_extends$1({}, newColumn), {
          children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
        });
      }
      return newColumn;
    });
  }
  function stateToInfo(sorterStates) {
    const {
      column: column2,
      sortOrder
    } = sorterStates;
    return {
      column: column2,
      order: sortOrder,
      field: column2.dataIndex,
      columnKey: column2.key
    };
  }
  function generateSorterInfo(sorterStates) {
    const list2 = sorterStates.filter((_ref2) => {
      let {
        sortOrder
      } = _ref2;
      return sortOrder;
    }).map(stateToInfo);
    if (list2.length === 0 && sorterStates.length) {
      return _extends$1(_extends$1({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
        column: void 0
      });
    }
    if (list2.length <= 1) {
      return list2[0] || {};
    }
    return list2;
  }
  function getSortData(data, sortStates, childrenColumnName) {
    const innerSorterStates = sortStates.slice().sort((a2, b2) => b2.multiplePriority - a2.multiplePriority);
    const cloneData = data.slice();
    const runningSorters = innerSorterStates.filter((_ref3) => {
      let {
        column: {
          sorter
        },
        sortOrder
      } = _ref3;
      return getSortFunction(sorter) && sortOrder;
    });
    if (!runningSorters.length) {
      return cloneData;
    }
    return cloneData.sort((record1, record2) => {
      for (let i2 = 0; i2 < runningSorters.length; i2 += 1) {
        const sorterState = runningSorters[i2];
        const {
          column: {
            sorter
          },
          sortOrder
        } = sorterState;
        const compareFn = getSortFunction(sorter);
        if (compareFn && sortOrder) {
          const compareResult = compareFn(record1, record2, sortOrder);
          if (compareResult !== 0) {
            return sortOrder === ASCEND ? compareResult : -compareResult;
          }
        }
      }
      return 0;
    }).map((record) => {
      const subRecords = record[childrenColumnName];
      if (subRecords) {
        return _extends$1(_extends$1({}, record), {
          [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
        });
      }
      return record;
    });
  }
  function useFilterSorter(_ref4) {
    let {
      prefixCls,
      mergedColumns,
      onSorterChange,
      sortDirections,
      tableLocale,
      showSorterTooltip
    } = _ref4;
    const [sortStates, setSortStates] = useState(collectSortStates(mergedColumns.value, true));
    const mergedSorterStates = computed(() => {
      let validate = true;
      const collectedStates = collectSortStates(mergedColumns.value, false);
      if (!collectedStates.length) {
        return sortStates.value;
      }
      const validateStates = [];
      function patchStates(state) {
        if (validate) {
          validateStates.push(state);
        } else {
          validateStates.push(_extends$1(_extends$1({}, state), {
            sortOrder: null
          }));
        }
      }
      let multipleMode = null;
      collectedStates.forEach((state) => {
        if (multipleMode === null) {
          patchStates(state);
          if (state.sortOrder) {
            if (state.multiplePriority === false) {
              validate = false;
            } else {
              multipleMode = true;
            }
          }
        } else if (multipleMode && state.multiplePriority !== false) {
          patchStates(state);
        } else {
          validate = false;
          patchStates(state);
        }
      });
      return validateStates;
    });
    const columnTitleSorterProps = computed(() => {
      const sortColumns = mergedSorterStates.value.map((_ref5) => {
        let {
          column: column2,
          sortOrder
        } = _ref5;
        return {
          column: column2,
          order: sortOrder
        };
      });
      return {
        sortColumns,
        // Legacy
        sortColumn: sortColumns[0] && sortColumns[0].column,
        sortOrder: sortColumns[0] && sortColumns[0].order
      };
    });
    function triggerSorter(sortState) {
      let newSorterStates;
      if (sortState.multiplePriority === false || !mergedSorterStates.value.length || mergedSorterStates.value[0].multiplePriority === false) {
        newSorterStates = [sortState];
      } else {
        newSorterStates = [...mergedSorterStates.value.filter((_ref6) => {
          let {
            key: key2
          } = _ref6;
          return key2 !== sortState.key;
        }), sortState];
      }
      setSortStates(newSorterStates);
      onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
    }
    const transformColumns = (innerColumns) => injectSorter(prefixCls.value, innerColumns, mergedSorterStates.value, triggerSorter, sortDirections.value, tableLocale.value, showSorterTooltip.value);
    const sorters = computed(() => generateSorterInfo(mergedSorterStates.value));
    return [transformColumns, mergedSorterStates, columnTitleSorterProps, sorters];
  }
  var FilterFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
  function _objectSpread$6(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$6(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$6(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var FilterFilled = function FilterFilled2(props2, context) {
    var p2 = _objectSpread$6({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$6({}, p2, {
      "icon": FilterFilled$1
    }), null);
  };
  FilterFilled.displayName = "FilterFilled";
  FilterFilled.inheritAttrs = false;
  const onKeyDown = (event) => {
    const {
      keyCode
    } = event;
    if (keyCode === KeyCode.ENTER) {
      event.stopPropagation();
    }
  };
  const FilterDropdownMenuWrapper = (_props, _ref) => {
    let {
      slots
    } = _ref;
    var _a2;
    return createVNode("div", {
      "onClick": (e2) => e2.stopPropagation(),
      "onKeydown": onKeyDown
    }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
  };
  const FilterSearch = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "FilterSearch",
    inheritAttrs: false,
    props: {
      value: stringType(),
      onChange: functionType(),
      filterSearch: someType([Boolean, Function]),
      tablePrefixCls: stringType(),
      locale: objectType()
    },
    setup(props2) {
      return () => {
        const {
          value,
          onChange,
          filterSearch,
          tablePrefixCls,
          locale: locale2
        } = props2;
        if (!filterSearch) {
          return null;
        }
        return createVNode("div", {
          "class": `${tablePrefixCls}-filter-dropdown-search`
        }, [createVNode(Input, {
          "placeholder": locale2.filterSearchPlaceholder,
          "onChange": onChange,
          "value": value,
          "htmlSize": 1,
          "class": `${tablePrefixCls}-filter-dropdown-search-input`
        }, {
          prefix: () => createVNode(SearchOutlined, null, null)
        })]);
      };
    }
  });
  var __rest$2 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const MotionTreeNode = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "MotionTreeNode",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, treeNodeProps), {
      active: Boolean,
      motion: Object,
      motionNodes: {
        type: Array
      },
      onMotionStart: Function,
      onMotionEnd: Function,
      motionType: String
    }),
    setup(props2, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const visible = shallowRef(true);
      const context = useInjectTreeContext();
      const motionedRef = shallowRef(false);
      const transitionProps = computed(() => {
        if (props2.motion) {
          return props2.motion;
        } else {
          return collapseMotion();
        }
      });
      const onMotionEnd = (node2, type) => {
        var _a2, _b2, _c2, _d;
        if (type === "appear") {
          (_b2 = (_a2 = transitionProps.value) === null || _a2 === void 0 ? void 0 : _a2.onAfterEnter) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, node2);
        } else if (type === "leave") {
          (_d = (_c2 = transitionProps.value) === null || _c2 === void 0 ? void 0 : _c2.onAfterLeave) === null || _d === void 0 ? void 0 : _d.call(_c2, node2);
        }
        if (!motionedRef.value) {
          props2.onMotionEnd();
        }
        motionedRef.value = true;
      };
      watch(() => props2.motionNodes, () => {
        if (props2.motionNodes && props2.motionType === "hide" && visible.value) {
          nextTick(() => {
            visible.value = false;
          });
        }
      }, {
        immediate: true,
        flush: "post"
      });
      onMounted(() => {
        props2.motionNodes && props2.onMotionStart();
      });
      onBeforeUnmount(() => {
        props2.motionNodes && onMotionEnd();
      });
      return () => {
        const {
          motion,
          motionNodes,
          motionType,
          active,
          eventKey
        } = props2, otherProps = __rest$2(props2, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
        if (motionNodes) {
          return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps.value), {}, {
            "appear": motionType === "show",
            "onAfterAppear": (node2) => onMotionEnd(node2, "appear"),
            "onAfterLeave": (node2) => onMotionEnd(node2, "leave")
          }), {
            default: () => [withDirectives(createVNode("div", {
              "class": `${context.value.prefixCls}-treenode-motion`
            }, [motionNodes.map((treeNode) => {
              const restProps = __rest$2(treeNode.data, []), {
                title,
                key: key2,
                isStart,
                isEnd
              } = treeNode;
              delete restProps.children;
              return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
                "title": title,
                "active": active,
                "data": treeNode.data,
                "key": key2,
                "eventKey": key2,
                "isStart": isStart,
                "isEnd": isEnd
              }), slots);
            })]), [[vShow, visible.value]])]
          });
        }
        return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
          "class": attrs.class,
          "style": attrs.style
        }, otherProps), {}, {
          "active": active,
          "eventKey": eventKey
        }), slots);
      };
    }
  });
  function findExpandedKeys() {
    let prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const prevLen = prev2.length;
    const nextLen = next2.length;
    if (Math.abs(prevLen - nextLen) !== 1) {
      return {
        add: false,
        key: null
      };
    }
    function find2(shorter, longer) {
      const cache2 = /* @__PURE__ */ new Map();
      shorter.forEach((key2) => {
        cache2.set(key2, true);
      });
      const keys2 = longer.filter((key2) => !cache2.has(key2));
      return keys2.length === 1 ? keys2[0] : null;
    }
    if (prevLen < nextLen) {
      return {
        add: true,
        key: find2(prev2, next2)
      };
    }
    return {
      add: false,
      key: find2(next2, prev2)
    };
  }
  function getExpandRange(shorter, longer, key2) {
    const shorterStartIndex = shorter.findIndex((item) => item.key === key2);
    const shorterEndNode = shorter[shorterStartIndex + 1];
    const longerStartIndex = longer.findIndex((item) => item.key === key2);
    if (shorterEndNode) {
      const longerEndIndex = longer.findIndex((item) => item.key === shorterEndNode.key);
      return longer.slice(longerStartIndex + 1, longerEndIndex);
    }
    return longer.slice(longerStartIndex + 1);
  }
  var __rest$1 = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const HIDDEN_STYLE = {
    width: 0,
    height: 0,
    display: "flex",
    overflow: "hidden",
    opacity: 0,
    border: 0,
    padding: 0,
    margin: 0
  };
  const noop$2 = () => {
  };
  const MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
  const MotionNode = {
    key: MOTION_KEY
  };
  const MotionEntity = {
    key: MOTION_KEY,
    level: 0,
    index: 0,
    pos: "0",
    node: MotionNode,
    nodes: [MotionNode]
  };
  const MotionFlattenData = {
    parent: null,
    children: [],
    pos: MotionEntity.pos,
    data: MotionNode,
    title: null,
    key: MOTION_KEY,
    /** Hold empty list here since we do not use it */
    isStart: [],
    isEnd: []
  };
  function getMinimumRangeTransitionRange(list2, virtual, height, itemHeight) {
    if (virtual === false || !height) {
      return list2;
    }
    return list2.slice(0, Math.ceil(height / itemHeight) + 1);
  }
  function itemKey(item) {
    const {
      key: key2,
      pos
    } = item;
    return getKey$1(key2, pos);
  }
  function getAccessibilityPath(item) {
    let path = String(item.key);
    let current = item;
    while (current.parent) {
      current = current.parent;
      path = `${current.key} > ${path}`;
    }
    return path;
  }
  const NodeList = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "NodeList",
    inheritAttrs: false,
    props: nodeListProps,
    setup(props2, _ref) {
      let {
        expose,
        attrs
      } = _ref;
      const listRef = ref();
      const indentMeasurerRef = ref();
      const {
        expandedKeys,
        flattenNodes
      } = useInjectKeysState();
      expose({
        scrollTo: (scroll) => {
          listRef.value.scrollTo(scroll);
        },
        getIndentWidth: () => indentMeasurerRef.value.offsetWidth
      });
      const transitionData = shallowRef(flattenNodes.value);
      const transitionRange = shallowRef([]);
      const motionType = ref(null);
      function onMotionEnd() {
        transitionData.value = flattenNodes.value;
        transitionRange.value = [];
        motionType.value = null;
        props2.onListChangeEnd();
      }
      const context = useInjectTreeContext();
      watch([() => expandedKeys.value.slice(), flattenNodes], (_ref2, _ref3) => {
        let [expandedKeys2, data] = _ref2;
        let [prevExpandedKeys, prevData] = _ref3;
        const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys2);
        if (diffExpanded.key !== null) {
          const {
            virtual,
            height,
            itemHeight
          } = props2;
          if (diffExpanded.add) {
            const keyIndex2 = prevData.findIndex((_ref4) => {
              let {
                key: key2
              } = _ref4;
              return key2 === diffExpanded.key;
            });
            const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
            const newTransitionData = prevData.slice();
            newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
            transitionData.value = newTransitionData;
            transitionRange.value = rangeNodes;
            motionType.value = "show";
          } else {
            const keyIndex2 = data.findIndex((_ref5) => {
              let {
                key: key2
              } = _ref5;
              return key2 === diffExpanded.key;
            });
            const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
            const newTransitionData = data.slice();
            newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
            transitionData.value = newTransitionData;
            transitionRange.value = rangeNodes;
            motionType.value = "hide";
          }
        } else if (prevData !== data) {
          transitionData.value = data;
        }
      });
      watch(() => context.value.dragging, (dragging) => {
        if (!dragging) {
          onMotionEnd();
        }
      });
      const mergedData = computed(() => props2.motion === void 0 ? transitionData.value : flattenNodes.value);
      const onActiveChange = () => {
        props2.onActiveChange(null);
      };
      return () => {
        const _a2 = _extends$1(_extends$1({}, props2), attrs), {
          prefixCls,
          selectable,
          checkable,
          disabled,
          motion,
          height,
          itemHeight,
          virtual,
          focusable,
          activeItem,
          focused,
          tabindex,
          onKeydown,
          onFocus,
          onBlur,
          onListChangeStart,
          onListChangeEnd
        } = _a2, domProps = __rest$1(_a2, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
        return createVNode(Fragment, null, [focused && activeItem && createVNode("span", {
          "style": HIDDEN_STYLE,
          "aria-live": "assertive"
        }, [getAccessibilityPath(activeItem)]), createVNode("div", null, [createVNode("input", {
          "style": HIDDEN_STYLE,
          "disabled": focusable === false || disabled,
          "tabindex": focusable !== false ? tabindex : null,
          "onKeydown": onKeydown,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "value": "",
          "onChange": noop$2,
          "aria-label": "for screen reader"
        }, null)]), createVNode("div", {
          "class": `${prefixCls}-treenode`,
          "aria-hidden": true,
          "style": {
            position: "absolute",
            pointerEvents: "none",
            visibility: "hidden",
            height: 0,
            overflow: "hidden"
          }
        }, [createVNode("div", {
          "class": `${prefixCls}-indent`
        }, [createVNode("div", {
          "ref": indentMeasurerRef,
          "class": `${prefixCls}-indent-unit`
        }, null)])]), createVNode(List, _objectSpread2$1(_objectSpread2$1({}, omit$1(domProps, ["onActiveChange"])), {}, {
          "data": mergedData.value,
          "itemKey": itemKey,
          "height": height,
          "fullHeight": false,
          "virtual": virtual,
          "itemHeight": itemHeight,
          "prefixCls": `${prefixCls}-list`,
          "ref": listRef,
          "onVisibleChange": (originList, fullList) => {
            const originSet = new Set(originList);
            const restList = fullList.filter((item) => !originSet.has(item));
            if (restList.some((item) => itemKey(item) === MOTION_KEY)) {
              onMotionEnd();
            }
          }
        }), {
          default: (treeNode) => {
            const {
              pos
            } = treeNode, restProps = __rest$1(treeNode.data, []), {
              title,
              key: key2,
              isStart,
              isEnd
            } = treeNode;
            const mergedKey = getKey$1(key2, pos);
            delete restProps.key;
            delete restProps.children;
            return createVNode(MotionTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
              "eventKey": mergedKey,
              "title": title,
              "active": !!activeItem && key2 === activeItem.key,
              "data": treeNode.data,
              "isStart": isStart,
              "isEnd": isEnd,
              "motion": motion,
              "motionNodes": key2 === MOTION_KEY ? transitionRange.value : null,
              "motionType": motionType.value,
              "onMotionStart": onListChangeStart,
              "onMotionEnd": onMotionEnd,
              "onMousemove": onActiveChange
            }), null);
          }
        })]);
      };
    }
  });
  function DropIndicator(_ref) {
    let {
      dropPosition,
      dropLevelOffset,
      indent
    } = _ref;
    const style = {
      pointerEvents: "none",
      position: "absolute",
      right: 0,
      backgroundColor: "red",
      height: `${2}px`
    };
    switch (dropPosition) {
      case -1:
        style.top = 0;
        style.left = `${-dropLevelOffset * indent}px`;
        break;
      case 1:
        style.bottom = 0;
        style.left = `${-dropLevelOffset * indent}px`;
        break;
      case 0:
        style.bottom = 0;
        style.left = `${indent}`;
        break;
    }
    return createVNode("div", {
      "style": style
    }, null);
  }
  const MAX_RETRY_TIMES = 10;
  const Tree$2 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Tree",
    inheritAttrs: false,
    props: initDefaultProps(treeProps$1(), {
      prefixCls: "vc-tree",
      showLine: false,
      showIcon: true,
      selectable: true,
      multiple: false,
      checkable: false,
      disabled: false,
      checkStrictly: false,
      draggable: false,
      expandAction: false,
      defaultExpandParent: true,
      autoExpandParent: false,
      defaultExpandAll: false,
      defaultExpandedKeys: [],
      defaultCheckedKeys: [],
      defaultSelectedKeys: [],
      dropIndicatorRender: DropIndicator,
      allowDrop: () => true
    }),
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        expose
      } = _ref;
      const destroyed = shallowRef(false);
      let delayedDragEnterLogic = {};
      const indent = shallowRef();
      const selectedKeys = shallowRef([]);
      const checkedKeys = shallowRef([]);
      const halfCheckedKeys = shallowRef([]);
      const loadedKeys = shallowRef([]);
      const loadingKeys = shallowRef([]);
      const expandedKeys = shallowRef([]);
      const loadingRetryTimes = {};
      const dragState = reactive({
        draggingNodeKey: null,
        dragChildrenKeys: [],
        // dropTargetKey is the key of abstract-drop-node
        // the abstract-drop-node is the real drop node when drag and drop
        // not the DOM drag over node
        dropTargetKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropLevelOffset: null,
        dropTargetPos: null,
        dropAllowed: true,
        // the abstract-drag-over-node
        // if mouse is on the bottom of top dom node or no the top of the bottom dom node
        // abstract-drag-over-node is the top node
        dragOverNodeKey: null
      });
      const treeData = shallowRef([]);
      watch([() => props2.treeData, () => props2.children], () => {
        treeData.value = props2.treeData !== void 0 ? props2.treeData.slice() : convertTreeToData(toRaw(props2.children));
      }, {
        immediate: true,
        deep: true
      });
      const keyEntities = shallowRef({});
      const focused = shallowRef(false);
      const activeKey = shallowRef(null);
      const listChanging = shallowRef(false);
      const fieldNames = computed(() => fillFieldNames(props2.fieldNames));
      const listRef = shallowRef();
      let dragStartMousePosition = null;
      let dragNode = null;
      let currentMouseOverDroppableNodeKey = null;
      const treeNodeRequiredProps = computed(() => {
        return {
          expandedKeysSet: expandedKeysSet.value,
          selectedKeysSet: selectedKeysSet.value,
          loadedKeysSet: loadedKeysSet.value,
          loadingKeysSet: loadingKeysSet.value,
          checkedKeysSet: checkedKeysSet.value,
          halfCheckedKeysSet: halfCheckedKeysSet.value,
          dragOverNodeKey: dragState.dragOverNodeKey,
          dropPosition: dragState.dropPosition,
          keyEntities: keyEntities.value
        };
      });
      const expandedKeysSet = computed(() => {
        return new Set(expandedKeys.value);
      });
      const selectedKeysSet = computed(() => {
        return new Set(selectedKeys.value);
      });
      const loadedKeysSet = computed(() => {
        return new Set(loadedKeys.value);
      });
      const loadingKeysSet = computed(() => {
        return new Set(loadingKeys.value);
      });
      const checkedKeysSet = computed(() => {
        return new Set(checkedKeys.value);
      });
      const halfCheckedKeysSet = computed(() => {
        return new Set(halfCheckedKeys.value);
      });
      watchEffect(() => {
        if (treeData.value) {
          const entitiesMap = convertDataToEntities(treeData.value, {
            fieldNames: fieldNames.value
          });
          keyEntities.value = _extends$1({
            [MOTION_KEY]: MotionEntity
          }, entitiesMap.keyEntities);
        }
      });
      let init2 = false;
      watch(
        [() => props2.expandedKeys, () => props2.autoExpandParent, keyEntities],
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (_ref2, _ref3) => {
          let [_newKeys, newAutoExpandParent] = _ref2;
          let [_oldKeys, oldAutoExpandParent] = _ref3;
          let keys2 = expandedKeys.value;
          if (props2.expandedKeys !== void 0 || init2 && newAutoExpandParent !== oldAutoExpandParent) {
            keys2 = props2.autoExpandParent || !init2 && props2.defaultExpandParent ? conductExpandParent(props2.expandedKeys, keyEntities.value) : props2.expandedKeys;
          } else if (!init2 && props2.defaultExpandAll) {
            const cloneKeyEntities = _extends$1({}, keyEntities.value);
            delete cloneKeyEntities[MOTION_KEY];
            keys2 = Object.keys(cloneKeyEntities).map((key2) => cloneKeyEntities[key2].key);
          } else if (!init2 && props2.defaultExpandedKeys) {
            keys2 = props2.autoExpandParent || props2.defaultExpandParent ? conductExpandParent(props2.defaultExpandedKeys, keyEntities.value) : props2.defaultExpandedKeys;
          }
          if (keys2) {
            expandedKeys.value = keys2;
          }
          init2 = true;
        },
        {
          immediate: true
        }
      );
      const flattenNodes = shallowRef([]);
      watchEffect(() => {
        flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);
      });
      watchEffect(() => {
        if (props2.selectable) {
          if (props2.selectedKeys !== void 0) {
            selectedKeys.value = calcSelectedKeys(props2.selectedKeys, props2);
          } else if (!init2 && props2.defaultSelectedKeys) {
            selectedKeys.value = calcSelectedKeys(props2.defaultSelectedKeys, props2);
          }
        }
      });
      const {
        maxLevel,
        levelEntities
      } = useMaxLevel(keyEntities);
      watchEffect(() => {
        if (props2.checkable) {
          let checkedKeyEntity;
          if (props2.checkedKeys !== void 0) {
            checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {};
          } else if (!init2 && props2.defaultCheckedKeys) {
            checkedKeyEntity = parseCheckedKeys(props2.defaultCheckedKeys) || {};
          } else if (treeData.value) {
            checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {
              checkedKeys: checkedKeys.value,
              halfCheckedKeys: halfCheckedKeys.value
            };
          }
          if (checkedKeyEntity) {
            let {
              checkedKeys: newCheckedKeys = [],
              halfCheckedKeys: newHalfCheckedKeys = []
            } = checkedKeyEntity;
            if (!props2.checkStrictly) {
              const conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);
              ({
                checkedKeys: newCheckedKeys,
                halfCheckedKeys: newHalfCheckedKeys
              } = conductKeys);
            }
            checkedKeys.value = newCheckedKeys;
            halfCheckedKeys.value = newHalfCheckedKeys;
          }
        }
      });
      watchEffect(() => {
        if (props2.loadedKeys) {
          loadedKeys.value = props2.loadedKeys;
        }
      });
      const resetDragState = () => {
        _extends$1(dragState, {
          dragOverNodeKey: null,
          dropPosition: null,
          dropLevelOffset: null,
          dropTargetKey: null,
          dropContainerKey: null,
          dropTargetPos: null,
          dropAllowed: false
        });
      };
      const scrollTo2 = (scroll) => {
        listRef.value.scrollTo(scroll);
      };
      watch(() => props2.activeKey, () => {
        if (props2.activeKey !== void 0) {
          activeKey.value = props2.activeKey;
        }
      }, {
        immediate: true
      });
      watch(activeKey, (val) => {
        nextTick(() => {
          if (val !== null) {
            scrollTo2({
              key: val
            });
          }
        });
      }, {
        immediate: true,
        flush: "post"
      });
      const setExpandedKeys = (keys2) => {
        if (props2.expandedKeys === void 0) {
          expandedKeys.value = keys2;
        }
      };
      const cleanDragState = () => {
        if (dragState.draggingNodeKey !== null) {
          _extends$1(dragState, {
            draggingNodeKey: null,
            dropPosition: null,
            dropContainerKey: null,
            dropTargetKey: null,
            dropLevelOffset: null,
            dropAllowed: true,
            dragOverNodeKey: null
          });
        }
        dragStartMousePosition = null;
        currentMouseOverDroppableNodeKey = null;
      };
      const onNodeDragEnd = (event, node2) => {
        const {
          onDragend
        } = props2;
        dragState.dragOverNodeKey = null;
        cleanDragState();
        onDragend === null || onDragend === void 0 ? void 0 : onDragend({
          event,
          node: node2.eventData
        });
        dragNode = null;
      };
      const onWindowDragEnd = (event) => {
        onNodeDragEnd(event, null);
        window.removeEventListener("dragend", onWindowDragEnd);
      };
      const onNodeDragStart = (event, node2) => {
        const {
          onDragstart
        } = props2;
        const {
          eventKey,
          eventData
        } = node2;
        dragNode = node2;
        dragStartMousePosition = {
          x: event.clientX,
          y: event.clientY
        };
        const newExpandedKeys = arrDel(expandedKeys.value, eventKey);
        dragState.draggingNodeKey = eventKey;
        dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);
        indent.value = listRef.value.getIndentWidth();
        setExpandedKeys(newExpandedKeys);
        window.addEventListener("dragend", onWindowDragEnd);
        if (onDragstart) {
          onDragstart({
            event,
            node: eventData
          });
        }
      };
      const onNodeDragEnter = (event, node2) => {
        const {
          onDragenter,
          onExpand,
          allowDrop,
          direction
        } = props2;
        const {
          pos,
          eventKey
        } = node2;
        if (currentMouseOverDroppableNodeKey !== eventKey) {
          currentMouseOverDroppableNodeKey = eventKey;
        }
        if (!dragNode) {
          resetDragState();
          return;
        }
        const {
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        } = calcDropPosition(event, dragNode, node2, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);
        if (
          // don't allow drop inside its children
          dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
          !dropAllowed
        ) {
          resetDragState();
          return;
        }
        if (!delayedDragEnterLogic) {
          delayedDragEnterLogic = {};
        }
        Object.keys(delayedDragEnterLogic).forEach((key2) => {
          clearTimeout(delayedDragEnterLogic[key2]);
        });
        if (dragNode.eventKey !== node2.eventKey) {
          delayedDragEnterLogic[pos] = window.setTimeout(() => {
            if (dragState.draggingNodeKey === null) return;
            let newExpandedKeys = expandedKeys.value.slice();
            const entity = keyEntities.value[node2.eventKey];
            if (entity && (entity.children || []).length) {
              newExpandedKeys = arrAdd(expandedKeys.value, node2.eventKey);
            }
            setExpandedKeys(newExpandedKeys);
            if (onExpand) {
              onExpand(newExpandedKeys, {
                node: node2.eventData,
                expanded: true,
                nativeEvent: event
              });
            }
          }, 800);
        }
        if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
          resetDragState();
          return;
        }
        _extends$1(dragState, {
          dragOverNodeKey,
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed
        });
        if (onDragenter) {
          onDragenter({
            event,
            node: node2.eventData,
            expandedKeys: expandedKeys.value
          });
        }
      };
      const onNodeDragOver = (event, node2) => {
        const {
          onDragover,
          allowDrop,
          direction
        } = props2;
        if (!dragNode) {
          return;
        }
        const {
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropAllowed,
          dropTargetPos,
          dragOverNodeKey
        } = calcDropPosition(event, dragNode, node2, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);
        if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
          return;
        }
        if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
          if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {
            resetDragState();
          }
        } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {
          _extends$1(dragState, {
            dropPosition,
            dropLevelOffset,
            dropTargetKey,
            dropContainerKey,
            dropTargetPos,
            dropAllowed,
            dragOverNodeKey
          });
        }
        if (onDragover) {
          onDragover({
            event,
            node: node2.eventData
          });
        }
      };
      const onNodeDragLeave = (event, node2) => {
        if (currentMouseOverDroppableNodeKey === node2.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
          resetDragState();
          currentMouseOverDroppableNodeKey = null;
        }
        const {
          onDragleave
        } = props2;
        if (onDragleave) {
          onDragleave({
            event,
            node: node2.eventData
          });
        }
      };
      const onNodeDrop = function(event, _node) {
        let outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var _a2;
        const {
          dragChildrenKeys,
          dropPosition,
          dropTargetKey,
          dropTargetPos,
          dropAllowed
        } = dragState;
        if (!dropAllowed) return;
        const {
          onDrop
        } = props2;
        dragState.dragOverNodeKey = null;
        cleanDragState();
        if (dropTargetKey === null) return;
        const abstractDropNodeProps = _extends$1(_extends$1({}, getTreeNodeProps(dropTargetKey, toRaw(treeNodeRequiredProps.value))), {
          active: ((_a2 = activeItem.value) === null || _a2 === void 0 ? void 0 : _a2.key) === dropTargetKey,
          data: keyEntities.value[dropTargetKey].node
        });
        dragChildrenKeys.indexOf(dropTargetKey) !== -1;
        const posArr = posToArr(dropTargetPos);
        const dropResult = {
          event,
          node: convertNodePropsToEventData(abstractDropNodeProps),
          dragNode: dragNode ? dragNode.eventData : null,
          dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),
          dropToGap: dropPosition !== 0,
          dropPosition: dropPosition + Number(posArr[posArr.length - 1])
        };
        if (!outsideTree) {
          onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
        }
        dragNode = null;
      };
      const triggerExpandActionExpand = (e2, treeNode) => {
        const {
          expanded,
          key: key2
        } = treeNode;
        const node2 = flattenNodes.value.filter((nodeItem) => nodeItem.key === key2)[0];
        const eventNode = convertNodePropsToEventData(_extends$1(_extends$1({}, getTreeNodeProps(key2, treeNodeRequiredProps.value)), {
          data: node2.data
        }));
        setExpandedKeys(expanded ? arrDel(expandedKeys.value, key2) : arrAdd(expandedKeys.value, key2));
        onNodeExpand(e2, eventNode);
      };
      const onNodeClick = (e2, treeNode) => {
        const {
          onClick,
          expandAction
        } = props2;
        if (expandAction === "click") {
          triggerExpandActionExpand(e2, treeNode);
        }
        if (onClick) {
          onClick(e2, treeNode);
        }
      };
      const onNodeDoubleClick = (e2, treeNode) => {
        const {
          onDblclick,
          expandAction
        } = props2;
        if (expandAction === "doubleclick" || expandAction === "dblclick") {
          triggerExpandActionExpand(e2, treeNode);
        }
        if (onDblclick) {
          onDblclick(e2, treeNode);
        }
      };
      const onNodeSelect = (e2, treeNode) => {
        let newSelectedKeys = selectedKeys.value;
        const {
          onSelect,
          multiple
        } = props2;
        const {
          selected
        } = treeNode;
        const key2 = treeNode[fieldNames.value.key];
        const targetSelected = !selected;
        if (!targetSelected) {
          newSelectedKeys = arrDel(newSelectedKeys, key2);
        } else if (!multiple) {
          newSelectedKeys = [key2];
        } else {
          newSelectedKeys = arrAdd(newSelectedKeys, key2);
        }
        const keyEntitiesValue = keyEntities.value;
        const selectedNodes = newSelectedKeys.map((selectedKey) => {
          const entity = keyEntitiesValue[selectedKey];
          if (!entity) return null;
          return entity.node;
        }).filter((node2) => node2);
        if (props2.selectedKeys === void 0) {
          selectedKeys.value = newSelectedKeys;
        }
        if (onSelect) {
          onSelect(newSelectedKeys, {
            event: "select",
            selected: targetSelected,
            node: treeNode,
            selectedNodes,
            nativeEvent: e2
          });
        }
      };
      const onNodeCheck = (e2, treeNode, checked) => {
        const {
          checkStrictly,
          onCheck
        } = props2;
        const key2 = treeNode[fieldNames.value.key];
        let checkedObj;
        const eventObj = {
          event: "check",
          node: treeNode,
          checked,
          nativeEvent: e2
        };
        const keyEntitiesValue = keyEntities.value;
        if (checkStrictly) {
          const newCheckedKeys = checked ? arrAdd(checkedKeys.value, key2) : arrDel(checkedKeys.value, key2);
          const newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key2);
          checkedObj = {
            checked: newCheckedKeys,
            halfChecked: newHalfCheckedKeys
          };
          eventObj.checkedNodes = newCheckedKeys.map((checkedKey) => keyEntitiesValue[checkedKey]).filter((entity) => entity).map((entity) => entity.node);
          if (props2.checkedKeys === void 0) {
            checkedKeys.value = newCheckedKeys;
          }
        } else {
          let {
            checkedKeys: newCheckedKeys,
            halfCheckedKeys: newHalfCheckedKeys
          } = conductCheck([...checkedKeys.value, key2], true, keyEntitiesValue, maxLevel.value, levelEntities.value);
          if (!checked) {
            const keySet = new Set(newCheckedKeys);
            keySet.delete(key2);
            ({
              checkedKeys: newCheckedKeys,
              halfCheckedKeys: newHalfCheckedKeys
            } = conductCheck(Array.from(keySet), {
              halfCheckedKeys: newHalfCheckedKeys
            }, keyEntitiesValue, maxLevel.value, levelEntities.value));
          }
          checkedObj = newCheckedKeys;
          eventObj.checkedNodes = [];
          eventObj.checkedNodesPositions = [];
          eventObj.halfCheckedKeys = newHalfCheckedKeys;
          newCheckedKeys.forEach((checkedKey) => {
            const entity = keyEntitiesValue[checkedKey];
            if (!entity) return;
            const {
              node: node2,
              pos
            } = entity;
            eventObj.checkedNodes.push(node2);
            eventObj.checkedNodesPositions.push({
              node: node2,
              pos
            });
          });
          if (props2.checkedKeys === void 0) {
            checkedKeys.value = newCheckedKeys;
            halfCheckedKeys.value = newHalfCheckedKeys;
          }
        }
        if (onCheck) {
          onCheck(checkedObj, eventObj);
        }
      };
      const onNodeLoad = (treeNode) => {
        const key2 = treeNode[fieldNames.value.key];
        const loadPromise = new Promise((resolve2, reject) => {
          const {
            loadData,
            onLoad
          } = props2;
          if (!loadData || loadedKeysSet.value.has(key2) || loadingKeysSet.value.has(key2)) {
            return null;
          }
          const promise = loadData(treeNode);
          promise.then(() => {
            const newLoadedKeys = arrAdd(loadedKeys.value, key2);
            const newLoadingKeys = arrDel(loadingKeys.value, key2);
            if (onLoad) {
              onLoad(newLoadedKeys, {
                event: "load",
                node: treeNode
              });
            }
            if (props2.loadedKeys === void 0) {
              loadedKeys.value = newLoadedKeys;
            }
            loadingKeys.value = newLoadingKeys;
            resolve2();
          }).catch((e2) => {
            const newLoadingKeys = arrDel(loadingKeys.value, key2);
            loadingKeys.value = newLoadingKeys;
            loadingRetryTimes[key2] = (loadingRetryTimes[key2] || 0) + 1;
            if (loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
              const newLoadedKeys = arrAdd(loadedKeys.value, key2);
              if (props2.loadedKeys === void 0) {
                loadedKeys.value = newLoadedKeys;
              }
              resolve2();
            }
            reject(e2);
          });
          loadingKeys.value = arrAdd(loadingKeys.value, key2);
        });
        loadPromise.catch(() => {
        });
        return loadPromise;
      };
      const onNodeMouseEnter = (event, node2) => {
        const {
          onMouseenter
        } = props2;
        if (onMouseenter) {
          onMouseenter({
            event,
            node: node2
          });
        }
      };
      const onNodeMouseLeave = (event, node2) => {
        const {
          onMouseleave
        } = props2;
        if (onMouseleave) {
          onMouseleave({
            event,
            node: node2
          });
        }
      };
      const onNodeContextMenu = (event, node2) => {
        const {
          onRightClick
        } = props2;
        if (onRightClick) {
          event.preventDefault();
          onRightClick({
            event,
            node: node2
          });
        }
      };
      const onFocus = (e2) => {
        const {
          onFocus: onFocus2
        } = props2;
        focused.value = true;
        if (onFocus2) {
          onFocus2(e2);
        }
      };
      const onBlur = (e2) => {
        const {
          onBlur: onBlur2
        } = props2;
        focused.value = false;
        onActiveChange(null);
        if (onBlur2) {
          onBlur2(e2);
        }
      };
      const onNodeExpand = (e2, treeNode) => {
        let newExpandedKeys = expandedKeys.value;
        const {
          onExpand,
          loadData
        } = props2;
        const {
          expanded
        } = treeNode;
        const key2 = treeNode[fieldNames.value.key];
        if (listChanging.value) {
          return;
        }
        newExpandedKeys.indexOf(key2);
        const targetExpanded = !expanded;
        if (targetExpanded) {
          newExpandedKeys = arrAdd(newExpandedKeys, key2);
        } else {
          newExpandedKeys = arrDel(newExpandedKeys, key2);
        }
        setExpandedKeys(newExpandedKeys);
        if (onExpand) {
          onExpand(newExpandedKeys, {
            node: treeNode,
            expanded: targetExpanded,
            nativeEvent: e2
          });
        }
        if (targetExpanded && loadData) {
          const loadPromise = onNodeLoad(treeNode);
          if (loadPromise) {
            loadPromise.then(() => {
            }).catch((e3) => {
              const expandedKeysToRestore = arrDel(expandedKeys.value, key2);
              setExpandedKeys(expandedKeysToRestore);
              Promise.reject(e3);
            });
          }
        }
      };
      const onListChangeStart = () => {
        listChanging.value = true;
      };
      const onListChangeEnd = () => {
        setTimeout(() => {
          listChanging.value = false;
        });
      };
      const onActiveChange = (newActiveKey) => {
        const {
          onActiveChange: onActiveChange2
        } = props2;
        if (activeKey.value === newActiveKey) {
          return;
        }
        if (props2.activeKey !== void 0) {
          activeKey.value = newActiveKey;
        }
        if (newActiveKey !== null) {
          scrollTo2({
            key: newActiveKey
          });
        }
        if (onActiveChange2) {
          onActiveChange2(newActiveKey);
        }
      };
      const activeItem = computed(() => {
        if (activeKey.value === null) {
          return null;
        }
        return flattenNodes.value.find((_ref4) => {
          let {
            key: key2
          } = _ref4;
          return key2 === activeKey.value;
        }) || null;
      });
      const offsetActiveKey = (offset2) => {
        let index2 = flattenNodes.value.findIndex((_ref5) => {
          let {
            key: key2
          } = _ref5;
          return key2 === activeKey.value;
        });
        if (index2 === -1 && offset2 < 0) {
          index2 = flattenNodes.value.length;
        }
        index2 = (index2 + offset2 + flattenNodes.value.length) % flattenNodes.value.length;
        const item = flattenNodes.value[index2];
        if (item) {
          const {
            key: key2
          } = item;
          onActiveChange(key2);
        } else {
          onActiveChange(null);
        }
      };
      const activeItemEventNode = computed(() => {
        return convertNodePropsToEventData(_extends$1(_extends$1({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {
          data: activeItem.value.data,
          active: true
        }));
      });
      const onKeydown = (event) => {
        const {
          onKeydown: onKeydown2,
          checkable,
          selectable
        } = props2;
        switch (event.which) {
          case KeyCode.UP: {
            offsetActiveKey(-1);
            event.preventDefault();
            break;
          }
          case KeyCode.DOWN: {
            offsetActiveKey(1);
            event.preventDefault();
            break;
          }
        }
        const item = activeItem.value;
        if (item && item.data) {
          const expandable = item.data.isLeaf === false || !!(item.data.children || []).length;
          const eventNode = activeItemEventNode.value;
          switch (event.which) {
            // >>> Expand
            case KeyCode.LEFT: {
              if (expandable && expandedKeysSet.value.has(activeKey.value)) {
                onNodeExpand({}, eventNode);
              } else if (item.parent) {
                onActiveChange(item.parent.key);
              }
              event.preventDefault();
              break;
            }
            case KeyCode.RIGHT: {
              if (expandable && !expandedKeysSet.value.has(activeKey.value)) {
                onNodeExpand({}, eventNode);
              } else if (item.children && item.children.length) {
                onActiveChange(item.children[0].key);
              }
              event.preventDefault();
              break;
            }
            // Selection
            case KeyCode.ENTER:
            case KeyCode.SPACE: {
              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));
              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                onNodeSelect({}, eventNode);
              }
              break;
            }
          }
        }
        if (onKeydown2) {
          onKeydown2(event);
        }
      };
      expose({
        onNodeExpand,
        scrollTo: scrollTo2,
        onKeydown,
        selectedKeys: computed(() => selectedKeys.value),
        checkedKeys: computed(() => checkedKeys.value),
        halfCheckedKeys: computed(() => halfCheckedKeys.value),
        loadedKeys: computed(() => loadedKeys.value),
        loadingKeys: computed(() => loadingKeys.value),
        expandedKeys: computed(() => expandedKeys.value)
      });
      onUnmounted(() => {
        window.removeEventListener("dragend", onWindowDragEnd);
        destroyed.value = true;
      });
      useProvideKeysState({
        expandedKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys,
        checkedKeys,
        halfCheckedKeys,
        expandedKeysSet,
        selectedKeysSet,
        loadedKeysSet,
        loadingKeysSet,
        checkedKeysSet,
        halfCheckedKeysSet,
        flattenNodes
      });
      return () => {
        const {
          // focused,
          // flattenNodes,
          // keyEntities,
          draggingNodeKey,
          // activeKey,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey
          // indent,
        } = dragState;
        const {
          prefixCls,
          showLine,
          focusable,
          tabindex = 0,
          selectable,
          showIcon,
          icon = slots.icon,
          switcherIcon,
          draggable,
          checkable,
          checkStrictly,
          disabled,
          motion,
          loadData,
          filterTreeNode,
          height,
          itemHeight,
          virtual,
          dropIndicatorRender: dropIndicatorRender2,
          onContextmenu,
          onScroll,
          direction,
          rootClassName,
          rootStyle
        } = props2;
        const {
          class: className,
          style
        } = attrs;
        const domProps = pickAttrs(_extends$1(_extends$1({}, props2), attrs), {
          aria: true,
          data: true
        });
        let draggableConfig;
        if (draggable) {
          if (typeof draggable === "object") {
            draggableConfig = draggable;
          } else if (typeof draggable === "function") {
            draggableConfig = {
              nodeDraggable: draggable
            };
          } else {
            draggableConfig = {};
          }
        } else {
          draggableConfig = false;
        }
        return createVNode(TreeContext, {
          "value": {
            prefixCls,
            selectable,
            showIcon,
            icon,
            switcherIcon,
            draggable: draggableConfig,
            draggingNodeKey,
            checkable,
            customCheckable: slots.checkable,
            checkStrictly,
            disabled,
            keyEntities: keyEntities.value,
            dropLevelOffset,
            dropContainerKey,
            dropTargetKey,
            dropPosition,
            dragOverNodeKey,
            dragging: draggingNodeKey !== null,
            indent: indent.value,
            direction,
            dropIndicatorRender: dropIndicatorRender2,
            loadData,
            filterTreeNode,
            onNodeClick,
            onNodeDoubleClick,
            onNodeExpand,
            onNodeSelect,
            onNodeCheck,
            onNodeLoad,
            onNodeMouseEnter,
            onNodeMouseLeave,
            onNodeContextMenu,
            onNodeDragStart,
            onNodeDragEnter,
            onNodeDragOver,
            onNodeDragLeave,
            onNodeDragEnd,
            onNodeDrop,
            slots
          }
        }, {
          default: () => [createVNode("div", {
            "role": "tree",
            "class": classNames(prefixCls, className, rootClassName, {
              [`${prefixCls}-show-line`]: showLine,
              [`${prefixCls}-focused`]: focused.value,
              [`${prefixCls}-active-focused`]: activeKey.value !== null
            }),
            "style": rootStyle
          }, [createVNode(NodeList, _objectSpread2$1({
            "ref": listRef,
            "prefixCls": prefixCls,
            "style": style,
            "disabled": disabled,
            "selectable": selectable,
            "checkable": !!checkable,
            "motion": motion,
            "height": height,
            "itemHeight": itemHeight,
            "virtual": virtual,
            "focusable": focusable,
            "focused": focused.value,
            "tabindex": tabindex,
            "activeItem": activeItem.value,
            "onFocus": onFocus,
            "onBlur": onBlur,
            "onKeydown": onKeydown,
            "onActiveChange": onActiveChange,
            "onListChangeStart": onListChangeStart,
            "onListChangeEnd": onListChangeEnd,
            "onContextmenu": onContextmenu,
            "onScroll": onScroll
          }, domProps), null)])]
        });
      };
    }
  });
  var FileOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
  function _objectSpread$5(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$5(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$5(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var FileOutlined = function FileOutlined2(props2, context) {
    var p2 = _objectSpread$5({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$5({}, p2, {
      "icon": FileOutlined$1
    }), null);
  };
  FileOutlined.displayName = "FileOutlined";
  FileOutlined.inheritAttrs = false;
  var MinusSquareOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
  function _objectSpread$4(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$4(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$4(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var MinusSquareOutlined = function MinusSquareOutlined2(props2, context) {
    var p2 = _objectSpread$4({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$4({}, p2, {
      "icon": MinusSquareOutlined$1
    }), null);
  };
  MinusSquareOutlined.displayName = "MinusSquareOutlined";
  MinusSquareOutlined.inheritAttrs = false;
  var PlusSquareOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
  function _objectSpread$3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$3(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$3(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var PlusSquareOutlined = function PlusSquareOutlined2(props2, context) {
    var p2 = _objectSpread$3({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$3({}, p2, {
      "icon": PlusSquareOutlined$1
    }), null);
  };
  PlusSquareOutlined.displayName = "PlusSquareOutlined";
  PlusSquareOutlined.inheritAttrs = false;
  var CaretDownFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
  function _objectSpread$2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$2(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$2(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var CaretDownFilled = function CaretDownFilled2(props2, context) {
    var p2 = _objectSpread$2({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$2({}, p2, {
      "icon": CaretDownFilled$1
    }), null);
  };
  CaretDownFilled.displayName = "CaretDownFilled";
  CaretDownFilled.inheritAttrs = false;
  function renderSwitcherIcon(prefixCls, switcherIcon, props2, leafIcon, showLine) {
    const {
      isLeaf,
      expanded,
      loading
    } = props2;
    let icon = switcherIcon;
    if (loading) {
      return createVNode(LoadingOutlined, {
        "class": `${prefixCls}-switcher-loading-icon`
      }, null);
    }
    let showLeafIcon;
    if (showLine && typeof showLine === "object") {
      showLeafIcon = showLine.showLeafIcon;
    }
    let defaultIcon = null;
    const switcherCls = `${prefixCls}-switcher-icon`;
    if (isLeaf) {
      if (!showLine) {
        return null;
      }
      if (showLeafIcon && leafIcon) {
        return leafIcon(props2);
      }
      if (typeof showLine === "object" && !showLeafIcon) {
        defaultIcon = createVNode("span", {
          "class": `${prefixCls}-switcher-leaf-line`
        }, null);
      } else {
        defaultIcon = createVNode(FileOutlined, {
          "class": `${prefixCls}-switcher-line-icon`
        }, null);
      }
      return defaultIcon;
    } else {
      defaultIcon = createVNode(CaretDownFilled, {
        "class": switcherCls
      }, null);
      if (showLine) {
        defaultIcon = expanded ? createVNode(MinusSquareOutlined, {
          "class": `${prefixCls}-switcher-line-icon`
        }, null) : createVNode(PlusSquareOutlined, {
          "class": `${prefixCls}-switcher-line-icon`
        }, null);
      }
    }
    if (typeof switcherIcon === "function") {
      icon = switcherIcon(_extends$1(_extends$1({}, props2), {
        defaultIcon,
        switcherCls
      }));
    } else if (isValidElement(icon)) {
      icon = cloneVNode(icon, {
        class: switcherCls
      });
    }
    return icon || defaultIcon;
  }
  const offset = 4;
  function dropIndicatorRender(props2) {
    const {
      dropPosition,
      dropLevelOffset,
      prefixCls,
      indent,
      direction = "ltr"
    } = props2;
    const startPosition = direction === "ltr" ? "left" : "right";
    const endPosition = direction === "ltr" ? "right" : "left";
    const style = {
      [startPosition]: `${-dropLevelOffset * indent + offset}px`,
      [endPosition]: 0
    };
    switch (dropPosition) {
      case -1:
        style.top = `${-3}px`;
        break;
      case 1:
        style.bottom = `${-3}px`;
        break;
      default:
        style.bottom = `${-3}px`;
        style[startPosition] = `${indent + offset}px`;
        break;
    }
    return createVNode("div", {
      "style": style,
      "class": `${prefixCls}-drop-indicator`
    }, null);
  }
  const treeNodeFX = new Keyframe("ant-tree-node-fx-do-not-use", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  const getSwitchStyle = (prefixCls, token2) => ({
    [`.${prefixCls}-switcher-icon`]: {
      display: "inline-block",
      fontSize: 10,
      verticalAlign: "baseline",
      svg: {
        transition: `transform ${token2.motionDurationSlow}`
      }
    }
  });
  const getDropIndicatorStyle = (prefixCls, token2) => ({
    [`.${prefixCls}-drop-indicator`]: {
      position: "absolute",
      // it should displayed over the following node
      zIndex: 1,
      height: 2,
      backgroundColor: token2.colorPrimary,
      borderRadius: 1,
      pointerEvents: "none",
      "&:after": {
        position: "absolute",
        top: -3,
        insetInlineStart: -6,
        width: 8,
        height: 8,
        backgroundColor: "transparent",
        border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
        borderRadius: "50%",
        content: '""'
      }
    }
  });
  const genBaseStyle = (prefixCls, token2) => {
    const {
      treeCls,
      treeNodeCls,
      treeNodePadding,
      treeTitleHeight
    } = token2;
    const treeCheckBoxMarginVertical = (treeTitleHeight - token2.fontSizeLG) / 2;
    const treeCheckBoxMarginHorizontal = token2.paddingXS;
    return {
      [treeCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        background: token2.colorBgContainer,
        borderRadius: token2.borderRadius,
        transition: `background-color ${token2.motionDurationSlow}`,
        [`&${treeCls}-rtl`]: {
          // >>> Switcher
          [`${treeCls}-switcher`]: {
            "&_close": {
              [`${treeCls}-switcher-icon`]: {
                svg: {
                  transform: "rotate(90deg)"
                }
              }
            }
          }
        },
        [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: _extends$1({}, genFocusOutline(token2)),
        // =================== Virtual List ===================
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "flex-start"
        },
        [`&${treeCls}-block-node`]: {
          [`${treeCls}-list-holder-inner`]: {
            alignItems: "stretch",
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              flex: "auto"
            },
            // >>> Drag
            [`${treeNodeCls}.dragging`]: {
              position: "relative",
              "&:after": {
                position: "absolute",
                top: 0,
                insetInlineEnd: 0,
                bottom: treeNodePadding,
                insetInlineStart: 0,
                border: `1px solid ${token2.colorPrimary}`,
                opacity: 0,
                animationName: treeNodeFX,
                animationDuration: token2.motionDurationSlow,
                animationPlayState: "running",
                animationFillMode: "forwards",
                content: '""',
                pointerEvents: "none"
              }
            }
          }
        },
        // ===================== TreeNode =====================
        [`${treeNodeCls}`]: {
          display: "flex",
          alignItems: "flex-start",
          padding: `0 0 ${treeNodePadding}px 0`,
          outline: "none",
          "&-rtl": {
            direction: "rtl"
          },
          // Disabled
          "&-disabled": {
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                background: "transparent"
              }
            }
          },
          [`&-active ${treeCls}-node-content-wrapper`]: _extends$1({}, genFocusOutline(token2)),
          [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
            color: "inherit",
            fontWeight: 500
          },
          "&-draggable": {
            [`${treeCls}-draggable-icon`]: {
              width: treeTitleHeight,
              lineHeight: `${treeTitleHeight}px`,
              textAlign: "center",
              visibility: "visible",
              opacity: 0.2,
              transition: `opacity ${token2.motionDurationSlow}`,
              [`${treeNodeCls}:hover &`]: {
                opacity: 0.45
              }
            },
            [`&${treeNodeCls}-disabled`]: {
              [`${treeCls}-draggable-icon`]: {
                visibility: "hidden"
              }
            }
          }
        },
        // >>> Indent
        [`${treeCls}-indent`]: {
          alignSelf: "stretch",
          whiteSpace: "nowrap",
          userSelect: "none",
          "&-unit": {
            display: "inline-block",
            width: treeTitleHeight
          }
        },
        // >>> Drag Handler
        [`${treeCls}-draggable-icon`]: {
          visibility: "hidden"
        },
        // >>> Switcher
        [`${treeCls}-switcher`]: _extends$1(_extends$1({}, getSwitchStyle(prefixCls, token2)), {
          position: "relative",
          flex: "none",
          alignSelf: "stretch",
          width: treeTitleHeight,
          margin: 0,
          lineHeight: `${treeTitleHeight}px`,
          textAlign: "center",
          cursor: "pointer",
          userSelect: "none",
          "&-noop": {
            cursor: "default"
          },
          "&_close": {
            [`${treeCls}-switcher-icon`]: {
              svg: {
                transform: "rotate(-90deg)"
              }
            }
          },
          "&-loading-icon": {
            color: token2.colorPrimary
          },
          "&-leaf-line": {
            position: "relative",
            zIndex: 1,
            display: "inline-block",
            width: "100%",
            height: "100%",
            // https://github.com/ant-design/ant-design/issues/31884
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: treeTitleHeight / 2,
              bottom: -treeNodePadding,
              marginInlineStart: -1,
              borderInlineEnd: `1px solid ${token2.colorBorder}`,
              content: '""'
            },
            "&:after": {
              position: "absolute",
              width: treeTitleHeight / 2 * 0.8,
              height: treeTitleHeight / 2,
              borderBottom: `1px solid ${token2.colorBorder}`,
              content: '""'
            }
          }
        }),
        // >>> Checkbox
        [`${treeCls}-checkbox`]: {
          top: "initial",
          marginInlineEnd: treeCheckBoxMarginHorizontal,
          marginBlockStart: treeCheckBoxMarginVertical
        },
        // >>> Title
        // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
        [`${treeCls}-node-content-wrapper, ${treeCls}-checkbox + span`]: {
          position: "relative",
          zIndex: "auto",
          minHeight: treeTitleHeight,
          margin: 0,
          padding: `0 ${token2.paddingXS / 2}px`,
          color: "inherit",
          lineHeight: `${treeTitleHeight}px`,
          background: "transparent",
          borderRadius: token2.borderRadius,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
          "&:hover": {
            backgroundColor: token2.controlItemBgHover
          },
          [`&${treeCls}-node-selected`]: {
            backgroundColor: token2.controlItemBgActive
          },
          // Icon
          [`${treeCls}-iconEle`]: {
            display: "inline-block",
            width: treeTitleHeight,
            height: treeTitleHeight,
            lineHeight: `${treeTitleHeight}px`,
            textAlign: "center",
            verticalAlign: "top",
            "&:empty": {
              display: "none"
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/28217
        [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
          backgroundColor: "transparent"
        },
        // ==================== Draggable =====================
        [`${treeCls}-node-content-wrapper`]: _extends$1({
          lineHeight: `${treeTitleHeight}px`,
          userSelect: "none"
        }, getDropIndicatorStyle(prefixCls, token2)),
        [`${treeNodeCls}.drop-container`]: {
          "> [draggable]": {
            boxShadow: `0 0 0 2px ${token2.colorPrimary}`
          }
        },
        // ==================== Show Line =====================
        "&-show-line": {
          // ================ Indent lines ================
          [`${treeCls}-indent`]: {
            "&-unit": {
              position: "relative",
              height: "100%",
              "&:before": {
                position: "absolute",
                top: 0,
                insetInlineEnd: treeTitleHeight / 2,
                bottom: -treeNodePadding,
                borderInlineEnd: `1px solid ${token2.colorBorder}`,
                content: '""'
              },
              "&-end": {
                "&:before": {
                  display: "none"
                }
              }
            }
          },
          // ============== Cover Background ==============
          [`${treeCls}-switcher`]: {
            background: "transparent",
            "&-line-icon": {
              // https://github.com/ant-design/ant-design/issues/32813
              verticalAlign: "-0.15em"
            }
          }
        },
        [`${treeNodeCls}-leaf-last`]: {
          [`${treeCls}-switcher`]: {
            "&-leaf-line": {
              "&:before": {
                top: "auto !important",
                bottom: "auto !important",
                height: `${treeTitleHeight / 2}px !important`
              }
            }
          }
        }
      })
    };
  };
  const genDirectoryStyle = (token2) => {
    const {
      treeCls,
      treeNodeCls,
      treeNodePadding
    } = token2;
    return {
      [`${treeCls}${treeCls}-directory`]: {
        // ================== TreeNode ==================
        [treeNodeCls]: {
          position: "relative",
          // Hover color
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: treeNodePadding,
            insetInlineStart: 0,
            transition: `background-color ${token2.motionDurationMid}`,
            content: '""',
            pointerEvents: "none"
          },
          "&:hover": {
            "&:before": {
              background: token2.controlItemBgHover
            }
          },
          // Elements
          "> *": {
            zIndex: 1
          },
          // >>> Switcher
          [`${treeCls}-switcher`]: {
            transition: `color ${token2.motionDurationMid}`
          },
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            borderRadius: 0,
            userSelect: "none",
            "&:hover": {
              background: "transparent"
            },
            [`&${treeCls}-node-selected`]: {
              color: token2.colorTextLightSolid,
              background: "transparent"
            }
          },
          // ============= Selected =============
          "&-selected": {
            [`
            &:hover::before,
            &::before
          `]: {
              background: token2.colorPrimary
            },
            // >>> Switcher
            [`${treeCls}-switcher`]: {
              color: token2.colorTextLightSolid
            },
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              color: token2.colorTextLightSolid,
              background: "transparent"
            }
          }
        }
      }
    };
  };
  const genTreeStyle = (prefixCls, token2) => {
    const treeCls = `.${prefixCls}`;
    const treeNodeCls = `${treeCls}-treenode`;
    const treeNodePadding = token2.paddingXS / 2;
    const treeTitleHeight = token2.controlHeightSM;
    const treeToken = merge$2(token2, {
      treeCls,
      treeNodeCls,
      treeNodePadding,
      treeTitleHeight
    });
    return [
      // Basic
      genBaseStyle(prefixCls, treeToken),
      // Directory
      genDirectoryStyle(treeToken)
    ];
  };
  const useStyle$1 = genComponentStyleHook("Tree", (token2, _ref) => {
    let {
      prefixCls
    } = _ref;
    return [{
      [token2.componentCls]: getStyle$2(`${prefixCls}-checkbox`, token2)
    }, genTreeStyle(prefixCls, token2), genCollapseMotion(token2)];
  });
  const treeProps = () => {
    const baseTreeProps = treeProps$1();
    return _extends$1(_extends$1({}, baseTreeProps), {
      showLine: someType([Boolean, Object]),
      /** 是否支持多选 */
      multiple: booleanType(),
      /** 是否自动展开父节点 */
      autoExpandParent: booleanType(),
      /** checkable状态下节点选择完全受控（父子节点选中状态不再关联）*/
      checkStrictly: booleanType(),
      /** 是否支持选中 */
      checkable: booleanType(),
      /** 是否禁用树 */
      disabled: booleanType(),
      /** 默认展开所有树节点 */
      defaultExpandAll: booleanType(),
      /** 默认展开对应树节点 */
      defaultExpandParent: booleanType(),
      /** 默认展开指定的树节点 */
      defaultExpandedKeys: arrayType(),
      /** （受控）展开指定的树节点 */
      expandedKeys: arrayType(),
      /** （受控）选中复选框的树节点 */
      checkedKeys: someType([Array, Object]),
      /** 默认选中复选框的树节点 */
      defaultCheckedKeys: arrayType(),
      /** （受控）设置选中的树节点 */
      selectedKeys: arrayType(),
      /** 默认选中的树节点 */
      defaultSelectedKeys: arrayType(),
      selectable: booleanType(),
      loadedKeys: arrayType(),
      draggable: booleanType(),
      showIcon: booleanType(),
      icon: functionType(),
      switcherIcon: PropTypes.any,
      prefixCls: String,
      /**
       * @default{title,key,children}
       * deprecated, please use `fieldNames` instead
       * 替换treeNode中 title,key,children字段为treeData中对应的字段
       */
      replaceFields: objectType(),
      blockNode: booleanType(),
      openAnimation: PropTypes.any,
      onDoubleclick: baseTreeProps.onDblclick,
      "onUpdate:selectedKeys": functionType(),
      "onUpdate:checkedKeys": functionType(),
      "onUpdate:expandedKeys": functionType()
    });
  };
  const Tree$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATree",
    inheritAttrs: false,
    props: initDefaultProps(treeProps(), {
      checkable: false,
      selectable: true,
      showIcon: false,
      blockNode: false
    }),
    slots: Object,
    setup(props2, _ref) {
      let {
        attrs,
        expose,
        emit: emit2,
        slots
      } = _ref;
      warning$3(!(props2.treeData === void 0 && slots.default));
      const {
        prefixCls,
        direction,
        virtual
      } = useConfigInject("tree", props2);
      const [wrapSSR, hashId] = useStyle$1(prefixCls);
      const treeRef = ref();
      const scrollTo2 = (scroll) => {
        var _a2;
        (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(scroll);
      };
      expose({
        treeRef,
        onNodeExpand: function() {
          var _a2;
          (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.onNodeExpand(...arguments);
        },
        scrollTo: scrollTo2,
        selectedKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectedKeys;
        }),
        checkedKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.checkedKeys;
        }),
        halfCheckedKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.halfCheckedKeys;
        }),
        loadedKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadedKeys;
        }),
        loadingKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadingKeys;
        }),
        expandedKeys: computed(() => {
          var _a2;
          return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.expandedKeys;
        })
      });
      watchEffect(() => {
        devWarning(props2.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
      });
      const handleCheck = (checkedObjOrKeys, eventObj) => {
        emit2("update:checkedKeys", checkedObjOrKeys);
        emit2("check", checkedObjOrKeys, eventObj);
      };
      const handleExpand = (expandedKeys, eventObj) => {
        emit2("update:expandedKeys", expandedKeys);
        emit2("expand", expandedKeys, eventObj);
      };
      const handleSelect = (selectedKeys, eventObj) => {
        emit2("update:selectedKeys", selectedKeys);
        emit2("select", selectedKeys, eventObj);
      };
      return () => {
        const {
          showIcon,
          showLine,
          switcherIcon = slots.switcherIcon,
          icon = slots.icon,
          blockNode,
          checkable,
          selectable,
          fieldNames = props2.replaceFields,
          motion = props2.openAnimation,
          itemHeight = 28,
          onDoubleclick,
          onDblclick
        } = props2;
        const newProps = _extends$1(_extends$1(_extends$1({}, attrs), omit$1(props2, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {
          showLine: Boolean(showLine),
          dropIndicatorRender,
          fieldNames,
          icon,
          itemHeight
        });
        const children = slots.default ? filterEmpty(slots.default()) : void 0;
        return wrapSSR(createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({}, newProps), {}, {
          "virtual": virtual.value,
          "motion": motion,
          "ref": treeRef,
          "prefixCls": prefixCls.value,
          "class": classNames({
            [`${prefixCls.value}-icon-hide`]: !showIcon,
            [`${prefixCls.value}-block-node`]: blockNode,
            [`${prefixCls.value}-unselectable`]: !selectable,
            [`${prefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value),
          "direction": direction.value,
          "checkable": checkable,
          "selectable": selectable,
          "switcherIcon": (nodeProps) => renderSwitcherIcon(prefixCls.value, switcherIcon, nodeProps, slots.leafIcon, showLine),
          "onCheck": handleCheck,
          "onExpand": handleExpand,
          "onSelect": handleSelect,
          "onDblclick": onDblclick || onDoubleclick,
          "children": children
        }), _extends$1(_extends$1({}, slots), {
          checkable: () => createVNode("span", {
            "class": `${prefixCls.value}-checkbox-inner`
          }, null)
        })));
      };
    }
  });
  var FolderOpenOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
  function _objectSpread$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$1(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var FolderOpenOutlined = function FolderOpenOutlined2(props2, context) {
    var p2 = _objectSpread$1({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread$1({}, p2, {
      "icon": FolderOpenOutlined$1
    }), null);
  };
  FolderOpenOutlined.displayName = "FolderOpenOutlined";
  FolderOpenOutlined.inheritAttrs = false;
  var FolderOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty(obj2, key2, value) {
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  var FolderOutlined = function FolderOutlined2(props2, context) {
    var p2 = _objectSpread({}, props2, context.attrs);
    return createVNode(Icon, _objectSpread({}, p2, {
      "icon": FolderOutlined$1
    }), null);
  };
  FolderOutlined.displayName = "FolderOutlined";
  FolderOutlined.inheritAttrs = false;
  var Record;
  (function(Record2) {
    Record2[Record2["None"] = 0] = "None";
    Record2[Record2["Start"] = 1] = "Start";
    Record2[Record2["End"] = 2] = "End";
  })(Record || (Record = {}));
  function traverseNodesKey(treeData, fieldNames, callback) {
    function processNode(dataNode) {
      const key2 = dataNode[fieldNames.key];
      const children = dataNode[fieldNames.children];
      if (callback(key2, dataNode) !== false) {
        traverseNodesKey(children || [], fieldNames, callback);
      }
    }
    treeData.forEach(processNode);
  }
  function calcRangeKeys(_ref) {
    let {
      treeData,
      expandedKeys,
      startKey,
      endKey,
      fieldNames = {
        title: "title",
        key: "key",
        children: "children"
      }
    } = _ref;
    const keys2 = [];
    let record = Record.None;
    if (startKey && startKey === endKey) {
      return [startKey];
    }
    if (!startKey || !endKey) {
      return [];
    }
    function matchKey(key2) {
      return key2 === startKey || key2 === endKey;
    }
    traverseNodesKey(treeData, fieldNames, (key2) => {
      if (record === Record.End) {
        return false;
      }
      if (matchKey(key2)) {
        keys2.push(key2);
        if (record === Record.None) {
          record = Record.Start;
        } else if (record === Record.Start) {
          record = Record.End;
          return false;
        }
      } else if (record === Record.Start) {
        keys2.push(key2);
      }
      return expandedKeys.includes(key2);
    });
    return keys2;
  }
  function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
    const restKeys = [...keys2];
    const nodes = [];
    traverseNodesKey(treeData, fieldNames, (key2, node2) => {
      const index2 = restKeys.indexOf(key2);
      if (index2 !== -1) {
        nodes.push(node2);
        restKeys.splice(index2, 1);
      }
      return !!restKeys.length;
    });
    return nodes;
  }
  var __rest = function(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) t2[p2[i2]] = s2[p2[i2]];
    }
    return t2;
  };
  const directoryTreeProps = () => _extends$1(_extends$1({}, treeProps()), {
    expandAction: someType([Boolean, String])
  });
  function getIcon(props2) {
    const {
      isLeaf,
      expanded
    } = props2;
    if (isLeaf) {
      return createVNode(FileOutlined, null, null);
    }
    return expanded ? createVNode(FolderOpenOutlined, null, null) : createVNode(FolderOutlined, null, null);
  }
  const DirectoryTree = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ADirectoryTree",
    inheritAttrs: false,
    props: initDefaultProps(directoryTreeProps(), {
      showIcon: true,
      expandAction: "click"
    }),
    slots: Object,
    // emits: [
    //   'update:selectedKeys',
    //   'update:checkedKeys',
    //   'update:expandedKeys',
    //   'expand',
    //   'select',
    //   'check',
    //   'doubleclick',
    //   'dblclick',
    //   'click',
    // ],
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        emit: emit2,
        expose
      } = _ref;
      var _a2;
      const treeData = ref(props2.treeData || convertTreeToData(filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))));
      watch(() => props2.treeData, () => {
        treeData.value = props2.treeData;
      });
      onUpdated(() => {
        nextTick(() => {
          var _a3;
          if (props2.treeData === void 0 && slots.default) {
            treeData.value = convertTreeToData(filterEmpty((_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)));
          }
        });
      });
      const lastSelectedKey = ref();
      const cachedSelectedKeys = ref();
      const fieldNames = computed(() => fillFieldNames(props2.fieldNames));
      const treeRef = ref();
      const scrollTo2 = (scroll) => {
        var _a3;
        (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.scrollTo(scroll);
      };
      expose({
        scrollTo: scrollTo2,
        selectedKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.selectedKeys;
        }),
        checkedKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.checkedKeys;
        }),
        halfCheckedKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.halfCheckedKeys;
        }),
        loadedKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.loadedKeys;
        }),
        loadingKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.loadingKeys;
        }),
        expandedKeys: computed(() => {
          var _a3;
          return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.expandedKeys;
        })
      });
      const getInitExpandedKeys = () => {
        const {
          keyEntities
        } = convertDataToEntities(treeData.value, {
          fieldNames: fieldNames.value
        });
        let initExpandedKeys;
        if (props2.defaultExpandAll) {
          initExpandedKeys = Object.keys(keyEntities);
        } else if (props2.defaultExpandParent) {
          initExpandedKeys = conductExpandParent(props2.expandedKeys || props2.defaultExpandedKeys || [], keyEntities);
        } else {
          initExpandedKeys = props2.expandedKeys || props2.defaultExpandedKeys;
        }
        return initExpandedKeys;
      };
      const selectedKeys = ref(props2.selectedKeys || props2.defaultSelectedKeys || []);
      const expandedKeys = ref(getInitExpandedKeys());
      watch(() => props2.selectedKeys, () => {
        if (props2.selectedKeys !== void 0) {
          selectedKeys.value = props2.selectedKeys;
        }
      }, {
        immediate: true
      });
      watch(() => props2.expandedKeys, () => {
        if (props2.expandedKeys !== void 0) {
          expandedKeys.value = props2.expandedKeys;
        }
      }, {
        immediate: true
      });
      const expandFolderNode = (event, node2) => {
        const {
          isLeaf
        } = node2;
        if (isLeaf || event.shiftKey || event.metaKey || event.ctrlKey) {
          return;
        }
        treeRef.value.onNodeExpand(event, node2);
      };
      const onDebounceExpand = debounce$1(expandFolderNode, 200, {
        leading: true
      });
      const onExpand = (keys2, info) => {
        if (props2.expandedKeys === void 0) {
          expandedKeys.value = keys2;
        }
        emit2("update:expandedKeys", keys2);
        emit2("expand", keys2, info);
      };
      const onClick = (event, node2) => {
        const {
          expandAction
        } = props2;
        if (expandAction === "click") {
          onDebounceExpand(event, node2);
        }
        emit2("click", event, node2);
      };
      const onDoubleClick = (event, node2) => {
        const {
          expandAction
        } = props2;
        if (expandAction === "dblclick" || expandAction === "doubleclick") {
          onDebounceExpand(event, node2);
        }
        emit2("doubleclick", event, node2);
        emit2("dblclick", event, node2);
      };
      const onSelect = (keys2, event) => {
        const {
          multiple
        } = props2;
        const {
          node: node2,
          nativeEvent
        } = event;
        const key2 = node2[fieldNames.value.key];
        const newEvent = _extends$1(_extends$1({}, event), {
          selected: true
        });
        const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
        const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
        let newSelectedKeys;
        if (multiple && ctrlPick) {
          newSelectedKeys = keys2;
          lastSelectedKey.value = key2;
          cachedSelectedKeys.value = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
        } else if (multiple && shiftPick) {
          newSelectedKeys = Array.from(/* @__PURE__ */ new Set([...cachedSelectedKeys.value || [], ...calcRangeKeys({
            treeData: treeData.value,
            expandedKeys: expandedKeys.value,
            startKey: key2,
            endKey: lastSelectedKey.value,
            fieldNames: fieldNames.value
          })]));
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
        } else {
          newSelectedKeys = [key2];
          lastSelectedKey.value = key2;
          cachedSelectedKeys.value = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
        }
        emit2("update:selectedKeys", newSelectedKeys);
        emit2("select", newSelectedKeys, newEvent);
        if (props2.selectedKeys === void 0) {
          selectedKeys.value = newSelectedKeys;
        }
      };
      const onCheck = (checkedObjOrKeys, eventObj) => {
        emit2("update:checkedKeys", checkedObjOrKeys);
        emit2("check", checkedObjOrKeys, eventObj);
      };
      const {
        prefixCls,
        direction
      } = useConfigInject("tree", props2);
      return () => {
        const connectClassName = classNames(`${prefixCls.value}-directory`, {
          [`${prefixCls.value}-directory-rtl`]: direction.value === "rtl"
        }, attrs.class);
        const {
          icon = slots.icon,
          blockNode = true
        } = props2, otherProps = __rest(props2, ["icon", "blockNode"]);
        return createVNode(Tree$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "icon": icon || getIcon,
          "ref": treeRef,
          "blockNode": blockNode
        }, otherProps), {}, {
          "prefixCls": prefixCls.value,
          "class": connectClassName,
          "expandedKeys": expandedKeys.value,
          "selectedKeys": selectedKeys.value,
          "onSelect": onSelect,
          "onClick": onClick,
          "onDblclick": onDoubleClick,
          "onExpand": onExpand,
          "onCheck": onCheck
        }), slots);
      };
    }
  });
  const TreeNode = VcTreeNode;
  const Tree = _extends$1(Tree$1, {
    DirectoryTree,
    TreeNode,
    install: (app2) => {
      app2.component(Tree$1.name, Tree$1);
      app2.component(TreeNode.name, TreeNode);
      app2.component(DirectoryTree.name, DirectoryTree);
      return app2;
    }
  });
  function isEqual(obj1, obj2) {
    let shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const refSet = /* @__PURE__ */ new Set();
    function deepEqual(a2, b2) {
      let level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      const circular = refSet.has(a2);
      warningOnce(!circular, "Warning: There may be circular references");
      if (circular) {
        return false;
      }
      if (a2 === b2) {
        return true;
      }
      if (shallow && level > 1) {
        return false;
      }
      refSet.add(a2);
      const newLevel = level + 1;
      if (Array.isArray(a2)) {
        if (!Array.isArray(b2) || a2.length !== b2.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          if (!deepEqual(a2[i2], b2[i2], newLevel)) {
            return false;
          }
        }
        return true;
      }
      if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
        const keys2 = Object.keys(a2);
        if (keys2.length !== Object.keys(b2).length) {
          return false;
        }
        return keys2.every((key2) => deepEqual(a2[key2], b2[key2], newLevel));
      }
      return false;
    }
    return deepEqual(obj1, obj2);
  }
  const {
    SubMenu,
    Item: MenuItem
  } = Menu;
  function hasSubMenu(filters) {
    return filters.some((_ref) => {
      let {
        children
      } = _ref;
      return children && children.length > 0;
    });
  }
  function searchValueMatched(searchValue, text) {
    if (typeof text === "string" || typeof text === "number") {
      return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
    }
    return false;
  }
  function renderFilterItems(_ref2) {
    let {
      filters,
      prefixCls,
      filteredKeys,
      filterMultiple,
      searchValue,
      filterSearch
    } = _ref2;
    return filters.map((filter2, index2) => {
      const key2 = String(filter2.value);
      if (filter2.children) {
        return createVNode(SubMenu, {
          "key": key2 || index2,
          "title": filter2.text,
          "popupClassName": `${prefixCls}-dropdown-submenu`
        }, {
          default: () => [renderFilterItems({
            filters: filter2.children,
            prefixCls,
            filteredKeys,
            filterMultiple,
            searchValue,
            filterSearch
          })]
        });
      }
      const Component = filterMultiple ? Checkbox : Radio;
      const item = createVNode(MenuItem, {
        "key": filter2.value !== void 0 ? key2 : index2
      }, {
        default: () => [createVNode(Component, {
          "checked": filteredKeys.includes(key2)
        }, null), createVNode("span", null, [filter2.text])]
      });
      if (searchValue.trim()) {
        if (typeof filterSearch === "function") {
          return filterSearch(searchValue, filter2) ? item : void 0;
        }
        return searchValueMatched(searchValue, filter2.text) ? item : void 0;
      }
      return item;
    });
  }
  const FilterDropdown = /* @__PURE__ */ defineComponent({
    name: "FilterDropdown",
    props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
    setup(props2, _ref3) {
      let {
        slots
      } = _ref3;
      const contextSlots = useInjectSlots();
      const filterMode = computed(() => {
        var _a2;
        return (_a2 = props2.filterMode) !== null && _a2 !== void 0 ? _a2 : "menu";
      });
      const filterSearch = computed(() => {
        var _a2;
        return (_a2 = props2.filterSearch) !== null && _a2 !== void 0 ? _a2 : false;
      });
      const filterDropdownOpen = computed(() => props2.column.filterDropdownOpen || props2.column.filterDropdownVisible);
      const onFilterDropdownOpenChange = computed(() => props2.column.onFilterDropdownOpenChange || props2.column.onFilterDropdownVisibleChange);
      const visible = shallowRef(false);
      const filtered = computed(() => {
        var _a2;
        return !!(props2.filterState && (((_a2 = props2.filterState.filteredKeys) === null || _a2 === void 0 ? void 0 : _a2.length) || props2.filterState.forceFiltered));
      });
      const filterFlattenKeys = computed(() => {
        var _a2;
        return flattenKeys((_a2 = props2.column) === null || _a2 === void 0 ? void 0 : _a2.filters);
      });
      const filterDropdownRef = computed(() => {
        const {
          filterDropdown,
          slots: slots2 = {},
          customFilterDropdown
        } = props2.column;
        return filterDropdown || slots2.filterDropdown && contextSlots.value[slots2.filterDropdown] || customFilterDropdown && contextSlots.value.customFilterDropdown;
      });
      const filterIconRef = computed(() => {
        const {
          filterIcon,
          slots: slots2 = {}
        } = props2.column;
        return filterIcon || slots2.filterIcon && contextSlots.value[slots2.filterIcon] || contextSlots.value.customFilterIcon;
      });
      const triggerVisible = (newVisible) => {
        var _a2;
        visible.value = newVisible;
        (_a2 = onFilterDropdownOpenChange.value) === null || _a2 === void 0 ? void 0 : _a2.call(onFilterDropdownOpenChange, newVisible);
      };
      const mergedVisible = computed(() => typeof filterDropdownOpen.value === "boolean" ? filterDropdownOpen.value : visible.value);
      const propFilteredKeys = computed(() => {
        var _a2;
        return (_a2 = props2.filterState) === null || _a2 === void 0 ? void 0 : _a2.filteredKeys;
      });
      const filteredKeys = shallowRef([]);
      const onSelectKeys = (_ref5) => {
        let {
          selectedKeys
        } = _ref5;
        filteredKeys.value = selectedKeys;
      };
      const onCheck = (keys2, _ref6) => {
        let {
          node: node2,
          checked
        } = _ref6;
        if (!props2.filterMultiple) {
          onSelectKeys({
            selectedKeys: checked && node2.key ? [node2.key] : []
          });
        } else {
          onSelectKeys({
            selectedKeys: keys2
          });
        }
      };
      watch(propFilteredKeys, () => {
        if (!visible.value) {
          return;
        }
        onSelectKeys({
          selectedKeys: propFilteredKeys.value || []
        });
      }, {
        immediate: true
      });
      const openKeys = shallowRef([]);
      const openRef = shallowRef();
      const onOpenChange = (keys2) => {
        openRef.value = setTimeout(() => {
          openKeys.value = keys2;
        });
      };
      const onMenuClick = () => {
        clearTimeout(openRef.value);
      };
      onBeforeUnmount(() => {
        clearTimeout(openRef.value);
      });
      const searchValue = shallowRef("");
      const onSearch = (e2) => {
        const {
          value
        } = e2.target;
        searchValue.value = value;
      };
      watch(visible, () => {
        if (!visible.value) {
          searchValue.value = "";
        }
      });
      const internalTriggerFilter = (keys2) => {
        const {
          column: column2,
          columnKey,
          filterState
        } = props2;
        const mergedKeys = keys2 && keys2.length ? keys2 : null;
        if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
          return null;
        }
        if (isEqual(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) {
          return null;
        }
        props2.triggerFilter({
          column: column2,
          key: columnKey,
          filteredKeys: mergedKeys
        });
      };
      const onConfirm = () => {
        triggerVisible(false);
        internalTriggerFilter(filteredKeys.value);
      };
      const onReset = function() {
        let {
          confirm,
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          confirm: false,
          closeDropdown: false
        };
        if (confirm) {
          internalTriggerFilter([]);
        }
        if (closeDropdown) {
          triggerVisible(false);
        }
        searchValue.value = "";
        if (props2.column.filterResetToDefaultFilteredValue) {
          filteredKeys.value = (props2.column.defaultFilteredValue || []).map((key2) => String(key2));
        } else {
          filteredKeys.value = [];
        }
      };
      const doFilter = function() {
        let {
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          closeDropdown: true
        };
        if (closeDropdown) {
          triggerVisible(false);
        }
        internalTriggerFilter(filteredKeys.value);
      };
      const onVisibleChange = (newVisible) => {
        if (newVisible && propFilteredKeys.value !== void 0) {
          filteredKeys.value = propFilteredKeys.value || [];
        }
        triggerVisible(newVisible);
        if (!newVisible && !filterDropdownRef.value) {
          onConfirm();
        }
      };
      const {
        direction
      } = useConfigInject("", props2);
      const onCheckAll = (e2) => {
        if (e2.target.checked) {
          const allFilterKeys = filterFlattenKeys.value;
          filteredKeys.value = allFilterKeys;
        } else {
          filteredKeys.value = [];
        }
      };
      const getTreeData = (_ref7) => {
        let {
          filters
        } = _ref7;
        return (filters || []).map((filter2, index2) => {
          const key2 = String(filter2.value);
          const item = {
            title: filter2.text,
            key: filter2.value !== void 0 ? key2 : index2
          };
          if (filter2.children) {
            item.children = getTreeData({
              filters: filter2.children
            });
          }
          return item;
        });
      };
      const getFilterData2 = (node2) => {
        var _a2;
        return _extends$1(_extends$1({}, node2), {
          text: node2.title,
          value: node2.key,
          children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
        });
      };
      const treeData = computed(() => getTreeData({
        filters: props2.column.filters
      }));
      const dropdownMenuClass = computed(() => classNames({
        [`${props2.dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(props2.column.filters || [])
      }));
      const getFilterComponent = () => {
        const selectedKeys = filteredKeys.value;
        const {
          column: column2,
          locale: locale2,
          tablePrefixCls,
          filterMultiple,
          dropdownPrefixCls,
          getPopupContainer,
          prefixCls
        } = props2;
        if ((column2.filters || []).length === 0) {
          return createVNode(Empty$1, {
            "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
            "description": locale2.filterEmptyText,
            "imageStyle": {
              height: 24
            },
            "style": {
              margin: 0,
              padding: "16px 0"
            }
          }, null);
        }
        if (filterMode.value === "tree") {
          return createVNode(Fragment, null, [createVNode(FilterSearch, {
            "filterSearch": filterSearch.value,
            "value": searchValue.value,
            "onChange": onSearch,
            "tablePrefixCls": tablePrefixCls,
            "locale": locale2
          }, null), createVNode("div", {
            "class": `${tablePrefixCls}-filter-dropdown-tree`
          }, [filterMultiple ? createVNode(Checkbox, {
            "class": `${tablePrefixCls}-filter-dropdown-checkall`,
            "onChange": onCheckAll,
            "checked": selectedKeys.length === filterFlattenKeys.value.length,
            "indeterminate": selectedKeys.length > 0 && selectedKeys.length < filterFlattenKeys.value.length
          }, {
            default: () => [locale2.filterCheckall]
          }) : null, createVNode(Tree, {
            "checkable": true,
            "selectable": false,
            "blockNode": true,
            "multiple": filterMultiple,
            "checkStrictly": !filterMultiple,
            "class": `${dropdownPrefixCls}-menu`,
            "onCheck": onCheck,
            "checkedKeys": selectedKeys,
            "selectedKeys": selectedKeys,
            "showIcon": false,
            "treeData": treeData.value,
            "autoExpandParent": true,
            "defaultExpandAll": true,
            "filterTreeNode": searchValue.value.trim() ? (node2) => {
              if (typeof filterSearch.value === "function") {
                return filterSearch.value(searchValue.value, getFilterData2(node2));
              }
              return searchValueMatched(searchValue.value, node2.title);
            } : void 0
          }, null)])]);
        }
        return createVNode(Fragment, null, [createVNode(FilterSearch, {
          "filterSearch": filterSearch.value,
          "value": searchValue.value,
          "onChange": onSearch,
          "tablePrefixCls": tablePrefixCls,
          "locale": locale2
        }, null), createVNode(Menu, {
          "multiple": filterMultiple,
          "prefixCls": `${dropdownPrefixCls}-menu`,
          "class": dropdownMenuClass.value,
          "onClick": onMenuClick,
          "onSelect": onSelectKeys,
          "onDeselect": onSelectKeys,
          "selectedKeys": selectedKeys,
          "getPopupContainer": getPopupContainer,
          "openKeys": openKeys.value,
          "onOpenChange": onOpenChange
        }, {
          default: () => renderFilterItems({
            filters: column2.filters || [],
            filterSearch: filterSearch.value,
            prefixCls,
            filteredKeys: filteredKeys.value,
            filterMultiple,
            searchValue: searchValue.value
          })
        })]);
      };
      const resetDisabled = computed(() => {
        const selectedKeys = filteredKeys.value;
        if (props2.column.filterResetToDefaultFilteredValue) {
          return isEqual((props2.column.defaultFilteredValue || []).map((key2) => String(key2)), selectedKeys, true);
        }
        return selectedKeys.length === 0;
      });
      return () => {
        var _a2;
        const {
          tablePrefixCls,
          prefixCls,
          column: column2,
          dropdownPrefixCls,
          locale: locale2,
          getPopupContainer
        } = props2;
        let dropdownContent;
        if (typeof filterDropdownRef.value === "function") {
          dropdownContent = filterDropdownRef.value({
            prefixCls: `${dropdownPrefixCls}-custom`,
            setSelectedKeys: (selectedKeys) => onSelectKeys({
              selectedKeys
            }),
            selectedKeys: filteredKeys.value,
            confirm: doFilter,
            clearFilters: onReset,
            filters: column2.filters,
            visible: mergedVisible.value,
            column: column2.__originColumn__,
            close: () => {
              triggerVisible(false);
            }
          });
        } else if (filterDropdownRef.value) {
          dropdownContent = filterDropdownRef.value;
        } else {
          dropdownContent = createVNode(Fragment, null, [getFilterComponent(), createVNode("div", {
            "class": `${prefixCls}-dropdown-btns`
          }, [createVNode(Button$1, {
            "type": "link",
            "size": "small",
            "disabled": resetDisabled.value,
            "onClick": () => onReset()
          }, {
            default: () => [locale2.filterReset]
          }), createVNode(Button$1, {
            "type": "primary",
            "size": "small",
            "onClick": onConfirm
          }, {
            default: () => [locale2.filterConfirm]
          })])]);
        }
        const menu = createVNode(FilterDropdownMenuWrapper, {
          "class": `${prefixCls}-dropdown`
        }, {
          default: () => [dropdownContent]
        });
        let filterIcon;
        if (typeof filterIconRef.value === "function") {
          filterIcon = filterIconRef.value({
            filtered: filtered.value,
            column: column2.__originColumn__
          });
        } else if (filterIconRef.value) {
          filterIcon = filterIconRef.value;
        } else {
          filterIcon = createVNode(FilterFilled, null, null);
        }
        return createVNode("div", {
          "class": `${prefixCls}-column`
        }, [createVNode("span", {
          "class": `${tablePrefixCls}-column-title`
        }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), createVNode(Dropdown, {
          "overlay": menu,
          "trigger": ["click"],
          "open": mergedVisible.value,
          "onOpenChange": onVisibleChange,
          "getPopupContainer": getPopupContainer,
          "placement": direction.value === "rtl" ? "bottomLeft" : "bottomRight"
        }, {
          default: () => [createVNode("span", {
            "role": "button",
            "tabindex": -1,
            "class": classNames(`${prefixCls}-trigger`, {
              active: filtered.value
            }),
            "onClick": (e2) => {
              e2.stopPropagation();
            }
          }, [filterIcon])]
        })]);
      };
    }
  });
  function collectFilterStates(columns, init2, pos) {
    let filterStates = [];
    (columns || []).forEach((column2, index2) => {
      var _a2, _b2;
      const columnPos = getColumnPos(index2, pos);
      const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
      if (column2.filters || hasFilterDropdown || "onFilter" in column2) {
        if ("filteredValue" in column2) {
          let filteredValues = column2.filteredValue;
          if (!hasFilterDropdown) {
            filteredValues = (_b2 = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _b2 !== void 0 ? _b2 : filteredValues;
          }
          filterStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            filteredKeys: filteredValues,
            forceFiltered: column2.filtered
          });
        } else {
          filterStates.push({
            column: column2,
            key: getColumnKey(column2, columnPos),
            filteredKeys: init2 && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
            forceFiltered: column2.filtered
          });
        }
      }
      if ("children" in column2) {
        filterStates = [...filterStates, ...collectFilterStates(column2.children, init2, columnPos)];
      }
    });
    return filterStates;
  }
  function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos) {
    return columns.map((column2, index2) => {
      var _a2;
      const columnPos = getColumnPos(index2, pos);
      const {
        filterMultiple = true,
        filterMode,
        filterSearch
      } = column2;
      let newColumn = column2;
      const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
      if (newColumn.filters || hasFilterDropdown) {
        const columnKey = getColumnKey(newColumn, columnPos);
        const filterState = filterStates.find((_ref) => {
          let {
            key: key2
          } = _ref;
          return columnKey === key2;
        });
        newColumn = _extends$1(_extends$1({}, newColumn), {
          title: (renderProps) => createVNode(FilterDropdown, {
            "tablePrefixCls": prefixCls,
            "prefixCls": `${prefixCls}-filter`,
            "dropdownPrefixCls": dropdownPrefixCls,
            "column": newColumn,
            "columnKey": columnKey,
            "filterState": filterState,
            "filterMultiple": filterMultiple,
            "filterMode": filterMode,
            "filterSearch": filterSearch,
            "triggerFilter": triggerFilter,
            "locale": locale2,
            "getPopupContainer": getPopupContainer
          }, {
            default: () => [renderColumnTitle(column2.title, renderProps)]
          })
        });
      }
      if ("children" in newColumn) {
        newColumn = _extends$1(_extends$1({}, newColumn), {
          children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos)
        });
      }
      return newColumn;
    });
  }
  function flattenKeys(filters) {
    let keys2 = [];
    (filters || []).forEach((_ref2) => {
      let {
        value,
        children
      } = _ref2;
      keys2.push(value);
      if (children) {
        keys2 = [...keys2, ...flattenKeys(children)];
      }
    });
    return keys2;
  }
  function generateFilterInfo(filterStates) {
    const currentFilters = {};
    filterStates.forEach((_ref3) => {
      let {
        key: key2,
        filteredKeys,
        column: column2
      } = _ref3;
      var _a2;
      const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
      const {
        filters
      } = column2;
      if (hasFilterDropdown) {
        currentFilters[key2] = filteredKeys || null;
      } else if (Array.isArray(filteredKeys)) {
        const keys2 = flattenKeys(filters);
        currentFilters[key2] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
      } else {
        currentFilters[key2] = null;
      }
    });
    return currentFilters;
  }
  function getFilterData(data, filterStates) {
    return filterStates.reduce((currentData, filterState) => {
      const {
        column: {
          onFilter,
          filters
        },
        filteredKeys
      } = filterState;
      if (onFilter && filteredKeys && filteredKeys.length) {
        return currentData.filter((record) => filteredKeys.some((key2) => {
          const keys2 = flattenKeys(filters);
          const keyIndex2 = keys2.findIndex((k2) => String(k2) === String(key2));
          const realKey = keyIndex2 !== -1 ? keys2[keyIndex2] : key2;
          return onFilter(realKey, record);
        }));
      }
      return currentData;
    }, data);
  }
  function getMergedColumns(rawMergedColumns) {
    return rawMergedColumns.flatMap((column2) => {
      if ("children" in column2) {
        return [column2, ...getMergedColumns(column2.children || [])];
      }
      return [column2];
    });
  }
  function useFilter(_ref4) {
    let {
      prefixCls,
      dropdownPrefixCls,
      mergedColumns: rawMergedColumns,
      locale: locale2,
      onFilterChange,
      getPopupContainer
    } = _ref4;
    const mergedColumns = computed(() => getMergedColumns(rawMergedColumns.value));
    const [filterStates, setFilterStates] = useState(collectFilterStates(mergedColumns.value, true));
    const mergedFilterStates = computed(() => {
      const collectedStates = collectFilterStates(mergedColumns.value, false);
      if (collectedStates.length === 0) {
        return collectedStates;
      }
      let filteredKeysIsAllNotControlled = true;
      let filteredKeysIsAllControlled = true;
      collectedStates.forEach((_ref5) => {
        let {
          filteredKeys
        } = _ref5;
        if (filteredKeys !== void 0) {
          filteredKeysIsAllNotControlled = false;
        } else {
          filteredKeysIsAllControlled = false;
        }
      });
      if (filteredKeysIsAllNotControlled) {
        const keyList = (mergedColumns.value || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
        return filterStates.value.filter((_ref6) => {
          let {
            key: key2
          } = _ref6;
          return keyList.includes(key2);
        }).map((item) => {
          const col = mergedColumns.value[keyList.findIndex((key2) => key2 === item.key)];
          return _extends$1(_extends$1({}, item), {
            column: _extends$1(_extends$1({}, item.column), col),
            forceFiltered: col.filtered
          });
        });
      }
      devWarning(filteredKeysIsAllControlled, "Table", "Columns should all contain `filteredValue` or not contain `filteredValue`.");
      return collectedStates;
    });
    const filters = computed(() => generateFilterInfo(mergedFilterStates.value));
    const triggerFilter = (filterState) => {
      const newFilterStates = mergedFilterStates.value.filter((_ref7) => {
        let {
          key: key2
        } = _ref7;
        return key2 !== filterState.key;
      });
      newFilterStates.push(filterState);
      setFilterStates(newFilterStates);
      onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
    };
    const transformColumns = (innerColumns) => {
      return injectFilter(prefixCls.value, dropdownPrefixCls.value, innerColumns, mergedFilterStates.value, locale2.value, triggerFilter, getPopupContainer.value);
    };
    return [transformColumns, mergedFilterStates, filters];
  }
  function fillTitle(columns, columnTitleProps) {
    return columns.map((column2) => {
      const cloneColumn = _extends$1({}, column2);
      cloneColumn.title = renderColumnTitle(cloneColumn.title, columnTitleProps);
      if ("children" in cloneColumn) {
        cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
      }
      return cloneColumn;
    });
  }
  function useTitleColumns(columnTitleProps) {
    const filledColumns = (columns) => fillTitle(columns, columnTitleProps.value);
    return [filledColumns];
  }
  function renderExpandIcon(locale2) {
    return function expandIcon(_ref) {
      let {
        prefixCls,
        onExpand,
        record,
        expanded,
        expandable
      } = _ref;
      const iconPrefix = `${prefixCls}-row-expand-icon`;
      return createVNode("button", {
        "type": "button",
        "onClick": (e2) => {
          onExpand(record, e2);
          e2.stopPropagation();
        },
        "class": classNames(iconPrefix, {
          [`${iconPrefix}-spaced`]: !expandable,
          [`${iconPrefix}-expanded`]: expandable && expanded,
          [`${iconPrefix}-collapsed`]: expandable && !expanded
        }),
        "aria-label": expanded ? locale2.collapse : locale2.expand,
        "aria-expanded": expanded
      }, null);
    };
  }
  function fillSlots(columns, contextSlots) {
    const $slots = contextSlots.value;
    return columns.map((column2) => {
      var _a2;
      if (column2 === SELECTION_COLUMN || column2 === EXPAND_COLUMN) return column2;
      const cloneColumn = _extends$1({}, column2);
      const {
        slots = {}
      } = cloneColumn;
      cloneColumn.__originColumn__ = column2;
      devWarning(!("slots" in cloneColumn), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead.");
      Object.keys(slots).forEach((key2) => {
        const name = slots[key2];
        if (cloneColumn[key2] === void 0 && $slots[name]) {
          cloneColumn[key2] = $slots[name];
        }
      });
      if (contextSlots.value.headerCell && !((_a2 = column2.slots) === null || _a2 === void 0 ? void 0 : _a2.title)) {
        cloneColumn.title = customRenderSlot(contextSlots.value, "headerCell", {
          title: column2.title,
          column: column2
        }, () => [column2.title]);
      }
      if ("children" in cloneColumn && Array.isArray(cloneColumn.children)) {
        cloneColumn.children = fillSlots(cloneColumn.children, contextSlots);
      }
      return cloneColumn;
    });
  }
  function useColumns(contextSlots) {
    const filledColumns = (columns) => fillSlots(columns, contextSlots);
    return [filledColumns];
  }
  const genBorderedStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
    const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
      [`&${componentCls}-${size}`]: {
        [`> ${componentCls}-container`]: {
          [`> ${componentCls}-content, > ${componentCls}-body`]: {
            "> table > tbody > tr > td": {
              [`> ${componentCls}-expanded-row-fixed`]: {
                margin: `-${paddingVertical}px -${paddingHorizontal + token2.lineWidth}px`
              }
            }
          }
        }
      }
    });
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}${componentCls}-bordered`]: _extends$1(_extends$1(_extends$1({
          // ============================ Title =============================
          [`> ${componentCls}-title`]: {
            border: tableBorder,
            borderBottom: 0
          },
          // ============================ Content ============================
          [`> ${componentCls}-container`]: {
            borderInlineStart: tableBorder,
            [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
              "> table": {
                // ============================= Cell =============================
                [`
                > thead > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                  borderInlineEnd: tableBorder
                },
                // ============================ Header ============================
                "> thead": {
                  "> tr:not(:last-child) > th": {
                    borderBottom: tableBorder
                  },
                  "> tr > th::before": {
                    backgroundColor: "transparent !important"
                  }
                },
                // Fixed right should provides additional border
                [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                  [`> ${componentCls}-cell-fix-right-first::after`]: {
                    borderInlineEnd: tableBorder
                  }
                },
                // ========================== Expandable ==========================
                "> tbody > tr > td": {
                  [`> ${componentCls}-expanded-row-fixed`]: {
                    margin: `-${token2.tablePaddingVertical}px -${token2.tablePaddingHorizontal + token2.lineWidth}px`,
                    "&::after": {
                      position: "absolute",
                      top: 0,
                      insetInlineEnd: token2.lineWidth,
                      bottom: 0,
                      borderInlineEnd: tableBorder,
                      content: '""'
                    }
                  }
                }
              }
            },
            [`
            > ${componentCls}-content,
            > ${componentCls}-header
          `]: {
              "> table": {
                borderTop: tableBorder
              }
            }
          },
          // ============================ Scroll ============================
          [`&${componentCls}-scroll-horizontal`]: {
            [`> ${componentCls}-container > ${componentCls}-body`]: {
              "> table > tbody": {
                [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                  "> td": {
                    borderInlineEnd: 0
                  }
                }
              }
            }
          }
        }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
          // ============================ Footer ============================
          [`> ${componentCls}-footer`]: {
            border: tableBorder,
            borderTop: 0
          }
        }),
        // ============================ Nested ============================
        [`${componentCls}-cell`]: {
          [`${componentCls}-container:first-child`]: {
            // :first-child to avoid the case when bordered and title is set
            borderTop: 0
          },
          // https://github.com/ant-design/ant-design/issues/35577
          "&-scrollbar:not([rowspan])": {
            boxShadow: `0 ${token2.lineWidth}px 0 ${token2.lineWidth}px ${token2.tableHeaderBg}`
          }
        }
      }
    };
  };
  const genEllipsisStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-cell-ellipsis`]: _extends$1(_extends$1({}, textEllipsis), {
          wordBreak: "keep-all",
          // Fixed first or last should special process
          [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
            overflow: "visible",
            [`${componentCls}-cell-content`]: {
              display: "block",
              overflow: "hidden",
              textOverflow: "ellipsis"
            }
          },
          [`${componentCls}-column-title`]: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            wordBreak: "keep-all"
          }
        })
      }
    };
  };
  const genEmptyStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
          textAlign: "center",
          color: token2.colorTextDisabled,
          "&:hover > td": {
            background: token2.colorBgContainer
          }
        }
      }
    };
  };
  const genExpandStyle = (token2) => {
    const {
      componentCls,
      antCls,
      controlInteractiveSize: checkboxSize,
      motionDurationSlow,
      lineWidth,
      paddingXS,
      lineType,
      tableBorderColor,
      tableExpandIconBg,
      tableExpandColumnWidth,
      borderRadius,
      fontSize,
      fontSizeSM,
      lineHeight,
      tablePaddingVertical,
      tablePaddingHorizontal,
      tableExpandedRowBg,
      paddingXXS
    } = token2;
    const halfInnerSize = checkboxSize / 2 - lineWidth;
    const expandIconSize = halfInnerSize * 2 + lineWidth * 3;
    const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
    const expandIconLineOffset = paddingXXS - lineWidth;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-expand-icon-col`]: {
          width: tableExpandColumnWidth
        },
        [`${componentCls}-row-expand-icon-cell`]: {
          textAlign: "center",
          [`${componentCls}-row-expand-icon`]: {
            display: "inline-flex",
            float: "none",
            verticalAlign: "sub"
          }
        },
        [`${componentCls}-row-indent`]: {
          height: 1,
          float: "left"
        },
        [`${componentCls}-row-expand-icon`]: _extends$1(_extends$1({}, operationUnit(token2)), {
          position: "relative",
          float: "left",
          boxSizing: "border-box",
          width: expandIconSize,
          height: expandIconSize,
          padding: 0,
          color: "inherit",
          lineHeight: `${expandIconSize}px`,
          background: tableExpandIconBg,
          border: tableBorder,
          borderRadius,
          transform: `scale(${checkboxSize / expandIconSize})`,
          transition: `all ${motionDurationSlow}`,
          userSelect: "none",
          [`&:focus, &:hover, &:active`]: {
            borderColor: "currentcolor"
          },
          [`&::before, &::after`]: {
            position: "absolute",
            background: "currentcolor",
            transition: `transform ${motionDurationSlow} ease-out`,
            content: '""'
          },
          "&::before": {
            top: halfInnerSize,
            insetInlineEnd: expandIconLineOffset,
            insetInlineStart: expandIconLineOffset,
            height: lineWidth
          },
          "&::after": {
            top: expandIconLineOffset,
            bottom: expandIconLineOffset,
            insetInlineStart: halfInnerSize,
            width: lineWidth,
            transform: "rotate(90deg)"
          },
          // Motion effect
          "&-collapsed::before": {
            transform: "rotate(-180deg)"
          },
          "&-collapsed::after": {
            transform: "rotate(0deg)"
          },
          "&-spaced": {
            "&::before, &::after": {
              display: "none",
              content: "none"
            },
            background: "transparent",
            border: 0,
            visibility: "hidden"
          }
        }),
        [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
          marginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
          marginInlineEnd: paddingXS
        },
        [`tr${componentCls}-expanded-row`]: {
          "&, &:hover": {
            "> td": {
              background: tableExpandedRowBg
            }
          },
          // https://github.com/ant-design/ant-design/issues/25573
          [`${antCls}-descriptions-view`]: {
            display: "flex",
            table: {
              flex: "auto",
              width: "auto"
            }
          }
        },
        // With fixed
        [`${componentCls}-expanded-row-fixed`]: {
          position: "relative",
          margin: `-${tablePaddingVertical}px -${tablePaddingHorizontal}px`,
          padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
        }
      }
    };
  };
  const genFilterStyle = (token2) => {
    const {
      componentCls,
      antCls,
      iconCls,
      tableFilterDropdownWidth,
      tableFilterDropdownSearchWidth,
      paddingXXS,
      paddingXS,
      colorText,
      lineWidth,
      lineType,
      tableBorderColor,
      tableHeaderIconColor,
      fontSizeSM,
      tablePaddingHorizontal,
      borderRadius,
      motionDurationSlow,
      colorTextDescription,
      colorPrimary,
      tableHeaderFilterActiveBg,
      colorTextDisabled,
      tableFilterDropdownBg,
      tableFilterDropdownHeight,
      controlItemBgHover,
      controlItemBgActive,
      boxShadowSecondary
    } = token2;
    const dropdownPrefixCls = `${antCls}-dropdown`;
    const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
    const treePrefixCls = `${antCls}-tree`;
    const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
    return [
      {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-filter-column`]: {
            display: "flex",
            justifyContent: "space-between"
          },
          [`${componentCls}-filter-trigger`]: {
            position: "relative",
            display: "flex",
            alignItems: "center",
            marginBlock: -paddingXXS,
            marginInline: `${paddingXXS}px ${-tablePaddingHorizontal / 2}px`,
            padding: `0 ${paddingXXS}px`,
            color: tableHeaderIconColor,
            fontSize: fontSizeSM,
            borderRadius,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorTextDescription,
              background: tableHeaderFilterActiveBg
            },
            "&.active": {
              color: colorPrimary
            }
          }
        }
      },
      {
        // Dropdown
        [`${antCls}-dropdown`]: {
          [tableFilterDropdownPrefixCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
            minWidth: tableFilterDropdownWidth,
            backgroundColor: tableFilterDropdownBg,
            borderRadius,
            boxShadow: boxShadowSecondary,
            // Reset menu
            [`${dropdownPrefixCls}-menu`]: {
              // https://github.com/ant-design/ant-design/issues/4916
              // https://github.com/ant-design/ant-design/issues/19542
              maxHeight: tableFilterDropdownHeight,
              overflowX: "hidden",
              border: 0,
              boxShadow: "none",
              "&:empty::after": {
                display: "block",
                padding: `${paddingXS}px 0`,
                color: colorTextDisabled,
                fontSize: fontSizeSM,
                textAlign: "center",
                content: '"Not Found"'
              }
            },
            [`${tableFilterDropdownPrefixCls}-tree`]: {
              paddingBlock: `${paddingXS}px 0`,
              paddingInline: paddingXS,
              [treePrefixCls]: {
                padding: 0
              },
              [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
                backgroundColor: controlItemBgHover
              },
              [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
                "&, &:hover": {
                  backgroundColor: controlItemBgActive
                }
              }
            },
            [`${tableFilterDropdownPrefixCls}-search`]: {
              padding: paddingXS,
              borderBottom: tableBorder,
              "&-input": {
                input: {
                  minWidth: tableFilterDropdownSearchWidth
                },
                [iconCls]: {
                  color: colorTextDisabled
                }
              }
            },
            [`${tableFilterDropdownPrefixCls}-checkall`]: {
              width: "100%",
              marginBottom: paddingXXS,
              marginInlineStart: paddingXXS
            },
            // Operation
            [`${tableFilterDropdownPrefixCls}-btns`]: {
              display: "flex",
              justifyContent: "space-between",
              padding: `${paddingXS - lineWidth}px ${paddingXS}px`,
              overflow: "hidden",
              backgroundColor: "inherit",
              borderTop: tableBorder
            }
          })
        }
      },
      // Dropdown Menu & SubMenu
      {
        // submenu of table filter dropdown
        [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
          // Checkbox
          [`${antCls}-checkbox-wrapper + span`]: {
            paddingInlineStart: paddingXS,
            color: colorText
          },
          [`> ul`]: {
            maxHeight: "calc(100vh - 130px)",
            overflowX: "hidden",
            overflowY: "auto"
          }
        }
      }
    ];
  };
  const genFixedStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      colorSplit,
      motionDurationSlow,
      zIndexTableFixed,
      tableBg,
      zIndexTableSticky
    } = token2;
    const shadowColor = colorSplit;
    return {
      [`${componentCls}-wrapper`]: {
        [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
          position: "sticky !important",
          zIndex: zIndexTableFixed,
          background: tableBg
        },
        [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
          position: "absolute",
          top: 0,
          right: {
            _skip_check_: true,
            value: 0
          },
          bottom: -lineWidth,
          width: 30,
          transform: "translateX(100%)",
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        [`${componentCls}-cell-fix-left-all::after`]: {
          display: "none"
        },
        [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
          position: "absolute",
          top: 0,
          bottom: -lineWidth,
          left: {
            _skip_check_: true,
            value: 0
          },
          width: 30,
          transform: "translateX(-100%)",
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        [`${componentCls}-container`]: {
          "&::before, &::after": {
            position: "absolute",
            top: 0,
            bottom: 0,
            zIndex: zIndexTableSticky + 1,
            width: 30,
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          "&::before": {
            insetInlineStart: 0
          },
          "&::after": {
            insetInlineEnd: 0
          }
        },
        [`${componentCls}-ping-left`]: {
          [`&:not(${componentCls}-has-fix-left) ${componentCls}-container`]: {
            position: "relative",
            "&::before": {
              boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
            }
          },
          [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
            boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
          },
          [`${componentCls}-cell-fix-left-last::before`]: {
            backgroundColor: "transparent !important"
          }
        },
        [`${componentCls}-ping-right`]: {
          [`&:not(${componentCls}-has-fix-right) ${componentCls}-container`]: {
            position: "relative",
            "&::after": {
              boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
            }
          },
          [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
            boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
          }
        }
      }
    };
  };
  const genPaginationStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        // ========================== Pagination ==========================
        [`${componentCls}-pagination${antCls}-pagination`]: {
          margin: `${token2.margin}px 0`
        },
        [`${componentCls}-pagination`]: {
          display: "flex",
          flexWrap: "wrap",
          rowGap: token2.paddingXS,
          "> *": {
            flex: "none"
          },
          "&-left": {
            justifyContent: "flex-start"
          },
          "&-center": {
            justifyContent: "center"
          },
          "&-right": {
            justifyContent: "flex-end"
          }
        }
      }
    };
  };
  const genRadiusStyle = (token2) => {
    const {
      componentCls,
      tableRadius
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [componentCls]: {
          // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
          [`${componentCls}-title, ${componentCls}-header`]: {
            borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
          },
          [`${componentCls}-title + ${componentCls}-container`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0,
            table: {
              borderRadius: 0,
              "> thead > tr:first-child": {
                "th:first-child": {
                  borderRadius: 0
                },
                "th:last-child": {
                  borderRadius: 0
                }
              }
            }
          },
          "&-container": {
            borderStartStartRadius: tableRadius,
            borderStartEndRadius: tableRadius,
            "table > thead > tr:first-child": {
              "> *:first-child": {
                borderStartStartRadius: tableRadius
              },
              "> *:last-child": {
                borderStartEndRadius: tableRadius
              }
            }
          },
          "&-footer": {
            borderRadius: `0 0 ${tableRadius}px ${tableRadius}px`
          }
        }
      }
    };
  };
  const genStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper-rtl`]: {
        direction: "rtl",
        table: {
          direction: "rtl"
        },
        [`${componentCls}-pagination-left`]: {
          justifyContent: "flex-end"
        },
        [`${componentCls}-pagination-right`]: {
          justifyContent: "flex-start"
        },
        [`${componentCls}-row-expand-icon`]: {
          "&::after": {
            transform: "rotate(-90deg)"
          },
          "&-collapsed::before": {
            transform: "rotate(180deg)"
          },
          "&-collapsed::after": {
            transform: "rotate(0deg)"
          }
        }
      }
    };
  };
  const genSelectionStyle = (token2) => {
    const {
      componentCls,
      antCls,
      iconCls,
      fontSizeIcon,
      paddingXS,
      tableHeaderIconColor,
      tableHeaderIconColorHover
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        // ========================== Selections ==========================
        [`${componentCls}-selection-col`]: {
          width: token2.tableSelectionColumnWidth
        },
        [`${componentCls}-bordered ${componentCls}-selection-col`]: {
          width: token2.tableSelectionColumnWidth + paddingXS * 2
        },
        [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column
      `]: {
          paddingInlineEnd: token2.paddingXS,
          paddingInlineStart: token2.paddingXS,
          textAlign: "center",
          [`${antCls}-radio-wrapper`]: {
            marginInlineEnd: 0
          }
        },
        [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
          zIndex: token2.zIndexTableFixed + 1
        },
        [`table tr th${componentCls}-selection-column::after`]: {
          backgroundColor: "transparent !important"
        },
        [`${componentCls}-selection`]: {
          position: "relative",
          display: "inline-flex",
          flexDirection: "column"
        },
        [`${componentCls}-selection-extra`]: {
          position: "absolute",
          top: 0,
          zIndex: 1,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          marginInlineStart: "100%",
          paddingInlineStart: `${token2.tablePaddingHorizontal / 4}px`,
          [iconCls]: {
            color: tableHeaderIconColor,
            fontSize: fontSizeIcon,
            verticalAlign: "baseline",
            "&:hover": {
              color: tableHeaderIconColorHover
            }
          }
        }
      }
    };
  };
  const genSizeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
      [`${componentCls}${componentCls}-${size}`]: {
        fontSize,
        [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
          padding: `${paddingVertical}px ${paddingHorizontal}px`
        },
        [`${componentCls}-filter-trigger`]: {
          marginInlineEnd: `-${paddingHorizontal / 2}px`
        },
        [`${componentCls}-expanded-row-fixed`]: {
          margin: `-${paddingVertical}px -${paddingHorizontal}px`
        },
        [`${componentCls}-tbody`]: {
          // ========================= Nest Table ===========================
          [`${componentCls}-wrapper:only-child ${componentCls}`]: {
            marginBlock: `-${paddingVertical}px`,
            marginInline: `${token2.tableExpandColumnWidth - paddingHorizontal}px -${paddingHorizontal}px`
          }
        },
        // https://github.com/ant-design/ant-design/issues/35167
        [`${componentCls}-selection-column`]: {
          paddingInlineStart: `${paddingHorizontal / 4}px`
        }
      }
    });
    return {
      [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
    };
  };
  const genResizeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-wrapper ${componentCls}-resize-handle`]: {
        position: "absolute",
        top: 0,
        height: "100% !important",
        bottom: 0,
        left: " auto !important",
        right: " -8px",
        cursor: "col-resize",
        touchAction: "none",
        userSelect: "auto",
        width: "16px",
        zIndex: 1,
        [`&-line`]: {
          display: "block",
          width: "1px",
          marginLeft: "7px",
          height: "100% !important",
          backgroundColor: token2.colorPrimary,
          opacity: 0
        },
        [`&:hover &-line`]: {
          opacity: 1
        }
      },
      [`${componentCls}-wrapper  ${componentCls}-resize-handle.dragging`]: {
        overflow: "hidden",
        [`${componentCls}-resize-handle-line`]: {
          opacity: 1
        },
        [`&:before`]: {
          position: "absolute",
          top: 0,
          bottom: 0,
          content: '" "',
          width: "200vw",
          transform: "translateX(-50%)",
          opacity: 0
        }
      }
    };
  };
  const genSorterStyle = (token2) => {
    const {
      componentCls,
      marginXXS,
      fontSizeIcon,
      tableHeaderIconColor,
      tableHeaderIconColorHover
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
          outline: "none",
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "&:hover": {
            background: token2.tableHeaderSortHoverBg,
            "&::before": {
              backgroundColor: "transparent !important"
            }
          },
          "&:focus-visible": {
            color: token2.colorPrimary
          },
          // https://github.com/ant-design/ant-design/issues/30969
          [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
            background: token2.tableFixedHeaderSortActiveBg
          }
        },
        [`${componentCls}-thead th${componentCls}-column-sort`]: {
          background: token2.tableHeaderSortBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        [`td${componentCls}-column-sort`]: {
          background: token2.tableBodySortBg
        },
        [`${componentCls}-column-title`]: {
          position: "relative",
          zIndex: 1,
          flex: 1
        },
        [`${componentCls}-column-sorters`]: {
          display: "flex",
          flex: "auto",
          alignItems: "center",
          justifyContent: "space-between",
          "&::after": {
            position: "absolute",
            inset: 0,
            width: "100%",
            height: "100%",
            content: '""'
          }
        },
        [`${componentCls}-column-sorter`]: {
          marginInlineStart: marginXXS,
          color: tableHeaderIconColor,
          fontSize: 0,
          transition: `color ${token2.motionDurationSlow}`,
          "&-inner": {
            display: "inline-flex",
            flexDirection: "column",
            alignItems: "center"
          },
          "&-up, &-down": {
            fontSize: fontSizeIcon,
            "&.active": {
              color: token2.colorPrimary
            }
          },
          [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
            marginTop: "-0.3em"
          }
        },
        [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
          color: tableHeaderIconColorHover
        }
      }
    };
  };
  const genStickyStyle = (token2) => {
    const {
      componentCls,
      opacityLoading,
      tableScrollThumbBg,
      tableScrollThumbBgHover,
      tableScrollThumbSize,
      tableScrollBg,
      zIndexTableSticky
    } = token2;
    const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-sticky`]: {
          "&-holder": {
            position: "sticky",
            zIndex: zIndexTableSticky,
            background: token2.colorBgContainer
          },
          "&-scroll": {
            position: "sticky",
            bottom: 0,
            height: `${tableScrollThumbSize}px !important`,
            zIndex: zIndexTableSticky,
            display: "flex",
            alignItems: "center",
            background: tableScrollBg,
            borderTop: tableBorder,
            opacity: opacityLoading,
            "&:hover": {
              transformOrigin: "center bottom"
            },
            // fake scrollbar style of sticky
            "&-bar": {
              height: tableScrollThumbSize,
              backgroundColor: tableScrollThumbBg,
              borderRadius: 100,
              transition: `all ${token2.motionDurationSlow}, transform none`,
              position: "absolute",
              bottom: 0,
              "&:hover, &-active": {
                backgroundColor: tableScrollThumbBgHover
              }
            }
          }
        }
      }
    };
  };
  const genSummaryStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      tableBorderColor
    } = token2;
    const tableBorder = `${lineWidth}px ${token2.lineType} ${tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-summary`]: {
          position: "relative",
          zIndex: token2.zIndexTableFixed,
          background: token2.tableBg,
          "> tr": {
            "> th, > td": {
              borderBottom: tableBorder
            }
          }
        },
        [`div${componentCls}-summary`]: {
          boxShadow: `0 -${lineWidth}px 0 ${tableBorderColor}`
        }
      }
    };
  };
  const genTableStyle = (token2) => {
    const {
      componentCls,
      fontWeightStrong,
      tablePaddingVertical,
      tablePaddingHorizontal,
      lineWidth,
      lineType,
      tableBorderColor,
      tableFontSize,
      tableBg,
      tableRadius,
      tableHeaderTextColor,
      motionDurationMid,
      tableHeaderBg,
      tableHeaderCellSplitColor,
      tableRowHoverBg,
      tableSelectedRowBg,
      tableSelectedRowHoverBg,
      tableFooterTextColor,
      tableFooterBg,
      paddingContentVerticalLG
    } = token2;
    const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
    return {
      [`${componentCls}-wrapper`]: _extends$1(_extends$1({
        clear: "both",
        maxWidth: "100%"
      }, clearFix()), {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          fontSize: tableFontSize,
          background: tableBg,
          borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
        }),
        // https://github.com/ant-design/ant-design/issues/17611
        table: {
          width: "100%",
          textAlign: "start",
          borderRadius: `${tableRadius}px ${tableRadius}px 0 0`,
          borderCollapse: "separate",
          borderSpacing: 0
        },
        // ============================= Cell =============================
        [`
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
          position: "relative",
          padding: `${paddingContentVerticalLG}px ${tablePaddingHorizontal}px`,
          overflowWrap: "break-word"
        },
        // ============================ Title =============================
        [`${componentCls}-title`]: {
          padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
        },
        // ============================ Header ============================
        [`${componentCls}-thead`]: {
          [`
          > tr > th,
          > tr > td
        `]: {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`,
            "&[colspan]:not([colspan='1'])": {
              textAlign: "center"
            },
            [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
              position: "absolute",
              top: "50%",
              insetInlineEnd: 0,
              width: 1,
              height: "1.6em",
              backgroundColor: tableHeaderCellSplitColor,
              transform: "translateY(-50%)",
              transition: `background-color ${motionDurationMid}`,
              content: '""'
            }
          },
          "> tr:not(:last-child) > th[colspan]": {
            borderBottom: 0
          }
        },
        // ============================ Body ============================
        // Borderless Table has unique hover style, which would be implemented with `borderTop`.
        [`${componentCls}:not(${componentCls}-bordered)`]: {
          [`${componentCls}-tbody`]: {
            "> tr": {
              "> td": {
                borderTop: tableBorder,
                borderBottom: "transparent"
              },
              "&:last-child > td": {
                borderBottom: tableBorder
              },
              [`&:first-child > td,
              &${componentCls}-measure-row + tr > td`]: {
                borderTop: "none",
                borderTopColor: "transparent"
              }
            }
          }
        },
        // Bordered Table remains simple `borderBottom`.
        // Ref issue: https://github.com/ant-design/ant-design/issues/38724
        [`${componentCls}${componentCls}-bordered`]: {
          [`${componentCls}-tbody`]: {
            "> tr": {
              "> td": {
                borderBottom: tableBorder
              }
            }
          }
        },
        [`${componentCls}-tbody`]: {
          "> tr": {
            "> td": {
              transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
              // ========================= Nest Table ===========================
              [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
                [componentCls]: {
                  marginBlock: `-${tablePaddingVertical}px`,
                  marginInline: `${token2.tableExpandColumnWidth - tablePaddingHorizontal}px -${tablePaddingHorizontal}px`,
                  [`${componentCls}-tbody > tr:last-child > td`]: {
                    borderBottom: 0,
                    "&:first-child, &:last-child": {
                      borderRadius: 0
                    }
                  }
                }
              }
            },
            [`
            &${componentCls}-row:hover > td,
            > td${componentCls}-cell-row-hover
          `]: {
              background: tableRowHoverBg
            },
            [`&${componentCls}-row-selected`]: {
              "> td": {
                background: tableSelectedRowBg
              },
              "&:hover > td": {
                background: tableSelectedRowHoverBg
              }
            }
          }
        },
        // ============================ Footer ============================
        [`${componentCls}-footer`]: {
          padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`,
          color: tableFooterTextColor,
          background: tableFooterBg
        }
      })
    };
  };
  const useStyle = genComponentStyleHook("Table", (token2) => {
    const {
      controlItemBgActive,
      controlItemBgActiveHover,
      colorTextPlaceholder,
      colorTextHeading,
      colorSplit,
      colorBorderSecondary,
      fontSize,
      padding,
      paddingXS,
      paddingSM,
      controlHeight,
      colorFillAlter,
      colorIcon,
      colorIconHover,
      opacityLoading,
      colorBgContainer,
      borderRadiusLG,
      colorFillContent,
      colorFillSecondary,
      controlInteractiveSize: checkboxSize
    } = token2;
    const baseColorAction = new TinyColor(colorIcon);
    const baseColorActionHover = new TinyColor(colorIconHover);
    const tableSelectedRowBg = controlItemBgActive;
    const zIndexTableFixed = 2;
    const colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
    const colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexString();
    const colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
    const tableToken = merge$2(token2, {
      tableFontSize: fontSize,
      tableBg: colorBgContainer,
      tableRadius: borderRadiusLG,
      tablePaddingVertical: padding,
      tablePaddingHorizontal: padding,
      tablePaddingVerticalMiddle: paddingSM,
      tablePaddingHorizontalMiddle: paddingXS,
      tablePaddingVerticalSmall: paddingXS,
      tablePaddingHorizontalSmall: paddingXS,
      tableBorderColor: colorBorderSecondary,
      tableHeaderTextColor: colorTextHeading,
      tableHeaderBg: colorFillAlterSolid,
      tableFooterTextColor: colorTextHeading,
      tableFooterBg: colorFillAlterSolid,
      tableHeaderCellSplitColor: colorBorderSecondary,
      tableHeaderSortBg: colorFillSecondarySolid,
      tableHeaderSortHoverBg: colorFillContentSolid,
      tableHeaderIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
      tableHeaderIconColorHover: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
      tableBodySortBg: colorFillAlterSolid,
      tableFixedHeaderSortActiveBg: colorFillSecondarySolid,
      tableHeaderFilterActiveBg: colorFillContent,
      tableFilterDropdownBg: colorBgContainer,
      tableRowHoverBg: colorFillAlterSolid,
      tableSelectedRowBg,
      tableSelectedRowHoverBg: controlItemBgActiveHover,
      zIndexTableFixed,
      zIndexTableSticky: zIndexTableFixed + 1,
      tableFontSizeMiddle: fontSize,
      tableFontSizeSmall: fontSize,
      tableSelectionColumnWidth: controlHeight,
      tableExpandIconBg: colorBgContainer,
      tableExpandColumnWidth: checkboxSize + 2 * token2.padding,
      tableExpandedRowBg: colorFillAlter,
      // Dropdown
      tableFilterDropdownWidth: 120,
      tableFilterDropdownHeight: 264,
      tableFilterDropdownSearchWidth: 140,
      // Virtual Scroll Bar
      tableScrollThumbSize: 8,
      tableScrollThumbBg: colorTextPlaceholder,
      tableScrollThumbBgHover: colorTextHeading,
      tableScrollBg: colorSplit
    });
    return [genTableStyle(tableToken), genPaginationStyle(tableToken), genSummaryStyle(tableToken), genSorterStyle(tableToken), genFilterStyle(tableToken), genBorderedStyle(tableToken), genRadiusStyle(tableToken), genExpandStyle(tableToken), genSummaryStyle(tableToken), genEmptyStyle(tableToken), genSelectionStyle(tableToken), genFixedStyle(tableToken), genStickyStyle(tableToken), genEllipsisStyle(tableToken), genSizeStyle(tableToken), genResizeStyle(tableToken), genStyle(tableToken)];
  });
  const EMPTY_LIST = [];
  const tableProps = () => {
    return {
      prefixCls: stringType(),
      columns: arrayType(),
      rowKey: someType([String, Function]),
      tableLayout: stringType(),
      rowClassName: someType([String, Function]),
      title: functionType(),
      footer: functionType(),
      id: stringType(),
      showHeader: booleanType(),
      components: objectType(),
      customRow: functionType(),
      customHeaderRow: functionType(),
      direction: stringType(),
      expandFixed: someType([Boolean, String]),
      expandColumnWidth: Number,
      expandedRowKeys: arrayType(),
      defaultExpandedRowKeys: arrayType(),
      expandedRowRender: functionType(),
      expandRowByClick: booleanType(),
      expandIcon: functionType(),
      onExpand: functionType(),
      onExpandedRowsChange: functionType(),
      "onUpdate:expandedRowKeys": functionType(),
      defaultExpandAllRows: booleanType(),
      indentSize: Number,
      /** @deprecated Please use `EXPAND_COLUMN` in `columns` directly */
      expandIconColumnIndex: Number,
      showExpandColumn: booleanType(),
      expandedRowClassName: functionType(),
      childrenColumnName: stringType(),
      rowExpandable: functionType(),
      sticky: someType([Boolean, Object]),
      dropdownPrefixCls: String,
      dataSource: arrayType(),
      pagination: someType([Boolean, Object]),
      loading: someType([Boolean, Object]),
      size: stringType(),
      bordered: booleanType(),
      locale: objectType(),
      onChange: functionType(),
      onResizeColumn: functionType(),
      rowSelection: objectType(),
      getPopupContainer: functionType(),
      scroll: objectType(),
      sortDirections: arrayType(),
      showSorterTooltip: someType([Boolean, Object], true),
      transformCellText: functionType()
    };
  };
  const InternalTable = /* @__PURE__ */ defineComponent({
    name: "InternalTable",
    inheritAttrs: false,
    props: initDefaultProps(_extends$1(_extends$1({}, tableProps()), {
      contextSlots: objectType()
    }), {
      rowKey: "key"
    }),
    setup(props2, _ref) {
      let {
        attrs,
        slots,
        expose,
        emit: emit2
      } = _ref;
      devWarning(!(typeof props2.rowKey === "function" && props2.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
      useProvideSlots(computed(() => props2.contextSlots));
      useProvideTableContext({
        onResizeColumn: (w2, col) => {
          emit2("resizeColumn", w2, col);
        }
      });
      const screens = useBreakpoint();
      const mergedColumns = computed(() => {
        const matched = new Set(Object.keys(screens.value).filter((m2) => screens.value[m2]));
        return props2.columns.filter((c2) => !c2.responsive || c2.responsive.some((r2) => matched.has(r2)));
      });
      const {
        size: mergedSize,
        renderEmpty: renderEmpty2,
        direction,
        prefixCls,
        configProvider
      } = useConfigInject("table", props2);
      const [wrapSSR, hashId] = useStyle(prefixCls);
      const transformCellText = computed(() => {
        var _a2;
        return props2.transformCellText || ((_a2 = configProvider.transformCellText) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      const [tableLocale] = useLocaleReceiver("Table", localeValues$1.Table, toRef(props2, "locale"));
      const rawData = computed(() => props2.dataSource || EMPTY_LIST);
      const dropdownPrefixCls = computed(() => configProvider.getPrefixCls("dropdown", props2.dropdownPrefixCls));
      const childrenColumnName = computed(() => props2.childrenColumnName || "children");
      const expandType = computed(() => {
        if (rawData.value.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName.value])) {
          return "nest";
        }
        if (props2.expandedRowRender) {
          return "row";
        }
        return null;
      });
      const internalRefs = reactive({
        body: null
      });
      const updateInternalRefs = (refs) => {
        _extends$1(internalRefs, refs);
      };
      const getRowKey = computed(() => {
        if (typeof props2.rowKey === "function") {
          return props2.rowKey;
        }
        return (record) => record === null || record === void 0 ? void 0 : record[props2.rowKey];
      });
      const [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey);
      const changeEventInfo = {};
      const triggerOnChange = function(info, action) {
        let reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const {
          pagination,
          scroll,
          onChange
        } = props2;
        const changeInfo = _extends$1(_extends$1({}, changeEventInfo), info);
        if (reset) {
          changeEventInfo.resetPagination();
          if (changeInfo.pagination.current) {
            changeInfo.pagination.current = 1;
          }
          if (pagination && pagination.onChange) {
            pagination.onChange(1, changeInfo.pagination.pageSize);
          }
        }
        if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body) {
          scrollTo(0, {
            getContainer: () => internalRefs.body
          });
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
          currentDataSource: getFilterData(getSortData(rawData.value, changeInfo.sorterStates, childrenColumnName.value), changeInfo.filterStates),
          action
        });
      };
      const onSorterChange = (sorter, sorterStates) => {
        triggerOnChange({
          sorter,
          sorterStates
        }, "sort", false);
      };
      const [transformSorterColumns, sortStates, sorterTitleProps, sorters] = useFilterSorter({
        prefixCls,
        mergedColumns,
        onSorterChange,
        sortDirections: computed(() => props2.sortDirections || ["ascend", "descend"]),
        tableLocale,
        showSorterTooltip: toRef(props2, "showSorterTooltip")
      });
      const sortedData = computed(() => getSortData(rawData.value, sortStates.value, childrenColumnName.value));
      const onFilterChange = (filters2, filterStates2) => {
        triggerOnChange({
          filters: filters2,
          filterStates: filterStates2
        }, "filter", true);
      };
      const [transformFilterColumns, filterStates, filters] = useFilter({
        prefixCls,
        locale: tableLocale,
        dropdownPrefixCls,
        mergedColumns,
        onFilterChange,
        getPopupContainer: toRef(props2, "getPopupContainer")
      });
      const mergedData = computed(() => getFilterData(sortedData.value, filterStates.value));
      const [transformBasicColumns] = useColumns(toRef(props2, "contextSlots"));
      const columnTitleProps = computed(() => {
        const mergedFilters = {};
        const filtersValue = filters.value;
        Object.keys(filtersValue).forEach((filterKey) => {
          if (filtersValue[filterKey] !== null) {
            mergedFilters[filterKey] = filtersValue[filterKey];
          }
        });
        return _extends$1(_extends$1({}, sorterTitleProps.value), {
          filters: mergedFilters
        });
      });
      const [transformTitleColumns] = useTitleColumns(columnTitleProps);
      const onPaginationChange = (current, pageSize) => {
        triggerOnChange({
          pagination: _extends$1(_extends$1({}, changeEventInfo.pagination), {
            current,
            pageSize
          })
        }, "paginate");
      };
      const [mergedPagination, resetPagination] = usePagination(computed(() => mergedData.value.length), toRef(props2, "pagination"), onPaginationChange);
      watchEffect(() => {
        changeEventInfo.sorter = sorters.value;
        changeEventInfo.sorterStates = sortStates.value;
        changeEventInfo.filters = filters.value;
        changeEventInfo.filterStates = filterStates.value;
        changeEventInfo.pagination = props2.pagination === false ? {} : getPaginationParam(mergedPagination.value, props2.pagination);
        changeEventInfo.resetPagination = resetPagination;
      });
      const pageData = computed(() => {
        if (props2.pagination === false || !mergedPagination.value.pageSize) {
          return mergedData.value;
        }
        const {
          current = 1,
          total,
          pageSize = DEFAULT_PAGE_SIZE
        } = mergedPagination.value;
        devWarning(current > 0, "Table", "`current` should be positive number.");
        if (mergedData.value.length < total) {
          if (mergedData.value.length > pageSize) {
            return mergedData.value.slice((current - 1) * pageSize, current * pageSize);
          }
          return mergedData.value;
        }
        return mergedData.value.slice((current - 1) * pageSize, current * pageSize);
      });
      watchEffect(() => {
        nextTick(() => {
          const {
            total,
            pageSize = DEFAULT_PAGE_SIZE
          } = mergedPagination.value;
          if (mergedData.value.length < total) {
            if (mergedData.value.length > pageSize) {
              devWarning(false, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
            }
          }
        });
      }, {
        flush: "post"
      });
      const expandIconColumnIndex = computed(() => {
        if (props2.showExpandColumn === false) return -1;
        if (expandType.value === "nest" && props2.expandIconColumnIndex === void 0) {
          return props2.rowSelection ? 1 : 0;
        } else if (props2.expandIconColumnIndex > 0 && props2.rowSelection) {
          return props2.expandIconColumnIndex - 1;
        }
        return props2.expandIconColumnIndex;
      });
      const rowSelection = ref();
      watch(() => props2.rowSelection, () => {
        rowSelection.value = props2.rowSelection ? _extends$1({}, props2.rowSelection) : props2.rowSelection;
      }, {
        deep: true,
        immediate: true
      });
      const [transformSelectionColumns, selectedKeySet] = useSelection(rowSelection, {
        prefixCls,
        data: mergedData,
        pageData,
        getRowKey,
        getRecordByKey,
        expandType,
        childrenColumnName,
        locale: tableLocale,
        getPopupContainer: computed(() => props2.getPopupContainer)
      });
      const internalRowClassName = (record, index2, indent) => {
        let mergedRowClassName;
        const {
          rowClassName
        } = props2;
        if (typeof rowClassName === "function") {
          mergedRowClassName = classNames(rowClassName(record, index2, indent));
        } else {
          mergedRowClassName = classNames(rowClassName);
        }
        return classNames({
          [`${prefixCls.value}-row-selected`]: selectedKeySet.value.has(getRowKey.value(record, index2))
        }, mergedRowClassName);
      };
      expose({
        selectedKeySet
      });
      const indentSize = computed(() => {
        return typeof props2.indentSize === "number" ? props2.indentSize : 15;
      });
      const transformColumns = (innerColumns) => {
        const res = transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(transformBasicColumns(innerColumns)))));
        return res;
      };
      return () => {
        var _a2;
        const {
          expandIcon = slots.expandIcon || renderExpandIcon(tableLocale.value),
          pagination,
          loading,
          bordered
        } = props2;
        let topPaginationNode;
        let bottomPaginationNode;
        if (pagination !== false && ((_a2 = mergedPagination.value) === null || _a2 === void 0 ? void 0 : _a2.total)) {
          let paginationSize;
          if (mergedPagination.value.size) {
            paginationSize = mergedPagination.value.size;
          } else {
            paginationSize = mergedSize.value === "small" || mergedSize.value === "middle" ? "small" : void 0;
          }
          const renderPagination = (position3) => createVNode(Pagination$1, _objectSpread2$1(_objectSpread2$1({}, mergedPagination.value), {}, {
            "class": [`${prefixCls.value}-pagination ${prefixCls.value}-pagination-${position3}`, mergedPagination.value.class],
            "size": paginationSize
          }), null);
          const defaultPosition = direction.value === "rtl" ? "left" : "right";
          const {
            position: position2
          } = mergedPagination.value;
          if (position2 !== null && Array.isArray(position2)) {
            const topPos = position2.find((p2) => p2.includes("top"));
            const bottomPos = position2.find((p2) => p2.includes("bottom"));
            const isDisable = position2.every((p2) => `${p2}` === "none");
            if (!topPos && !bottomPos && !isDisable) {
              bottomPaginationNode = renderPagination(defaultPosition);
            }
            if (topPos) {
              topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
            }
            if (bottomPos) {
              bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
            }
          } else {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
        }
        let spinProps2;
        if (typeof loading === "boolean") {
          spinProps2 = {
            spinning: loading
          };
        } else if (typeof loading === "object") {
          spinProps2 = _extends$1({
            spinning: true
          }, loading);
        }
        const wrapperClassNames = classNames(`${prefixCls.value}-wrapper`, {
          [`${prefixCls.value}-wrapper-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value);
        const tableProps2 = omit$1(props2, ["columns"]);
        return wrapSSR(createVNode("div", {
          "class": wrapperClassNames,
          "style": attrs.style
        }, [createVNode(Spin, _objectSpread2$1({
          "spinning": false
        }, spinProps2), {
          default: () => [topPaginationNode, createVNode(Table$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), tableProps2), {}, {
            "expandedRowKeys": props2.expandedRowKeys,
            "defaultExpandedRowKeys": props2.defaultExpandedRowKeys,
            "expandIconColumnIndex": expandIconColumnIndex.value,
            "indentSize": indentSize.value,
            "expandIcon": expandIcon,
            "columns": mergedColumns.value,
            "direction": direction.value,
            "prefixCls": prefixCls.value,
            "class": classNames({
              [`${prefixCls.value}-middle`]: mergedSize.value === "middle",
              [`${prefixCls.value}-small`]: mergedSize.value === "small",
              [`${prefixCls.value}-bordered`]: bordered,
              [`${prefixCls.value}-empty`]: rawData.value.length === 0
            }),
            "data": pageData.value,
            "rowKey": getRowKey.value,
            "rowClassName": internalRowClassName,
            "internalHooks": INTERNAL_HOOKS,
            "internalRefs": internalRefs,
            "onUpdateInternalRefs": updateInternalRefs,
            "transformColumns": transformColumns,
            "transformCellText": transformCellText.value
          }), _extends$1(_extends$1({}, slots), {
            emptyText: () => {
              var _a3, _b2;
              return ((_a3 = slots.emptyText) === null || _a3 === void 0 ? void 0 : _a3.call(slots)) || ((_b2 = props2.locale) === null || _b2 === void 0 ? void 0 : _b2.emptyText) || renderEmpty2("Table");
            }
          })), bottomPaginationNode]
        })]));
      };
    }
  });
  const Table$1 = /* @__PURE__ */ defineComponent({
    name: "ATable",
    inheritAttrs: false,
    props: initDefaultProps(tableProps(), {
      rowKey: "key"
    }),
    slots: Object,
    setup(props2, _ref2) {
      let {
        attrs,
        slots,
        expose
      } = _ref2;
      const table = ref();
      expose({
        table
      });
      return () => {
        var _a2;
        const columns = props2.columns || convertChildrenToColumns((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        return createVNode(InternalTable, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "ref": table
        }, attrs), props2), {}, {
          "columns": columns || [],
          "expandedRowRender": slots.expandedRowRender || props2.expandedRowRender,
          "contextSlots": _extends$1({}, slots)
        }), slots);
      };
    }
  });
  const Column = /* @__PURE__ */ defineComponent({
    name: "ATableColumn",
    slots: Object,
    render() {
      return null;
    }
  });
  const ColumnGroup = /* @__PURE__ */ defineComponent({
    name: "ATableColumnGroup",
    slots: Object,
    __ANT_TABLE_COLUMN_GROUP: true,
    render() {
      return null;
    }
  });
  const TableSummaryRow = SummaryRow;
  const TableSummaryCell = SummaryCell;
  const TableSummary = _extends$1(FooterComponents, {
    Cell: TableSummaryCell,
    Row: TableSummaryRow,
    name: "ATableSummary"
  });
  const Table = _extends$1(Table$1, {
    SELECTION_ALL,
    SELECTION_INVERT,
    SELECTION_NONE,
    SELECTION_COLUMN,
    EXPAND_COLUMN,
    Column,
    ColumnGroup,
    Summary: TableSummary,
    install: (app2) => {
      app2.component(TableSummary.name, TableSummary);
      app2.component(TableSummaryCell.name, TableSummaryCell);
      app2.component(TableSummaryRow.name, TableSummaryRow);
      app2.component(Table$1.name, Table$1);
      app2.component(Column.name, Column);
      app2.component(ColumnGroup.name, ColumnGroup);
      return app2;
    }
  });
  function installAntd(app2) {
    app2.use(Button$1);
    app2.use(Form);
    app2.use(Input);
    app2.use(Table);
    app2.use(Select);
    app2.use(Row);
    app2.use(Col);
    app2.use(ConfigProvider);
    app2.use(Dropdown);
    app2.use(Avatar);
    app2.use(Pagination$1);
    app2.use(Badge);
  }
  var mock$1 = { exports: {} };
  var mock = mock$1.exports;
  var hasRequiredMock;
  function requireMock() {
    if (hasRequiredMock) return mock$1.exports;
    hasRequiredMock = 1;
    (function(module, exports) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        module.exports = factory();
      })(mock, function() {
        return (
          /******/
          function(modules) {
            var installedModules = {};
            function __webpack_require__2(moduleId) {
              if (installedModules[moduleId])
                return installedModules[moduleId].exports;
              var module2 = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: false
                /******/
              };
              modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);
              module2.loaded = true;
              return module2.exports;
            }
            __webpack_require__2.m = modules;
            __webpack_require__2.c = installedModules;
            __webpack_require__2.p = "";
            return __webpack_require__2(0);
          }([
            /* 0 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Handler2 = __webpack_require__2(1);
              var Util2 = __webpack_require__2(3);
              var Random2 = __webpack_require__2(5);
              var RE2 = __webpack_require__2(20);
              var toJSONSchema = __webpack_require__2(23);
              var valid = __webpack_require__2(25);
              var XHR;
              if (typeof window !== "undefined") XHR = __webpack_require__2(27);
              /*!
                  Mock - 模拟请求 & 模拟数据
                  https://github.com/nuysoft/Mock
                  墨智 mozhi.gyy@taobao.com nuysoft@gmail.com
              */
              var Mock2 = {
                Handler: Handler2,
                Random: Random2,
                Util: Util2,
                XHR,
                RE: RE2,
                toJSONSchema,
                valid,
                heredoc: Util2.heredoc,
                setup: function(settings) {
                  return XHR.setup(settings);
                },
                _mocked: {}
              };
              Mock2.version = "1.0.1-beta3";
              if (XHR) XHR.Mock = Mock2;
              Mock2.mock = function(rurl, rtype, template) {
                if (arguments.length === 1) {
                  return Handler2.gen(rurl);
                }
                if (arguments.length === 2) {
                  template = rtype;
                  rtype = void 0;
                }
                if (XHR) window.XMLHttpRequest = XHR;
                Mock2._mocked[rurl + (rtype || "")] = {
                  rurl,
                  rtype,
                  template
                };
                return Mock2;
              };
              module2.exports = Mock2;
            },
            /* 1 */
            /***/
            function(module, exports, __webpack_require__) {
              var Constant = __webpack_require__(2);
              var Util = __webpack_require__(3);
              var Parser = __webpack_require__(4);
              var Random = __webpack_require__(5);
              var RE = __webpack_require__(20);
              var Handler = {
                extend: Util.extend
              };
              Handler.gen = function(template, name, context) {
                name = name == void 0 ? "" : name + "";
                context = context || {};
                context = {
                  // 当前访问路径，只有属性名，不包括生成规则
                  path: context.path || [Constant.GUID],
                  templatePath: context.templatePath || [Constant.GUID++],
                  // 最终属性值的上下文
                  currentContext: context.currentContext,
                  // 属性值模板的上下文
                  templateCurrentContext: context.templateCurrentContext || template,
                  // 最终值的根
                  root: context.root || context.currentContext,
                  // 模板的根
                  templateRoot: context.templateRoot || context.templateCurrentContext || template
                };
                var rule = Parser.parse(name);
                var type = Util.type(template);
                var data;
                if (Handler[type]) {
                  data = Handler[type]({
                    // 属性值类型
                    type,
                    // 属性值模板
                    template,
                    // 属性名 + 生成规则
                    name,
                    // 属性名
                    parsedName: name ? name.replace(Constant.RE_KEY, "$1") : name,
                    // 解析后的生成规则
                    rule,
                    // 相关上下文
                    context
                  });
                  if (!context.root) context.root = data;
                  return data;
                }
                return template;
              };
              Handler.extend({
                array: function(options2) {
                  var result = [], i2, ii;
                  if (options2.template.length === 0) return result;
                  if (!options2.rule.parameters) {
                    for (i2 = 0; i2 < options2.template.length; i2++) {
                      options2.context.path.push(i2);
                      options2.context.templatePath.push(i2);
                      result.push(
                        Handler.gen(options2.template[i2], i2, {
                          path: options2.context.path,
                          templatePath: options2.context.templatePath,
                          currentContext: result,
                          templateCurrentContext: options2.template,
                          root: options2.context.root || result,
                          templateRoot: options2.context.templateRoot || options2.template
                        })
                      );
                      options2.context.path.pop();
                      options2.context.templatePath.pop();
                    }
                  } else {
                    if (options2.rule.min === 1 && options2.rule.max === void 0) {
                      options2.context.path.push(options2.name);
                      options2.context.templatePath.push(options2.name);
                      result = Random.pick(
                        Handler.gen(options2.template, void 0, {
                          path: options2.context.path,
                          templatePath: options2.context.templatePath,
                          currentContext: result,
                          templateCurrentContext: options2.template,
                          root: options2.context.root || result,
                          templateRoot: options2.context.templateRoot || options2.template
                        })
                      );
                      options2.context.path.pop();
                      options2.context.templatePath.pop();
                    } else {
                      if (options2.rule.parameters[2]) {
                        options2.template.__order_index = options2.template.__order_index || 0;
                        options2.context.path.push(options2.name);
                        options2.context.templatePath.push(options2.name);
                        result = Handler.gen(options2.template, void 0, {
                          path: options2.context.path,
                          templatePath: options2.context.templatePath,
                          currentContext: result,
                          templateCurrentContext: options2.template,
                          root: options2.context.root || result,
                          templateRoot: options2.context.templateRoot || options2.template
                        })[options2.template.__order_index % options2.template.length];
                        options2.template.__order_index += +options2.rule.parameters[2];
                        options2.context.path.pop();
                        options2.context.templatePath.pop();
                      } else {
                        for (i2 = 0; i2 < options2.rule.count; i2++) {
                          for (ii = 0; ii < options2.template.length; ii++) {
                            options2.context.path.push(result.length);
                            options2.context.templatePath.push(ii);
                            result.push(
                              Handler.gen(options2.template[ii], result.length, {
                                path: options2.context.path,
                                templatePath: options2.context.templatePath,
                                currentContext: result,
                                templateCurrentContext: options2.template,
                                root: options2.context.root || result,
                                templateRoot: options2.context.templateRoot || options2.template
                              })
                            );
                            options2.context.path.pop();
                            options2.context.templatePath.pop();
                          }
                        }
                      }
                    }
                  }
                  return result;
                },
                object: function(options2) {
                  var result = {}, keys2, fnKeys, key2, parsedKey, inc2, i2;
                  if (options2.rule.min != void 0) {
                    keys2 = Util.keys(options2.template);
                    keys2 = Random.shuffle(keys2);
                    keys2 = keys2.slice(0, options2.rule.count);
                    for (i2 = 0; i2 < keys2.length; i2++) {
                      key2 = keys2[i2];
                      parsedKey = key2.replace(Constant.RE_KEY, "$1");
                      options2.context.path.push(parsedKey);
                      options2.context.templatePath.push(key2);
                      result[parsedKey] = Handler.gen(options2.template[key2], key2, {
                        path: options2.context.path,
                        templatePath: options2.context.templatePath,
                        currentContext: result,
                        templateCurrentContext: options2.template,
                        root: options2.context.root || result,
                        templateRoot: options2.context.templateRoot || options2.template
                      });
                      options2.context.path.pop();
                      options2.context.templatePath.pop();
                    }
                  } else {
                    keys2 = [];
                    fnKeys = [];
                    for (key2 in options2.template) {
                      (typeof options2.template[key2] === "function" ? fnKeys : keys2).push(key2);
                    }
                    keys2 = keys2.concat(fnKeys);
                    for (i2 = 0; i2 < keys2.length; i2++) {
                      key2 = keys2[i2];
                      parsedKey = key2.replace(Constant.RE_KEY, "$1");
                      options2.context.path.push(parsedKey);
                      options2.context.templatePath.push(key2);
                      result[parsedKey] = Handler.gen(options2.template[key2], key2, {
                        path: options2.context.path,
                        templatePath: options2.context.templatePath,
                        currentContext: result,
                        templateCurrentContext: options2.template,
                        root: options2.context.root || result,
                        templateRoot: options2.context.templateRoot || options2.template
                      });
                      options2.context.path.pop();
                      options2.context.templatePath.pop();
                      inc2 = key2.match(Constant.RE_KEY);
                      if (inc2 && inc2[2] && Util.type(options2.template[key2]) === "number") {
                        options2.template[key2] += parseInt(inc2[2], 10);
                      }
                    }
                  }
                  return result;
                },
                number: function(options2) {
                  var result, parts2;
                  if (options2.rule.decimal) {
                    options2.template += "";
                    parts2 = options2.template.split(".");
                    parts2[0] = options2.rule.range ? options2.rule.count : parts2[0];
                    parts2[1] = (parts2[1] || "").slice(0, options2.rule.dcount);
                    while (parts2[1].length < options2.rule.dcount) {
                      parts2[1] += // 最后一位不能为 0：如果最后一位为 0，会被 JS 引擎忽略掉。
                      parts2[1].length < options2.rule.dcount - 1 ? Random.character("number") : Random.character("123456789");
                    }
                    result = parseFloat(parts2.join("."), 10);
                  } else {
                    result = options2.rule.range && !options2.rule.parameters[2] ? options2.rule.count : options2.template;
                  }
                  return result;
                },
                boolean: function(options2) {
                  var result;
                  result = options2.rule.parameters ? Random.bool(options2.rule.min, options2.rule.max, options2.template) : options2.template;
                  return result;
                },
                string: function(options2) {
                  var result = "", i2, placeholders, ph, phed;
                  if (options2.template.length) {
                    if (options2.rule.count == void 0) {
                      result += options2.template;
                    }
                    for (i2 = 0; i2 < options2.rule.count; i2++) {
                      result += options2.template;
                    }
                    placeholders = result.match(Constant.RE_PLACEHOLDER) || [];
                    for (i2 = 0; i2 < placeholders.length; i2++) {
                      ph = placeholders[i2];
                      if (/^\\/.test(ph)) {
                        placeholders.splice(i2--, 1);
                        continue;
                      }
                      phed = Handler.placeholder(ph, options2.context.currentContext, options2.context.templateCurrentContext, options2);
                      if (placeholders.length === 1 && ph === result && typeof phed !== typeof result) {
                        result = phed;
                        break;
                      }
                      result = result.replace(ph, phed);
                    }
                  } else {
                    result = options2.rule.range ? Random.string(options2.rule.count) : options2.template;
                  }
                  return result;
                },
                "function": function(options2) {
                  return options2.template.call(options2.context.currentContext, options2);
                },
                "regexp": function(options2) {
                  var source = "";
                  if (options2.rule.count == void 0) {
                    source += options2.template.source;
                  }
                  for (var i2 = 0; i2 < options2.rule.count; i2++) {
                    source += options2.template.source;
                  }
                  return RE.Handler.gen(
                    RE.Parser.parse(
                      source
                    )
                  );
                }
              });
              Handler.extend({
                _all: function() {
                  var re2 = {};
                  for (var key2 in Random) re2[key2.toLowerCase()] = key2;
                  return re2;
                },
                // 处理占位符，转换为最终值
                placeholder: function(placeholder, obj, templateContext, options) {
                  Constant.RE_PLACEHOLDER.exec("");
                  var parts = Constant.RE_PLACEHOLDER.exec(placeholder), key = parts && parts[1], lkey = key && key.toLowerCase(), okey = this._all()[lkey], params = parts && parts[2] || "";
                  var pathParts = this.splitPathToArray(key);
                  try {
                    params = eval("(function(){ return [].splice.call(arguments, 0 ) })(" + params + ")");
                  } catch (error) {
                    params = parts[2].split(/,\s*/);
                  }
                  if (obj && key in obj) return obj[key];
                  if (key.charAt(0) === "/" || pathParts.length > 1) return this.getValueByKeyPath(key, options);
                  if (templateContext && typeof templateContext === "object" && key in templateContext && placeholder !== templateContext[key]) {
                    templateContext[key] = Handler.gen(templateContext[key], key, {
                      currentContext: obj,
                      templateCurrentContext: templateContext
                    });
                    return templateContext[key];
                  }
                  if (!(key in Random) && !(lkey in Random) && !(okey in Random)) return placeholder;
                  for (var i = 0; i < params.length; i++) {
                    Constant.RE_PLACEHOLDER.exec("");
                    if (Constant.RE_PLACEHOLDER.test(params[i])) {
                      params[i] = Handler.placeholder(params[i], obj, templateContext, options);
                    }
                  }
                  var handle = Random[key] || Random[lkey] || Random[okey];
                  switch (Util.type(handle)) {
                    case "array":
                      return Random.pick(handle);
                    case "function":
                      handle.options = options;
                      var re = handle.apply(Random, params);
                      if (re === void 0) re = "";
                      delete handle.options;
                      return re;
                  }
                },
                getValueByKeyPath: function(key2, options2) {
                  var originalKey = key2;
                  var keyPathParts = this.splitPathToArray(key2);
                  var absolutePathParts = [];
                  if (key2.charAt(0) === "/") {
                    absolutePathParts = [options2.context.path[0]].concat(
                      this.normalizePath(keyPathParts)
                    );
                  } else {
                    if (keyPathParts.length > 1) {
                      absolutePathParts = options2.context.path.slice(0);
                      absolutePathParts.pop();
                      absolutePathParts = this.normalizePath(
                        absolutePathParts.concat(keyPathParts)
                      );
                    }
                  }
                  try {
                    key2 = keyPathParts[keyPathParts.length - 1];
                    var currentContext = options2.context.root;
                    var templateCurrentContext = options2.context.templateRoot;
                    for (var i2 = 1; i2 < absolutePathParts.length - 1; i2++) {
                      currentContext = currentContext[absolutePathParts[i2]];
                      templateCurrentContext = templateCurrentContext[absolutePathParts[i2]];
                    }
                    if (currentContext && key2 in currentContext) return currentContext[key2];
                    if (templateCurrentContext && typeof templateCurrentContext === "object" && key2 in templateCurrentContext && originalKey !== templateCurrentContext[key2]) {
                      templateCurrentContext[key2] = Handler.gen(templateCurrentContext[key2], key2, {
                        currentContext,
                        templateCurrentContext
                      });
                      return templateCurrentContext[key2];
                    }
                  } catch (err) {
                  }
                  return "@" + keyPathParts.join("/");
                },
                // https://github.com/kissyteam/kissy/blob/master/src/path/src/path.js
                normalizePath: function(pathParts2) {
                  var newPathParts = [];
                  for (var i2 = 0; i2 < pathParts2.length; i2++) {
                    switch (pathParts2[i2]) {
                      case "..":
                        newPathParts.pop();
                        break;
                      case ".":
                        break;
                      default:
                        newPathParts.push(pathParts2[i2]);
                    }
                  }
                  return newPathParts;
                },
                splitPathToArray: function(path) {
                  var parts2 = path.split(/\/+/);
                  if (!parts2[parts2.length - 1]) parts2 = parts2.slice(0, -1);
                  if (!parts2[0]) parts2 = parts2.slice(1);
                  return parts2;
                }
              });
              module.exports = Handler;
            },
            /* 2 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                GUID: 1,
                RE_KEY: /(.+)\|(?:\+(\d+)|([\+\-]?\d+-?[\+\-]?\d*)?(?:\.(\d+-?\d*))?)/,
                RE_RANGE: /([\+\-]?\d+)-?([\+\-]?\d+)?/,
                RE_PLACEHOLDER: /\\*@([^@#%&()\?\s]+)(?:\((.*?)\))?/g
                // /\\*@([^@#%&()\?\s\/\.]+)(?:\((.*?)\))?/g
                // RE_INDEX: /^index$/,
                // RE_KEY: /^key$/
              };
            },
            /* 3 */
            /***/
            function(module2, exports2) {
              var Util2 = {};
              Util2.extend = function extend2() {
                var target = arguments[0] || {}, i2 = 1, length2 = arguments.length, options2, name, src, copy2, clone2;
                if (length2 === 1) {
                  target = this;
                  i2 = 0;
                }
                for (; i2 < length2; i2++) {
                  options2 = arguments[i2];
                  if (!options2) continue;
                  for (name in options2) {
                    src = target[name];
                    copy2 = options2[name];
                    if (target === copy2) continue;
                    if (copy2 === void 0) continue;
                    if (Util2.isArray(copy2) || Util2.isObject(copy2)) {
                      if (Util2.isArray(copy2)) clone2 = src && Util2.isArray(src) ? src : [];
                      if (Util2.isObject(copy2)) clone2 = src && Util2.isObject(src) ? src : {};
                      target[name] = Util2.extend(clone2, copy2);
                    } else {
                      target[name] = copy2;
                    }
                  }
                }
                return target;
              };
              Util2.each = function each2(obj2, iterator2, context) {
                var i2, key2;
                if (this.type(obj2) === "number") {
                  for (i2 = 0; i2 < obj2; i2++) {
                    iterator2(i2, i2);
                  }
                } else if (obj2.length === +obj2.length) {
                  for (i2 = 0; i2 < obj2.length; i2++) {
                    if (iterator2.call(context, obj2[i2], i2, obj2) === false) break;
                  }
                } else {
                  for (key2 in obj2) {
                    if (iterator2.call(context, obj2[key2], key2, obj2) === false) break;
                  }
                }
              };
              Util2.type = function type(obj2) {
                return obj2 === null || obj2 === void 0 ? String(obj2) : Object.prototype.toString.call(obj2).match(/\[object (\w+)\]/)[1].toLowerCase();
              };
              Util2.each("String Object Array RegExp Function".split(" "), function(value) {
                Util2["is" + value] = function(obj2) {
                  return Util2.type(obj2) === value.toLowerCase();
                };
              });
              Util2.isObjectOrArray = function(value) {
                return Util2.isObject(value) || Util2.isArray(value);
              };
              Util2.isNumeric = function(value) {
                return !isNaN(parseFloat(value)) && isFinite(value);
              };
              Util2.keys = function(obj2) {
                var keys2 = [];
                for (var key2 in obj2) {
                  if (obj2.hasOwnProperty(key2)) keys2.push(key2);
                }
                return keys2;
              };
              Util2.values = function(obj2) {
                var values = [];
                for (var key2 in obj2) {
                  if (obj2.hasOwnProperty(key2)) values.push(obj2[key2]);
                }
                return values;
              };
              Util2.heredoc = function heredoc(fn) {
                return fn.toString().replace(/^[^\/]+\/\*!?/, "").replace(/\*\/[^\/]+$/, "").replace(/^[\s\xA0]+/, "").replace(/[\s\xA0]+$/, "");
              };
              Util2.noop = function() {
              };
              module2.exports = Util2;
            },
            /* 4 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Constant2 = __webpack_require__2(2);
              var Random2 = __webpack_require__2(5);
              module2.exports = {
                parse: function(name) {
                  name = name == void 0 ? "" : name + "";
                  var parameters = (name || "").match(Constant2.RE_KEY);
                  var range2 = parameters && parameters[3] && parameters[3].match(Constant2.RE_RANGE);
                  var min3 = range2 && range2[1] && parseInt(range2[1], 10);
                  var max3 = range2 && range2[2] && parseInt(range2[2], 10);
                  var count = range2 ? !range2[2] ? parseInt(range2[1], 10) : Random2.integer(min3, max3) : void 0;
                  var decimal = parameters && parameters[4] && parameters[4].match(Constant2.RE_RANGE);
                  var dmin = decimal && decimal[1] && parseInt(decimal[1], 10);
                  var dmax = decimal && decimal[2] && parseInt(decimal[2], 10);
                  var dcount = decimal ? !decimal[2] && parseInt(decimal[1], 10) || Random2.integer(dmin, dmax) : void 0;
                  var result = {
                    // 1 name, 2 inc, 3 range, 4 decimal
                    parameters,
                    // 1 min, 2 max
                    range: range2,
                    min: min3,
                    max: max3,
                    // min-max
                    count,
                    // 是否有 decimal
                    decimal,
                    dmin,
                    dmax,
                    // dmin-dimax
                    dcount
                  };
                  for (var r2 in result) {
                    if (result[r2] != void 0) return result;
                  }
                  return {};
                }
              };
            },
            /* 5 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Util2 = __webpack_require__2(3);
              var Random2 = {
                extend: Util2.extend
              };
              Random2.extend(__webpack_require__2(6));
              Random2.extend(__webpack_require__2(7));
              Random2.extend(__webpack_require__2(8));
              Random2.extend(__webpack_require__2(10));
              Random2.extend(__webpack_require__2(13));
              Random2.extend(__webpack_require__2(15));
              Random2.extend(__webpack_require__2(16));
              Random2.extend(__webpack_require__2(17));
              Random2.extend(__webpack_require__2(14));
              Random2.extend(__webpack_require__2(19));
              module2.exports = Random2;
            },
            /* 6 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                // 返回一个随机的布尔值。
                boolean: function(min3, max3, cur) {
                  if (cur !== void 0) {
                    min3 = typeof min3 !== "undefined" && !isNaN(min3) ? parseInt(min3, 10) : 1;
                    max3 = typeof max3 !== "undefined" && !isNaN(max3) ? parseInt(max3, 10) : 1;
                    return Math.random() > 1 / (min3 + max3) * min3 ? !cur : cur;
                  }
                  return Math.random() >= 0.5;
                },
                bool: function(min3, max3, cur) {
                  return this.boolean(min3, max3, cur);
                },
                // 返回一个随机的自然数（大于等于 0 的整数）。
                natural: function(min3, max3) {
                  min3 = typeof min3 !== "undefined" ? parseInt(min3, 10) : 0;
                  max3 = typeof max3 !== "undefined" ? parseInt(max3, 10) : 9007199254740992;
                  return Math.round(Math.random() * (max3 - min3)) + min3;
                },
                // 返回一个随机的整数。
                integer: function(min3, max3) {
                  min3 = typeof min3 !== "undefined" ? parseInt(min3, 10) : -9007199254740992;
                  max3 = typeof max3 !== "undefined" ? parseInt(max3, 10) : 9007199254740992;
                  return Math.round(Math.random() * (max3 - min3)) + min3;
                },
                int: function(min3, max3) {
                  return this.integer(min3, max3);
                },
                // 返回一个随机的浮点数。
                float: function(min3, max3, dmin, dmax) {
                  dmin = dmin === void 0 ? 0 : dmin;
                  dmin = Math.max(Math.min(dmin, 17), 0);
                  dmax = dmax === void 0 ? 17 : dmax;
                  dmax = Math.max(Math.min(dmax, 17), 0);
                  var ret = this.integer(min3, max3) + ".";
                  for (var i2 = 0, dcount = this.natural(dmin, dmax); i2 < dcount; i2++) {
                    ret += // 最后一位不能为 0：如果最后一位为 0，会被 JS 引擎忽略掉。
                    i2 < dcount - 1 ? this.character("number") : this.character("123456789");
                  }
                  return parseFloat(ret, 10);
                },
                // 返回一个随机字符。
                character: function(pool) {
                  var pools = {
                    lower: "abcdefghijklmnopqrstuvwxyz",
                    upper: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    number: "0123456789",
                    symbol: "!@#$%^&*()[]"
                  };
                  pools.alpha = pools.lower + pools.upper;
                  pools["undefined"] = pools.lower + pools.upper + pools.number + pools.symbol;
                  pool = pools[("" + pool).toLowerCase()] || pool;
                  return pool.charAt(this.natural(0, pool.length - 1));
                },
                char: function(pool) {
                  return this.character(pool);
                },
                // 返回一个随机字符串。
                string: function(pool, min3, max3) {
                  var len2;
                  switch (arguments.length) {
                    case 0:
                      len2 = this.natural(3, 7);
                      break;
                    case 1:
                      len2 = pool;
                      pool = void 0;
                      break;
                    case 2:
                      if (typeof arguments[0] === "string") {
                        len2 = min3;
                      } else {
                        len2 = this.natural(pool, min3);
                        pool = void 0;
                      }
                      break;
                    case 3:
                      len2 = this.natural(min3, max3);
                      break;
                  }
                  var text = "";
                  for (var i2 = 0; i2 < len2; i2++) {
                    text += this.character(pool);
                  }
                  return text;
                },
                str: function() {
                  return this.string.apply(this, arguments);
                },
                // 返回一个整型数组。
                range: function(start2, stop2, step) {
                  if (arguments.length <= 1) {
                    stop2 = start2 || 0;
                    start2 = 0;
                  }
                  step = arguments[2] || 1;
                  start2 = +start2;
                  stop2 = +stop2;
                  step = +step;
                  var len2 = Math.max(Math.ceil((stop2 - start2) / step), 0);
                  var idx = 0;
                  var range2 = new Array(len2);
                  while (idx < len2) {
                    range2[idx++] = start2;
                    start2 += step;
                  }
                  return range2;
                }
              };
            },
            /* 7 */
            /***/
            function(module2, exports2) {
              var patternLetters = {
                yyyy: "getFullYear",
                yy: function(date) {
                  return ("" + date.getFullYear()).slice(2);
                },
                y: "yy",
                MM: function(date) {
                  var m2 = date.getMonth() + 1;
                  return m2 < 10 ? "0" + m2 : m2;
                },
                M: function(date) {
                  return date.getMonth() + 1;
                },
                dd: function(date) {
                  var d2 = date.getDate();
                  return d2 < 10 ? "0" + d2 : d2;
                },
                d: "getDate",
                HH: function(date) {
                  var h2 = date.getHours();
                  return h2 < 10 ? "0" + h2 : h2;
                },
                H: "getHours",
                hh: function(date) {
                  var h2 = date.getHours() % 12;
                  return h2 < 10 ? "0" + h2 : h2;
                },
                h: function(date) {
                  return date.getHours() % 12;
                },
                mm: function(date) {
                  var m2 = date.getMinutes();
                  return m2 < 10 ? "0" + m2 : m2;
                },
                m: "getMinutes",
                ss: function(date) {
                  var s2 = date.getSeconds();
                  return s2 < 10 ? "0" + s2 : s2;
                },
                s: "getSeconds",
                SS: function(date) {
                  var ms = date.getMilliseconds();
                  return ms < 10 && "00" + ms || ms < 100 && "0" + ms || ms;
                },
                S: "getMilliseconds",
                A: function(date) {
                  return date.getHours() < 12 ? "AM" : "PM";
                },
                a: function(date) {
                  return date.getHours() < 12 ? "am" : "pm";
                },
                T: "getTime"
              };
              module2.exports = {
                // 日期占位符集合。
                _patternLetters: patternLetters,
                // 日期占位符正则。
                _rformat: new RegExp(function() {
                  var re2 = [];
                  for (var i2 in patternLetters) re2.push(i2);
                  return "(" + re2.join("|") + ")";
                }(), "g"),
                // 格式化日期。
                _formatDate: function(date, format2) {
                  return format2.replace(this._rformat, function creatNewSubString($0, flag) {
                    return typeof patternLetters[flag] === "function" ? patternLetters[flag](date) : patternLetters[flag] in patternLetters ? creatNewSubString($0, patternLetters[flag]) : date[patternLetters[flag]]();
                  });
                },
                // 生成一个随机的 Date 对象。
                _randomDate: function(min3, max3) {
                  min3 = min3 === void 0 ? /* @__PURE__ */ new Date(0) : min3;
                  max3 = max3 === void 0 ? /* @__PURE__ */ new Date() : max3;
                  return new Date(Math.random() * (max3.getTime() - min3.getTime()));
                },
                // 返回一个随机的日期字符串。
                date: function(format2) {
                  format2 = format2 || "yyyy-MM-dd";
                  return this._formatDate(this._randomDate(), format2);
                },
                // 返回一个随机的时间字符串。
                time: function(format2) {
                  format2 = format2 || "HH:mm:ss";
                  return this._formatDate(this._randomDate(), format2);
                },
                // 返回一个随机的日期和时间字符串。
                datetime: function(format2) {
                  format2 = format2 || "yyyy-MM-dd HH:mm:ss";
                  return this._formatDate(this._randomDate(), format2);
                },
                // 返回当前的日期和时间字符串。
                now: function(unit, format2) {
                  if (arguments.length === 1) {
                    if (!/year|month|day|hour|minute|second|week/.test(unit)) {
                      format2 = unit;
                      unit = "";
                    }
                  }
                  unit = (unit || "").toLowerCase();
                  format2 = format2 || "yyyy-MM-dd HH:mm:ss";
                  var date = /* @__PURE__ */ new Date();
                  switch (unit) {
                    case "year":
                      date.setMonth(0);
                    case "month":
                      date.setDate(1);
                    case "week":
                    case "day":
                      date.setHours(0);
                    case "hour":
                      date.setMinutes(0);
                    case "minute":
                      date.setSeconds(0);
                    case "second":
                      date.setMilliseconds(0);
                  }
                  switch (unit) {
                    case "week":
                      date.setDate(date.getDate() - date.getDay());
                  }
                  return this._formatDate(date, format2);
                }
              };
            },
            /* 8 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              (function(module3) {
                module3.exports = {
                  // 常见的广告宽高
                  _adSize: [
                    "300x250",
                    "250x250",
                    "240x400",
                    "336x280",
                    "180x150",
                    "720x300",
                    "468x60",
                    "234x60",
                    "88x31",
                    "120x90",
                    "120x60",
                    "120x240",
                    "125x125",
                    "728x90",
                    "160x600",
                    "120x600",
                    "300x600"
                  ],
                  // 常见的屏幕宽高
                  _screenSize: [
                    "320x200",
                    "320x240",
                    "640x480",
                    "800x480",
                    "800x480",
                    "1024x600",
                    "1024x768",
                    "1280x800",
                    "1440x900",
                    "1920x1200",
                    "2560x1600"
                  ],
                  // 常见的视频宽高
                  _videoSize: ["720x480", "768x576", "1280x720", "1920x1080"],
                  /*
                  				        生成一个随机的图片地址。
                  
                  				        替代图片源
                  				            http://fpoimg.com/
                  				        参考自 
                  				            http://rensanning.iteye.com/blog/1933310
                  				            http://code.tutsplus.com/articles/the-top-8-placeholders-for-web-designers--net-19485
                  				    */
                  image: function(size, background, foreground, format2, text) {
                    if (arguments.length === 4) {
                      text = format2;
                      format2 = void 0;
                    }
                    if (arguments.length === 3) {
                      text = foreground;
                      foreground = void 0;
                    }
                    if (!size) size = this.pick(this._adSize);
                    if (background && ~background.indexOf("#")) background = background.slice(1);
                    if (foreground && ~foreground.indexOf("#")) foreground = foreground.slice(1);
                    return "http://dummyimage.com/" + size + (background ? "/" + background : "") + (foreground ? "/" + foreground : "") + (format2 ? "." + format2 : "") + (text ? "&text=" + text : "");
                  },
                  img: function() {
                    return this.image.apply(this, arguments);
                  },
                  /*
                  				        BrandColors
                  				        http://brandcolors.net/
                  				        A collection of major brand color codes curated by Galen Gidman.
                  				        大牌公司的颜色集合
                  
                  				        // 获取品牌和颜色
                  				        $('h2').each(function(index, item){
                  				            item = $(item)
                  				            console.log('\'' + item.text() + '\'', ':', '\'' + item.next().text() + '\'', ',')
                  				        })
                  				    */
                  _brandColors: {
                    "4ormat": "#fb0a2a",
                    "500px": "#02adea",
                    "About.me (blue)": "#00405d",
                    "About.me (yellow)": "#ffcc33",
                    "Addvocate": "#ff6138",
                    "Adobe": "#ff0000",
                    "Aim": "#fcd20b",
                    "Amazon": "#e47911",
                    "Android": "#a4c639",
                    "Angie's List": "#7fbb00",
                    "AOL": "#0060a3",
                    "Atlassian": "#003366",
                    "Behance": "#053eff",
                    "Big Cartel": "#97b538",
                    "bitly": "#ee6123",
                    "Blogger": "#fc4f08",
                    "Boeing": "#0039a6",
                    "Booking.com": "#003580",
                    "Carbonmade": "#613854",
                    "Cheddar": "#ff7243",
                    "Code School": "#3d4944",
                    "Delicious": "#205cc0",
                    "Dell": "#3287c1",
                    "Designmoo": "#e54a4f",
                    "Deviantart": "#4e6252",
                    "Designer News": "#2d72da",
                    "Devour": "#fd0001",
                    "DEWALT": "#febd17",
                    "Disqus (blue)": "#59a3fc",
                    "Disqus (orange)": "#db7132",
                    "Dribbble": "#ea4c89",
                    "Dropbox": "#3d9ae8",
                    "Drupal": "#0c76ab",
                    "Dunked": "#2a323a",
                    "eBay": "#89c507",
                    "Ember": "#f05e1b",
                    "Engadget": "#00bdf6",
                    "Envato": "#528036",
                    "Etsy": "#eb6d20",
                    "Evernote": "#5ba525",
                    "Fab.com": "#dd0017",
                    "Facebook": "#3b5998",
                    "Firefox": "#e66000",
                    "Flickr (blue)": "#0063dc",
                    "Flickr (pink)": "#ff0084",
                    "Forrst": "#5b9a68",
                    "Foursquare": "#25a0ca",
                    "Garmin": "#007cc3",
                    "GetGlue": "#2d75a2",
                    "Gimmebar": "#f70078",
                    "GitHub": "#171515",
                    "Google Blue": "#0140ca",
                    "Google Green": "#16a61e",
                    "Google Red": "#dd1812",
                    "Google Yellow": "#fcca03",
                    "Google+": "#dd4b39",
                    "Grooveshark": "#f77f00",
                    "Groupon": "#82b548",
                    "Hacker News": "#ff6600",
                    "HelloWallet": "#0085ca",
                    "Heroku (light)": "#c7c5e6",
                    "Heroku (dark)": "#6567a5",
                    "HootSuite": "#003366",
                    "Houzz": "#73ba37",
                    "HTML5": "#ec6231",
                    "IKEA": "#ffcc33",
                    "IMDb": "#f3ce13",
                    "Instagram": "#3f729b",
                    "Intel": "#0071c5",
                    "Intuit": "#365ebf",
                    "Kickstarter": "#76cc1e",
                    "kippt": "#e03500",
                    "Kodery": "#00af81",
                    "LastFM": "#c3000d",
                    "LinkedIn": "#0e76a8",
                    "Livestream": "#cf0005",
                    "Lumo": "#576396",
                    "Mixpanel": "#a086d3",
                    "Meetup": "#e51937",
                    "Nokia": "#183693",
                    "NVIDIA": "#76b900",
                    "Opera": "#cc0f16",
                    "Path": "#e41f11",
                    "PayPal (dark)": "#1e477a",
                    "PayPal (light)": "#3b7bbf",
                    "Pinboard": "#0000e6",
                    "Pinterest": "#c8232c",
                    "PlayStation": "#665cbe",
                    "Pocket": "#ee4056",
                    "Prezi": "#318bff",
                    "Pusha": "#0f71b4",
                    "Quora": "#a82400",
                    "QUOTE.fm": "#66ceff",
                    "Rdio": "#008fd5",
                    "Readability": "#9c0000",
                    "Red Hat": "#cc0000",
                    "Resource": "#7eb400",
                    "Rockpack": "#0ba6ab",
                    "Roon": "#62b0d9",
                    "RSS": "#ee802f",
                    "Salesforce": "#1798c1",
                    "Samsung": "#0c4da2",
                    "Shopify": "#96bf48",
                    "Skype": "#00aff0",
                    "Snagajob": "#f47a20",
                    "Softonic": "#008ace",
                    "SoundCloud": "#ff7700",
                    "Space Box": "#f86960",
                    "Spotify": "#81b71a",
                    "Sprint": "#fee100",
                    "Squarespace": "#121212",
                    "StackOverflow": "#ef8236",
                    "Staples": "#cc0000",
                    "Status Chart": "#d7584f",
                    "Stripe": "#008cdd",
                    "StudyBlue": "#00afe1",
                    "StumbleUpon": "#f74425",
                    "T-Mobile": "#ea0a8e",
                    "Technorati": "#40a800",
                    "The Next Web": "#ef4423",
                    "Treehouse": "#5cb868",
                    "Trulia": "#5eab1f",
                    "Tumblr": "#34526f",
                    "Twitch.tv": "#6441a5",
                    "Twitter": "#00acee",
                    "TYPO3": "#ff8700",
                    "Ubuntu": "#dd4814",
                    "Ustream": "#3388ff",
                    "Verizon": "#ef1d1d",
                    "Vimeo": "#86c9ef",
                    "Vine": "#00a478",
                    "Virb": "#06afd8",
                    "Virgin Media": "#cc0000",
                    "Wooga": "#5b009c",
                    "WordPress (blue)": "#21759b",
                    "WordPress (orange)": "#d54e21",
                    "WordPress (grey)": "#464646",
                    "Wunderlist": "#2b88d9",
                    "XBOX": "#9bc848",
                    "XING": "#126567",
                    "Yahoo!": "#720e9e",
                    "Yandex": "#ffcc00",
                    "Yelp": "#c41200",
                    "YouTube": "#c4302b",
                    "Zalongo": "#5498dc",
                    "Zendesk": "#78a300",
                    "Zerply": "#9dcc7a",
                    "Zootool": "#5e8b1d"
                  },
                  _brandNames: function() {
                    var brands = [];
                    for (var b2 in this._brandColors) {
                      brands.push(b2);
                    }
                    return brands;
                  },
                  /*
                  				        生成一段随机的 Base64 图片编码。
                  
                  				        https://github.com/imsky/holder
                  				        Holder renders image placeholders entirely on the client side.
                  
                  				        dataImageHolder: function(size) {
                  				            return 'holder.js/' + size
                  				        },
                  				    */
                  dataImage: function(size, text) {
                    var canvas;
                    if (typeof document !== "undefined") {
                      canvas = document.createElement("canvas");
                    } else {
                      var Canvas = module3.require("canvas");
                      canvas = new Canvas();
                    }
                    var ctx = canvas && canvas.getContext && canvas.getContext("2d");
                    if (!canvas || !ctx) return "";
                    if (!size) size = this.pick(this._adSize);
                    text = text !== void 0 ? text : size;
                    size = size.split("x");
                    var width = parseInt(size[0], 10), height = parseInt(size[1], 10), background = this._brandColors[this.pick(this._brandNames())], foreground = "#FFF", text_height = 14, font = "sans-serif";
                    canvas.width = width;
                    canvas.height = height;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = background;
                    ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = foreground;
                    ctx.font = "bold " + text_height + "px " + font;
                    ctx.fillText(text, width / 2, height / 2, width);
                    return canvas.toDataURL("image/png");
                  }
                };
              }).call(exports2, __webpack_require__2(9)(module2));
            },
            /* 9 */
            /***/
            function(module2, exports2) {
              module2.exports = function(module3) {
                if (!module3.webpackPolyfill) {
                  module3.deprecate = function() {
                  };
                  module3.paths = [];
                  module3.children = [];
                  module3.webpackPolyfill = 1;
                }
                return module3;
              };
            },
            /* 10 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Convert = __webpack_require__2(11);
              var DICT = __webpack_require__2(12);
              module2.exports = {
                // 随机生成一个有吸引力的颜色，格式为 '#RRGGBB'。
                color: function(name) {
                  if (name || DICT[name]) return DICT[name].nicer;
                  return this.hex();
                },
                // #DAC0DE
                hex: function() {
                  var hsv = this._goldenRatioColor();
                  var rgb = Convert.hsv2rgb(hsv);
                  var hex = Convert.rgb2hex(rgb[0], rgb[1], rgb[2]);
                  return hex;
                },
                // rgb(128,255,255)
                rgb: function() {
                  var hsv = this._goldenRatioColor();
                  var rgb = Convert.hsv2rgb(hsv);
                  return "rgb(" + parseInt(rgb[0], 10) + ", " + parseInt(rgb[1], 10) + ", " + parseInt(rgb[2], 10) + ")";
                },
                // rgba(128,255,255,0.3)
                rgba: function() {
                  var hsv = this._goldenRatioColor();
                  var rgb = Convert.hsv2rgb(hsv);
                  return "rgba(" + parseInt(rgb[0], 10) + ", " + parseInt(rgb[1], 10) + ", " + parseInt(rgb[2], 10) + ", " + Math.random().toFixed(2) + ")";
                },
                // hsl(300,80%,90%)
                hsl: function() {
                  var hsv = this._goldenRatioColor();
                  var hsl = Convert.hsv2hsl(hsv);
                  return "hsl(" + parseInt(hsl[0], 10) + ", " + parseInt(hsl[1], 10) + ", " + parseInt(hsl[2], 10) + ")";
                },
                // http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
                // https://github.com/devongovett/color-generator/blob/master/index.js
                // 随机生成一个有吸引力的颜色。
                _goldenRatioColor: function(saturation, value) {
                  this._goldenRatio = 0.618033988749895;
                  this._hue = this._hue || Math.random();
                  this._hue += this._goldenRatio;
                  this._hue %= 1;
                  if (typeof saturation !== "number") saturation = 0.5;
                  if (typeof value !== "number") value = 0.95;
                  return [
                    this._hue * 360,
                    saturation * 100,
                    value * 100
                  ];
                }
              };
            },
            /* 11 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                rgb2hsl: function rgb2hsl(rgb) {
                  var r2 = rgb[0] / 255, g2 = rgb[1] / 255, b2 = rgb[2] / 255, min3 = Math.min(r2, g2, b2), max3 = Math.max(r2, g2, b2), delta = max3 - min3, h2, s2, l2;
                  if (max3 == min3)
                    h2 = 0;
                  else if (r2 == max3)
                    h2 = (g2 - b2) / delta;
                  else if (g2 == max3)
                    h2 = 2 + (b2 - r2) / delta;
                  else if (b2 == max3)
                    h2 = 4 + (r2 - g2) / delta;
                  h2 = Math.min(h2 * 60, 360);
                  if (h2 < 0)
                    h2 += 360;
                  l2 = (min3 + max3) / 2;
                  if (max3 == min3)
                    s2 = 0;
                  else if (l2 <= 0.5)
                    s2 = delta / (max3 + min3);
                  else
                    s2 = delta / (2 - max3 - min3);
                  return [h2, s2 * 100, l2 * 100];
                },
                rgb2hsv: function rgb2hsv(rgb) {
                  var r2 = rgb[0], g2 = rgb[1], b2 = rgb[2], min3 = Math.min(r2, g2, b2), max3 = Math.max(r2, g2, b2), delta = max3 - min3, h2, s2, v2;
                  if (max3 === 0)
                    s2 = 0;
                  else
                    s2 = delta / max3 * 1e3 / 10;
                  if (max3 == min3)
                    h2 = 0;
                  else if (r2 == max3)
                    h2 = (g2 - b2) / delta;
                  else if (g2 == max3)
                    h2 = 2 + (b2 - r2) / delta;
                  else if (b2 == max3)
                    h2 = 4 + (r2 - g2) / delta;
                  h2 = Math.min(h2 * 60, 360);
                  if (h2 < 0)
                    h2 += 360;
                  v2 = max3 / 255 * 1e3 / 10;
                  return [h2, s2, v2];
                },
                hsl2rgb: function hsl2rgb(hsl) {
                  var h2 = hsl[0] / 360, s2 = hsl[1] / 100, l2 = hsl[2] / 100, t1, t2, t3, rgb, val;
                  if (s2 === 0) {
                    val = l2 * 255;
                    return [val, val, val];
                  }
                  if (l2 < 0.5)
                    t2 = l2 * (1 + s2);
                  else
                    t2 = l2 + s2 - l2 * s2;
                  t1 = 2 * l2 - t2;
                  rgb = [0, 0, 0];
                  for (var i2 = 0; i2 < 3; i2++) {
                    t3 = h2 + 1 / 3 * -(i2 - 1);
                    if (t3 < 0) t3++;
                    if (t3 > 1) t3--;
                    if (6 * t3 < 1)
                      val = t1 + (t2 - t1) * 6 * t3;
                    else if (2 * t3 < 1)
                      val = t2;
                    else if (3 * t3 < 2)
                      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                    else
                      val = t1;
                    rgb[i2] = val * 255;
                  }
                  return rgb;
                },
                hsl2hsv: function hsl2hsv(hsl) {
                  var h2 = hsl[0], s2 = hsl[1] / 100, l2 = hsl[2] / 100, sv, v2;
                  l2 *= 2;
                  s2 *= l2 <= 1 ? l2 : 2 - l2;
                  v2 = (l2 + s2) / 2;
                  sv = 2 * s2 / (l2 + s2);
                  return [h2, sv * 100, v2 * 100];
                },
                hsv2rgb: function hsv2rgb(hsv) {
                  var h2 = hsv[0] / 60;
                  var s2 = hsv[1] / 100;
                  var v2 = hsv[2] / 100;
                  var hi = Math.floor(h2) % 6;
                  var f2 = h2 - Math.floor(h2);
                  var p2 = 255 * v2 * (1 - s2);
                  var q2 = 255 * v2 * (1 - s2 * f2);
                  var t2 = 255 * v2 * (1 - s2 * (1 - f2));
                  v2 = 255 * v2;
                  switch (hi) {
                    case 0:
                      return [v2, t2, p2];
                    case 1:
                      return [q2, v2, p2];
                    case 2:
                      return [p2, v2, t2];
                    case 3:
                      return [p2, q2, v2];
                    case 4:
                      return [t2, p2, v2];
                    case 5:
                      return [v2, p2, q2];
                  }
                },
                hsv2hsl: function hsv2hsl(hsv) {
                  var h2 = hsv[0], s2 = hsv[1] / 100, v2 = hsv[2] / 100, sl, l2;
                  l2 = (2 - s2) * v2;
                  sl = s2 * v2;
                  sl /= l2 <= 1 ? l2 : 2 - l2;
                  l2 /= 2;
                  return [h2, sl * 100, l2 * 100];
                },
                // http://www.140byt.es/keywords/color
                rgb2hex: function(a2, b2, c2) {
                  return "#" + ((256 + a2 << 8 | b2) << 8 | c2).toString(16).slice(1);
                },
                hex2rgb: function(a2) {
                  a2 = "0x" + a2.slice(1).replace(a2.length > 4 ? a2 : /./g, "$&$&") | 0;
                  return [a2 >> 16, a2 >> 8 & 255, a2 & 255];
                }
              };
            },
            /* 12 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                // name value nicer
                navy: {
                  value: "#000080",
                  nicer: "#001F3F"
                },
                blue: {
                  value: "#0000ff",
                  nicer: "#0074D9"
                },
                aqua: {
                  value: "#00ffff",
                  nicer: "#7FDBFF"
                },
                teal: {
                  value: "#008080",
                  nicer: "#39CCCC"
                },
                olive: {
                  value: "#008000",
                  nicer: "#3D9970"
                },
                green: {
                  value: "#008000",
                  nicer: "#2ECC40"
                },
                lime: {
                  value: "#00ff00",
                  nicer: "#01FF70"
                },
                yellow: {
                  value: "#ffff00",
                  nicer: "#FFDC00"
                },
                orange: {
                  value: "#ffa500",
                  nicer: "#FF851B"
                },
                red: {
                  value: "#ff0000",
                  nicer: "#FF4136"
                },
                maroon: {
                  value: "#800000",
                  nicer: "#85144B"
                },
                fuchsia: {
                  value: "#ff00ff",
                  nicer: "#F012BE"
                },
                purple: {
                  value: "#800080",
                  nicer: "#B10DC9"
                },
                silver: {
                  value: "#c0c0c0",
                  nicer: "#DDDDDD"
                },
                gray: {
                  value: "#808080",
                  nicer: "#AAAAAA"
                },
                black: {
                  value: "#000000",
                  nicer: "#111111"
                },
                white: {
                  value: "#FFFFFF",
                  nicer: "#FFFFFF"
                }
              };
            },
            /* 13 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Basic = __webpack_require__2(6);
              var Helper = __webpack_require__2(14);
              function range2(defaultMin, defaultMax, min3, max3) {
                return min3 === void 0 ? Basic.natural(defaultMin, defaultMax) : (
                  // ()
                  max3 === void 0 ? min3 : (
                    // ( len )
                    Basic.natural(parseInt(min3, 10), parseInt(max3, 10))
                  )
                );
              }
              module2.exports = {
                // 随机生成一段文本。
                paragraph: function(min3, max3) {
                  var len2 = range2(3, 7, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.sentence());
                  }
                  return result.join(" ");
                },
                // 
                cparagraph: function(min3, max3) {
                  var len2 = range2(3, 7, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.csentence());
                  }
                  return result.join("");
                },
                // 随机生成一个句子，第一个单词的首字母大写。
                sentence: function(min3, max3) {
                  var len2 = range2(12, 18, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.word());
                  }
                  return Helper.capitalize(result.join(" ")) + ".";
                },
                // 随机生成一个中文句子。
                csentence: function(min3, max3) {
                  var len2 = range2(12, 18, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.cword());
                  }
                  return result.join("") + "。";
                },
                // 随机生成一个单词。
                word: function(min3, max3) {
                  var len2 = range2(3, 10, min3, max3);
                  var result = "";
                  for (var i2 = 0; i2 < len2; i2++) {
                    result += Basic.character("lower");
                  }
                  return result;
                },
                // 随机生成一个或多个汉字。
                cword: function(pool, min3, max3) {
                  var DICT_KANZI = "的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家电力里如水化高自二理起小物现实加量都两体制机当使点从业本去把性好应开它合还因由其些然前外天政四日那社义事平形相全表间样与关各重新线内数正心反你明看原又么利比或但质气第向道命此变条只没结解问意建月公无系军很情者最立代想已通并提直题党程展五果料象员革位入常文总次品式活设及管特件长求老头基资边流路级少图山统接知较将组见计别她手角期根论运农指几九区强放决西被干做必战先回则任取据处队南给色光门即保治北造百规热领七海口东导器压志世金增争济阶油思术极交受联什认六共权收证改清己美再采转更单风切打白教速花带安场身车例真务具万每目至达走积示议声报斗完类八离华名确才科张信马节话米整空元况今集温传土许步群广石记需段研界拉林律叫且究观越织装影算低持音众书布复容儿须际商非验连断深难近矿千周委素技备半办青省列习响约支般史感劳便团往酸历市克何除消构府称太准精值号率族维划选标写存候毛亲快效斯院查江型眼王按格养易置派层片始却专状育厂京识适属圆包火住调满县局照参红细引听该铁价严龙飞";
                  var len2;
                  switch (arguments.length) {
                    case 0:
                      pool = DICT_KANZI;
                      len2 = 1;
                      break;
                    case 1:
                      if (typeof arguments[0] === "string") {
                        len2 = 1;
                      } else {
                        len2 = pool;
                        pool = DICT_KANZI;
                      }
                      break;
                    case 2:
                      if (typeof arguments[0] === "string") {
                        len2 = min3;
                      } else {
                        len2 = this.natural(pool, min3);
                        pool = DICT_KANZI;
                      }
                      break;
                    case 3:
                      len2 = this.natural(min3, max3);
                      break;
                  }
                  var result = "";
                  for (var i2 = 0; i2 < len2; i2++) {
                    result += pool.charAt(this.natural(0, pool.length - 1));
                  }
                  return result;
                },
                // 随机生成一句标题，其中每个单词的首字母大写。
                title: function(min3, max3) {
                  var len2 = range2(3, 7, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.capitalize(this.word()));
                  }
                  return result.join(" ");
                },
                // 随机生成一句中文标题。
                ctitle: function(min3, max3) {
                  var len2 = range2(3, 7, min3, max3);
                  var result = [];
                  for (var i2 = 0; i2 < len2; i2++) {
                    result.push(this.cword());
                  }
                  return result.join("");
                }
              };
            },
            /* 14 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Util2 = __webpack_require__2(3);
              module2.exports = {
                // 把字符串的第一个字母转换为大写。
                capitalize: function(word) {
                  return (word + "").charAt(0).toUpperCase() + (word + "").substr(1);
                },
                // 把字符串转换为大写。
                upper: function(str) {
                  return (str + "").toUpperCase();
                },
                // 把字符串转换为小写。
                lower: function(str) {
                  return (str + "").toLowerCase();
                },
                // 从数组中随机选取一个元素，并返回。
                pick: function pick(arr, min3, max3) {
                  if (!Util2.isArray(arr)) {
                    arr = [].slice.call(arguments);
                    min3 = 1;
                    max3 = 1;
                  } else {
                    if (min3 === void 0) min3 = 1;
                    if (max3 === void 0) max3 = min3;
                  }
                  if (min3 === 1 && max3 === 1) return arr[this.natural(0, arr.length - 1)];
                  return this.shuffle(arr, min3, max3);
                },
                /*
                					    打乱数组中元素的顺序，并返回。
                					    Given an array, scramble the order and return it.
                
                					    其他的实现思路：
                					        // https://code.google.com/p/jslibs/wiki/JavascriptTips
                					        result = result.sort(function() {
                					            return Math.random() - 0.5
                					        })
                					*/
                shuffle: function shuffle(arr, min3, max3) {
                  arr = arr || [];
                  var old = arr.slice(0), result = [], index2 = 0, length2 = old.length;
                  for (var i2 = 0; i2 < length2; i2++) {
                    index2 = this.natural(0, old.length - 1);
                    result.push(old[index2]);
                    old.splice(index2, 1);
                  }
                  switch (arguments.length) {
                    case 0:
                    case 1:
                      return result;
                    case 2:
                      max3 = min3;
                    /* falls through */
                    case 3:
                      min3 = parseInt(min3, 10);
                      max3 = parseInt(max3, 10);
                      return result.slice(0, this.natural(min3, max3));
                  }
                },
                /*
                					    * Random.order(item, item)
                					    * Random.order([item, item ...])
                
                					    顺序获取数组中的元素
                
                					    [JSON导入数组支持数组数据录入](https://github.com/thx/RAP/issues/22)
                
                					    不支持单独调用！
                					*/
                order: function order(array) {
                  order.cache = order.cache || {};
                  if (arguments.length > 1) array = [].slice.call(arguments, 0);
                  var options2 = order.options;
                  var templatePath = options2.context.templatePath.join(".");
                  var cache2 = order.cache[templatePath] = order.cache[templatePath] || {
                    index: 0,
                    array
                  };
                  return cache2.array[cache2.index++ % cache2.array.length];
                }
              };
            },
            /* 15 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                // 随机生成一个常见的英文名。
                first: function() {
                  var names2 = [
                    // male
                    "James",
                    "John",
                    "Robert",
                    "Michael",
                    "William",
                    "David",
                    "Richard",
                    "Charles",
                    "Joseph",
                    "Thomas",
                    "Christopher",
                    "Daniel",
                    "Paul",
                    "Mark",
                    "Donald",
                    "George",
                    "Kenneth",
                    "Steven",
                    "Edward",
                    "Brian",
                    "Ronald",
                    "Anthony",
                    "Kevin",
                    "Jason",
                    "Matthew",
                    "Gary",
                    "Timothy",
                    "Jose",
                    "Larry",
                    "Jeffrey",
                    "Frank",
                    "Scott",
                    "Eric"
                  ].concat([
                    // female
                    "Mary",
                    "Patricia",
                    "Linda",
                    "Barbara",
                    "Elizabeth",
                    "Jennifer",
                    "Maria",
                    "Susan",
                    "Margaret",
                    "Dorothy",
                    "Lisa",
                    "Nancy",
                    "Karen",
                    "Betty",
                    "Helen",
                    "Sandra",
                    "Donna",
                    "Carol",
                    "Ruth",
                    "Sharon",
                    "Michelle",
                    "Laura",
                    "Sarah",
                    "Kimberly",
                    "Deborah",
                    "Jessica",
                    "Shirley",
                    "Cynthia",
                    "Angela",
                    "Melissa",
                    "Brenda",
                    "Amy",
                    "Anna"
                  ]);
                  return this.pick(names2);
                },
                // 随机生成一个常见的英文姓。
                last: function() {
                  var names2 = [
                    "Smith",
                    "Johnson",
                    "Williams",
                    "Brown",
                    "Jones",
                    "Miller",
                    "Davis",
                    "Garcia",
                    "Rodriguez",
                    "Wilson",
                    "Martinez",
                    "Anderson",
                    "Taylor",
                    "Thomas",
                    "Hernandez",
                    "Moore",
                    "Martin",
                    "Jackson",
                    "Thompson",
                    "White",
                    "Lopez",
                    "Lee",
                    "Gonzalez",
                    "Harris",
                    "Clark",
                    "Lewis",
                    "Robinson",
                    "Walker",
                    "Perez",
                    "Hall",
                    "Young",
                    "Allen"
                  ];
                  return this.pick(names2);
                },
                // 随机生成一个常见的英文姓名。
                name: function(middle) {
                  return this.first() + " " + (middle ? this.first() + " " : "") + this.last();
                },
                /*
                    随机生成一个常见的中文姓。
                    [世界常用姓氏排行](http://baike.baidu.com/view/1719115.htm)
                    [玄派网 - 网络小说创作辅助平台](http://xuanpai.sinaapp.com/)
                 */
                cfirst: function() {
                  var names2 = "王 李 张 刘 陈 杨 赵 黄 周 吴 徐 孙 胡 朱 高 林 何 郭 马 罗 梁 宋 郑 谢 韩 唐 冯 于 董 萧 程 曹 袁 邓 许 傅 沈 曾 彭 吕 苏 卢 蒋 蔡 贾 丁 魏 薛 叶 阎 余 潘 杜 戴 夏 锺 汪 田 任 姜 范 方 石 姚 谭 廖 邹 熊 金 陆 郝 孔 白 崔 康 毛 邱 秦 江 史 顾 侯 邵 孟 龙 万 段 雷 钱 汤 尹 黎 易 常 武 乔 贺 赖 龚 文".split(" ");
                  return this.pick(names2);
                },
                /*
                    随机生成一个常见的中文名。
                    [中国最常见名字前50名_三九算命网](http://www.name999.net/xingming/xingshi/20131004/48.html)
                 */
                clast: function() {
                  var names2 = "伟 芳 娜 秀英 敏 静 丽 强 磊 军 洋 勇 艳 杰 娟 涛 明 超 秀兰 霞 平 刚 桂英".split(" ");
                  return this.pick(names2);
                },
                // 随机生成一个常见的中文姓名。
                cname: function() {
                  return this.cfirst() + this.clast();
                }
              };
            },
            /* 16 */
            /***/
            function(module2, exports2) {
              module2.exports = {
                /*
                				        随机生成一个 URL。
                
                				        [URL 规范](http://www.w3.org/Addressing/URL/url-spec.txt)
                				            http                    Hypertext Transfer Protocol 
                				            ftp                     File Transfer protocol 
                				            gopher                  The Gopher protocol 
                				            mailto                  Electronic mail address 
                				            mid                     Message identifiers for electronic mail 
                				            cid                     Content identifiers for MIME body part 
                				            news                    Usenet news 
                				            nntp                    Usenet news for local NNTP access only 
                				            prospero                Access using the prospero protocols 
                				            telnet rlogin tn3270    Reference to interactive sessions
                				            wais                    Wide Area Information Servers 
                				    */
                url: function(protocol, host) {
                  return (protocol || this.protocol()) + "://" + // protocol?
                  (host || this.domain()) + // host?
                  "/" + this.word();
                },
                // 随机生成一个 URL 协议。
                protocol: function() {
                  return this.pick(
                    // 协议簇
                    "http ftp gopher mailto mid cid news nntp prospero telnet rlogin tn3270 wais".split(" ")
                  );
                },
                // 随机生成一个域名。
                domain: function(tld) {
                  return this.word() + "." + (tld || this.tld());
                },
                /*
                    随机生成一个顶级域名。
                    国际顶级域名 international top-level domain-names, iTLDs
                    国家顶级域名 national top-level domainnames, nTLDs
                    [域名后缀大全](http://www.163ns.com/zixun/post/4417.html)
                */
                tld: function() {
                  return this.pick(
                    // 域名后缀
                    "com net org edu gov int mil cn com.cn net.cn gov.cn org.cn 中国 中国互联.公司 中国互联.网络 tel biz cc tv info name hk mobi asia cd travel pro museum coop aero ad ae af ag ai al am an ao aq ar as at au aw az ba bb bd be bf bg bh bi bj bm bn bo br bs bt bv bw by bz ca cc cf cg ch ci ck cl cm cn co cq cr cu cv cx cy cz de dj dk dm do dz ec ee eg eh es et ev fi fj fk fm fo fr ga gb gd ge gf gh gi gl gm gn gp gr gt gu gw gy hk hm hn hr ht hu id ie il in io iq ir is it jm jo jp ke kg kh ki km kn kp kr kw ky kz la lb lc li lk lr ls lt lu lv ly ma mc md mg mh ml mm mn mo mp mq mr ms mt mv mw mx my mz na nc ne nf ng ni nl no np nr nt nu nz om qa pa pe pf pg ph pk pl pm pn pr pt pw py re ro ru rw sa sb sc sd se sg sh si sj sk sl sm sn so sr st su sy sz tc td tf tg th tj tk tm tn to tp tr tt tv tw tz ua ug uk us uy va vc ve vg vn vu wf ws ye yu za zm zr zw".split(" ")
                  );
                },
                // 随机生成一个邮件地址。
                email: function(domain) {
                  return this.character("lower") + "." + this.word() + "@" + (domain || this.word() + "." + this.tld());
                },
                // 随机生成一个 IP 地址。
                ip: function() {
                  return this.natural(0, 255) + "." + this.natural(0, 255) + "." + this.natural(0, 255) + "." + this.natural(0, 255);
                }
              };
            },
            /* 17 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var DICT = __webpack_require__2(18);
              var REGION = ["东北", "华北", "华东", "华中", "华南", "西南", "西北"];
              module2.exports = {
                // 随机生成一个大区。
                region: function() {
                  return this.pick(REGION);
                },
                // 随机生成一个（中国）省（或直辖市、自治区、特别行政区）。
                province: function() {
                  return this.pick(DICT).name;
                },
                // 随机生成一个（中国）市。
                city: function(prefix) {
                  var province = this.pick(DICT);
                  var city = this.pick(province.children);
                  return prefix ? [province.name, city.name].join(" ") : city.name;
                },
                // 随机生成一个（中国）县。
                county: function(prefix) {
                  var province = this.pick(DICT);
                  var city = this.pick(province.children);
                  var county = this.pick(city.children) || {
                    name: "-"
                  };
                  return prefix ? [province.name, city.name, county.name].join(" ") : county.name;
                },
                // 随机生成一个邮政编码（六位数字）。
                zip: function(len2) {
                  var zip = "";
                  for (var i2 = 0; i2 < (len2 || 6); i2++) zip += this.natural(0, 9);
                  return zip;
                }
                // address: function() {},
                // phone: function() {},
                // areacode: function() {},
                // street: function() {},
                // street_suffixes: function() {},
                // street_suffix: function() {},
                // states: function() {},
                // state: function() {},
              };
            },
            /* 18 */
            /***/
            function(module2, exports2) {
              var DICT = {
                "110000": "北京",
                "110100": "北京市",
                "110101": "东城区",
                "110102": "西城区",
                "110105": "朝阳区",
                "110106": "丰台区",
                "110107": "石景山区",
                "110108": "海淀区",
                "110109": "门头沟区",
                "110111": "房山区",
                "110112": "通州区",
                "110113": "顺义区",
                "110114": "昌平区",
                "110115": "大兴区",
                "110116": "怀柔区",
                "110117": "平谷区",
                "110228": "密云县",
                "110229": "延庆县",
                "110230": "其它区",
                "120000": "天津",
                "120100": "天津市",
                "120101": "和平区",
                "120102": "河东区",
                "120103": "河西区",
                "120104": "南开区",
                "120105": "河北区",
                "120106": "红桥区",
                "120110": "东丽区",
                "120111": "西青区",
                "120112": "津南区",
                "120113": "北辰区",
                "120114": "武清区",
                "120115": "宝坻区",
                "120116": "滨海新区",
                "120221": "宁河县",
                "120223": "静海县",
                "120225": "蓟县",
                "120226": "其它区",
                "130000": "河北省",
                "130100": "石家庄市",
                "130102": "长安区",
                "130103": "桥东区",
                "130104": "桥西区",
                "130105": "新华区",
                "130107": "井陉矿区",
                "130108": "裕华区",
                "130121": "井陉县",
                "130123": "正定县",
                "130124": "栾城县",
                "130125": "行唐县",
                "130126": "灵寿县",
                "130127": "高邑县",
                "130128": "深泽县",
                "130129": "赞皇县",
                "130130": "无极县",
                "130131": "平山县",
                "130132": "元氏县",
                "130133": "赵县",
                "130181": "辛集市",
                "130182": "藁城市",
                "130183": "晋州市",
                "130184": "新乐市",
                "130185": "鹿泉市",
                "130186": "其它区",
                "130200": "唐山市",
                "130202": "路南区",
                "130203": "路北区",
                "130204": "古冶区",
                "130205": "开平区",
                "130207": "丰南区",
                "130208": "丰润区",
                "130223": "滦县",
                "130224": "滦南县",
                "130225": "乐亭县",
                "130227": "迁西县",
                "130229": "玉田县",
                "130230": "曹妃甸区",
                "130281": "遵化市",
                "130283": "迁安市",
                "130284": "其它区",
                "130300": "秦皇岛市",
                "130302": "海港区",
                "130303": "山海关区",
                "130304": "北戴河区",
                "130321": "青龙满族自治县",
                "130322": "昌黎县",
                "130323": "抚宁县",
                "130324": "卢龙县",
                "130398": "其它区",
                "130400": "邯郸市",
                "130402": "邯山区",
                "130403": "丛台区",
                "130404": "复兴区",
                "130406": "峰峰矿区",
                "130421": "邯郸县",
                "130423": "临漳县",
                "130424": "成安县",
                "130425": "大名县",
                "130426": "涉县",
                "130427": "磁县",
                "130428": "肥乡县",
                "130429": "永年县",
                "130430": "邱县",
                "130431": "鸡泽县",
                "130432": "广平县",
                "130433": "馆陶县",
                "130434": "魏县",
                "130435": "曲周县",
                "130481": "武安市",
                "130482": "其它区",
                "130500": "邢台市",
                "130502": "桥东区",
                "130503": "桥西区",
                "130521": "邢台县",
                "130522": "临城县",
                "130523": "内丘县",
                "130524": "柏乡县",
                "130525": "隆尧县",
                "130526": "任县",
                "130527": "南和县",
                "130528": "宁晋县",
                "130529": "巨鹿县",
                "130530": "新河县",
                "130531": "广宗县",
                "130532": "平乡县",
                "130533": "威县",
                "130534": "清河县",
                "130535": "临西县",
                "130581": "南宫市",
                "130582": "沙河市",
                "130583": "其它区",
                "130600": "保定市",
                "130602": "新市区",
                "130603": "北市区",
                "130604": "南市区",
                "130621": "满城县",
                "130622": "清苑县",
                "130623": "涞水县",
                "130624": "阜平县",
                "130625": "徐水县",
                "130626": "定兴县",
                "130627": "唐县",
                "130628": "高阳县",
                "130629": "容城县",
                "130630": "涞源县",
                "130631": "望都县",
                "130632": "安新县",
                "130633": "易县",
                "130634": "曲阳县",
                "130635": "蠡县",
                "130636": "顺平县",
                "130637": "博野县",
                "130638": "雄县",
                "130681": "涿州市",
                "130682": "定州市",
                "130683": "安国市",
                "130684": "高碑店市",
                "130699": "其它区",
                "130700": "张家口市",
                "130702": "桥东区",
                "130703": "桥西区",
                "130705": "宣化区",
                "130706": "下花园区",
                "130721": "宣化县",
                "130722": "张北县",
                "130723": "康保县",
                "130724": "沽源县",
                "130725": "尚义县",
                "130726": "蔚县",
                "130727": "阳原县",
                "130728": "怀安县",
                "130729": "万全县",
                "130730": "怀来县",
                "130731": "涿鹿县",
                "130732": "赤城县",
                "130733": "崇礼县",
                "130734": "其它区",
                "130800": "承德市",
                "130802": "双桥区",
                "130803": "双滦区",
                "130804": "鹰手营子矿区",
                "130821": "承德县",
                "130822": "兴隆县",
                "130823": "平泉县",
                "130824": "滦平县",
                "130825": "隆化县",
                "130826": "丰宁满族自治县",
                "130827": "宽城满族自治县",
                "130828": "围场满族蒙古族自治县",
                "130829": "其它区",
                "130900": "沧州市",
                "130902": "新华区",
                "130903": "运河区",
                "130921": "沧县",
                "130922": "青县",
                "130923": "东光县",
                "130924": "海兴县",
                "130925": "盐山县",
                "130926": "肃宁县",
                "130927": "南皮县",
                "130928": "吴桥县",
                "130929": "献县",
                "130930": "孟村回族自治县",
                "130981": "泊头市",
                "130982": "任丘市",
                "130983": "黄骅市",
                "130984": "河间市",
                "130985": "其它区",
                "131000": "廊坊市",
                "131002": "安次区",
                "131003": "广阳区",
                "131022": "固安县",
                "131023": "永清县",
                "131024": "香河县",
                "131025": "大城县",
                "131026": "文安县",
                "131028": "大厂回族自治县",
                "131081": "霸州市",
                "131082": "三河市",
                "131083": "其它区",
                "131100": "衡水市",
                "131102": "桃城区",
                "131121": "枣强县",
                "131122": "武邑县",
                "131123": "武强县",
                "131124": "饶阳县",
                "131125": "安平县",
                "131126": "故城县",
                "131127": "景县",
                "131128": "阜城县",
                "131181": "冀州市",
                "131182": "深州市",
                "131183": "其它区",
                "140000": "山西省",
                "140100": "太原市",
                "140105": "小店区",
                "140106": "迎泽区",
                "140107": "杏花岭区",
                "140108": "尖草坪区",
                "140109": "万柏林区",
                "140110": "晋源区",
                "140121": "清徐县",
                "140122": "阳曲县",
                "140123": "娄烦县",
                "140181": "古交市",
                "140182": "其它区",
                "140200": "大同市",
                "140202": "城区",
                "140203": "矿区",
                "140211": "南郊区",
                "140212": "新荣区",
                "140221": "阳高县",
                "140222": "天镇县",
                "140223": "广灵县",
                "140224": "灵丘县",
                "140225": "浑源县",
                "140226": "左云县",
                "140227": "大同县",
                "140228": "其它区",
                "140300": "阳泉市",
                "140302": "城区",
                "140303": "矿区",
                "140311": "郊区",
                "140321": "平定县",
                "140322": "盂县",
                "140323": "其它区",
                "140400": "长治市",
                "140421": "长治县",
                "140423": "襄垣县",
                "140424": "屯留县",
                "140425": "平顺县",
                "140426": "黎城县",
                "140427": "壶关县",
                "140428": "长子县",
                "140429": "武乡县",
                "140430": "沁县",
                "140431": "沁源县",
                "140481": "潞城市",
                "140482": "城区",
                "140483": "郊区",
                "140485": "其它区",
                "140500": "晋城市",
                "140502": "城区",
                "140521": "沁水县",
                "140522": "阳城县",
                "140524": "陵川县",
                "140525": "泽州县",
                "140581": "高平市",
                "140582": "其它区",
                "140600": "朔州市",
                "140602": "朔城区",
                "140603": "平鲁区",
                "140621": "山阴县",
                "140622": "应县",
                "140623": "右玉县",
                "140624": "怀仁县",
                "140625": "其它区",
                "140700": "晋中市",
                "140702": "榆次区",
                "140721": "榆社县",
                "140722": "左权县",
                "140723": "和顺县",
                "140724": "昔阳县",
                "140725": "寿阳县",
                "140726": "太谷县",
                "140727": "祁县",
                "140728": "平遥县",
                "140729": "灵石县",
                "140781": "介休市",
                "140782": "其它区",
                "140800": "运城市",
                "140802": "盐湖区",
                "140821": "临猗县",
                "140822": "万荣县",
                "140823": "闻喜县",
                "140824": "稷山县",
                "140825": "新绛县",
                "140826": "绛县",
                "140827": "垣曲县",
                "140828": "夏县",
                "140829": "平陆县",
                "140830": "芮城县",
                "140881": "永济市",
                "140882": "河津市",
                "140883": "其它区",
                "140900": "忻州市",
                "140902": "忻府区",
                "140921": "定襄县",
                "140922": "五台县",
                "140923": "代县",
                "140924": "繁峙县",
                "140925": "宁武县",
                "140926": "静乐县",
                "140927": "神池县",
                "140928": "五寨县",
                "140929": "岢岚县",
                "140930": "河曲县",
                "140931": "保德县",
                "140932": "偏关县",
                "140981": "原平市",
                "140982": "其它区",
                "141000": "临汾市",
                "141002": "尧都区",
                "141021": "曲沃县",
                "141022": "翼城县",
                "141023": "襄汾县",
                "141024": "洪洞县",
                "141025": "古县",
                "141026": "安泽县",
                "141027": "浮山县",
                "141028": "吉县",
                "141029": "乡宁县",
                "141030": "大宁县",
                "141031": "隰县",
                "141032": "永和县",
                "141033": "蒲县",
                "141034": "汾西县",
                "141081": "侯马市",
                "141082": "霍州市",
                "141083": "其它区",
                "141100": "吕梁市",
                "141102": "离石区",
                "141121": "文水县",
                "141122": "交城县",
                "141123": "兴县",
                "141124": "临县",
                "141125": "柳林县",
                "141126": "石楼县",
                "141127": "岚县",
                "141128": "方山县",
                "141129": "中阳县",
                "141130": "交口县",
                "141181": "孝义市",
                "141182": "汾阳市",
                "141183": "其它区",
                "150000": "内蒙古自治区",
                "150100": "呼和浩特市",
                "150102": "新城区",
                "150103": "回民区",
                "150104": "玉泉区",
                "150105": "赛罕区",
                "150121": "土默特左旗",
                "150122": "托克托县",
                "150123": "和林格尔县",
                "150124": "清水河县",
                "150125": "武川县",
                "150126": "其它区",
                "150200": "包头市",
                "150202": "东河区",
                "150203": "昆都仑区",
                "150204": "青山区",
                "150205": "石拐区",
                "150206": "白云鄂博矿区",
                "150207": "九原区",
                "150221": "土默特右旗",
                "150222": "固阳县",
                "150223": "达尔罕茂明安联合旗",
                "150224": "其它区",
                "150300": "乌海市",
                "150302": "海勃湾区",
                "150303": "海南区",
                "150304": "乌达区",
                "150305": "其它区",
                "150400": "赤峰市",
                "150402": "红山区",
                "150403": "元宝山区",
                "150404": "松山区",
                "150421": "阿鲁科尔沁旗",
                "150422": "巴林左旗",
                "150423": "巴林右旗",
                "150424": "林西县",
                "150425": "克什克腾旗",
                "150426": "翁牛特旗",
                "150428": "喀喇沁旗",
                "150429": "宁城县",
                "150430": "敖汉旗",
                "150431": "其它区",
                "150500": "通辽市",
                "150502": "科尔沁区",
                "150521": "科尔沁左翼中旗",
                "150522": "科尔沁左翼后旗",
                "150523": "开鲁县",
                "150524": "库伦旗",
                "150525": "奈曼旗",
                "150526": "扎鲁特旗",
                "150581": "霍林郭勒市",
                "150582": "其它区",
                "150600": "鄂尔多斯市",
                "150602": "东胜区",
                "150621": "达拉特旗",
                "150622": "准格尔旗",
                "150623": "鄂托克前旗",
                "150624": "鄂托克旗",
                "150625": "杭锦旗",
                "150626": "乌审旗",
                "150627": "伊金霍洛旗",
                "150628": "其它区",
                "150700": "呼伦贝尔市",
                "150702": "海拉尔区",
                "150703": "扎赉诺尔区",
                "150721": "阿荣旗",
                "150722": "莫力达瓦达斡尔族自治旗",
                "150723": "鄂伦春自治旗",
                "150724": "鄂温克族自治旗",
                "150725": "陈巴尔虎旗",
                "150726": "新巴尔虎左旗",
                "150727": "新巴尔虎右旗",
                "150781": "满洲里市",
                "150782": "牙克石市",
                "150783": "扎兰屯市",
                "150784": "额尔古纳市",
                "150785": "根河市",
                "150786": "其它区",
                "150800": "巴彦淖尔市",
                "150802": "临河区",
                "150821": "五原县",
                "150822": "磴口县",
                "150823": "乌拉特前旗",
                "150824": "乌拉特中旗",
                "150825": "乌拉特后旗",
                "150826": "杭锦后旗",
                "150827": "其它区",
                "150900": "乌兰察布市",
                "150902": "集宁区",
                "150921": "卓资县",
                "150922": "化德县",
                "150923": "商都县",
                "150924": "兴和县",
                "150925": "凉城县",
                "150926": "察哈尔右翼前旗",
                "150927": "察哈尔右翼中旗",
                "150928": "察哈尔右翼后旗",
                "150929": "四子王旗",
                "150981": "丰镇市",
                "150982": "其它区",
                "152200": "兴安盟",
                "152201": "乌兰浩特市",
                "152202": "阿尔山市",
                "152221": "科尔沁右翼前旗",
                "152222": "科尔沁右翼中旗",
                "152223": "扎赉特旗",
                "152224": "突泉县",
                "152225": "其它区",
                "152500": "锡林郭勒盟",
                "152501": "二连浩特市",
                "152502": "锡林浩特市",
                "152522": "阿巴嘎旗",
                "152523": "苏尼特左旗",
                "152524": "苏尼特右旗",
                "152525": "东乌珠穆沁旗",
                "152526": "西乌珠穆沁旗",
                "152527": "太仆寺旗",
                "152528": "镶黄旗",
                "152529": "正镶白旗",
                "152530": "正蓝旗",
                "152531": "多伦县",
                "152532": "其它区",
                "152900": "阿拉善盟",
                "152921": "阿拉善左旗",
                "152922": "阿拉善右旗",
                "152923": "额济纳旗",
                "152924": "其它区",
                "210000": "辽宁省",
                "210100": "沈阳市",
                "210102": "和平区",
                "210103": "沈河区",
                "210104": "大东区",
                "210105": "皇姑区",
                "210106": "铁西区",
                "210111": "苏家屯区",
                "210112": "东陵区",
                "210113": "新城子区",
                "210114": "于洪区",
                "210122": "辽中县",
                "210123": "康平县",
                "210124": "法库县",
                "210181": "新民市",
                "210184": "沈北新区",
                "210185": "其它区",
                "210200": "大连市",
                "210202": "中山区",
                "210203": "西岗区",
                "210204": "沙河口区",
                "210211": "甘井子区",
                "210212": "旅顺口区",
                "210213": "金州区",
                "210224": "长海县",
                "210281": "瓦房店市",
                "210282": "普兰店市",
                "210283": "庄河市",
                "210298": "其它区",
                "210300": "鞍山市",
                "210302": "铁东区",
                "210303": "铁西区",
                "210304": "立山区",
                "210311": "千山区",
                "210321": "台安县",
                "210323": "岫岩满族自治县",
                "210381": "海城市",
                "210382": "其它区",
                "210400": "抚顺市",
                "210402": "新抚区",
                "210403": "东洲区",
                "210404": "望花区",
                "210411": "顺城区",
                "210421": "抚顺县",
                "210422": "新宾满族自治县",
                "210423": "清原满族自治县",
                "210424": "其它区",
                "210500": "本溪市",
                "210502": "平山区",
                "210503": "溪湖区",
                "210504": "明山区",
                "210505": "南芬区",
                "210521": "本溪满族自治县",
                "210522": "桓仁满族自治县",
                "210523": "其它区",
                "210600": "丹东市",
                "210602": "元宝区",
                "210603": "振兴区",
                "210604": "振安区",
                "210624": "宽甸满族自治县",
                "210681": "东港市",
                "210682": "凤城市",
                "210683": "其它区",
                "210700": "锦州市",
                "210702": "古塔区",
                "210703": "凌河区",
                "210711": "太和区",
                "210726": "黑山县",
                "210727": "义县",
                "210781": "凌海市",
                "210782": "北镇市",
                "210783": "其它区",
                "210800": "营口市",
                "210802": "站前区",
                "210803": "西市区",
                "210804": "鲅鱼圈区",
                "210811": "老边区",
                "210881": "盖州市",
                "210882": "大石桥市",
                "210883": "其它区",
                "210900": "阜新市",
                "210902": "海州区",
                "210903": "新邱区",
                "210904": "太平区",
                "210905": "清河门区",
                "210911": "细河区",
                "210921": "阜新蒙古族自治县",
                "210922": "彰武县",
                "210923": "其它区",
                "211000": "辽阳市",
                "211002": "白塔区",
                "211003": "文圣区",
                "211004": "宏伟区",
                "211005": "弓长岭区",
                "211011": "太子河区",
                "211021": "辽阳县",
                "211081": "灯塔市",
                "211082": "其它区",
                "211100": "盘锦市",
                "211102": "双台子区",
                "211103": "兴隆台区",
                "211121": "大洼县",
                "211122": "盘山县",
                "211123": "其它区",
                "211200": "铁岭市",
                "211202": "银州区",
                "211204": "清河区",
                "211221": "铁岭县",
                "211223": "西丰县",
                "211224": "昌图县",
                "211281": "调兵山市",
                "211282": "开原市",
                "211283": "其它区",
                "211300": "朝阳市",
                "211302": "双塔区",
                "211303": "龙城区",
                "211321": "朝阳县",
                "211322": "建平县",
                "211324": "喀喇沁左翼蒙古族自治县",
                "211381": "北票市",
                "211382": "凌源市",
                "211383": "其它区",
                "211400": "葫芦岛市",
                "211402": "连山区",
                "211403": "龙港区",
                "211404": "南票区",
                "211421": "绥中县",
                "211422": "建昌县",
                "211481": "兴城市",
                "211482": "其它区",
                "220000": "吉林省",
                "220100": "长春市",
                "220102": "南关区",
                "220103": "宽城区",
                "220104": "朝阳区",
                "220105": "二道区",
                "220106": "绿园区",
                "220112": "双阳区",
                "220122": "农安县",
                "220181": "九台市",
                "220182": "榆树市",
                "220183": "德惠市",
                "220188": "其它区",
                "220200": "吉林市",
                "220202": "昌邑区",
                "220203": "龙潭区",
                "220204": "船营区",
                "220211": "丰满区",
                "220221": "永吉县",
                "220281": "蛟河市",
                "220282": "桦甸市",
                "220283": "舒兰市",
                "220284": "磐石市",
                "220285": "其它区",
                "220300": "四平市",
                "220302": "铁西区",
                "220303": "铁东区",
                "220322": "梨树县",
                "220323": "伊通满族自治县",
                "220381": "公主岭市",
                "220382": "双辽市",
                "220383": "其它区",
                "220400": "辽源市",
                "220402": "龙山区",
                "220403": "西安区",
                "220421": "东丰县",
                "220422": "东辽县",
                "220423": "其它区",
                "220500": "通化市",
                "220502": "东昌区",
                "220503": "二道江区",
                "220521": "通化县",
                "220523": "辉南县",
                "220524": "柳河县",
                "220581": "梅河口市",
                "220582": "集安市",
                "220583": "其它区",
                "220600": "白山市",
                "220602": "浑江区",
                "220621": "抚松县",
                "220622": "靖宇县",
                "220623": "长白朝鲜族自治县",
                "220625": "江源区",
                "220681": "临江市",
                "220682": "其它区",
                "220700": "松原市",
                "220702": "宁江区",
                "220721": "前郭尔罗斯蒙古族自治县",
                "220722": "长岭县",
                "220723": "乾安县",
                "220724": "扶余市",
                "220725": "其它区",
                "220800": "白城市",
                "220802": "洮北区",
                "220821": "镇赉县",
                "220822": "通榆县",
                "220881": "洮南市",
                "220882": "大安市",
                "220883": "其它区",
                "222400": "延边朝鲜族自治州",
                "222401": "延吉市",
                "222402": "图们市",
                "222403": "敦化市",
                "222404": "珲春市",
                "222405": "龙井市",
                "222406": "和龙市",
                "222424": "汪清县",
                "222426": "安图县",
                "222427": "其它区",
                "230000": "黑龙江省",
                "230100": "哈尔滨市",
                "230102": "道里区",
                "230103": "南岗区",
                "230104": "道外区",
                "230106": "香坊区",
                "230108": "平房区",
                "230109": "松北区",
                "230111": "呼兰区",
                "230123": "依兰县",
                "230124": "方正县",
                "230125": "宾县",
                "230126": "巴彦县",
                "230127": "木兰县",
                "230128": "通河县",
                "230129": "延寿县",
                "230181": "阿城区",
                "230182": "双城市",
                "230183": "尚志市",
                "230184": "五常市",
                "230186": "其它区",
                "230200": "齐齐哈尔市",
                "230202": "龙沙区",
                "230203": "建华区",
                "230204": "铁锋区",
                "230205": "昂昂溪区",
                "230206": "富拉尔基区",
                "230207": "碾子山区",
                "230208": "梅里斯达斡尔族区",
                "230221": "龙江县",
                "230223": "依安县",
                "230224": "泰来县",
                "230225": "甘南县",
                "230227": "富裕县",
                "230229": "克山县",
                "230230": "克东县",
                "230231": "拜泉县",
                "230281": "讷河市",
                "230282": "其它区",
                "230300": "鸡西市",
                "230302": "鸡冠区",
                "230303": "恒山区",
                "230304": "滴道区",
                "230305": "梨树区",
                "230306": "城子河区",
                "230307": "麻山区",
                "230321": "鸡东县",
                "230381": "虎林市",
                "230382": "密山市",
                "230383": "其它区",
                "230400": "鹤岗市",
                "230402": "向阳区",
                "230403": "工农区",
                "230404": "南山区",
                "230405": "兴安区",
                "230406": "东山区",
                "230407": "兴山区",
                "230421": "萝北县",
                "230422": "绥滨县",
                "230423": "其它区",
                "230500": "双鸭山市",
                "230502": "尖山区",
                "230503": "岭东区",
                "230505": "四方台区",
                "230506": "宝山区",
                "230521": "集贤县",
                "230522": "友谊县",
                "230523": "宝清县",
                "230524": "饶河县",
                "230525": "其它区",
                "230600": "大庆市",
                "230602": "萨尔图区",
                "230603": "龙凤区",
                "230604": "让胡路区",
                "230605": "红岗区",
                "230606": "大同区",
                "230621": "肇州县",
                "230622": "肇源县",
                "230623": "林甸县",
                "230624": "杜尔伯特蒙古族自治县",
                "230625": "其它区",
                "230700": "伊春市",
                "230702": "伊春区",
                "230703": "南岔区",
                "230704": "友好区",
                "230705": "西林区",
                "230706": "翠峦区",
                "230707": "新青区",
                "230708": "美溪区",
                "230709": "金山屯区",
                "230710": "五营区",
                "230711": "乌马河区",
                "230712": "汤旺河区",
                "230713": "带岭区",
                "230714": "乌伊岭区",
                "230715": "红星区",
                "230716": "上甘岭区",
                "230722": "嘉荫县",
                "230781": "铁力市",
                "230782": "其它区",
                "230800": "佳木斯市",
                "230803": "向阳区",
                "230804": "前进区",
                "230805": "东风区",
                "230811": "郊区",
                "230822": "桦南县",
                "230826": "桦川县",
                "230828": "汤原县",
                "230833": "抚远县",
                "230881": "同江市",
                "230882": "富锦市",
                "230883": "其它区",
                "230900": "七台河市",
                "230902": "新兴区",
                "230903": "桃山区",
                "230904": "茄子河区",
                "230921": "勃利县",
                "230922": "其它区",
                "231000": "牡丹江市",
                "231002": "东安区",
                "231003": "阳明区",
                "231004": "爱民区",
                "231005": "西安区",
                "231024": "东宁县",
                "231025": "林口县",
                "231081": "绥芬河市",
                "231083": "海林市",
                "231084": "宁安市",
                "231085": "穆棱市",
                "231086": "其它区",
                "231100": "黑河市",
                "231102": "爱辉区",
                "231121": "嫩江县",
                "231123": "逊克县",
                "231124": "孙吴县",
                "231181": "北安市",
                "231182": "五大连池市",
                "231183": "其它区",
                "231200": "绥化市",
                "231202": "北林区",
                "231221": "望奎县",
                "231222": "兰西县",
                "231223": "青冈县",
                "231224": "庆安县",
                "231225": "明水县",
                "231226": "绥棱县",
                "231281": "安达市",
                "231282": "肇东市",
                "231283": "海伦市",
                "231284": "其它区",
                "232700": "大兴安岭地区",
                "232702": "松岭区",
                "232703": "新林区",
                "232704": "呼中区",
                "232721": "呼玛县",
                "232722": "塔河县",
                "232723": "漠河县",
                "232724": "加格达奇区",
                "232725": "其它区",
                "310000": "上海",
                "310100": "上海市",
                "310101": "黄浦区",
                "310104": "徐汇区",
                "310105": "长宁区",
                "310106": "静安区",
                "310107": "普陀区",
                "310108": "闸北区",
                "310109": "虹口区",
                "310110": "杨浦区",
                "310112": "闵行区",
                "310113": "宝山区",
                "310114": "嘉定区",
                "310115": "浦东新区",
                "310116": "金山区",
                "310117": "松江区",
                "310118": "青浦区",
                "310120": "奉贤区",
                "310230": "崇明县",
                "310231": "其它区",
                "320000": "江苏省",
                "320100": "南京市",
                "320102": "玄武区",
                "320104": "秦淮区",
                "320105": "建邺区",
                "320106": "鼓楼区",
                "320111": "浦口区",
                "320113": "栖霞区",
                "320114": "雨花台区",
                "320115": "江宁区",
                "320116": "六合区",
                "320124": "溧水区",
                "320125": "高淳区",
                "320126": "其它区",
                "320200": "无锡市",
                "320202": "崇安区",
                "320203": "南长区",
                "320204": "北塘区",
                "320205": "锡山区",
                "320206": "惠山区",
                "320211": "滨湖区",
                "320281": "江阴市",
                "320282": "宜兴市",
                "320297": "其它区",
                "320300": "徐州市",
                "320302": "鼓楼区",
                "320303": "云龙区",
                "320305": "贾汪区",
                "320311": "泉山区",
                "320321": "丰县",
                "320322": "沛县",
                "320323": "铜山区",
                "320324": "睢宁县",
                "320381": "新沂市",
                "320382": "邳州市",
                "320383": "其它区",
                "320400": "常州市",
                "320402": "天宁区",
                "320404": "钟楼区",
                "320405": "戚墅堰区",
                "320411": "新北区",
                "320412": "武进区",
                "320481": "溧阳市",
                "320482": "金坛市",
                "320483": "其它区",
                "320500": "苏州市",
                "320505": "虎丘区",
                "320506": "吴中区",
                "320507": "相城区",
                "320508": "姑苏区",
                "320581": "常熟市",
                "320582": "张家港市",
                "320583": "昆山市",
                "320584": "吴江区",
                "320585": "太仓市",
                "320596": "其它区",
                "320600": "南通市",
                "320602": "崇川区",
                "320611": "港闸区",
                "320612": "通州区",
                "320621": "海安县",
                "320623": "如东县",
                "320681": "启东市",
                "320682": "如皋市",
                "320684": "海门市",
                "320694": "其它区",
                "320700": "连云港市",
                "320703": "连云区",
                "320705": "新浦区",
                "320706": "海州区",
                "320721": "赣榆县",
                "320722": "东海县",
                "320723": "灌云县",
                "320724": "灌南县",
                "320725": "其它区",
                "320800": "淮安市",
                "320802": "清河区",
                "320803": "淮安区",
                "320804": "淮阴区",
                "320811": "清浦区",
                "320826": "涟水县",
                "320829": "洪泽县",
                "320830": "盱眙县",
                "320831": "金湖县",
                "320832": "其它区",
                "320900": "盐城市",
                "320902": "亭湖区",
                "320903": "盐都区",
                "320921": "响水县",
                "320922": "滨海县",
                "320923": "阜宁县",
                "320924": "射阳县",
                "320925": "建湖县",
                "320981": "东台市",
                "320982": "大丰市",
                "320983": "其它区",
                "321000": "扬州市",
                "321002": "广陵区",
                "321003": "邗江区",
                "321023": "宝应县",
                "321081": "仪征市",
                "321084": "高邮市",
                "321088": "江都区",
                "321093": "其它区",
                "321100": "镇江市",
                "321102": "京口区",
                "321111": "润州区",
                "321112": "丹徒区",
                "321181": "丹阳市",
                "321182": "扬中市",
                "321183": "句容市",
                "321184": "其它区",
                "321200": "泰州市",
                "321202": "海陵区",
                "321203": "高港区",
                "321281": "兴化市",
                "321282": "靖江市",
                "321283": "泰兴市",
                "321284": "姜堰区",
                "321285": "其它区",
                "321300": "宿迁市",
                "321302": "宿城区",
                "321311": "宿豫区",
                "321322": "沭阳县",
                "321323": "泗阳县",
                "321324": "泗洪县",
                "321325": "其它区",
                "330000": "浙江省",
                "330100": "杭州市",
                "330102": "上城区",
                "330103": "下城区",
                "330104": "江干区",
                "330105": "拱墅区",
                "330106": "西湖区",
                "330108": "滨江区",
                "330109": "萧山区",
                "330110": "余杭区",
                "330122": "桐庐县",
                "330127": "淳安县",
                "330182": "建德市",
                "330183": "富阳市",
                "330185": "临安市",
                "330186": "其它区",
                "330200": "宁波市",
                "330203": "海曙区",
                "330204": "江东区",
                "330205": "江北区",
                "330206": "北仑区",
                "330211": "镇海区",
                "330212": "鄞州区",
                "330225": "象山县",
                "330226": "宁海县",
                "330281": "余姚市",
                "330282": "慈溪市",
                "330283": "奉化市",
                "330284": "其它区",
                "330300": "温州市",
                "330302": "鹿城区",
                "330303": "龙湾区",
                "330304": "瓯海区",
                "330322": "洞头县",
                "330324": "永嘉县",
                "330326": "平阳县",
                "330327": "苍南县",
                "330328": "文成县",
                "330329": "泰顺县",
                "330381": "瑞安市",
                "330382": "乐清市",
                "330383": "其它区",
                "330400": "嘉兴市",
                "330402": "南湖区",
                "330411": "秀洲区",
                "330421": "嘉善县",
                "330424": "海盐县",
                "330481": "海宁市",
                "330482": "平湖市",
                "330483": "桐乡市",
                "330484": "其它区",
                "330500": "湖州市",
                "330502": "吴兴区",
                "330503": "南浔区",
                "330521": "德清县",
                "330522": "长兴县",
                "330523": "安吉县",
                "330524": "其它区",
                "330600": "绍兴市",
                "330602": "越城区",
                "330621": "绍兴县",
                "330624": "新昌县",
                "330681": "诸暨市",
                "330682": "上虞市",
                "330683": "嵊州市",
                "330684": "其它区",
                "330700": "金华市",
                "330702": "婺城区",
                "330703": "金东区",
                "330723": "武义县",
                "330726": "浦江县",
                "330727": "磐安县",
                "330781": "兰溪市",
                "330782": "义乌市",
                "330783": "东阳市",
                "330784": "永康市",
                "330785": "其它区",
                "330800": "衢州市",
                "330802": "柯城区",
                "330803": "衢江区",
                "330822": "常山县",
                "330824": "开化县",
                "330825": "龙游县",
                "330881": "江山市",
                "330882": "其它区",
                "330900": "舟山市",
                "330902": "定海区",
                "330903": "普陀区",
                "330921": "岱山县",
                "330922": "嵊泗县",
                "330923": "其它区",
                "331000": "台州市",
                "331002": "椒江区",
                "331003": "黄岩区",
                "331004": "路桥区",
                "331021": "玉环县",
                "331022": "三门县",
                "331023": "天台县",
                "331024": "仙居县",
                "331081": "温岭市",
                "331082": "临海市",
                "331083": "其它区",
                "331100": "丽水市",
                "331102": "莲都区",
                "331121": "青田县",
                "331122": "缙云县",
                "331123": "遂昌县",
                "331124": "松阳县",
                "331125": "云和县",
                "331126": "庆元县",
                "331127": "景宁畲族自治县",
                "331181": "龙泉市",
                "331182": "其它区",
                "340000": "安徽省",
                "340100": "合肥市",
                "340102": "瑶海区",
                "340103": "庐阳区",
                "340104": "蜀山区",
                "340111": "包河区",
                "340121": "长丰县",
                "340122": "肥东县",
                "340123": "肥西县",
                "340192": "其它区",
                "340200": "芜湖市",
                "340202": "镜湖区",
                "340203": "弋江区",
                "340207": "鸠江区",
                "340208": "三山区",
                "340221": "芜湖县",
                "340222": "繁昌县",
                "340223": "南陵县",
                "340224": "其它区",
                "340300": "蚌埠市",
                "340302": "龙子湖区",
                "340303": "蚌山区",
                "340304": "禹会区",
                "340311": "淮上区",
                "340321": "怀远县",
                "340322": "五河县",
                "340323": "固镇县",
                "340324": "其它区",
                "340400": "淮南市",
                "340402": "大通区",
                "340403": "田家庵区",
                "340404": "谢家集区",
                "340405": "八公山区",
                "340406": "潘集区",
                "340421": "凤台县",
                "340422": "其它区",
                "340500": "马鞍山市",
                "340503": "花山区",
                "340504": "雨山区",
                "340506": "博望区",
                "340521": "当涂县",
                "340522": "其它区",
                "340600": "淮北市",
                "340602": "杜集区",
                "340603": "相山区",
                "340604": "烈山区",
                "340621": "濉溪县",
                "340622": "其它区",
                "340700": "铜陵市",
                "340702": "铜官山区",
                "340703": "狮子山区",
                "340711": "郊区",
                "340721": "铜陵县",
                "340722": "其它区",
                "340800": "安庆市",
                "340802": "迎江区",
                "340803": "大观区",
                "340811": "宜秀区",
                "340822": "怀宁县",
                "340823": "枞阳县",
                "340824": "潜山县",
                "340825": "太湖县",
                "340826": "宿松县",
                "340827": "望江县",
                "340828": "岳西县",
                "340881": "桐城市",
                "340882": "其它区",
                "341000": "黄山市",
                "341002": "屯溪区",
                "341003": "黄山区",
                "341004": "徽州区",
                "341021": "歙县",
                "341022": "休宁县",
                "341023": "黟县",
                "341024": "祁门县",
                "341025": "其它区",
                "341100": "滁州市",
                "341102": "琅琊区",
                "341103": "南谯区",
                "341122": "来安县",
                "341124": "全椒县",
                "341125": "定远县",
                "341126": "凤阳县",
                "341181": "天长市",
                "341182": "明光市",
                "341183": "其它区",
                "341200": "阜阳市",
                "341202": "颍州区",
                "341203": "颍东区",
                "341204": "颍泉区",
                "341221": "临泉县",
                "341222": "太和县",
                "341225": "阜南县",
                "341226": "颍上县",
                "341282": "界首市",
                "341283": "其它区",
                "341300": "宿州市",
                "341302": "埇桥区",
                "341321": "砀山县",
                "341322": "萧县",
                "341323": "灵璧县",
                "341324": "泗县",
                "341325": "其它区",
                "341400": "巢湖市",
                "341421": "庐江县",
                "341422": "无为县",
                "341423": "含山县",
                "341424": "和县",
                "341500": "六安市",
                "341502": "金安区",
                "341503": "裕安区",
                "341521": "寿县",
                "341522": "霍邱县",
                "341523": "舒城县",
                "341524": "金寨县",
                "341525": "霍山县",
                "341526": "其它区",
                "341600": "亳州市",
                "341602": "谯城区",
                "341621": "涡阳县",
                "341622": "蒙城县",
                "341623": "利辛县",
                "341624": "其它区",
                "341700": "池州市",
                "341702": "贵池区",
                "341721": "东至县",
                "341722": "石台县",
                "341723": "青阳县",
                "341724": "其它区",
                "341800": "宣城市",
                "341802": "宣州区",
                "341821": "郎溪县",
                "341822": "广德县",
                "341823": "泾县",
                "341824": "绩溪县",
                "341825": "旌德县",
                "341881": "宁国市",
                "341882": "其它区",
                "350000": "福建省",
                "350100": "福州市",
                "350102": "鼓楼区",
                "350103": "台江区",
                "350104": "仓山区",
                "350105": "马尾区",
                "350111": "晋安区",
                "350121": "闽侯县",
                "350122": "连江县",
                "350123": "罗源县",
                "350124": "闽清县",
                "350125": "永泰县",
                "350128": "平潭县",
                "350181": "福清市",
                "350182": "长乐市",
                "350183": "其它区",
                "350200": "厦门市",
                "350203": "思明区",
                "350205": "海沧区",
                "350206": "湖里区",
                "350211": "集美区",
                "350212": "同安区",
                "350213": "翔安区",
                "350214": "其它区",
                "350300": "莆田市",
                "350302": "城厢区",
                "350303": "涵江区",
                "350304": "荔城区",
                "350305": "秀屿区",
                "350322": "仙游县",
                "350323": "其它区",
                "350400": "三明市",
                "350402": "梅列区",
                "350403": "三元区",
                "350421": "明溪县",
                "350423": "清流县",
                "350424": "宁化县",
                "350425": "大田县",
                "350426": "尤溪县",
                "350427": "沙县",
                "350428": "将乐县",
                "350429": "泰宁县",
                "350430": "建宁县",
                "350481": "永安市",
                "350482": "其它区",
                "350500": "泉州市",
                "350502": "鲤城区",
                "350503": "丰泽区",
                "350504": "洛江区",
                "350505": "泉港区",
                "350521": "惠安县",
                "350524": "安溪县",
                "350525": "永春县",
                "350526": "德化县",
                "350527": "金门县",
                "350581": "石狮市",
                "350582": "晋江市",
                "350583": "南安市",
                "350584": "其它区",
                "350600": "漳州市",
                "350602": "芗城区",
                "350603": "龙文区",
                "350622": "云霄县",
                "350623": "漳浦县",
                "350624": "诏安县",
                "350625": "长泰县",
                "350626": "东山县",
                "350627": "南靖县",
                "350628": "平和县",
                "350629": "华安县",
                "350681": "龙海市",
                "350682": "其它区",
                "350700": "南平市",
                "350702": "延平区",
                "350721": "顺昌县",
                "350722": "浦城县",
                "350723": "光泽县",
                "350724": "松溪县",
                "350725": "政和县",
                "350781": "邵武市",
                "350782": "武夷山市",
                "350783": "建瓯市",
                "350784": "建阳市",
                "350785": "其它区",
                "350800": "龙岩市",
                "350802": "新罗区",
                "350821": "长汀县",
                "350822": "永定县",
                "350823": "上杭县",
                "350824": "武平县",
                "350825": "连城县",
                "350881": "漳平市",
                "350882": "其它区",
                "350900": "宁德市",
                "350902": "蕉城区",
                "350921": "霞浦县",
                "350922": "古田县",
                "350923": "屏南县",
                "350924": "寿宁县",
                "350925": "周宁县",
                "350926": "柘荣县",
                "350981": "福安市",
                "350982": "福鼎市",
                "350983": "其它区",
                "360000": "江西省",
                "360100": "南昌市",
                "360102": "东湖区",
                "360103": "西湖区",
                "360104": "青云谱区",
                "360105": "湾里区",
                "360111": "青山湖区",
                "360121": "南昌县",
                "360122": "新建县",
                "360123": "安义县",
                "360124": "进贤县",
                "360128": "其它区",
                "360200": "景德镇市",
                "360202": "昌江区",
                "360203": "珠山区",
                "360222": "浮梁县",
                "360281": "乐平市",
                "360282": "其它区",
                "360300": "萍乡市",
                "360302": "安源区",
                "360313": "湘东区",
                "360321": "莲花县",
                "360322": "上栗县",
                "360323": "芦溪县",
                "360324": "其它区",
                "360400": "九江市",
                "360402": "庐山区",
                "360403": "浔阳区",
                "360421": "九江县",
                "360423": "武宁县",
                "360424": "修水县",
                "360425": "永修县",
                "360426": "德安县",
                "360427": "星子县",
                "360428": "都昌县",
                "360429": "湖口县",
                "360430": "彭泽县",
                "360481": "瑞昌市",
                "360482": "其它区",
                "360483": "共青城市",
                "360500": "新余市",
                "360502": "渝水区",
                "360521": "分宜县",
                "360522": "其它区",
                "360600": "鹰潭市",
                "360602": "月湖区",
                "360622": "余江县",
                "360681": "贵溪市",
                "360682": "其它区",
                "360700": "赣州市",
                "360702": "章贡区",
                "360721": "赣县",
                "360722": "信丰县",
                "360723": "大余县",
                "360724": "上犹县",
                "360725": "崇义县",
                "360726": "安远县",
                "360727": "龙南县",
                "360728": "定南县",
                "360729": "全南县",
                "360730": "宁都县",
                "360731": "于都县",
                "360732": "兴国县",
                "360733": "会昌县",
                "360734": "寻乌县",
                "360735": "石城县",
                "360781": "瑞金市",
                "360782": "南康市",
                "360783": "其它区",
                "360800": "吉安市",
                "360802": "吉州区",
                "360803": "青原区",
                "360821": "吉安县",
                "360822": "吉水县",
                "360823": "峡江县",
                "360824": "新干县",
                "360825": "永丰县",
                "360826": "泰和县",
                "360827": "遂川县",
                "360828": "万安县",
                "360829": "安福县",
                "360830": "永新县",
                "360881": "井冈山市",
                "360882": "其它区",
                "360900": "宜春市",
                "360902": "袁州区",
                "360921": "奉新县",
                "360922": "万载县",
                "360923": "上高县",
                "360924": "宜丰县",
                "360925": "靖安县",
                "360926": "铜鼓县",
                "360981": "丰城市",
                "360982": "樟树市",
                "360983": "高安市",
                "360984": "其它区",
                "361000": "抚州市",
                "361002": "临川区",
                "361021": "南城县",
                "361022": "黎川县",
                "361023": "南丰县",
                "361024": "崇仁县",
                "361025": "乐安县",
                "361026": "宜黄县",
                "361027": "金溪县",
                "361028": "资溪县",
                "361029": "东乡县",
                "361030": "广昌县",
                "361031": "其它区",
                "361100": "上饶市",
                "361102": "信州区",
                "361121": "上饶县",
                "361122": "广丰县",
                "361123": "玉山县",
                "361124": "铅山县",
                "361125": "横峰县",
                "361126": "弋阳县",
                "361127": "余干县",
                "361128": "鄱阳县",
                "361129": "万年县",
                "361130": "婺源县",
                "361181": "德兴市",
                "361182": "其它区",
                "370000": "山东省",
                "370100": "济南市",
                "370102": "历下区",
                "370103": "市中区",
                "370104": "槐荫区",
                "370105": "天桥区",
                "370112": "历城区",
                "370113": "长清区",
                "370124": "平阴县",
                "370125": "济阳县",
                "370126": "商河县",
                "370181": "章丘市",
                "370182": "其它区",
                "370200": "青岛市",
                "370202": "市南区",
                "370203": "市北区",
                "370211": "黄岛区",
                "370212": "崂山区",
                "370213": "李沧区",
                "370214": "城阳区",
                "370281": "胶州市",
                "370282": "即墨市",
                "370283": "平度市",
                "370285": "莱西市",
                "370286": "其它区",
                "370300": "淄博市",
                "370302": "淄川区",
                "370303": "张店区",
                "370304": "博山区",
                "370305": "临淄区",
                "370306": "周村区",
                "370321": "桓台县",
                "370322": "高青县",
                "370323": "沂源县",
                "370324": "其它区",
                "370400": "枣庄市",
                "370402": "市中区",
                "370403": "薛城区",
                "370404": "峄城区",
                "370405": "台儿庄区",
                "370406": "山亭区",
                "370481": "滕州市",
                "370482": "其它区",
                "370500": "东营市",
                "370502": "东营区",
                "370503": "河口区",
                "370521": "垦利县",
                "370522": "利津县",
                "370523": "广饶县",
                "370591": "其它区",
                "370600": "烟台市",
                "370602": "芝罘区",
                "370611": "福山区",
                "370612": "牟平区",
                "370613": "莱山区",
                "370634": "长岛县",
                "370681": "龙口市",
                "370682": "莱阳市",
                "370683": "莱州市",
                "370684": "蓬莱市",
                "370685": "招远市",
                "370686": "栖霞市",
                "370687": "海阳市",
                "370688": "其它区",
                "370700": "潍坊市",
                "370702": "潍城区",
                "370703": "寒亭区",
                "370704": "坊子区",
                "370705": "奎文区",
                "370724": "临朐县",
                "370725": "昌乐县",
                "370781": "青州市",
                "370782": "诸城市",
                "370783": "寿光市",
                "370784": "安丘市",
                "370785": "高密市",
                "370786": "昌邑市",
                "370787": "其它区",
                "370800": "济宁市",
                "370802": "市中区",
                "370811": "任城区",
                "370826": "微山县",
                "370827": "鱼台县",
                "370828": "金乡县",
                "370829": "嘉祥县",
                "370830": "汶上县",
                "370831": "泗水县",
                "370832": "梁山县",
                "370881": "曲阜市",
                "370882": "兖州市",
                "370883": "邹城市",
                "370884": "其它区",
                "370900": "泰安市",
                "370902": "泰山区",
                "370903": "岱岳区",
                "370921": "宁阳县",
                "370923": "东平县",
                "370982": "新泰市",
                "370983": "肥城市",
                "370984": "其它区",
                "371000": "威海市",
                "371002": "环翠区",
                "371081": "文登市",
                "371082": "荣成市",
                "371083": "乳山市",
                "371084": "其它区",
                "371100": "日照市",
                "371102": "东港区",
                "371103": "岚山区",
                "371121": "五莲县",
                "371122": "莒县",
                "371123": "其它区",
                "371200": "莱芜市",
                "371202": "莱城区",
                "371203": "钢城区",
                "371204": "其它区",
                "371300": "临沂市",
                "371302": "兰山区",
                "371311": "罗庄区",
                "371312": "河东区",
                "371321": "沂南县",
                "371322": "郯城县",
                "371323": "沂水县",
                "371324": "苍山县",
                "371325": "费县",
                "371326": "平邑县",
                "371327": "莒南县",
                "371328": "蒙阴县",
                "371329": "临沭县",
                "371330": "其它区",
                "371400": "德州市",
                "371402": "德城区",
                "371421": "陵县",
                "371422": "宁津县",
                "371423": "庆云县",
                "371424": "临邑县",
                "371425": "齐河县",
                "371426": "平原县",
                "371427": "夏津县",
                "371428": "武城县",
                "371481": "乐陵市",
                "371482": "禹城市",
                "371483": "其它区",
                "371500": "聊城市",
                "371502": "东昌府区",
                "371521": "阳谷县",
                "371522": "莘县",
                "371523": "茌平县",
                "371524": "东阿县",
                "371525": "冠县",
                "371526": "高唐县",
                "371581": "临清市",
                "371582": "其它区",
                "371600": "滨州市",
                "371602": "滨城区",
                "371621": "惠民县",
                "371622": "阳信县",
                "371623": "无棣县",
                "371624": "沾化县",
                "371625": "博兴县",
                "371626": "邹平县",
                "371627": "其它区",
                "371700": "菏泽市",
                "371702": "牡丹区",
                "371721": "曹县",
                "371722": "单县",
                "371723": "成武县",
                "371724": "巨野县",
                "371725": "郓城县",
                "371726": "鄄城县",
                "371727": "定陶县",
                "371728": "东明县",
                "371729": "其它区",
                "410000": "河南省",
                "410100": "郑州市",
                "410102": "中原区",
                "410103": "二七区",
                "410104": "管城回族区",
                "410105": "金水区",
                "410106": "上街区",
                "410108": "惠济区",
                "410122": "中牟县",
                "410181": "巩义市",
                "410182": "荥阳市",
                "410183": "新密市",
                "410184": "新郑市",
                "410185": "登封市",
                "410188": "其它区",
                "410200": "开封市",
                "410202": "龙亭区",
                "410203": "顺河回族区",
                "410204": "鼓楼区",
                "410205": "禹王台区",
                "410211": "金明区",
                "410221": "杞县",
                "410222": "通许县",
                "410223": "尉氏县",
                "410224": "开封县",
                "410225": "兰考县",
                "410226": "其它区",
                "410300": "洛阳市",
                "410302": "老城区",
                "410303": "西工区",
                "410304": "瀍河回族区",
                "410305": "涧西区",
                "410306": "吉利区",
                "410307": "洛龙区",
                "410322": "孟津县",
                "410323": "新安县",
                "410324": "栾川县",
                "410325": "嵩县",
                "410326": "汝阳县",
                "410327": "宜阳县",
                "410328": "洛宁县",
                "410329": "伊川县",
                "410381": "偃师市",
                "410400": "平顶山市",
                "410402": "新华区",
                "410403": "卫东区",
                "410404": "石龙区",
                "410411": "湛河区",
                "410421": "宝丰县",
                "410422": "叶县",
                "410423": "鲁山县",
                "410425": "郏县",
                "410481": "舞钢市",
                "410482": "汝州市",
                "410483": "其它区",
                "410500": "安阳市",
                "410502": "文峰区",
                "410503": "北关区",
                "410505": "殷都区",
                "410506": "龙安区",
                "410522": "安阳县",
                "410523": "汤阴县",
                "410526": "滑县",
                "410527": "内黄县",
                "410581": "林州市",
                "410582": "其它区",
                "410600": "鹤壁市",
                "410602": "鹤山区",
                "410603": "山城区",
                "410611": "淇滨区",
                "410621": "浚县",
                "410622": "淇县",
                "410623": "其它区",
                "410700": "新乡市",
                "410702": "红旗区",
                "410703": "卫滨区",
                "410704": "凤泉区",
                "410711": "牧野区",
                "410721": "新乡县",
                "410724": "获嘉县",
                "410725": "原阳县",
                "410726": "延津县",
                "410727": "封丘县",
                "410728": "长垣县",
                "410781": "卫辉市",
                "410782": "辉县市",
                "410783": "其它区",
                "410800": "焦作市",
                "410802": "解放区",
                "410803": "中站区",
                "410804": "马村区",
                "410811": "山阳区",
                "410821": "修武县",
                "410822": "博爱县",
                "410823": "武陟县",
                "410825": "温县",
                "410881": "济源市",
                "410882": "沁阳市",
                "410883": "孟州市",
                "410884": "其它区",
                "410900": "濮阳市",
                "410902": "华龙区",
                "410922": "清丰县",
                "410923": "南乐县",
                "410926": "范县",
                "410927": "台前县",
                "410928": "濮阳县",
                "410929": "其它区",
                "411000": "许昌市",
                "411002": "魏都区",
                "411023": "许昌县",
                "411024": "鄢陵县",
                "411025": "襄城县",
                "411081": "禹州市",
                "411082": "长葛市",
                "411083": "其它区",
                "411100": "漯河市",
                "411102": "源汇区",
                "411103": "郾城区",
                "411104": "召陵区",
                "411121": "舞阳县",
                "411122": "临颍县",
                "411123": "其它区",
                "411200": "三门峡市",
                "411202": "湖滨区",
                "411221": "渑池县",
                "411222": "陕县",
                "411224": "卢氏县",
                "411281": "义马市",
                "411282": "灵宝市",
                "411283": "其它区",
                "411300": "南阳市",
                "411302": "宛城区",
                "411303": "卧龙区",
                "411321": "南召县",
                "411322": "方城县",
                "411323": "西峡县",
                "411324": "镇平县",
                "411325": "内乡县",
                "411326": "淅川县",
                "411327": "社旗县",
                "411328": "唐河县",
                "411329": "新野县",
                "411330": "桐柏县",
                "411381": "邓州市",
                "411382": "其它区",
                "411400": "商丘市",
                "411402": "梁园区",
                "411403": "睢阳区",
                "411421": "民权县",
                "411422": "睢县",
                "411423": "宁陵县",
                "411424": "柘城县",
                "411425": "虞城县",
                "411426": "夏邑县",
                "411481": "永城市",
                "411482": "其它区",
                "411500": "信阳市",
                "411502": "浉河区",
                "411503": "平桥区",
                "411521": "罗山县",
                "411522": "光山县",
                "411523": "新县",
                "411524": "商城县",
                "411525": "固始县",
                "411526": "潢川县",
                "411527": "淮滨县",
                "411528": "息县",
                "411529": "其它区",
                "411600": "周口市",
                "411602": "川汇区",
                "411621": "扶沟县",
                "411622": "西华县",
                "411623": "商水县",
                "411624": "沈丘县",
                "411625": "郸城县",
                "411626": "淮阳县",
                "411627": "太康县",
                "411628": "鹿邑县",
                "411681": "项城市",
                "411682": "其它区",
                "411700": "驻马店市",
                "411702": "驿城区",
                "411721": "西平县",
                "411722": "上蔡县",
                "411723": "平舆县",
                "411724": "正阳县",
                "411725": "确山县",
                "411726": "泌阳县",
                "411727": "汝南县",
                "411728": "遂平县",
                "411729": "新蔡县",
                "411730": "其它区",
                "420000": "湖北省",
                "420100": "武汉市",
                "420102": "江岸区",
                "420103": "江汉区",
                "420104": "硚口区",
                "420105": "汉阳区",
                "420106": "武昌区",
                "420107": "青山区",
                "420111": "洪山区",
                "420112": "东西湖区",
                "420113": "汉南区",
                "420114": "蔡甸区",
                "420115": "江夏区",
                "420116": "黄陂区",
                "420117": "新洲区",
                "420118": "其它区",
                "420200": "黄石市",
                "420202": "黄石港区",
                "420203": "西塞山区",
                "420204": "下陆区",
                "420205": "铁山区",
                "420222": "阳新县",
                "420281": "大冶市",
                "420282": "其它区",
                "420300": "十堰市",
                "420302": "茅箭区",
                "420303": "张湾区",
                "420321": "郧县",
                "420322": "郧西县",
                "420323": "竹山县",
                "420324": "竹溪县",
                "420325": "房县",
                "420381": "丹江口市",
                "420383": "其它区",
                "420500": "宜昌市",
                "420502": "西陵区",
                "420503": "伍家岗区",
                "420504": "点军区",
                "420505": "猇亭区",
                "420506": "夷陵区",
                "420525": "远安县",
                "420526": "兴山县",
                "420527": "秭归县",
                "420528": "长阳土家族自治县",
                "420529": "五峰土家族自治县",
                "420581": "宜都市",
                "420582": "当阳市",
                "420583": "枝江市",
                "420584": "其它区",
                "420600": "襄阳市",
                "420602": "襄城区",
                "420606": "樊城区",
                "420607": "襄州区",
                "420624": "南漳县",
                "420625": "谷城县",
                "420626": "保康县",
                "420682": "老河口市",
                "420683": "枣阳市",
                "420684": "宜城市",
                "420685": "其它区",
                "420700": "鄂州市",
                "420702": "梁子湖区",
                "420703": "华容区",
                "420704": "鄂城区",
                "420705": "其它区",
                "420800": "荆门市",
                "420802": "东宝区",
                "420804": "掇刀区",
                "420821": "京山县",
                "420822": "沙洋县",
                "420881": "钟祥市",
                "420882": "其它区",
                "420900": "孝感市",
                "420902": "孝南区",
                "420921": "孝昌县",
                "420922": "大悟县",
                "420923": "云梦县",
                "420981": "应城市",
                "420982": "安陆市",
                "420984": "汉川市",
                "420985": "其它区",
                "421000": "荆州市",
                "421002": "沙市区",
                "421003": "荆州区",
                "421022": "公安县",
                "421023": "监利县",
                "421024": "江陵县",
                "421081": "石首市",
                "421083": "洪湖市",
                "421087": "松滋市",
                "421088": "其它区",
                "421100": "黄冈市",
                "421102": "黄州区",
                "421121": "团风县",
                "421122": "红安县",
                "421123": "罗田县",
                "421124": "英山县",
                "421125": "浠水县",
                "421126": "蕲春县",
                "421127": "黄梅县",
                "421181": "麻城市",
                "421182": "武穴市",
                "421183": "其它区",
                "421200": "咸宁市",
                "421202": "咸安区",
                "421221": "嘉鱼县",
                "421222": "通城县",
                "421223": "崇阳县",
                "421224": "通山县",
                "421281": "赤壁市",
                "421283": "其它区",
                "421300": "随州市",
                "421302": "曾都区",
                "421321": "随县",
                "421381": "广水市",
                "421382": "其它区",
                "422800": "恩施土家族苗族自治州",
                "422801": "恩施市",
                "422802": "利川市",
                "422822": "建始县",
                "422823": "巴东县",
                "422825": "宣恩县",
                "422826": "咸丰县",
                "422827": "来凤县",
                "422828": "鹤峰县",
                "422829": "其它区",
                "429004": "仙桃市",
                "429005": "潜江市",
                "429006": "天门市",
                "429021": "神农架林区",
                "430000": "湖南省",
                "430100": "长沙市",
                "430102": "芙蓉区",
                "430103": "天心区",
                "430104": "岳麓区",
                "430105": "开福区",
                "430111": "雨花区",
                "430121": "长沙县",
                "430122": "望城区",
                "430124": "宁乡县",
                "430181": "浏阳市",
                "430182": "其它区",
                "430200": "株洲市",
                "430202": "荷塘区",
                "430203": "芦淞区",
                "430204": "石峰区",
                "430211": "天元区",
                "430221": "株洲县",
                "430223": "攸县",
                "430224": "茶陵县",
                "430225": "炎陵县",
                "430281": "醴陵市",
                "430282": "其它区",
                "430300": "湘潭市",
                "430302": "雨湖区",
                "430304": "岳塘区",
                "430321": "湘潭县",
                "430381": "湘乡市",
                "430382": "韶山市",
                "430383": "其它区",
                "430400": "衡阳市",
                "430405": "珠晖区",
                "430406": "雁峰区",
                "430407": "石鼓区",
                "430408": "蒸湘区",
                "430412": "南岳区",
                "430421": "衡阳县",
                "430422": "衡南县",
                "430423": "衡山县",
                "430424": "衡东县",
                "430426": "祁东县",
                "430481": "耒阳市",
                "430482": "常宁市",
                "430483": "其它区",
                "430500": "邵阳市",
                "430502": "双清区",
                "430503": "大祥区",
                "430511": "北塔区",
                "430521": "邵东县",
                "430522": "新邵县",
                "430523": "邵阳县",
                "430524": "隆回县",
                "430525": "洞口县",
                "430527": "绥宁县",
                "430528": "新宁县",
                "430529": "城步苗族自治县",
                "430581": "武冈市",
                "430582": "其它区",
                "430600": "岳阳市",
                "430602": "岳阳楼区",
                "430603": "云溪区",
                "430611": "君山区",
                "430621": "岳阳县",
                "430623": "华容县",
                "430624": "湘阴县",
                "430626": "平江县",
                "430681": "汨罗市",
                "430682": "临湘市",
                "430683": "其它区",
                "430700": "常德市",
                "430702": "武陵区",
                "430703": "鼎城区",
                "430721": "安乡县",
                "430722": "汉寿县",
                "430723": "澧县",
                "430724": "临澧县",
                "430725": "桃源县",
                "430726": "石门县",
                "430781": "津市市",
                "430782": "其它区",
                "430800": "张家界市",
                "430802": "永定区",
                "430811": "武陵源区",
                "430821": "慈利县",
                "430822": "桑植县",
                "430823": "其它区",
                "430900": "益阳市",
                "430902": "资阳区",
                "430903": "赫山区",
                "430921": "南县",
                "430922": "桃江县",
                "430923": "安化县",
                "430981": "沅江市",
                "430982": "其它区",
                "431000": "郴州市",
                "431002": "北湖区",
                "431003": "苏仙区",
                "431021": "桂阳县",
                "431022": "宜章县",
                "431023": "永兴县",
                "431024": "嘉禾县",
                "431025": "临武县",
                "431026": "汝城县",
                "431027": "桂东县",
                "431028": "安仁县",
                "431081": "资兴市",
                "431082": "其它区",
                "431100": "永州市",
                "431102": "零陵区",
                "431103": "冷水滩区",
                "431121": "祁阳县",
                "431122": "东安县",
                "431123": "双牌县",
                "431124": "道县",
                "431125": "江永县",
                "431126": "宁远县",
                "431127": "蓝山县",
                "431128": "新田县",
                "431129": "江华瑶族自治县",
                "431130": "其它区",
                "431200": "怀化市",
                "431202": "鹤城区",
                "431221": "中方县",
                "431222": "沅陵县",
                "431223": "辰溪县",
                "431224": "溆浦县",
                "431225": "会同县",
                "431226": "麻阳苗族自治县",
                "431227": "新晃侗族自治县",
                "431228": "芷江侗族自治县",
                "431229": "靖州苗族侗族自治县",
                "431230": "通道侗族自治县",
                "431281": "洪江市",
                "431282": "其它区",
                "431300": "娄底市",
                "431302": "娄星区",
                "431321": "双峰县",
                "431322": "新化县",
                "431381": "冷水江市",
                "431382": "涟源市",
                "431383": "其它区",
                "433100": "湘西土家族苗族自治州",
                "433101": "吉首市",
                "433122": "泸溪县",
                "433123": "凤凰县",
                "433124": "花垣县",
                "433125": "保靖县",
                "433126": "古丈县",
                "433127": "永顺县",
                "433130": "龙山县",
                "433131": "其它区",
                "440000": "广东省",
                "440100": "广州市",
                "440103": "荔湾区",
                "440104": "越秀区",
                "440105": "海珠区",
                "440106": "天河区",
                "440111": "白云区",
                "440112": "黄埔区",
                "440113": "番禺区",
                "440114": "花都区",
                "440115": "南沙区",
                "440116": "萝岗区",
                "440183": "增城市",
                "440184": "从化市",
                "440189": "其它区",
                "440200": "韶关市",
                "440203": "武江区",
                "440204": "浈江区",
                "440205": "曲江区",
                "440222": "始兴县",
                "440224": "仁化县",
                "440229": "翁源县",
                "440232": "乳源瑶族自治县",
                "440233": "新丰县",
                "440281": "乐昌市",
                "440282": "南雄市",
                "440283": "其它区",
                "440300": "深圳市",
                "440303": "罗湖区",
                "440304": "福田区",
                "440305": "南山区",
                "440306": "宝安区",
                "440307": "龙岗区",
                "440308": "盐田区",
                "440309": "其它区",
                "440320": "光明新区",
                "440321": "坪山新区",
                "440322": "大鹏新区",
                "440323": "龙华新区",
                "440400": "珠海市",
                "440402": "香洲区",
                "440403": "斗门区",
                "440404": "金湾区",
                "440488": "其它区",
                "440500": "汕头市",
                "440507": "龙湖区",
                "440511": "金平区",
                "440512": "濠江区",
                "440513": "潮阳区",
                "440514": "潮南区",
                "440515": "澄海区",
                "440523": "南澳县",
                "440524": "其它区",
                "440600": "佛山市",
                "440604": "禅城区",
                "440605": "南海区",
                "440606": "顺德区",
                "440607": "三水区",
                "440608": "高明区",
                "440609": "其它区",
                "440700": "江门市",
                "440703": "蓬江区",
                "440704": "江海区",
                "440705": "新会区",
                "440781": "台山市",
                "440783": "开平市",
                "440784": "鹤山市",
                "440785": "恩平市",
                "440786": "其它区",
                "440800": "湛江市",
                "440802": "赤坎区",
                "440803": "霞山区",
                "440804": "坡头区",
                "440811": "麻章区",
                "440823": "遂溪县",
                "440825": "徐闻县",
                "440881": "廉江市",
                "440882": "雷州市",
                "440883": "吴川市",
                "440884": "其它区",
                "440900": "茂名市",
                "440902": "茂南区",
                "440903": "茂港区",
                "440923": "电白县",
                "440981": "高州市",
                "440982": "化州市",
                "440983": "信宜市",
                "440984": "其它区",
                "441200": "肇庆市",
                "441202": "端州区",
                "441203": "鼎湖区",
                "441223": "广宁县",
                "441224": "怀集县",
                "441225": "封开县",
                "441226": "德庆县",
                "441283": "高要市",
                "441284": "四会市",
                "441285": "其它区",
                "441300": "惠州市",
                "441302": "惠城区",
                "441303": "惠阳区",
                "441322": "博罗县",
                "441323": "惠东县",
                "441324": "龙门县",
                "441325": "其它区",
                "441400": "梅州市",
                "441402": "梅江区",
                "441421": "梅县",
                "441422": "大埔县",
                "441423": "丰顺县",
                "441424": "五华县",
                "441426": "平远县",
                "441427": "蕉岭县",
                "441481": "兴宁市",
                "441482": "其它区",
                "441500": "汕尾市",
                "441502": "城区",
                "441521": "海丰县",
                "441523": "陆河县",
                "441581": "陆丰市",
                "441582": "其它区",
                "441600": "河源市",
                "441602": "源城区",
                "441621": "紫金县",
                "441622": "龙川县",
                "441623": "连平县",
                "441624": "和平县",
                "441625": "东源县",
                "441626": "其它区",
                "441700": "阳江市",
                "441702": "江城区",
                "441721": "阳西县",
                "441723": "阳东县",
                "441781": "阳春市",
                "441782": "其它区",
                "441800": "清远市",
                "441802": "清城区",
                "441821": "佛冈县",
                "441823": "阳山县",
                "441825": "连山壮族瑶族自治县",
                "441826": "连南瑶族自治县",
                "441827": "清新区",
                "441881": "英德市",
                "441882": "连州市",
                "441883": "其它区",
                "441900": "东莞市",
                "442000": "中山市",
                "442101": "东沙群岛",
                "445100": "潮州市",
                "445102": "湘桥区",
                "445121": "潮安区",
                "445122": "饶平县",
                "445186": "其它区",
                "445200": "揭阳市",
                "445202": "榕城区",
                "445221": "揭东区",
                "445222": "揭西县",
                "445224": "惠来县",
                "445281": "普宁市",
                "445285": "其它区",
                "445300": "云浮市",
                "445302": "云城区",
                "445321": "新兴县",
                "445322": "郁南县",
                "445323": "云安县",
                "445381": "罗定市",
                "445382": "其它区",
                "450000": "广西壮族自治区",
                "450100": "南宁市",
                "450102": "兴宁区",
                "450103": "青秀区",
                "450105": "江南区",
                "450107": "西乡塘区",
                "450108": "良庆区",
                "450109": "邕宁区",
                "450122": "武鸣县",
                "450123": "隆安县",
                "450124": "马山县",
                "450125": "上林县",
                "450126": "宾阳县",
                "450127": "横县",
                "450128": "其它区",
                "450200": "柳州市",
                "450202": "城中区",
                "450203": "鱼峰区",
                "450204": "柳南区",
                "450205": "柳北区",
                "450221": "柳江县",
                "450222": "柳城县",
                "450223": "鹿寨县",
                "450224": "融安县",
                "450225": "融水苗族自治县",
                "450226": "三江侗族自治县",
                "450227": "其它区",
                "450300": "桂林市",
                "450302": "秀峰区",
                "450303": "叠彩区",
                "450304": "象山区",
                "450305": "七星区",
                "450311": "雁山区",
                "450321": "阳朔县",
                "450322": "临桂区",
                "450323": "灵川县",
                "450324": "全州县",
                "450325": "兴安县",
                "450326": "永福县",
                "450327": "灌阳县",
                "450328": "龙胜各族自治县",
                "450329": "资源县",
                "450330": "平乐县",
                "450331": "荔浦县",
                "450332": "恭城瑶族自治县",
                "450333": "其它区",
                "450400": "梧州市",
                "450403": "万秀区",
                "450405": "长洲区",
                "450406": "龙圩区",
                "450421": "苍梧县",
                "450422": "藤县",
                "450423": "蒙山县",
                "450481": "岑溪市",
                "450482": "其它区",
                "450500": "北海市",
                "450502": "海城区",
                "450503": "银海区",
                "450512": "铁山港区",
                "450521": "合浦县",
                "450522": "其它区",
                "450600": "防城港市",
                "450602": "港口区",
                "450603": "防城区",
                "450621": "上思县",
                "450681": "东兴市",
                "450682": "其它区",
                "450700": "钦州市",
                "450702": "钦南区",
                "450703": "钦北区",
                "450721": "灵山县",
                "450722": "浦北县",
                "450723": "其它区",
                "450800": "贵港市",
                "450802": "港北区",
                "450803": "港南区",
                "450804": "覃塘区",
                "450821": "平南县",
                "450881": "桂平市",
                "450882": "其它区",
                "450900": "玉林市",
                "450902": "玉州区",
                "450903": "福绵区",
                "450921": "容县",
                "450922": "陆川县",
                "450923": "博白县",
                "450924": "兴业县",
                "450981": "北流市",
                "450982": "其它区",
                "451000": "百色市",
                "451002": "右江区",
                "451021": "田阳县",
                "451022": "田东县",
                "451023": "平果县",
                "451024": "德保县",
                "451025": "靖西县",
                "451026": "那坡县",
                "451027": "凌云县",
                "451028": "乐业县",
                "451029": "田林县",
                "451030": "西林县",
                "451031": "隆林各族自治县",
                "451032": "其它区",
                "451100": "贺州市",
                "451102": "八步区",
                "451119": "平桂管理区",
                "451121": "昭平县",
                "451122": "钟山县",
                "451123": "富川瑶族自治县",
                "451124": "其它区",
                "451200": "河池市",
                "451202": "金城江区",
                "451221": "南丹县",
                "451222": "天峨县",
                "451223": "凤山县",
                "451224": "东兰县",
                "451225": "罗城仫佬族自治县",
                "451226": "环江毛南族自治县",
                "451227": "巴马瑶族自治县",
                "451228": "都安瑶族自治县",
                "451229": "大化瑶族自治县",
                "451281": "宜州市",
                "451282": "其它区",
                "451300": "来宾市",
                "451302": "兴宾区",
                "451321": "忻城县",
                "451322": "象州县",
                "451323": "武宣县",
                "451324": "金秀瑶族自治县",
                "451381": "合山市",
                "451382": "其它区",
                "451400": "崇左市",
                "451402": "江州区",
                "451421": "扶绥县",
                "451422": "宁明县",
                "451423": "龙州县",
                "451424": "大新县",
                "451425": "天等县",
                "451481": "凭祥市",
                "451482": "其它区",
                "460000": "海南省",
                "460100": "海口市",
                "460105": "秀英区",
                "460106": "龙华区",
                "460107": "琼山区",
                "460108": "美兰区",
                "460109": "其它区",
                "460200": "三亚市",
                "460300": "三沙市",
                "460321": "西沙群岛",
                "460322": "南沙群岛",
                "460323": "中沙群岛的岛礁及其海域",
                "469001": "五指山市",
                "469002": "琼海市",
                "469003": "儋州市",
                "469005": "文昌市",
                "469006": "万宁市",
                "469007": "东方市",
                "469025": "定安县",
                "469026": "屯昌县",
                "469027": "澄迈县",
                "469028": "临高县",
                "469030": "白沙黎族自治县",
                "469031": "昌江黎族自治县",
                "469033": "乐东黎族自治县",
                "469034": "陵水黎族自治县",
                "469035": "保亭黎族苗族自治县",
                "469036": "琼中黎族苗族自治县",
                "471005": "其它区",
                "500000": "重庆",
                "500100": "重庆市",
                "500101": "万州区",
                "500102": "涪陵区",
                "500103": "渝中区",
                "500104": "大渡口区",
                "500105": "江北区",
                "500106": "沙坪坝区",
                "500107": "九龙坡区",
                "500108": "南岸区",
                "500109": "北碚区",
                "500110": "万盛区",
                "500111": "双桥区",
                "500112": "渝北区",
                "500113": "巴南区",
                "500114": "黔江区",
                "500115": "长寿区",
                "500222": "綦江区",
                "500223": "潼南县",
                "500224": "铜梁县",
                "500225": "大足区",
                "500226": "荣昌县",
                "500227": "璧山县",
                "500228": "梁平县",
                "500229": "城口县",
                "500230": "丰都县",
                "500231": "垫江县",
                "500232": "武隆县",
                "500233": "忠县",
                "500234": "开县",
                "500235": "云阳县",
                "500236": "奉节县",
                "500237": "巫山县",
                "500238": "巫溪县",
                "500240": "石柱土家族自治县",
                "500241": "秀山土家族苗族自治县",
                "500242": "酉阳土家族苗族自治县",
                "500243": "彭水苗族土家族自治县",
                "500381": "江津区",
                "500382": "合川区",
                "500383": "永川区",
                "500384": "南川区",
                "500385": "其它区",
                "510000": "四川省",
                "510100": "成都市",
                "510104": "锦江区",
                "510105": "青羊区",
                "510106": "金牛区",
                "510107": "武侯区",
                "510108": "成华区",
                "510112": "龙泉驿区",
                "510113": "青白江区",
                "510114": "新都区",
                "510115": "温江区",
                "510121": "金堂县",
                "510122": "双流县",
                "510124": "郫县",
                "510129": "大邑县",
                "510131": "蒲江县",
                "510132": "新津县",
                "510181": "都江堰市",
                "510182": "彭州市",
                "510183": "邛崃市",
                "510184": "崇州市",
                "510185": "其它区",
                "510300": "自贡市",
                "510302": "自流井区",
                "510303": "贡井区",
                "510304": "大安区",
                "510311": "沿滩区",
                "510321": "荣县",
                "510322": "富顺县",
                "510323": "其它区",
                "510400": "攀枝花市",
                "510402": "东区",
                "510403": "西区",
                "510411": "仁和区",
                "510421": "米易县",
                "510422": "盐边县",
                "510423": "其它区",
                "510500": "泸州市",
                "510502": "江阳区",
                "510503": "纳溪区",
                "510504": "龙马潭区",
                "510521": "泸县",
                "510522": "合江县",
                "510524": "叙永县",
                "510525": "古蔺县",
                "510526": "其它区",
                "510600": "德阳市",
                "510603": "旌阳区",
                "510623": "中江县",
                "510626": "罗江县",
                "510681": "广汉市",
                "510682": "什邡市",
                "510683": "绵竹市",
                "510684": "其它区",
                "510700": "绵阳市",
                "510703": "涪城区",
                "510704": "游仙区",
                "510722": "三台县",
                "510723": "盐亭县",
                "510724": "安县",
                "510725": "梓潼县",
                "510726": "北川羌族自治县",
                "510727": "平武县",
                "510781": "江油市",
                "510782": "其它区",
                "510800": "广元市",
                "510802": "利州区",
                "510811": "昭化区",
                "510812": "朝天区",
                "510821": "旺苍县",
                "510822": "青川县",
                "510823": "剑阁县",
                "510824": "苍溪县",
                "510825": "其它区",
                "510900": "遂宁市",
                "510903": "船山区",
                "510904": "安居区",
                "510921": "蓬溪县",
                "510922": "射洪县",
                "510923": "大英县",
                "510924": "其它区",
                "511000": "内江市",
                "511002": "市中区",
                "511011": "东兴区",
                "511024": "威远县",
                "511025": "资中县",
                "511028": "隆昌县",
                "511029": "其它区",
                "511100": "乐山市",
                "511102": "市中区",
                "511111": "沙湾区",
                "511112": "五通桥区",
                "511113": "金口河区",
                "511123": "犍为县",
                "511124": "井研县",
                "511126": "夹江县",
                "511129": "沐川县",
                "511132": "峨边彝族自治县",
                "511133": "马边彝族自治县",
                "511181": "峨眉山市",
                "511182": "其它区",
                "511300": "南充市",
                "511302": "顺庆区",
                "511303": "高坪区",
                "511304": "嘉陵区",
                "511321": "南部县",
                "511322": "营山县",
                "511323": "蓬安县",
                "511324": "仪陇县",
                "511325": "西充县",
                "511381": "阆中市",
                "511382": "其它区",
                "511400": "眉山市",
                "511402": "东坡区",
                "511421": "仁寿县",
                "511422": "彭山县",
                "511423": "洪雅县",
                "511424": "丹棱县",
                "511425": "青神县",
                "511426": "其它区",
                "511500": "宜宾市",
                "511502": "翠屏区",
                "511521": "宜宾县",
                "511522": "南溪区",
                "511523": "江安县",
                "511524": "长宁县",
                "511525": "高县",
                "511526": "珙县",
                "511527": "筠连县",
                "511528": "兴文县",
                "511529": "屏山县",
                "511530": "其它区",
                "511600": "广安市",
                "511602": "广安区",
                "511603": "前锋区",
                "511621": "岳池县",
                "511622": "武胜县",
                "511623": "邻水县",
                "511681": "华蓥市",
                "511683": "其它区",
                "511700": "达州市",
                "511702": "通川区",
                "511721": "达川区",
                "511722": "宣汉县",
                "511723": "开江县",
                "511724": "大竹县",
                "511725": "渠县",
                "511781": "万源市",
                "511782": "其它区",
                "511800": "雅安市",
                "511802": "雨城区",
                "511821": "名山区",
                "511822": "荥经县",
                "511823": "汉源县",
                "511824": "石棉县",
                "511825": "天全县",
                "511826": "芦山县",
                "511827": "宝兴县",
                "511828": "其它区",
                "511900": "巴中市",
                "511902": "巴州区",
                "511903": "恩阳区",
                "511921": "通江县",
                "511922": "南江县",
                "511923": "平昌县",
                "511924": "其它区",
                "512000": "资阳市",
                "512002": "雁江区",
                "512021": "安岳县",
                "512022": "乐至县",
                "512081": "简阳市",
                "512082": "其它区",
                "513200": "阿坝藏族羌族自治州",
                "513221": "汶川县",
                "513222": "理县",
                "513223": "茂县",
                "513224": "松潘县",
                "513225": "九寨沟县",
                "513226": "金川县",
                "513227": "小金县",
                "513228": "黑水县",
                "513229": "马尔康县",
                "513230": "壤塘县",
                "513231": "阿坝县",
                "513232": "若尔盖县",
                "513233": "红原县",
                "513234": "其它区",
                "513300": "甘孜藏族自治州",
                "513321": "康定县",
                "513322": "泸定县",
                "513323": "丹巴县",
                "513324": "九龙县",
                "513325": "雅江县",
                "513326": "道孚县",
                "513327": "炉霍县",
                "513328": "甘孜县",
                "513329": "新龙县",
                "513330": "德格县",
                "513331": "白玉县",
                "513332": "石渠县",
                "513333": "色达县",
                "513334": "理塘县",
                "513335": "巴塘县",
                "513336": "乡城县",
                "513337": "稻城县",
                "513338": "得荣县",
                "513339": "其它区",
                "513400": "凉山彝族自治州",
                "513401": "西昌市",
                "513422": "木里藏族自治县",
                "513423": "盐源县",
                "513424": "德昌县",
                "513425": "会理县",
                "513426": "会东县",
                "513427": "宁南县",
                "513428": "普格县",
                "513429": "布拖县",
                "513430": "金阳县",
                "513431": "昭觉县",
                "513432": "喜德县",
                "513433": "冕宁县",
                "513434": "越西县",
                "513435": "甘洛县",
                "513436": "美姑县",
                "513437": "雷波县",
                "513438": "其它区",
                "520000": "贵州省",
                "520100": "贵阳市",
                "520102": "南明区",
                "520103": "云岩区",
                "520111": "花溪区",
                "520112": "乌当区",
                "520113": "白云区",
                "520121": "开阳县",
                "520122": "息烽县",
                "520123": "修文县",
                "520151": "观山湖区",
                "520181": "清镇市",
                "520182": "其它区",
                "520200": "六盘水市",
                "520201": "钟山区",
                "520203": "六枝特区",
                "520221": "水城县",
                "520222": "盘县",
                "520223": "其它区",
                "520300": "遵义市",
                "520302": "红花岗区",
                "520303": "汇川区",
                "520321": "遵义县",
                "520322": "桐梓县",
                "520323": "绥阳县",
                "520324": "正安县",
                "520325": "道真仡佬族苗族自治县",
                "520326": "务川仡佬族苗族自治县",
                "520327": "凤冈县",
                "520328": "湄潭县",
                "520329": "余庆县",
                "520330": "习水县",
                "520381": "赤水市",
                "520382": "仁怀市",
                "520383": "其它区",
                "520400": "安顺市",
                "520402": "西秀区",
                "520421": "平坝县",
                "520422": "普定县",
                "520423": "镇宁布依族苗族自治县",
                "520424": "关岭布依族苗族自治县",
                "520425": "紫云苗族布依族自治县",
                "520426": "其它区",
                "522200": "铜仁市",
                "522201": "碧江区",
                "522222": "江口县",
                "522223": "玉屏侗族自治县",
                "522224": "石阡县",
                "522225": "思南县",
                "522226": "印江土家族苗族自治县",
                "522227": "德江县",
                "522228": "沿河土家族自治县",
                "522229": "松桃苗族自治县",
                "522230": "万山区",
                "522231": "其它区",
                "522300": "黔西南布依族苗族自治州",
                "522301": "兴义市",
                "522322": "兴仁县",
                "522323": "普安县",
                "522324": "晴隆县",
                "522325": "贞丰县",
                "522326": "望谟县",
                "522327": "册亨县",
                "522328": "安龙县",
                "522329": "其它区",
                "522400": "毕节市",
                "522401": "七星关区",
                "522422": "大方县",
                "522423": "黔西县",
                "522424": "金沙县",
                "522425": "织金县",
                "522426": "纳雍县",
                "522427": "威宁彝族回族苗族自治县",
                "522428": "赫章县",
                "522429": "其它区",
                "522600": "黔东南苗族侗族自治州",
                "522601": "凯里市",
                "522622": "黄平县",
                "522623": "施秉县",
                "522624": "三穗县",
                "522625": "镇远县",
                "522626": "岑巩县",
                "522627": "天柱县",
                "522628": "锦屏县",
                "522629": "剑河县",
                "522630": "台江县",
                "522631": "黎平县",
                "522632": "榕江县",
                "522633": "从江县",
                "522634": "雷山县",
                "522635": "麻江县",
                "522636": "丹寨县",
                "522637": "其它区",
                "522700": "黔南布依族苗族自治州",
                "522701": "都匀市",
                "522702": "福泉市",
                "522722": "荔波县",
                "522723": "贵定县",
                "522725": "瓮安县",
                "522726": "独山县",
                "522727": "平塘县",
                "522728": "罗甸县",
                "522729": "长顺县",
                "522730": "龙里县",
                "522731": "惠水县",
                "522732": "三都水族自治县",
                "522733": "其它区",
                "530000": "云南省",
                "530100": "昆明市",
                "530102": "五华区",
                "530103": "盘龙区",
                "530111": "官渡区",
                "530112": "西山区",
                "530113": "东川区",
                "530121": "呈贡区",
                "530122": "晋宁县",
                "530124": "富民县",
                "530125": "宜良县",
                "530126": "石林彝族自治县",
                "530127": "嵩明县",
                "530128": "禄劝彝族苗族自治县",
                "530129": "寻甸回族彝族自治县",
                "530181": "安宁市",
                "530182": "其它区",
                "530300": "曲靖市",
                "530302": "麒麟区",
                "530321": "马龙县",
                "530322": "陆良县",
                "530323": "师宗县",
                "530324": "罗平县",
                "530325": "富源县",
                "530326": "会泽县",
                "530328": "沾益县",
                "530381": "宣威市",
                "530382": "其它区",
                "530400": "玉溪市",
                "530402": "红塔区",
                "530421": "江川县",
                "530422": "澄江县",
                "530423": "通海县",
                "530424": "华宁县",
                "530425": "易门县",
                "530426": "峨山彝族自治县",
                "530427": "新平彝族傣族自治县",
                "530428": "元江哈尼族彝族傣族自治县",
                "530429": "其它区",
                "530500": "保山市",
                "530502": "隆阳区",
                "530521": "施甸县",
                "530522": "腾冲县",
                "530523": "龙陵县",
                "530524": "昌宁县",
                "530525": "其它区",
                "530600": "昭通市",
                "530602": "昭阳区",
                "530621": "鲁甸县",
                "530622": "巧家县",
                "530623": "盐津县",
                "530624": "大关县",
                "530625": "永善县",
                "530626": "绥江县",
                "530627": "镇雄县",
                "530628": "彝良县",
                "530629": "威信县",
                "530630": "水富县",
                "530631": "其它区",
                "530700": "丽江市",
                "530702": "古城区",
                "530721": "玉龙纳西族自治县",
                "530722": "永胜县",
                "530723": "华坪县",
                "530724": "宁蒗彝族自治县",
                "530725": "其它区",
                "530800": "普洱市",
                "530802": "思茅区",
                "530821": "宁洱哈尼族彝族自治县",
                "530822": "墨江哈尼族自治县",
                "530823": "景东彝族自治县",
                "530824": "景谷傣族彝族自治县",
                "530825": "镇沅彝族哈尼族拉祜族自治县",
                "530826": "江城哈尼族彝族自治县",
                "530827": "孟连傣族拉祜族佤族自治县",
                "530828": "澜沧拉祜族自治县",
                "530829": "西盟佤族自治县",
                "530830": "其它区",
                "530900": "临沧市",
                "530902": "临翔区",
                "530921": "凤庆县",
                "530922": "云县",
                "530923": "永德县",
                "530924": "镇康县",
                "530925": "双江拉祜族佤族布朗族傣族自治县",
                "530926": "耿马傣族佤族自治县",
                "530927": "沧源佤族自治县",
                "530928": "其它区",
                "532300": "楚雄彝族自治州",
                "532301": "楚雄市",
                "532322": "双柏县",
                "532323": "牟定县",
                "532324": "南华县",
                "532325": "姚安县",
                "532326": "大姚县",
                "532327": "永仁县",
                "532328": "元谋县",
                "532329": "武定县",
                "532331": "禄丰县",
                "532332": "其它区",
                "532500": "红河哈尼族彝族自治州",
                "532501": "个旧市",
                "532502": "开远市",
                "532522": "蒙自市",
                "532523": "屏边苗族自治县",
                "532524": "建水县",
                "532525": "石屏县",
                "532526": "弥勒市",
                "532527": "泸西县",
                "532528": "元阳县",
                "532529": "红河县",
                "532530": "金平苗族瑶族傣族自治县",
                "532531": "绿春县",
                "532532": "河口瑶族自治县",
                "532533": "其它区",
                "532600": "文山壮族苗族自治州",
                "532621": "文山市",
                "532622": "砚山县",
                "532623": "西畴县",
                "532624": "麻栗坡县",
                "532625": "马关县",
                "532626": "丘北县",
                "532627": "广南县",
                "532628": "富宁县",
                "532629": "其它区",
                "532800": "西双版纳傣族自治州",
                "532801": "景洪市",
                "532822": "勐海县",
                "532823": "勐腊县",
                "532824": "其它区",
                "532900": "大理白族自治州",
                "532901": "大理市",
                "532922": "漾濞彝族自治县",
                "532923": "祥云县",
                "532924": "宾川县",
                "532925": "弥渡县",
                "532926": "南涧彝族自治县",
                "532927": "巍山彝族回族自治县",
                "532928": "永平县",
                "532929": "云龙县",
                "532930": "洱源县",
                "532931": "剑川县",
                "532932": "鹤庆县",
                "532933": "其它区",
                "533100": "德宏傣族景颇族自治州",
                "533102": "瑞丽市",
                "533103": "芒市",
                "533122": "梁河县",
                "533123": "盈江县",
                "533124": "陇川县",
                "533125": "其它区",
                "533300": "怒江傈僳族自治州",
                "533321": "泸水县",
                "533323": "福贡县",
                "533324": "贡山独龙族怒族自治县",
                "533325": "兰坪白族普米族自治县",
                "533326": "其它区",
                "533400": "迪庆藏族自治州",
                "533421": "香格里拉县",
                "533422": "德钦县",
                "533423": "维西傈僳族自治县",
                "533424": "其它区",
                "540000": "西藏自治区",
                "540100": "拉萨市",
                "540102": "城关区",
                "540121": "林周县",
                "540122": "当雄县",
                "540123": "尼木县",
                "540124": "曲水县",
                "540125": "堆龙德庆县",
                "540126": "达孜县",
                "540127": "墨竹工卡县",
                "540128": "其它区",
                "542100": "昌都地区",
                "542121": "昌都县",
                "542122": "江达县",
                "542123": "贡觉县",
                "542124": "类乌齐县",
                "542125": "丁青县",
                "542126": "察雅县",
                "542127": "八宿县",
                "542128": "左贡县",
                "542129": "芒康县",
                "542132": "洛隆县",
                "542133": "边坝县",
                "542134": "其它区",
                "542200": "山南地区",
                "542221": "乃东县",
                "542222": "扎囊县",
                "542223": "贡嘎县",
                "542224": "桑日县",
                "542225": "琼结县",
                "542226": "曲松县",
                "542227": "措美县",
                "542228": "洛扎县",
                "542229": "加查县",
                "542231": "隆子县",
                "542232": "错那县",
                "542233": "浪卡子县",
                "542234": "其它区",
                "542300": "日喀则地区",
                "542301": "日喀则市",
                "542322": "南木林县",
                "542323": "江孜县",
                "542324": "定日县",
                "542325": "萨迦县",
                "542326": "拉孜县",
                "542327": "昂仁县",
                "542328": "谢通门县",
                "542329": "白朗县",
                "542330": "仁布县",
                "542331": "康马县",
                "542332": "定结县",
                "542333": "仲巴县",
                "542334": "亚东县",
                "542335": "吉隆县",
                "542336": "聂拉木县",
                "542337": "萨嘎县",
                "542338": "岗巴县",
                "542339": "其它区",
                "542400": "那曲地区",
                "542421": "那曲县",
                "542422": "嘉黎县",
                "542423": "比如县",
                "542424": "聂荣县",
                "542425": "安多县",
                "542426": "申扎县",
                "542427": "索县",
                "542428": "班戈县",
                "542429": "巴青县",
                "542430": "尼玛县",
                "542431": "其它区",
                "542432": "双湖县",
                "542500": "阿里地区",
                "542521": "普兰县",
                "542522": "札达县",
                "542523": "噶尔县",
                "542524": "日土县",
                "542525": "革吉县",
                "542526": "改则县",
                "542527": "措勤县",
                "542528": "其它区",
                "542600": "林芝地区",
                "542621": "林芝县",
                "542622": "工布江达县",
                "542623": "米林县",
                "542624": "墨脱县",
                "542625": "波密县",
                "542626": "察隅县",
                "542627": "朗县",
                "542628": "其它区",
                "610000": "陕西省",
                "610100": "西安市",
                "610102": "新城区",
                "610103": "碑林区",
                "610104": "莲湖区",
                "610111": "灞桥区",
                "610112": "未央区",
                "610113": "雁塔区",
                "610114": "阎良区",
                "610115": "临潼区",
                "610116": "长安区",
                "610122": "蓝田县",
                "610124": "周至县",
                "610125": "户县",
                "610126": "高陵县",
                "610127": "其它区",
                "610200": "铜川市",
                "610202": "王益区",
                "610203": "印台区",
                "610204": "耀州区",
                "610222": "宜君县",
                "610223": "其它区",
                "610300": "宝鸡市",
                "610302": "渭滨区",
                "610303": "金台区",
                "610304": "陈仓区",
                "610322": "凤翔县",
                "610323": "岐山县",
                "610324": "扶风县",
                "610326": "眉县",
                "610327": "陇县",
                "610328": "千阳县",
                "610329": "麟游县",
                "610330": "凤县",
                "610331": "太白县",
                "610332": "其它区",
                "610400": "咸阳市",
                "610402": "秦都区",
                "610403": "杨陵区",
                "610404": "渭城区",
                "610422": "三原县",
                "610423": "泾阳县",
                "610424": "乾县",
                "610425": "礼泉县",
                "610426": "永寿县",
                "610427": "彬县",
                "610428": "长武县",
                "610429": "旬邑县",
                "610430": "淳化县",
                "610431": "武功县",
                "610481": "兴平市",
                "610482": "其它区",
                "610500": "渭南市",
                "610502": "临渭区",
                "610521": "华县",
                "610522": "潼关县",
                "610523": "大荔县",
                "610524": "合阳县",
                "610525": "澄城县",
                "610526": "蒲城县",
                "610527": "白水县",
                "610528": "富平县",
                "610581": "韩城市",
                "610582": "华阴市",
                "610583": "其它区",
                "610600": "延安市",
                "610602": "宝塔区",
                "610621": "延长县",
                "610622": "延川县",
                "610623": "子长县",
                "610624": "安塞县",
                "610625": "志丹县",
                "610626": "吴起县",
                "610627": "甘泉县",
                "610628": "富县",
                "610629": "洛川县",
                "610630": "宜川县",
                "610631": "黄龙县",
                "610632": "黄陵县",
                "610633": "其它区",
                "610700": "汉中市",
                "610702": "汉台区",
                "610721": "南郑县",
                "610722": "城固县",
                "610723": "洋县",
                "610724": "西乡县",
                "610725": "勉县",
                "610726": "宁强县",
                "610727": "略阳县",
                "610728": "镇巴县",
                "610729": "留坝县",
                "610730": "佛坪县",
                "610731": "其它区",
                "610800": "榆林市",
                "610802": "榆阳区",
                "610821": "神木县",
                "610822": "府谷县",
                "610823": "横山县",
                "610824": "靖边县",
                "610825": "定边县",
                "610826": "绥德县",
                "610827": "米脂县",
                "610828": "佳县",
                "610829": "吴堡县",
                "610830": "清涧县",
                "610831": "子洲县",
                "610832": "其它区",
                "610900": "安康市",
                "610902": "汉滨区",
                "610921": "汉阴县",
                "610922": "石泉县",
                "610923": "宁陕县",
                "610924": "紫阳县",
                "610925": "岚皋县",
                "610926": "平利县",
                "610927": "镇坪县",
                "610928": "旬阳县",
                "610929": "白河县",
                "610930": "其它区",
                "611000": "商洛市",
                "611002": "商州区",
                "611021": "洛南县",
                "611022": "丹凤县",
                "611023": "商南县",
                "611024": "山阳县",
                "611025": "镇安县",
                "611026": "柞水县",
                "611027": "其它区",
                "620000": "甘肃省",
                "620100": "兰州市",
                "620102": "城关区",
                "620103": "七里河区",
                "620104": "西固区",
                "620105": "安宁区",
                "620111": "红古区",
                "620121": "永登县",
                "620122": "皋兰县",
                "620123": "榆中县",
                "620124": "其它区",
                "620200": "嘉峪关市",
                "620300": "金昌市",
                "620302": "金川区",
                "620321": "永昌县",
                "620322": "其它区",
                "620400": "白银市",
                "620402": "白银区",
                "620403": "平川区",
                "620421": "靖远县",
                "620422": "会宁县",
                "620423": "景泰县",
                "620424": "其它区",
                "620500": "天水市",
                "620502": "秦州区",
                "620503": "麦积区",
                "620521": "清水县",
                "620522": "秦安县",
                "620523": "甘谷县",
                "620524": "武山县",
                "620525": "张家川回族自治县",
                "620526": "其它区",
                "620600": "武威市",
                "620602": "凉州区",
                "620621": "民勤县",
                "620622": "古浪县",
                "620623": "天祝藏族自治县",
                "620624": "其它区",
                "620700": "张掖市",
                "620702": "甘州区",
                "620721": "肃南裕固族自治县",
                "620722": "民乐县",
                "620723": "临泽县",
                "620724": "高台县",
                "620725": "山丹县",
                "620726": "其它区",
                "620800": "平凉市",
                "620802": "崆峒区",
                "620821": "泾川县",
                "620822": "灵台县",
                "620823": "崇信县",
                "620824": "华亭县",
                "620825": "庄浪县",
                "620826": "静宁县",
                "620827": "其它区",
                "620900": "酒泉市",
                "620902": "肃州区",
                "620921": "金塔县",
                "620922": "瓜州县",
                "620923": "肃北蒙古族自治县",
                "620924": "阿克塞哈萨克族自治县",
                "620981": "玉门市",
                "620982": "敦煌市",
                "620983": "其它区",
                "621000": "庆阳市",
                "621002": "西峰区",
                "621021": "庆城县",
                "621022": "环县",
                "621023": "华池县",
                "621024": "合水县",
                "621025": "正宁县",
                "621026": "宁县",
                "621027": "镇原县",
                "621028": "其它区",
                "621100": "定西市",
                "621102": "安定区",
                "621121": "通渭县",
                "621122": "陇西县",
                "621123": "渭源县",
                "621124": "临洮县",
                "621125": "漳县",
                "621126": "岷县",
                "621127": "其它区",
                "621200": "陇南市",
                "621202": "武都区",
                "621221": "成县",
                "621222": "文县",
                "621223": "宕昌县",
                "621224": "康县",
                "621225": "西和县",
                "621226": "礼县",
                "621227": "徽县",
                "621228": "两当县",
                "621229": "其它区",
                "622900": "临夏回族自治州",
                "622901": "临夏市",
                "622921": "临夏县",
                "622922": "康乐县",
                "622923": "永靖县",
                "622924": "广河县",
                "622925": "和政县",
                "622926": "东乡族自治县",
                "622927": "积石山保安族东乡族撒拉族自治县",
                "622928": "其它区",
                "623000": "甘南藏族自治州",
                "623001": "合作市",
                "623021": "临潭县",
                "623022": "卓尼县",
                "623023": "舟曲县",
                "623024": "迭部县",
                "623025": "玛曲县",
                "623026": "碌曲县",
                "623027": "夏河县",
                "623028": "其它区",
                "630000": "青海省",
                "630100": "西宁市",
                "630102": "城东区",
                "630103": "城中区",
                "630104": "城西区",
                "630105": "城北区",
                "630121": "大通回族土族自治县",
                "630122": "湟中县",
                "630123": "湟源县",
                "630124": "其它区",
                "632100": "海东市",
                "632121": "平安县",
                "632122": "民和回族土族自治县",
                "632123": "乐都区",
                "632126": "互助土族自治县",
                "632127": "化隆回族自治县",
                "632128": "循化撒拉族自治县",
                "632129": "其它区",
                "632200": "海北藏族自治州",
                "632221": "门源回族自治县",
                "632222": "祁连县",
                "632223": "海晏县",
                "632224": "刚察县",
                "632225": "其它区",
                "632300": "黄南藏族自治州",
                "632321": "同仁县",
                "632322": "尖扎县",
                "632323": "泽库县",
                "632324": "河南蒙古族自治县",
                "632325": "其它区",
                "632500": "海南藏族自治州",
                "632521": "共和县",
                "632522": "同德县",
                "632523": "贵德县",
                "632524": "兴海县",
                "632525": "贵南县",
                "632526": "其它区",
                "632600": "果洛藏族自治州",
                "632621": "玛沁县",
                "632622": "班玛县",
                "632623": "甘德县",
                "632624": "达日县",
                "632625": "久治县",
                "632626": "玛多县",
                "632627": "其它区",
                "632700": "玉树藏族自治州",
                "632721": "玉树市",
                "632722": "杂多县",
                "632723": "称多县",
                "632724": "治多县",
                "632725": "囊谦县",
                "632726": "曲麻莱县",
                "632727": "其它区",
                "632800": "海西蒙古族藏族自治州",
                "632801": "格尔木市",
                "632802": "德令哈市",
                "632821": "乌兰县",
                "632822": "都兰县",
                "632823": "天峻县",
                "632824": "其它区",
                "640000": "宁夏回族自治区",
                "640100": "银川市",
                "640104": "兴庆区",
                "640105": "西夏区",
                "640106": "金凤区",
                "640121": "永宁县",
                "640122": "贺兰县",
                "640181": "灵武市",
                "640182": "其它区",
                "640200": "石嘴山市",
                "640202": "大武口区",
                "640205": "惠农区",
                "640221": "平罗县",
                "640222": "其它区",
                "640300": "吴忠市",
                "640302": "利通区",
                "640303": "红寺堡区",
                "640323": "盐池县",
                "640324": "同心县",
                "640381": "青铜峡市",
                "640382": "其它区",
                "640400": "固原市",
                "640402": "原州区",
                "640422": "西吉县",
                "640423": "隆德县",
                "640424": "泾源县",
                "640425": "彭阳县",
                "640426": "其它区",
                "640500": "中卫市",
                "640502": "沙坡头区",
                "640521": "中宁县",
                "640522": "海原县",
                "640523": "其它区",
                "650000": "新疆维吾尔自治区",
                "650100": "乌鲁木齐市",
                "650102": "天山区",
                "650103": "沙依巴克区",
                "650104": "新市区",
                "650105": "水磨沟区",
                "650106": "头屯河区",
                "650107": "达坂城区",
                "650109": "米东区",
                "650121": "乌鲁木齐县",
                "650122": "其它区",
                "650200": "克拉玛依市",
                "650202": "独山子区",
                "650203": "克拉玛依区",
                "650204": "白碱滩区",
                "650205": "乌尔禾区",
                "650206": "其它区",
                "652100": "吐鲁番地区",
                "652101": "吐鲁番市",
                "652122": "鄯善县",
                "652123": "托克逊县",
                "652124": "其它区",
                "652200": "哈密地区",
                "652201": "哈密市",
                "652222": "巴里坤哈萨克自治县",
                "652223": "伊吾县",
                "652224": "其它区",
                "652300": "昌吉回族自治州",
                "652301": "昌吉市",
                "652302": "阜康市",
                "652323": "呼图壁县",
                "652324": "玛纳斯县",
                "652325": "奇台县",
                "652327": "吉木萨尔县",
                "652328": "木垒哈萨克自治县",
                "652329": "其它区",
                "652700": "博尔塔拉蒙古自治州",
                "652701": "博乐市",
                "652702": "阿拉山口市",
                "652722": "精河县",
                "652723": "温泉县",
                "652724": "其它区",
                "652800": "巴音郭楞蒙古自治州",
                "652801": "库尔勒市",
                "652822": "轮台县",
                "652823": "尉犁县",
                "652824": "若羌县",
                "652825": "且末县",
                "652826": "焉耆回族自治县",
                "652827": "和静县",
                "652828": "和硕县",
                "652829": "博湖县",
                "652830": "其它区",
                "652900": "阿克苏地区",
                "652901": "阿克苏市",
                "652922": "温宿县",
                "652923": "库车县",
                "652924": "沙雅县",
                "652925": "新和县",
                "652926": "拜城县",
                "652927": "乌什县",
                "652928": "阿瓦提县",
                "652929": "柯坪县",
                "652930": "其它区",
                "653000": "克孜勒苏柯尔克孜自治州",
                "653001": "阿图什市",
                "653022": "阿克陶县",
                "653023": "阿合奇县",
                "653024": "乌恰县",
                "653025": "其它区",
                "653100": "喀什地区",
                "653101": "喀什市",
                "653121": "疏附县",
                "653122": "疏勒县",
                "653123": "英吉沙县",
                "653124": "泽普县",
                "653125": "莎车县",
                "653126": "叶城县",
                "653127": "麦盖提县",
                "653128": "岳普湖县",
                "653129": "伽师县",
                "653130": "巴楚县",
                "653131": "塔什库尔干塔吉克自治县",
                "653132": "其它区",
                "653200": "和田地区",
                "653201": "和田市",
                "653221": "和田县",
                "653222": "墨玉县",
                "653223": "皮山县",
                "653224": "洛浦县",
                "653225": "策勒县",
                "653226": "于田县",
                "653227": "民丰县",
                "653228": "其它区",
                "654000": "伊犁哈萨克自治州",
                "654002": "伊宁市",
                "654003": "奎屯市",
                "654021": "伊宁县",
                "654022": "察布查尔锡伯自治县",
                "654023": "霍城县",
                "654024": "巩留县",
                "654025": "新源县",
                "654026": "昭苏县",
                "654027": "特克斯县",
                "654028": "尼勒克县",
                "654029": "其它区",
                "654200": "塔城地区",
                "654201": "塔城市",
                "654202": "乌苏市",
                "654221": "额敏县",
                "654223": "沙湾县",
                "654224": "托里县",
                "654225": "裕民县",
                "654226": "和布克赛尔蒙古自治县",
                "654227": "其它区",
                "654300": "阿勒泰地区",
                "654301": "阿勒泰市",
                "654321": "布尔津县",
                "654322": "富蕴县",
                "654323": "福海县",
                "654324": "哈巴河县",
                "654325": "青河县",
                "654326": "吉木乃县",
                "654327": "其它区",
                "659001": "石河子市",
                "659002": "阿拉尔市",
                "659003": "图木舒克市",
                "659004": "五家渠市",
                "710000": "台湾",
                "710100": "台北市",
                "710101": "中正区",
                "710102": "大同区",
                "710103": "中山区",
                "710104": "松山区",
                "710105": "大安区",
                "710106": "万华区",
                "710107": "信义区",
                "710108": "士林区",
                "710109": "北投区",
                "710110": "内湖区",
                "710111": "南港区",
                "710112": "文山区",
                "710113": "其它区",
                "710200": "高雄市",
                "710201": "新兴区",
                "710202": "前金区",
                "710203": "芩雅区",
                "710204": "盐埕区",
                "710205": "鼓山区",
                "710206": "旗津区",
                "710207": "前镇区",
                "710208": "三民区",
                "710209": "左营区",
                "710210": "楠梓区",
                "710211": "小港区",
                "710212": "其它区",
                "710241": "苓雅区",
                "710242": "仁武区",
                "710243": "大社区",
                "710244": "冈山区",
                "710245": "路竹区",
                "710246": "阿莲区",
                "710247": "田寮区",
                "710248": "燕巢区",
                "710249": "桥头区",
                "710250": "梓官区",
                "710251": "弥陀区",
                "710252": "永安区",
                "710253": "湖内区",
                "710254": "凤山区",
                "710255": "大寮区",
                "710256": "林园区",
                "710257": "鸟松区",
                "710258": "大树区",
                "710259": "旗山区",
                "710260": "美浓区",
                "710261": "六龟区",
                "710262": "内门区",
                "710263": "杉林区",
                "710264": "甲仙区",
                "710265": "桃源区",
                "710266": "那玛夏区",
                "710267": "茂林区",
                "710268": "茄萣区",
                "710300": "台南市",
                "710301": "中西区",
                "710302": "东区",
                "710303": "南区",
                "710304": "北区",
                "710305": "安平区",
                "710306": "安南区",
                "710307": "其它区",
                "710339": "永康区",
                "710340": "归仁区",
                "710341": "新化区",
                "710342": "左镇区",
                "710343": "玉井区",
                "710344": "楠西区",
                "710345": "南化区",
                "710346": "仁德区",
                "710347": "关庙区",
                "710348": "龙崎区",
                "710349": "官田区",
                "710350": "麻豆区",
                "710351": "佳里区",
                "710352": "西港区",
                "710353": "七股区",
                "710354": "将军区",
                "710355": "学甲区",
                "710356": "北门区",
                "710357": "新营区",
                "710358": "后壁区",
                "710359": "白河区",
                "710360": "东山区",
                "710361": "六甲区",
                "710362": "下营区",
                "710363": "柳营区",
                "710364": "盐水区",
                "710365": "善化区",
                "710366": "大内区",
                "710367": "山上区",
                "710368": "新市区",
                "710369": "安定区",
                "710400": "台中市",
                "710401": "中区",
                "710402": "东区",
                "710403": "南区",
                "710404": "西区",
                "710405": "北区",
                "710406": "北屯区",
                "710407": "西屯区",
                "710408": "南屯区",
                "710409": "其它区",
                "710431": "太平区",
                "710432": "大里区",
                "710433": "雾峰区",
                "710434": "乌日区",
                "710435": "丰原区",
                "710436": "后里区",
                "710437": "石冈区",
                "710438": "东势区",
                "710439": "和平区",
                "710440": "新社区",
                "710441": "潭子区",
                "710442": "大雅区",
                "710443": "神冈区",
                "710444": "大肚区",
                "710445": "沙鹿区",
                "710446": "龙井区",
                "710447": "梧栖区",
                "710448": "清水区",
                "710449": "大甲区",
                "710450": "外埔区",
                "710451": "大安区",
                "710500": "金门县",
                "710507": "金沙镇",
                "710508": "金湖镇",
                "710509": "金宁乡",
                "710510": "金城镇",
                "710511": "烈屿乡",
                "710512": "乌坵乡",
                "710600": "南投县",
                "710614": "南投市",
                "710615": "中寮乡",
                "710616": "草屯镇",
                "710617": "国姓乡",
                "710618": "埔里镇",
                "710619": "仁爱乡",
                "710620": "名间乡",
                "710621": "集集镇",
                "710622": "水里乡",
                "710623": "鱼池乡",
                "710624": "信义乡",
                "710625": "竹山镇",
                "710626": "鹿谷乡",
                "710700": "基隆市",
                "710701": "仁爱区",
                "710702": "信义区",
                "710703": "中正区",
                "710704": "中山区",
                "710705": "安乐区",
                "710706": "暖暖区",
                "710707": "七堵区",
                "710708": "其它区",
                "710800": "新竹市",
                "710801": "东区",
                "710802": "北区",
                "710803": "香山区",
                "710804": "其它区",
                "710900": "嘉义市",
                "710901": "东区",
                "710902": "西区",
                "710903": "其它区",
                "711100": "新北市",
                "711130": "万里区",
                "711131": "金山区",
                "711132": "板桥区",
                "711133": "汐止区",
                "711134": "深坑区",
                "711135": "石碇区",
                "711136": "瑞芳区",
                "711137": "平溪区",
                "711138": "双溪区",
                "711139": "贡寮区",
                "711140": "新店区",
                "711141": "坪林区",
                "711142": "乌来区",
                "711143": "永和区",
                "711144": "中和区",
                "711145": "土城区",
                "711146": "三峡区",
                "711147": "树林区",
                "711148": "莺歌区",
                "711149": "三重区",
                "711150": "新庄区",
                "711151": "泰山区",
                "711152": "林口区",
                "711153": "芦洲区",
                "711154": "五股区",
                "711155": "八里区",
                "711156": "淡水区",
                "711157": "三芝区",
                "711158": "石门区",
                "711200": "宜兰县",
                "711214": "宜兰市",
                "711215": "头城镇",
                "711216": "礁溪乡",
                "711217": "壮围乡",
                "711218": "员山乡",
                "711219": "罗东镇",
                "711220": "三星乡",
                "711221": "大同乡",
                "711222": "五结乡",
                "711223": "冬山乡",
                "711224": "苏澳镇",
                "711225": "南澳乡",
                "711226": "钓鱼台",
                "711300": "新竹县",
                "711314": "竹北市",
                "711315": "湖口乡",
                "711316": "新丰乡",
                "711317": "新埔镇",
                "711318": "关西镇",
                "711319": "芎林乡",
                "711320": "宝山乡",
                "711321": "竹东镇",
                "711322": "五峰乡",
                "711323": "横山乡",
                "711324": "尖石乡",
                "711325": "北埔乡",
                "711326": "峨眉乡",
                "711400": "桃园县",
                "711414": "中坜市",
                "711415": "平镇市",
                "711416": "龙潭乡",
                "711417": "杨梅市",
                "711418": "新屋乡",
                "711419": "观音乡",
                "711420": "桃园市",
                "711421": "龟山乡",
                "711422": "八德市",
                "711423": "大溪镇",
                "711424": "复兴乡",
                "711425": "大园乡",
                "711426": "芦竹乡",
                "711500": "苗栗县",
                "711519": "竹南镇",
                "711520": "头份镇",
                "711521": "三湾乡",
                "711522": "南庄乡",
                "711523": "狮潭乡",
                "711524": "后龙镇",
                "711525": "通霄镇",
                "711526": "苑里镇",
                "711527": "苗栗市",
                "711528": "造桥乡",
                "711529": "头屋乡",
                "711530": "公馆乡",
                "711531": "大湖乡",
                "711532": "泰安乡",
                "711533": "铜锣乡",
                "711534": "三义乡",
                "711535": "西湖乡",
                "711536": "卓兰镇",
                "711700": "彰化县",
                "711727": "彰化市",
                "711728": "芬园乡",
                "711729": "花坛乡",
                "711730": "秀水乡",
                "711731": "鹿港镇",
                "711732": "福兴乡",
                "711733": "线西乡",
                "711734": "和美镇",
                "711735": "伸港乡",
                "711736": "员林镇",
                "711737": "社头乡",
                "711738": "永靖乡",
                "711739": "埔心乡",
                "711740": "溪湖镇",
                "711741": "大村乡",
                "711742": "埔盐乡",
                "711743": "田中镇",
                "711744": "北斗镇",
                "711745": "田尾乡",
                "711746": "埤头乡",
                "711747": "溪州乡",
                "711748": "竹塘乡",
                "711749": "二林镇",
                "711750": "大城乡",
                "711751": "芳苑乡",
                "711752": "二水乡",
                "711900": "嘉义县",
                "711919": "番路乡",
                "711920": "梅山乡",
                "711921": "竹崎乡",
                "711922": "阿里山乡",
                "711923": "中埔乡",
                "711924": "大埔乡",
                "711925": "水上乡",
                "711926": "鹿草乡",
                "711927": "太保市",
                "711928": "朴子市",
                "711929": "东石乡",
                "711930": "六脚乡",
                "711931": "新港乡",
                "711932": "民雄乡",
                "711933": "大林镇",
                "711934": "溪口乡",
                "711935": "义竹乡",
                "711936": "布袋镇",
                "712100": "云林县",
                "712121": "斗南镇",
                "712122": "大埤乡",
                "712123": "虎尾镇",
                "712124": "土库镇",
                "712125": "褒忠乡",
                "712126": "东势乡",
                "712127": "台西乡",
                "712128": "仑背乡",
                "712129": "麦寮乡",
                "712130": "斗六市",
                "712131": "林内乡",
                "712132": "古坑乡",
                "712133": "莿桐乡",
                "712134": "西螺镇",
                "712135": "二仑乡",
                "712136": "北港镇",
                "712137": "水林乡",
                "712138": "口湖乡",
                "712139": "四湖乡",
                "712140": "元长乡",
                "712400": "屏东县",
                "712434": "屏东市",
                "712435": "三地门乡",
                "712436": "雾台乡",
                "712437": "玛家乡",
                "712438": "九如乡",
                "712439": "里港乡",
                "712440": "高树乡",
                "712441": "盐埔乡",
                "712442": "长治乡",
                "712443": "麟洛乡",
                "712444": "竹田乡",
                "712445": "内埔乡",
                "712446": "万丹乡",
                "712447": "潮州镇",
                "712448": "泰武乡",
                "712449": "来义乡",
                "712450": "万峦乡",
                "712451": "崁顶乡",
                "712452": "新埤乡",
                "712453": "南州乡",
                "712454": "林边乡",
                "712455": "东港镇",
                "712456": "琉球乡",
                "712457": "佳冬乡",
                "712458": "新园乡",
                "712459": "枋寮乡",
                "712460": "枋山乡",
                "712461": "春日乡",
                "712462": "狮子乡",
                "712463": "车城乡",
                "712464": "牡丹乡",
                "712465": "恒春镇",
                "712466": "满州乡",
                "712500": "台东县",
                "712517": "台东市",
                "712518": "绿岛乡",
                "712519": "兰屿乡",
                "712520": "延平乡",
                "712521": "卑南乡",
                "712522": "鹿野乡",
                "712523": "关山镇",
                "712524": "海端乡",
                "712525": "池上乡",
                "712526": "东河乡",
                "712527": "成功镇",
                "712528": "长滨乡",
                "712529": "金峰乡",
                "712530": "大武乡",
                "712531": "达仁乡",
                "712532": "太麻里乡",
                "712600": "花莲县",
                "712615": "花莲市",
                "712616": "新城乡",
                "712617": "太鲁阁",
                "712618": "秀林乡",
                "712619": "吉安乡",
                "712620": "寿丰乡",
                "712621": "凤林镇",
                "712622": "光复乡",
                "712623": "丰滨乡",
                "712624": "瑞穗乡",
                "712625": "万荣乡",
                "712626": "玉里镇",
                "712627": "卓溪乡",
                "712628": "富里乡",
                "712700": "澎湖县",
                "712707": "马公市",
                "712708": "西屿乡",
                "712709": "望安乡",
                "712710": "七美乡",
                "712711": "白沙乡",
                "712712": "湖西乡",
                "712800": "连江县",
                "712805": "南竿乡",
                "712806": "北竿乡",
                "712807": "莒光乡",
                "712808": "东引乡",
                "810000": "香港特别行政区",
                "810100": "香港岛",
                "810101": "中西区",
                "810102": "湾仔",
                "810103": "东区",
                "810104": "南区",
                "810200": "九龙",
                "810201": "九龙城区",
                "810202": "油尖旺区",
                "810203": "深水埗区",
                "810204": "黄大仙区",
                "810205": "观塘区",
                "810300": "新界",
                "810301": "北区",
                "810302": "大埔区",
                "810303": "沙田区",
                "810304": "西贡区",
                "810305": "元朗区",
                "810306": "屯门区",
                "810307": "荃湾区",
                "810308": "葵青区",
                "810309": "离岛区",
                "820000": "澳门特别行政区",
                "820100": "澳门半岛",
                "820200": "离岛",
                "990000": "海外",
                "990100": "海外"
              };
              function tree(list2) {
                var mapped = {};
                for (var i2 = 0, item; i2 < list2.length; i2++) {
                  item = list2[i2];
                  if (!item || !item.id) continue;
                  mapped[item.id] = item;
                }
                var result = [];
                for (var ii = 0; ii < list2.length; ii++) {
                  item = list2[ii];
                  if (!item) continue;
                  if (item.pid == void 0 && item.parentId == void 0) {
                    result.push(item);
                    continue;
                  }
                  var parent2 = mapped[item.pid] || mapped[item.parentId];
                  if (!parent2) continue;
                  if (!parent2.children) parent2.children = [];
                  parent2.children.push(item);
                }
                return result;
              }
              var DICT_FIXED = function() {
                var fixed = [];
                for (var id in DICT) {
                  var pid = id.slice(2, 6) === "0000" ? void 0 : id.slice(4, 6) == "00" ? id.slice(0, 2) + "0000" : id.slice(0, 4) + "00";
                  fixed.push({
                    id,
                    pid,
                    name: DICT[id]
                  });
                }
                return tree(fixed);
              }();
              module2.exports = DICT_FIXED;
            },
            /* 19 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var DICT = __webpack_require__2(18);
              module2.exports = {
                // Dice
                d4: function() {
                  return this.natural(1, 4);
                },
                d6: function() {
                  return this.natural(1, 6);
                },
                d8: function() {
                  return this.natural(1, 8);
                },
                d12: function() {
                  return this.natural(1, 12);
                },
                d20: function() {
                  return this.natural(1, 20);
                },
                d100: function() {
                  return this.natural(1, 100);
                },
                /*
                					    随机生成一个 GUID。
                
                					    http://www.broofa.com/2008/09/javascript-uuid-function/
                					    [UUID 规范](http://www.ietf.org/rfc/rfc4122.txt)
                					        UUIDs (Universally Unique IDentifier)
                					        GUIDs (Globally Unique IDentifier)
                					        The formal definition of the UUID string representation is provided by the following ABNF [7]:
                					            UUID                   = time-low "-" time-mid "-"
                					                                   time-high-and-version "-"
                					                                   clock-seq-and-reserved
                					                                   clock-seq-low "-" node
                					            time-low               = 4hexOctet
                					            time-mid               = 2hexOctet
                					            time-high-and-version  = 2hexOctet
                					            clock-seq-and-reserved = hexOctet
                					            clock-seq-low          = hexOctet
                					            node                   = 6hexOctet
                					            hexOctet               = hexDigit hexDigit
                					            hexDigit =
                					                "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
                					                "a" / "b" / "c" / "d" / "e" / "f" /
                					                "A" / "B" / "C" / "D" / "E" / "F"
                					    
                					    https://github.com/victorquinn/chancejs/blob/develop/chance.js#L1349
                					*/
                guid: function() {
                  var pool = "abcdefABCDEF1234567890", guid2 = this.string(pool, 8) + "-" + this.string(pool, 4) + "-" + this.string(pool, 4) + "-" + this.string(pool, 4) + "-" + this.string(pool, 12);
                  return guid2;
                },
                uuid: function() {
                  return this.guid();
                },
                /*
                					    随机生成一个 18 位身份证。
                
                					    [身份证](http://baike.baidu.com/view/1697.htm#4)
                					        地址码 6 + 出生日期码 8 + 顺序码 3 + 校验码 1
                					    [《中华人民共和国行政区划代码》国家标准(GB/T2260)](http://zhidao.baidu.com/question/1954561.html)
                					*/
                id: function() {
                  var id, sum = 0, rank = [
                    "7",
                    "9",
                    "10",
                    "5",
                    "8",
                    "4",
                    "2",
                    "1",
                    "6",
                    "3",
                    "7",
                    "9",
                    "10",
                    "5",
                    "8",
                    "4",
                    "2"
                  ], last2 = [
                    "1",
                    "0",
                    "X",
                    "9",
                    "8",
                    "7",
                    "6",
                    "5",
                    "4",
                    "3",
                    "2"
                  ];
                  id = this.pick(DICT).id + this.date("yyyyMMdd") + this.string("number", 3);
                  for (var i2 = 0; i2 < id.length; i2++) {
                    sum += id[i2] * rank[i2];
                  }
                  id += last2[sum % 11];
                  return id;
                },
                /*
                    生成一个全局的自增整数。
                    类似自增主键（auto increment primary key）。
                */
                increment: /* @__PURE__ */ function() {
                  var key2 = 0;
                  return function(step) {
                    return key2 += +step || 1;
                  };
                }(),
                inc: function(step) {
                  return this.increment(step);
                }
              };
            },
            /* 20 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Parser2 = __webpack_require__2(21);
              var Handler2 = __webpack_require__2(22);
              module2.exports = {
                Parser: Parser2,
                Handler: Handler2
              };
            },
            /* 21 */
            /***/
            function(module2, exports2) {
              function Token(n2) {
                this.type = n2, this.offset = Token.offset(), this.text = Token.text();
              }
              function Alternate(n2, l2) {
                Token.call(this, "alternate"), this.left = n2, this.right = l2;
              }
              function Match(n2) {
                Token.call(this, "match"), this.body = n2.filter(Boolean);
              }
              function Group2(n2, l2) {
                Token.call(this, n2), this.body = l2;
              }
              function CaptureGroup(n2) {
                Group2.call(this, "capture-group"), this.index = cgs[this.offset] || (cgs[this.offset] = index2++), this.body = n2;
              }
              function Quantified(n2, l2) {
                Token.call(this, "quantified"), this.body = n2, this.quantifier = l2;
              }
              function Quantifier(n2, l2) {
                Token.call(this, "quantifier"), this.min = n2, this.max = l2, this.greedy = true;
              }
              function CharSet(n2, l2) {
                Token.call(this, "charset"), this.invert = n2, this.body = l2;
              }
              function CharacterRange(n2, l2) {
                Token.call(this, "range"), this.start = n2, this.end = l2;
              }
              function Literal(n2) {
                Token.call(this, "literal"), this.body = n2, this.escaped = this.body != this.text;
              }
              function Unicode(n2) {
                Token.call(this, "unicode"), this.code = n2.toUpperCase();
              }
              function Hex(n2) {
                Token.call(this, "hex"), this.code = n2.toUpperCase();
              }
              function Octal(n2) {
                Token.call(this, "octal"), this.code = n2.toUpperCase();
              }
              function BackReference(n2) {
                Token.call(this, "back-reference"), this.code = n2.toUpperCase();
              }
              function ControlCharacter(n2) {
                Token.call(this, "control-character"), this.code = n2.toUpperCase();
              }
              var parser = function() {
                function n2(n3, l3) {
                  function u3() {
                    this.constructor = n3;
                  }
                  u3.prototype = l3.prototype, n3.prototype = new u3();
                }
                function l2(n3, l3, u3, t2, r2) {
                  function e2(n4, l4) {
                    function u4(n5) {
                      function l5(n6) {
                        return n6.charCodeAt(0).toString(16).toUpperCase();
                      }
                      return n5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(n6) {
                        return "\\x0" + l5(n6);
                      }).replace(/[\x10-\x1F\x80-\xFF]/g, function(n6) {
                        return "\\x" + l5(n6);
                      }).replace(/[\u0180-\u0FFF]/g, function(n6) {
                        return "\\u0" + l5(n6);
                      }).replace(/[\u1080-\uFFFF]/g, function(n6) {
                        return "\\u" + l5(n6);
                      });
                    }
                    var t3, r3;
                    switch (n4.length) {
                      case 0:
                        t3 = "end of input";
                        break;
                      case 1:
                        t3 = n4[0];
                        break;
                      default:
                        t3 = n4.slice(0, -1).join(", ") + " or " + n4[n4.length - 1];
                    }
                    return r3 = l4 ? '"' + u4(l4) + '"' : "end of input", "Expected " + t3 + " but " + r3 + " found.";
                  }
                  this.expected = n3, this.found = l3, this.offset = u3, this.line = t2, this.column = r2, this.name = "SyntaxError", this.message = e2(n3, l3);
                }
                function u2(n3) {
                  function u3() {
                    return n3.substring(Lt, qt);
                  }
                  function t2() {
                    return Lt;
                  }
                  function r2(l3) {
                    function u4(l4, u5, t3) {
                      var r3, e3;
                      for (r3 = u5; t3 > r3; r3++) e3 = n3.charAt(r3), "\n" === e3 ? (l4.seenCR || l4.line++, l4.column = 1, l4.seenCR = false) : "\r" === e3 || "\u2028" === e3 || "\u2029" === e3 ? (l4.line++, l4.column = 1, l4.seenCR = true) : (l4.column++, l4.seenCR = false);
                    }
                    return Mt !== l3 && (Mt > l3 && (Mt = 0, Dt = {
                      line: 1,
                      column: 1,
                      seenCR: false
                    }), u4(Dt, Mt, l3), Mt = l3), Dt;
                  }
                  function e2(n4) {
                    Ht > qt || (qt > Ht && (Ht = qt, Ot = []), Ot.push(n4));
                  }
                  function o2(n4) {
                    var l3 = 0;
                    for (n4.sort(); l3 < n4.length; ) n4[l3 - 1] === n4[l3] ? n4.splice(l3, 1) : l3++;
                  }
                  function c2() {
                    var l3, u4, t3, r3, o3;
                    return l3 = qt, u4 = i2(), null !== u4 ? (t3 = qt, 124 === n3.charCodeAt(qt) ? (r3 = fl, qt++) : (r3 = null, 0 === Wt && e2(sl)), null !== r3 ? (o3 = c2(), null !== o3 ? (r3 = [r3, o3], t3 = r3) : (qt = t3, t3 = il)) : (qt = t3, t3 = il), null === t3 && (t3 = al), null !== t3 ? (Lt = l3, u4 = hl(u4, t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function i2() {
                    var n4, l3, u4, t3, r3;
                    if (n4 = qt, l3 = f2(), null === l3 && (l3 = al), null !== l3) if (u4 = qt, Wt++, t3 = d2(), Wt--, null === t3 ? u4 = al : (qt = u4, u4 = il), null !== u4) {
                      for (t3 = [], r3 = h2(), null === r3 && (r3 = a2()); null !== r3; ) t3.push(r3), r3 = h2(), null === r3 && (r3 = a2());
                      null !== t3 ? (r3 = s2(), null === r3 && (r3 = al), null !== r3 ? (Lt = n4, l3 = dl(l3, t3, r3), null === l3 ? (qt = n4, n4 = l3) : n4 = l3) : (qt = n4, n4 = il)) : (qt = n4, n4 = il);
                    } else qt = n4, n4 = il;
                    else qt = n4, n4 = il;
                    return n4;
                  }
                  function a2() {
                    var n4;
                    return n4 = x2(), null === n4 && (n4 = Q(), null === n4 && (n4 = B2())), n4;
                  }
                  function f2() {
                    var l3, u4;
                    return l3 = qt, 94 === n3.charCodeAt(qt) ? (u4 = pl, qt++) : (u4 = null, 0 === Wt && e2(vl)), null !== u4 && (Lt = l3, u4 = wl()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function s2() {
                    var l3, u4;
                    return l3 = qt, 36 === n3.charCodeAt(qt) ? (u4 = Al, qt++) : (u4 = null, 0 === Wt && e2(Cl)), null !== u4 && (Lt = l3, u4 = gl()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function h2() {
                    var n4, l3, u4;
                    return n4 = qt, l3 = a2(), null !== l3 ? (u4 = d2(), null !== u4 ? (Lt = n4, l3 = bl(l3, u4), null === l3 ? (qt = n4, n4 = l3) : n4 = l3) : (qt = n4, n4 = il)) : (qt = n4, n4 = il), n4;
                  }
                  function d2() {
                    var n4, l3, u4;
                    return Wt++, n4 = qt, l3 = p2(), null !== l3 ? (u4 = k2(), null === u4 && (u4 = al), null !== u4 ? (Lt = n4, l3 = Tl(l3, u4), null === l3 ? (qt = n4, n4 = l3) : n4 = l3) : (qt = n4, n4 = il)) : (qt = n4, n4 = il), Wt--, null === n4 && (l3 = null, 0 === Wt && e2(kl)), n4;
                  }
                  function p2() {
                    var n4;
                    return n4 = v2(), null === n4 && (n4 = w2(), null === n4 && (n4 = A2(), null === n4 && (n4 = C(), null === n4 && (n4 = g2(), null === n4 && (n4 = b2()))))), n4;
                  }
                  function v2() {
                    var l3, u4, t3, r3, o3, c3;
                    return l3 = qt, 123 === n3.charCodeAt(qt) ? (u4 = xl, qt++) : (u4 = null, 0 === Wt && e2(yl)), null !== u4 ? (t3 = T2(), null !== t3 ? (44 === n3.charCodeAt(qt) ? (r3 = ml, qt++) : (r3 = null, 0 === Wt && e2(Rl)), null !== r3 ? (o3 = T2(), null !== o3 ? (125 === n3.charCodeAt(qt) ? (c3 = Fl, qt++) : (c3 = null, 0 === Wt && e2(Ql)), null !== c3 ? (Lt = l3, u4 = Sl(t3, o3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function w2() {
                    var l3, u4, t3, r3;
                    return l3 = qt, 123 === n3.charCodeAt(qt) ? (u4 = xl, qt++) : (u4 = null, 0 === Wt && e2(yl)), null !== u4 ? (t3 = T2(), null !== t3 ? (n3.substr(qt, 2) === Ul ? (r3 = Ul, qt += 2) : (r3 = null, 0 === Wt && e2(El)), null !== r3 ? (Lt = l3, u4 = Gl(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function A2() {
                    var l3, u4, t3, r3;
                    return l3 = qt, 123 === n3.charCodeAt(qt) ? (u4 = xl, qt++) : (u4 = null, 0 === Wt && e2(yl)), null !== u4 ? (t3 = T2(), null !== t3 ? (125 === n3.charCodeAt(qt) ? (r3 = Fl, qt++) : (r3 = null, 0 === Wt && e2(Ql)), null !== r3 ? (Lt = l3, u4 = Bl(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function C() {
                    var l3, u4;
                    return l3 = qt, 43 === n3.charCodeAt(qt) ? (u4 = jl, qt++) : (u4 = null, 0 === Wt && e2($l)), null !== u4 && (Lt = l3, u4 = ql()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function g2() {
                    var l3, u4;
                    return l3 = qt, 42 === n3.charCodeAt(qt) ? (u4 = Ll, qt++) : (u4 = null, 0 === Wt && e2(Ml)), null !== u4 && (Lt = l3, u4 = Dl()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function b2() {
                    var l3, u4;
                    return l3 = qt, 63 === n3.charCodeAt(qt) ? (u4 = Hl, qt++) : (u4 = null, 0 === Wt && e2(Ol)), null !== u4 && (Lt = l3, u4 = Wl()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function k2() {
                    var l3;
                    return 63 === n3.charCodeAt(qt) ? (l3 = Hl, qt++) : (l3 = null, 0 === Wt && e2(Ol)), l3;
                  }
                  function T2() {
                    var l3, u4, t3;
                    if (l3 = qt, u4 = [], zl.test(n3.charAt(qt)) ? (t3 = n3.charAt(qt), qt++) : (t3 = null, 0 === Wt && e2(Il)), null !== t3) for (; null !== t3; ) u4.push(t3), zl.test(n3.charAt(qt)) ? (t3 = n3.charAt(qt), qt++) : (t3 = null, 0 === Wt && e2(Il));
                    else u4 = il;
                    return null !== u4 && (Lt = l3, u4 = Jl(u4)), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function x2() {
                    var l3, u4, t3, r3;
                    return l3 = qt, 40 === n3.charCodeAt(qt) ? (u4 = Kl, qt++) : (u4 = null, 0 === Wt && e2(Nl)), null !== u4 ? (t3 = R2(), null === t3 && (t3 = F2(), null === t3 && (t3 = m2(), null === t3 && (t3 = y2()))), null !== t3 ? (41 === n3.charCodeAt(qt) ? (r3 = Pl, qt++) : (r3 = null, 0 === Wt && e2(Vl)), null !== r3 ? (Lt = l3, u4 = Xl(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function y2() {
                    var n4, l3;
                    return n4 = qt, l3 = c2(), null !== l3 && (Lt = n4, l3 = Yl(l3)), null === l3 ? (qt = n4, n4 = l3) : n4 = l3, n4;
                  }
                  function m2() {
                    var l3, u4, t3;
                    return l3 = qt, n3.substr(qt, 2) === Zl ? (u4 = Zl, qt += 2) : (u4 = null, 0 === Wt && e2(_l)), null !== u4 ? (t3 = c2(), null !== t3 ? (Lt = l3, u4 = nu(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function R2() {
                    var l3, u4, t3;
                    return l3 = qt, n3.substr(qt, 2) === lu ? (u4 = lu, qt += 2) : (u4 = null, 0 === Wt && e2(uu)), null !== u4 ? (t3 = c2(), null !== t3 ? (Lt = l3, u4 = tu(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function F2() {
                    var l3, u4, t3;
                    return l3 = qt, n3.substr(qt, 2) === ru ? (u4 = ru, qt += 2) : (u4 = null, 0 === Wt && e2(eu)), null !== u4 ? (t3 = c2(), null !== t3 ? (Lt = l3, u4 = ou(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function Q() {
                    var l3, u4, t3, r3, o3;
                    if (Wt++, l3 = qt, 91 === n3.charCodeAt(qt) ? (u4 = iu, qt++) : (u4 = null, 0 === Wt && e2(au)), null !== u4) if (94 === n3.charCodeAt(qt) ? (t3 = pl, qt++) : (t3 = null, 0 === Wt && e2(vl)), null === t3 && (t3 = al), null !== t3) {
                      for (r3 = [], o3 = S2(), null === o3 && (o3 = U()); null !== o3; ) r3.push(o3), o3 = S2(), null === o3 && (o3 = U());
                      null !== r3 ? (93 === n3.charCodeAt(qt) ? (o3 = fu, qt++) : (o3 = null, 0 === Wt && e2(su)), null !== o3 ? (Lt = l3, u4 = hu(t3, r3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il);
                    } else qt = l3, l3 = il;
                    else qt = l3, l3 = il;
                    return Wt--, null === l3 && (u4 = null, 0 === Wt && e2(cu)), l3;
                  }
                  function S2() {
                    var l3, u4, t3, r3;
                    return Wt++, l3 = qt, u4 = U(), null !== u4 ? (45 === n3.charCodeAt(qt) ? (t3 = pu, qt++) : (t3 = null, 0 === Wt && e2(vu)), null !== t3 ? (r3 = U(), null !== r3 ? (Lt = l3, u4 = wu(u4, r3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), Wt--, null === l3 && (u4 = null, 0 === Wt && e2(du)), l3;
                  }
                  function U() {
                    var n4;
                    return Wt++, n4 = G(), null === n4 && (n4 = E2()), Wt--, null === n4 && (0 === Wt && e2(Au)), n4;
                  }
                  function E2() {
                    var l3, u4;
                    return l3 = qt, Cu.test(n3.charAt(qt)) ? (u4 = n3.charAt(qt), qt++) : (u4 = null, 0 === Wt && e2(gu)), null !== u4 && (Lt = l3, u4 = bu(u4)), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function G() {
                    var n4;
                    return n4 = L2(), null === n4 && (n4 = Y2(), null === n4 && (n4 = H(), null === n4 && (n4 = O2(), null === n4 && (n4 = W(), null === n4 && (n4 = z2(), null === n4 && (n4 = I2(), null === n4 && (n4 = J2(), null === n4 && (n4 = K(), null === n4 && (n4 = N2(), null === n4 && (n4 = P2(), null === n4 && (n4 = V2(), null === n4 && (n4 = X(), null === n4 && (n4 = _2(), null === n4 && (n4 = nl(), null === n4 && (n4 = ll(), null === n4 && (n4 = ul(), null === n4 && (n4 = tl()))))))))))))))))), n4;
                  }
                  function B2() {
                    var n4;
                    return n4 = j2(), null === n4 && (n4 = q2(), null === n4 && (n4 = $2())), n4;
                  }
                  function j2() {
                    var l3, u4;
                    return l3 = qt, 46 === n3.charCodeAt(qt) ? (u4 = ku, qt++) : (u4 = null, 0 === Wt && e2(Tu)), null !== u4 && (Lt = l3, u4 = xu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function $2() {
                    var l3, u4;
                    return Wt++, l3 = qt, mu.test(n3.charAt(qt)) ? (u4 = n3.charAt(qt), qt++) : (u4 = null, 0 === Wt && e2(Ru)), null !== u4 && (Lt = l3, u4 = bu(u4)), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, Wt--, null === l3 && (u4 = null, 0 === Wt && e2(yu)), l3;
                  }
                  function q2() {
                    var n4;
                    return n4 = M2(), null === n4 && (n4 = D2(), null === n4 && (n4 = Y2(), null === n4 && (n4 = H(), null === n4 && (n4 = O2(), null === n4 && (n4 = W(), null === n4 && (n4 = z2(), null === n4 && (n4 = I2(), null === n4 && (n4 = J2(), null === n4 && (n4 = K(), null === n4 && (n4 = N2(), null === n4 && (n4 = P2(), null === n4 && (n4 = V2(), null === n4 && (n4 = X(), null === n4 && (n4 = Z(), null === n4 && (n4 = _2(), null === n4 && (n4 = nl(), null === n4 && (n4 = ll(), null === n4 && (n4 = ul(), null === n4 && (n4 = tl()))))))))))))))))))), n4;
                  }
                  function L2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Fu ? (u4 = Fu, qt += 2) : (u4 = null, 0 === Wt && e2(Qu)), null !== u4 && (Lt = l3, u4 = Su()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function M2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Fu ? (u4 = Fu, qt += 2) : (u4 = null, 0 === Wt && e2(Qu)), null !== u4 && (Lt = l3, u4 = Uu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function D2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Eu ? (u4 = Eu, qt += 2) : (u4 = null, 0 === Wt && e2(Gu)), null !== u4 && (Lt = l3, u4 = Bu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function H() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === ju ? (u4 = ju, qt += 2) : (u4 = null, 0 === Wt && e2($u)), null !== u4 && (Lt = l3, u4 = qu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function O2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Lu ? (u4 = Lu, qt += 2) : (u4 = null, 0 === Wt && e2(Mu)), null !== u4 && (Lt = l3, u4 = Du()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function W() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Hu ? (u4 = Hu, qt += 2) : (u4 = null, 0 === Wt && e2(Ou)), null !== u4 && (Lt = l3, u4 = Wu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function z2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === zu ? (u4 = zu, qt += 2) : (u4 = null, 0 === Wt && e2(Iu)), null !== u4 && (Lt = l3, u4 = Ju()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function I2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Ku ? (u4 = Ku, qt += 2) : (u4 = null, 0 === Wt && e2(Nu)), null !== u4 && (Lt = l3, u4 = Pu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function J2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Vu ? (u4 = Vu, qt += 2) : (u4 = null, 0 === Wt && e2(Xu)), null !== u4 && (Lt = l3, u4 = Yu()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function K() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Zu ? (u4 = Zu, qt += 2) : (u4 = null, 0 === Wt && e2(_u)), null !== u4 && (Lt = l3, u4 = nt()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function N2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === lt2 ? (u4 = lt2, qt += 2) : (u4 = null, 0 === Wt && e2(ut)), null !== u4 && (Lt = l3, u4 = tt2()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function P2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === rt2 ? (u4 = rt2, qt += 2) : (u4 = null, 0 === Wt && e2(et)), null !== u4 && (Lt = l3, u4 = ot()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function V2() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === ct ? (u4 = ct, qt += 2) : (u4 = null, 0 === Wt && e2(it)), null !== u4 && (Lt = l3, u4 = at()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function X() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === ft ? (u4 = ft, qt += 2) : (u4 = null, 0 === Wt && e2(st)), null !== u4 && (Lt = l3, u4 = ht()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function Y2() {
                    var l3, u4, t3;
                    return l3 = qt, n3.substr(qt, 2) === dt ? (u4 = dt, qt += 2) : (u4 = null, 0 === Wt && e2(pt)), null !== u4 ? (n3.length > qt ? (t3 = n3.charAt(qt), qt++) : (t3 = null, 0 === Wt && e2(vt)), null !== t3 ? (Lt = l3, u4 = wt(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function Z() {
                    var l3, u4, t3;
                    return l3 = qt, 92 === n3.charCodeAt(qt) ? (u4 = At, qt++) : (u4 = null, 0 === Wt && e2(Ct)), null !== u4 ? (gt.test(n3.charAt(qt)) ? (t3 = n3.charAt(qt), qt++) : (t3 = null, 0 === Wt && e2(bt)), null !== t3 ? (Lt = l3, u4 = kt(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  function _2() {
                    var l3, u4, t3, r3;
                    if (l3 = qt, n3.substr(qt, 2) === Tt ? (u4 = Tt, qt += 2) : (u4 = null, 0 === Wt && e2(xt)), null !== u4) {
                      if (t3 = [], yt.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(mt)), null !== r3) for (; null !== r3; ) t3.push(r3), yt.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(mt));
                      else t3 = il;
                      null !== t3 ? (Lt = l3, u4 = Rt(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il);
                    } else qt = l3, l3 = il;
                    return l3;
                  }
                  function nl() {
                    var l3, u4, t3, r3;
                    if (l3 = qt, n3.substr(qt, 2) === Ft ? (u4 = Ft, qt += 2) : (u4 = null, 0 === Wt && e2(Qt)), null !== u4) {
                      if (t3 = [], St.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(Ut)), null !== r3) for (; null !== r3; ) t3.push(r3), St.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(Ut));
                      else t3 = il;
                      null !== t3 ? (Lt = l3, u4 = Et(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il);
                    } else qt = l3, l3 = il;
                    return l3;
                  }
                  function ll() {
                    var l3, u4, t3, r3;
                    if (l3 = qt, n3.substr(qt, 2) === Gt ? (u4 = Gt, qt += 2) : (u4 = null, 0 === Wt && e2(Bt)), null !== u4) {
                      if (t3 = [], St.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(Ut)), null !== r3) for (; null !== r3; ) t3.push(r3), St.test(n3.charAt(qt)) ? (r3 = n3.charAt(qt), qt++) : (r3 = null, 0 === Wt && e2(Ut));
                      else t3 = il;
                      null !== t3 ? (Lt = l3, u4 = jt(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il);
                    } else qt = l3, l3 = il;
                    return l3;
                  }
                  function ul() {
                    var l3, u4;
                    return l3 = qt, n3.substr(qt, 2) === Tt ? (u4 = Tt, qt += 2) : (u4 = null, 0 === Wt && e2(xt)), null !== u4 && (Lt = l3, u4 = $t()), null === u4 ? (qt = l3, l3 = u4) : l3 = u4, l3;
                  }
                  function tl() {
                    var l3, u4, t3;
                    return l3 = qt, 92 === n3.charCodeAt(qt) ? (u4 = At, qt++) : (u4 = null, 0 === Wt && e2(Ct)), null !== u4 ? (n3.length > qt ? (t3 = n3.charAt(qt), qt++) : (t3 = null, 0 === Wt && e2(vt)), null !== t3 ? (Lt = l3, u4 = bu(t3), null === u4 ? (qt = l3, l3 = u4) : l3 = u4) : (qt = l3, l3 = il)) : (qt = l3, l3 = il), l3;
                  }
                  var rl, el = arguments.length > 1 ? arguments[1] : {}, ol = {
                    regexp: c2
                  }, cl = c2, il = null, al = "", fl = "|", sl = '"|"', hl = function(n4, l3) {
                    return l3 ? new Alternate(n4, l3[1]) : n4;
                  }, dl = function(n4, l3, u4) {
                    return new Match([n4].concat(l3).concat([u4]));
                  }, pl = "^", vl = '"^"', wl = function() {
                    return new Token("start");
                  }, Al = "$", Cl = '"$"', gl = function() {
                    return new Token("end");
                  }, bl = function(n4, l3) {
                    return new Quantified(n4, l3);
                  }, kl = "Quantifier", Tl = function(n4, l3) {
                    return l3 && (n4.greedy = false), n4;
                  }, xl = "{", yl = '"{"', ml = ",", Rl = '","', Fl = "}", Ql = '"}"', Sl = function(n4, l3) {
                    return new Quantifier(n4, l3);
                  }, Ul = ",}", El = '",}"', Gl = function(n4) {
                    return new Quantifier(n4, 1 / 0);
                  }, Bl = function(n4) {
                    return new Quantifier(n4, n4);
                  }, jl = "+", $l = '"+"', ql = function() {
                    return new Quantifier(1, 1 / 0);
                  }, Ll = "*", Ml = '"*"', Dl = function() {
                    return new Quantifier(0, 1 / 0);
                  }, Hl = "?", Ol = '"?"', Wl = function() {
                    return new Quantifier(0, 1);
                  }, zl = /^[0-9]/, Il = "[0-9]", Jl = function(n4) {
                    return +n4.join("");
                  }, Kl = "(", Nl = '"("', Pl = ")", Vl = '")"', Xl = function(n4) {
                    return n4;
                  }, Yl = function(n4) {
                    return new CaptureGroup(n4);
                  }, Zl = "?:", _l = '"?:"', nu = function(n4) {
                    return new Group2("non-capture-group", n4);
                  }, lu = "?=", uu = '"?="', tu = function(n4) {
                    return new Group2("positive-lookahead", n4);
                  }, ru = "?!", eu = '"?!"', ou = function(n4) {
                    return new Group2("negative-lookahead", n4);
                  }, cu = "CharacterSet", iu = "[", au = '"["', fu = "]", su = '"]"', hu = function(n4, l3) {
                    return new CharSet(!!n4, l3);
                  }, du = "CharacterRange", pu = "-", vu = '"-"', wu = function(n4, l3) {
                    return new CharacterRange(n4, l3);
                  }, Au = "Character", Cu = /^[^\\\]]/, gu = "[^\\\\\\]]", bu = function(n4) {
                    return new Literal(n4);
                  }, ku = ".", Tu = '"."', xu = function() {
                    return new Token("any-character");
                  }, yu = "Literal", mu = /^[^|\\\/.[()?+*$\^]/, Ru = "[^|\\\\\\/.[()?+*$\\^]", Fu = "\\b", Qu = '"\\\\b"', Su = function() {
                    return new Token("backspace");
                  }, Uu = function() {
                    return new Token("word-boundary");
                  }, Eu = "\\B", Gu = '"\\\\B"', Bu = function() {
                    return new Token("non-word-boundary");
                  }, ju = "\\d", $u = '"\\\\d"', qu = function() {
                    return new Token("digit");
                  }, Lu = "\\D", Mu = '"\\\\D"', Du = function() {
                    return new Token("non-digit");
                  }, Hu = "\\f", Ou = '"\\\\f"', Wu = function() {
                    return new Token("form-feed");
                  }, zu = "\\n", Iu = '"\\\\n"', Ju = function() {
                    return new Token("line-feed");
                  }, Ku = "\\r", Nu = '"\\\\r"', Pu = function() {
                    return new Token("carriage-return");
                  }, Vu = "\\s", Xu = '"\\\\s"', Yu = function() {
                    return new Token("white-space");
                  }, Zu = "\\S", _u = '"\\\\S"', nt = function() {
                    return new Token("non-white-space");
                  }, lt2 = "\\t", ut = '"\\\\t"', tt2 = function() {
                    return new Token("tab");
                  }, rt2 = "\\v", et = '"\\\\v"', ot = function() {
                    return new Token("vertical-tab");
                  }, ct = "\\w", it = '"\\\\w"', at = function() {
                    return new Token("word");
                  }, ft = "\\W", st = '"\\\\W"', ht = function() {
                    return new Token("non-word");
                  }, dt = "\\c", pt = '"\\\\c"', vt = "any character", wt = function(n4) {
                    return new ControlCharacter(n4);
                  }, At = "\\", Ct = '"\\\\"', gt = /^[1-9]/, bt = "[1-9]", kt = function(n4) {
                    return new BackReference(n4);
                  }, Tt = "\\0", xt = '"\\\\0"', yt = /^[0-7]/, mt = "[0-7]", Rt = function(n4) {
                    return new Octal(n4.join(""));
                  }, Ft = "\\x", Qt = '"\\\\x"', St = /^[0-9a-fA-F]/, Ut = "[0-9a-fA-F]", Et = function(n4) {
                    return new Hex(n4.join(""));
                  }, Gt = "\\u", Bt = '"\\\\u"', jt = function(n4) {
                    return new Unicode(n4.join(""));
                  }, $t = function() {
                    return new Token("null-character");
                  }, qt = 0, Lt = 0, Mt = 0, Dt = {
                    line: 1,
                    column: 1,
                    seenCR: false
                  }, Ht = 0, Ot = [], Wt = 0;
                  if ("startRule" in el) {
                    if (!(el.startRule in ol)) throw new Error(`Can't start parsing from rule "` + el.startRule + '".');
                    cl = ol[el.startRule];
                  }
                  if (Token.offset = t2, Token.text = u3, rl = cl(), null !== rl && qt === n3.length) return rl;
                  throw o2(Ot), Lt = Math.max(qt, Ht), new l2(Ot, Lt < n3.length ? n3.charAt(Lt) : null, Lt, r2(Lt).line, r2(Lt).column);
                }
                return n2(l2, Error), {
                  SyntaxError: l2,
                  parse: u2
                };
              }(), index2 = 1, cgs = {};
              module2.exports = parser;
            },
            /* 22 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Util2 = __webpack_require__2(3);
              var Random2 = __webpack_require__2(5);
              var Handler2 = {
                extend: Util2.extend
              };
              var LOWER = ascii(97, 122);
              var UPPER = ascii(65, 90);
              var NUMBER = ascii(48, 57);
              var OTHER = ascii(32, 47) + ascii(58, 64) + ascii(91, 96) + ascii(123, 126);
              var PRINTABLE = ascii(32, 126);
              var SPACE = " \f\n\r	\v \u2028\u2029";
              var CHARACTER_CLASSES = {
                "\\w": LOWER + UPPER + NUMBER + "_",
                // ascii(95, 95)
                "\\W": OTHER.replace("_", ""),
                "\\s": SPACE,
                "\\S": function() {
                  var result = PRINTABLE;
                  for (var i2 = 0; i2 < SPACE.length; i2++) {
                    result = result.replace(SPACE[i2], "");
                  }
                  return result;
                }(),
                "\\d": NUMBER,
                "\\D": LOWER + UPPER + OTHER
              };
              function ascii(from2, to) {
                var result = "";
                for (var i2 = from2; i2 <= to; i2++) {
                  result += String.fromCharCode(i2);
                }
                return result;
              }
              Handler2.gen = function(node2, result, cache2) {
                cache2 = cache2 || {
                  guid: 1
                };
                return Handler2[node2.type] ? Handler2[node2.type](node2, result, cache2) : Handler2.token(node2, result, cache2);
              };
              Handler2.extend({
                /* jshint unused:false */
                token: function(node2, result, cache2) {
                  switch (node2.type) {
                    case "start":
                    case "end":
                      return "";
                    case "any-character":
                      return Random2.character();
                    case "backspace":
                      return "";
                    case "word-boundary":
                      return "";
                    case "non-word-boundary":
                      break;
                    case "digit":
                      return Random2.pick(
                        NUMBER.split("")
                      );
                    case "non-digit":
                      return Random2.pick(
                        (LOWER + UPPER + OTHER).split("")
                      );
                    case "form-feed":
                      break;
                    case "line-feed":
                      return node2.body || node2.text;
                    case "carriage-return":
                      break;
                    case "white-space":
                      return Random2.pick(
                        SPACE.split("")
                      );
                    case "non-white-space":
                      return Random2.pick(
                        (LOWER + UPPER + NUMBER).split("")
                      );
                    case "tab":
                      break;
                    case "vertical-tab":
                      break;
                    case "word":
                      return Random2.pick(
                        (LOWER + UPPER + NUMBER).split("")
                      );
                    case "non-word":
                      return Random2.pick(
                        OTHER.replace("_", "").split("")
                      );
                  }
                  return node2.body || node2.text;
                },
                /*
                    {
                        type: 'alternate',
                        offset: 0,
                        text: '',
                        left: {
                            boyd: []
                        },
                        right: {
                            boyd: []
                        }
                    }
                */
                alternate: function(node2, result, cache2) {
                  return this.gen(
                    Random2.boolean() ? node2.left : node2.right,
                    result,
                    cache2
                  );
                },
                /*
                    {
                        type: 'match',
                        offset: 0,
                        text: '',
                        body: []
                    }
                */
                match: function(node2, result, cache2) {
                  result = "";
                  for (var i2 = 0; i2 < node2.body.length; i2++) {
                    result += this.gen(node2.body[i2], result, cache2);
                  }
                  return result;
                },
                // ()
                "capture-group": function(node2, result, cache2) {
                  result = this.gen(node2.body, result, cache2);
                  cache2[cache2.guid++] = result;
                  return result;
                },
                // (?:...)
                "non-capture-group": function(node2, result, cache2) {
                  return this.gen(node2.body, result, cache2);
                },
                // (?=p)
                "positive-lookahead": function(node2, result, cache2) {
                  return this.gen(node2.body, result, cache2);
                },
                // (?!p)
                "negative-lookahead": function(node2, result, cache2) {
                  return "";
                },
                /*
                    {
                        type: 'quantified',
                        offset: 3,
                        text: 'c*',
                        body: {
                            type: 'literal',
                            offset: 3,
                            text: 'c',
                            body: 'c',
                            escaped: false
                        },
                        quantifier: {
                            type: 'quantifier',
                            offset: 4,
                            text: '*',
                            min: 0,
                            max: Infinity,
                            greedy: true
                        }
                    }
                */
                quantified: function(node2, result, cache2) {
                  result = "";
                  var count = this.quantifier(node2.quantifier);
                  for (var i2 = 0; i2 < count; i2++) {
                    result += this.gen(node2.body, result, cache2);
                  }
                  return result;
                },
                /*
                    quantifier: {
                        type: 'quantifier',
                        offset: 4,
                        text: '*',
                        min: 0,
                        max: Infinity,
                        greedy: true
                    }
                */
                quantifier: function(node2, result, cache2) {
                  var min3 = Math.max(node2.min, 0);
                  var max3 = isFinite(node2.max) ? node2.max : min3 + Random2.integer(3, 7);
                  return Random2.integer(min3, max3);
                },
                /*
                    
                */
                charset: function(node2, result, cache2) {
                  if (node2.invert) return this["invert-charset"](node2, result, cache2);
                  var literal = Random2.pick(node2.body);
                  return this.gen(literal, result, cache2);
                },
                "invert-charset": function(node2, result, cache2) {
                  var pool = PRINTABLE;
                  for (var i2 = 0, item; i2 < node2.body.length; i2++) {
                    item = node2.body[i2];
                    switch (item.type) {
                      case "literal":
                        pool = pool.replace(item.body, "");
                        break;
                      case "range":
                        var min3 = this.gen(item.start, result, cache2).charCodeAt();
                        var max3 = this.gen(item.end, result, cache2).charCodeAt();
                        for (var ii = min3; ii <= max3; ii++) {
                          pool = pool.replace(String.fromCharCode(ii), "");
                        }
                      /* falls through */
                      default:
                        var characters2 = CHARACTER_CLASSES[item.text];
                        if (characters2) {
                          for (var iii = 0; iii <= characters2.length; iii++) {
                            pool = pool.replace(characters2[iii], "");
                          }
                        }
                    }
                  }
                  return Random2.pick(pool.split(""));
                },
                range: function(node2, result, cache2) {
                  var min3 = this.gen(node2.start, result, cache2).charCodeAt();
                  var max3 = this.gen(node2.end, result, cache2).charCodeAt();
                  return String.fromCharCode(
                    Random2.integer(min3, max3)
                  );
                },
                literal: function(node2, result, cache2) {
                  return node2.escaped ? node2.body : node2.text;
                },
                // Unicode \u
                unicode: function(node2, result, cache2) {
                  return String.fromCharCode(
                    parseInt(node2.code, 16)
                  );
                },
                // 十六进制 \xFF
                hex: function(node2, result, cache2) {
                  return String.fromCharCode(
                    parseInt(node2.code, 16)
                  );
                },
                // 八进制 \0
                octal: function(node2, result, cache2) {
                  return String.fromCharCode(
                    parseInt(node2.code, 8)
                  );
                },
                // 反向引用
                "back-reference": function(node2, result, cache2) {
                  return cache2[node2.code] || "";
                },
                /*
                    http://en.wikipedia.org/wiki/C0_and_C1_control_codes
                */
                CONTROL_CHARACTER_MAP: function() {
                  var CONTROL_CHARACTER = "@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _".split(" ");
                  var CONTROL_CHARACTER_UNICODE = "\0       \x07 \b 	 \n \v \f \r              \x1B    ".split(" ");
                  var map2 = {};
                  for (var i2 = 0; i2 < CONTROL_CHARACTER.length; i2++) {
                    map2[CONTROL_CHARACTER[i2]] = CONTROL_CHARACTER_UNICODE[i2];
                  }
                  return map2;
                }(),
                "control-character": function(node2, result, cache2) {
                  return this.CONTROL_CHARACTER_MAP[node2.code];
                }
              });
              module2.exports = Handler2;
            },
            /* 23 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              module2.exports = __webpack_require__2(24);
            },
            /* 24 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Constant2 = __webpack_require__2(2);
              var Util2 = __webpack_require__2(3);
              var Parser2 = __webpack_require__2(4);
              function toJSONSchema(template, name, path) {
                path = path || [];
                var result = {
                  name: typeof name === "string" ? name.replace(Constant2.RE_KEY, "$1") : name,
                  template,
                  type: Util2.type(template),
                  // 可能不准确，例如 { 'name|1': [{}, {} ...] }
                  rule: Parser2.parse(name)
                };
                result.path = path.slice(0);
                result.path.push(name === void 0 ? "ROOT" : result.name);
                switch (result.type) {
                  case "array":
                    result.items = [];
                    Util2.each(template, function(value, index2) {
                      result.items.push(
                        toJSONSchema(value, index2, result.path)
                      );
                    });
                    break;
                  case "object":
                    result.properties = [];
                    Util2.each(template, function(value, name2) {
                      result.properties.push(
                        toJSONSchema(value, name2, result.path)
                      );
                    });
                    break;
                }
                return result;
              }
              module2.exports = toJSONSchema;
            },
            /* 25 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              module2.exports = __webpack_require__2(26);
            },
            /* 26 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Constant2 = __webpack_require__2(2);
              var Util2 = __webpack_require__2(3);
              var toJSONSchema = __webpack_require__2(23);
              function valid(template, data) {
                var schema = toJSONSchema(template);
                var result = Diff.diff(schema, data);
                for (var i2 = 0; i2 < result.length; i2++) {
                }
                return result;
              }
              var Diff = {
                diff: function diff(schema, data, name) {
                  var result = [];
                  if (this.name(schema, data, name, result) && this.type(schema, data, name, result)) {
                    this.value(schema, data, name, result);
                    this.properties(schema, data, name, result);
                    this.items(schema, data, name, result);
                  }
                  return result;
                },
                /* jshint unused:false */
                name: function(schema, data, name, result) {
                  var length2 = result.length;
                  Assert.equal("name", schema.path, name + "", schema.name + "", result);
                  return result.length === length2;
                },
                type: function(schema, data, name, result) {
                  var length2 = result.length;
                  switch (schema.type) {
                    case "string":
                      if (schema.template.match(Constant2.RE_PLACEHOLDER)) return true;
                      break;
                    case "array":
                      if (schema.rule.parameters) {
                        if (schema.rule.min !== void 0 && schema.rule.max === void 0) {
                          if (schema.rule.count === 1) return true;
                        }
                        if (schema.rule.parameters[2]) return true;
                      }
                      break;
                    case "function":
                      return true;
                  }
                  Assert.equal("type", schema.path, Util2.type(data), schema.type, result);
                  return result.length === length2;
                },
                value: function(schema, data, name, result) {
                  var length2 = result.length;
                  var rule = schema.rule;
                  var templateType = schema.type;
                  if (templateType === "object" || templateType === "array" || templateType === "function") return true;
                  if (!rule.parameters) {
                    switch (templateType) {
                      case "regexp":
                        Assert.match("value", schema.path, data, schema.template, result);
                        return result.length === length2;
                      case "string":
                        if (schema.template.match(Constant2.RE_PLACEHOLDER)) return result.length === length2;
                        break;
                    }
                    Assert.equal("value", schema.path, data, schema.template, result);
                    return result.length === length2;
                  }
                  var actualRepeatCount;
                  switch (templateType) {
                    case "number":
                      var parts2 = (data + "").split(".");
                      parts2[0] = +parts2[0];
                      if (rule.min !== void 0 && rule.max !== void 0) {
                        Assert.greaterThanOrEqualTo("value", schema.path, parts2[0], Math.min(rule.min, rule.max), result);
                        Assert.lessThanOrEqualTo("value", schema.path, parts2[0], Math.max(rule.min, rule.max), result);
                      }
                      if (rule.min !== void 0 && rule.max === void 0) {
                        Assert.equal("value", schema.path, parts2[0], rule.min, result, "[value] " + name);
                      }
                      if (rule.decimal) {
                        if (rule.dmin !== void 0 && rule.dmax !== void 0) {
                          Assert.greaterThanOrEqualTo("value", schema.path, parts2[1].length, rule.dmin, result);
                          Assert.lessThanOrEqualTo("value", schema.path, parts2[1].length, rule.dmax, result);
                        }
                        if (rule.dmin !== void 0 && rule.dmax === void 0) {
                          Assert.equal("value", schema.path, parts2[1].length, rule.dmin, result);
                        }
                      }
                      break;
                    case "boolean":
                      break;
                    case "string":
                      actualRepeatCount = data.match(new RegExp(schema.template, "g"));
                      actualRepeatCount = actualRepeatCount ? actualRepeatCount.length : 0;
                      if (rule.min !== void 0 && rule.max !== void 0) {
                        Assert.greaterThanOrEqualTo("repeat count", schema.path, actualRepeatCount, rule.min, result);
                        Assert.lessThanOrEqualTo("repeat count", schema.path, actualRepeatCount, rule.max, result);
                      }
                      if (rule.min !== void 0 && rule.max === void 0) {
                        Assert.equal("repeat count", schema.path, actualRepeatCount, rule.min, result);
                      }
                      break;
                    case "regexp":
                      actualRepeatCount = data.match(new RegExp(schema.template.source.replace(/^\^|\$$/g, ""), "g"));
                      actualRepeatCount = actualRepeatCount ? actualRepeatCount.length : 0;
                      if (rule.min !== void 0 && rule.max !== void 0) {
                        Assert.greaterThanOrEqualTo("repeat count", schema.path, actualRepeatCount, rule.min, result);
                        Assert.lessThanOrEqualTo("repeat count", schema.path, actualRepeatCount, rule.max, result);
                      }
                      if (rule.min !== void 0 && rule.max === void 0) {
                        Assert.equal("repeat count", schema.path, actualRepeatCount, rule.min, result);
                      }
                      break;
                  }
                  return result.length === length2;
                },
                properties: function(schema, data, name, result) {
                  var length2 = result.length;
                  var rule = schema.rule;
                  var keys2 = Util2.keys(data);
                  if (!schema.properties) return;
                  if (!schema.rule.parameters) {
                    Assert.equal("properties length", schema.path, keys2.length, schema.properties.length, result);
                  } else {
                    if (rule.min !== void 0 && rule.max !== void 0) {
                      Assert.greaterThanOrEqualTo("properties length", schema.path, keys2.length, Math.min(rule.min, rule.max), result);
                      Assert.lessThanOrEqualTo("properties length", schema.path, keys2.length, Math.max(rule.min, rule.max), result);
                    }
                    if (rule.min !== void 0 && rule.max === void 0) {
                      if (rule.count !== 1) Assert.equal("properties length", schema.path, keys2.length, rule.min, result);
                    }
                  }
                  if (result.length !== length2) return false;
                  for (var i2 = 0; i2 < keys2.length; i2++) {
                    result.push.apply(
                      result,
                      this.diff(
                        function() {
                          var property2;
                          Util2.each(schema.properties, function(item) {
                            if (item.name === keys2[i2]) property2 = item;
                          });
                          return property2 || schema.properties[i2];
                        }(),
                        data[keys2[i2]],
                        keys2[i2]
                      )
                    );
                  }
                  return result.length === length2;
                },
                items: function(schema, data, name, result) {
                  var length2 = result.length;
                  if (!schema.items) return;
                  var rule = schema.rule;
                  if (!schema.rule.parameters) {
                    Assert.equal("items length", schema.path, data.length, schema.items.length, result);
                  } else {
                    if (rule.min !== void 0 && rule.max !== void 0) {
                      Assert.greaterThanOrEqualTo(
                        "items",
                        schema.path,
                        data.length,
                        Math.min(rule.min, rule.max) * schema.items.length,
                        result,
                        "[{utype}] array is too short: {path} must have at least {expected} elements but instance has {actual} elements"
                      );
                      Assert.lessThanOrEqualTo(
                        "items",
                        schema.path,
                        data.length,
                        Math.max(rule.min, rule.max) * schema.items.length,
                        result,
                        "[{utype}] array is too long: {path} must have at most {expected} elements but instance has {actual} elements"
                      );
                    }
                    if (rule.min !== void 0 && rule.max === void 0) {
                      if (rule.count === 1) return result.length === length2;
                      else Assert.equal("items length", schema.path, data.length, rule.min * schema.items.length, result);
                    }
                    if (rule.parameters[2]) return result.length === length2;
                  }
                  if (result.length !== length2) return false;
                  for (var i2 = 0; i2 < data.length; i2++) {
                    result.push.apply(
                      result,
                      this.diff(
                        schema.items[i2 % schema.items.length],
                        data[i2],
                        i2 % schema.items.length
                      )
                    );
                  }
                  return result.length === length2;
                }
              };
              var Assert = {
                message: function(item) {
                  return (item.message || "[{utype}] Expect {path}'{ltype} {action} {expected}, but is {actual}").replace("{utype}", item.type.toUpperCase()).replace("{ltype}", item.type.toLowerCase()).replace("{path}", Util2.isArray(item.path) && item.path.join(".") || item.path).replace("{action}", item.action).replace("{expected}", item.expected).replace("{actual}", item.actual);
                },
                equal: function(type, path, actual, expected, result, message) {
                  if (actual === expected) return true;
                  switch (type) {
                    case "type":
                      if (expected === "regexp" && actual === "string") return true;
                      break;
                  }
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is equal to",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                // actual matches expected
                match: function(type, path, actual, expected, result, message) {
                  if (expected.test(actual)) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "matches",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                notEqual: function(type, path, actual, expected, result, message) {
                  if (actual !== expected) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is not equal to",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                greaterThan: function(type, path, actual, expected, result, message) {
                  if (actual > expected) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is greater than",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                lessThan: function(type, path, actual, expected, result, message) {
                  if (actual < expected) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is less to",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                greaterThanOrEqualTo: function(type, path, actual, expected, result, message) {
                  if (actual >= expected) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is greater than or equal to",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                },
                lessThanOrEqualTo: function(type, path, actual, expected, result, message) {
                  if (actual <= expected) return true;
                  var item = {
                    path,
                    type,
                    actual,
                    expected,
                    action: "is less than or equal to",
                    message
                  };
                  item.message = Assert.message(item);
                  result.push(item);
                  return false;
                }
              };
              valid.Diff = Diff;
              valid.Assert = Assert;
              module2.exports = valid;
            },
            /* 27 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              module2.exports = __webpack_require__2(28);
            },
            /* 28 */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var Util2 = __webpack_require__2(3);
              window._XMLHttpRequest = window.XMLHttpRequest;
              window._ActiveXObject = window.ActiveXObject;
              try {
                new window.Event("custom");
              } catch (exception) {
                window.Event = function(type, bubbles, cancelable, detail) {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent(type, bubbles, cancelable, detail);
                  return event;
                };
              }
              var XHR_STATES = {
                // The object has been constructed.
                UNSENT: 0,
                // The open() method has been successfully invoked.
                OPENED: 1,
                // All redirects (if any) have been followed and all HTTP headers of the response have been received.
                HEADERS_RECEIVED: 2,
                // The response's body is being received.
                LOADING: 3,
                // The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects).
                DONE: 4
              };
              var XHR_EVENTS = "readystatechange loadstart progress abort error load timeout loadend".split(" ");
              var XHR_REQUEST_PROPERTIES = "timeout withCredentials".split(" ");
              var XHR_RESPONSE_PROPERTIES = "readyState responseURL status statusText responseType response responseText responseXML".split(" ");
              var HTTP_STATUS_CODES = {
                200: "OK"
              };
              function MockXMLHttpRequest() {
                this.custom = {
                  events: {},
                  requestHeaders: {},
                  responseHeaders: {}
                };
              }
              MockXMLHttpRequest._settings = {
                timeout: "10-100"
                /*
                    timeout: 50,
                    timeout: '10-100',
                 */
              };
              MockXMLHttpRequest.setup = function(settings) {
                Util2.extend(MockXMLHttpRequest._settings, settings);
                return MockXMLHttpRequest._settings;
              };
              Util2.extend(MockXMLHttpRequest, XHR_STATES);
              Util2.extend(MockXMLHttpRequest.prototype, XHR_STATES);
              MockXMLHttpRequest.prototype.mock = true;
              MockXMLHttpRequest.prototype.match = false;
              Util2.extend(MockXMLHttpRequest.prototype, {
                // https://xhr.spec.whatwg.org/#the-open()-method
                // Sets the request method, request URL, and synchronous flag.
                open: function(method, url, async, username, password) {
                  var that = this;
                  Util2.extend(this.custom, {
                    method,
                    url,
                    async: typeof async === "boolean" ? async : true,
                    username,
                    password,
                    options: {
                      url,
                      type: method
                    }
                  });
                  this.custom.timeout = function(timeout) {
                    if (typeof timeout === "number") return timeout;
                    if (typeof timeout === "string" && !~timeout.indexOf("-")) return parseInt(timeout, 10);
                    if (typeof timeout === "string" && ~timeout.indexOf("-")) {
                      var tmp = timeout.split("-");
                      var min3 = parseInt(tmp[0], 10);
                      var max3 = parseInt(tmp[1], 10);
                      return Math.round(Math.random() * (max3 - min3)) + min3;
                    }
                  }(MockXMLHttpRequest._settings.timeout);
                  var item = find2(this.custom.options);
                  function handle2(event) {
                    for (var i3 = 0; i3 < XHR_RESPONSE_PROPERTIES.length; i3++) {
                      try {
                        that[XHR_RESPONSE_PROPERTIES[i3]] = xhr[XHR_RESPONSE_PROPERTIES[i3]];
                      } catch (e2) {
                      }
                    }
                    that.dispatchEvent(new Event(
                      event.type
                      /*, false, false, that*/
                    ));
                  }
                  if (!item) {
                    var xhr = createNativeXMLHttpRequest();
                    this.custom.xhr = xhr;
                    for (var i2 = 0; i2 < XHR_EVENTS.length; i2++) {
                      xhr.addEventListener(XHR_EVENTS[i2], handle2);
                    }
                    if (username) xhr.open(method, url, async, username, password);
                    else xhr.open(method, url, async);
                    for (var j2 = 0; j2 < XHR_REQUEST_PROPERTIES.length; j2++) {
                      try {
                        xhr[XHR_REQUEST_PROPERTIES[j2]] = that[XHR_REQUEST_PROPERTIES[j2]];
                      } catch (e2) {
                      }
                    }
                    return;
                  }
                  this.match = true;
                  this.custom.template = item;
                  this.readyState = MockXMLHttpRequest.OPENED;
                  this.dispatchEvent(new Event(
                    "readystatechange"
                    /*, false, false, this*/
                  ));
                },
                // https://xhr.spec.whatwg.org/#the-setrequestheader()-method
                // Combines a header in author request headers.
                setRequestHeader: function(name, value) {
                  if (!this.match) {
                    this.custom.xhr.setRequestHeader(name, value);
                    return;
                  }
                  var requestHeaders = this.custom.requestHeaders;
                  if (requestHeaders[name]) requestHeaders[name] += "," + value;
                  else requestHeaders[name] = value;
                },
                timeout: 0,
                withCredentials: false,
                upload: {},
                // https://xhr.spec.whatwg.org/#the-send()-method
                // Initiates the request.
                send: function send(data) {
                  var that = this;
                  this.custom.options.body = data;
                  if (!this.match) {
                    this.custom.xhr.send(data);
                    return;
                  }
                  this.setRequestHeader("X-Requested-With", "MockXMLHttpRequest");
                  this.dispatchEvent(new Event(
                    "loadstart"
                    /*, false, false, this*/
                  ));
                  if (this.custom.async) setTimeout(done, this.custom.timeout);
                  else done();
                  function done() {
                    that.readyState = MockXMLHttpRequest.HEADERS_RECEIVED;
                    that.dispatchEvent(new Event(
                      "readystatechange"
                      /*, false, false, that*/
                    ));
                    that.readyState = MockXMLHttpRequest.LOADING;
                    that.dispatchEvent(new Event(
                      "readystatechange"
                      /*, false, false, that*/
                    ));
                    that.status = 200;
                    that.statusText = HTTP_STATUS_CODES[200];
                    that.response = that.responseText = JSON.stringify(
                      convert(that.custom.template, that.custom.options),
                      null,
                      4
                    );
                    that.readyState = MockXMLHttpRequest.DONE;
                    that.dispatchEvent(new Event(
                      "readystatechange"
                      /*, false, false, that*/
                    ));
                    that.dispatchEvent(new Event(
                      "load"
                      /*, false, false, that*/
                    ));
                    that.dispatchEvent(new Event(
                      "loadend"
                      /*, false, false, that*/
                    ));
                  }
                },
                // https://xhr.spec.whatwg.org/#the-abort()-method
                // Cancels any network activity.
                abort: function abort() {
                  if (!this.match) {
                    this.custom.xhr.abort();
                    return;
                  }
                  this.readyState = MockXMLHttpRequest.UNSENT;
                  this.dispatchEvent(new Event("abort", false, false, this));
                  this.dispatchEvent(new Event("error", false, false, this));
                }
              });
              Util2.extend(MockXMLHttpRequest.prototype, {
                responseURL: "",
                status: MockXMLHttpRequest.UNSENT,
                statusText: "",
                // https://xhr.spec.whatwg.org/#the-getresponseheader()-method
                getResponseHeader: function(name) {
                  if (!this.match) {
                    return this.custom.xhr.getResponseHeader(name);
                  }
                  return this.custom.responseHeaders[name.toLowerCase()];
                },
                // https://xhr.spec.whatwg.org/#the-getallresponseheaders()-method
                // http://www.utf8-chartable.de/
                getAllResponseHeaders: function() {
                  if (!this.match) {
                    return this.custom.xhr.getAllResponseHeaders();
                  }
                  var responseHeaders = this.custom.responseHeaders;
                  var headers = "";
                  for (var h2 in responseHeaders) {
                    if (!responseHeaders.hasOwnProperty(h2)) continue;
                    headers += h2 + ": " + responseHeaders[h2] + "\r\n";
                  }
                  return headers;
                },
                overrideMimeType: function() {
                },
                responseType: "",
                // '', 'text', 'arraybuffer', 'blob', 'document', 'json'
                response: null,
                responseText: "",
                responseXML: null
              });
              Util2.extend(MockXMLHttpRequest.prototype, {
                addEventListener: function addEventListener2(type, handle2) {
                  var events2 = this.custom.events;
                  if (!events2[type]) events2[type] = [];
                  events2[type].push(handle2);
                },
                removeEventListener: function removeEventListener2(type, handle2) {
                  var handles = this.custom.events[type] || [];
                  for (var i2 = 0; i2 < handles.length; i2++) {
                    if (handles[i2] === handle2) {
                      handles.splice(i2--, 1);
                    }
                  }
                },
                dispatchEvent: function dispatchEvent(event) {
                  var handles = this.custom.events[event.type] || [];
                  for (var i2 = 0; i2 < handles.length; i2++) {
                    handles[i2].call(this, event);
                  }
                  var ontype = "on" + event.type;
                  if (this[ontype]) this[ontype](event);
                }
              });
              function createNativeXMLHttpRequest() {
                var isLocal = function() {
                  var rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/;
                  var rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/;
                  var ajaxLocation = location.href;
                  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
                  return rlocalProtocol.test(ajaxLocParts[1]);
                }();
                return window.ActiveXObject ? !isLocal && createStandardXHR() || createActiveXHR() : createStandardXHR();
                function createStandardXHR() {
                  try {
                    return new window._XMLHttpRequest();
                  } catch (e2) {
                  }
                }
                function createActiveXHR() {
                  try {
                    return new window._ActiveXObject("Microsoft.XMLHTTP");
                  } catch (e2) {
                  }
                }
              }
              function find2(options2) {
                for (var sUrlType in MockXMLHttpRequest.Mock._mocked) {
                  var item = MockXMLHttpRequest.Mock._mocked[sUrlType];
                  if ((!item.rurl || match2(item.rurl, options2.url)) && (!item.rtype || match2(item.rtype, options2.type.toLowerCase()))) {
                    return item;
                  }
                }
                function match2(expected, actual) {
                  if (Util2.type(expected) === "string") {
                    return expected === actual;
                  }
                  if (Util2.type(expected) === "regexp") {
                    return expected.test(actual);
                  }
                }
              }
              function convert(item, options2) {
                return Util2.isFunction(item.template) ? item.template(options2) : MockXMLHttpRequest.Mock.mock(item.template);
              }
              module2.exports = MockXMLHttpRequest;
            }
            /******/
          ])
        );
      });
    })(mock$1);
    return mock$1.exports;
  }
  var mockExports = requireMock();
  const Mock = /* @__PURE__ */ getDefaultExportFromCjs(mockExports);
  const ruleData = [
    {
      key: 99,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 99",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 346,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 69
    },
    {
      key: 98,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 98",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 107,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 57
    },
    {
      key: 97,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 97",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 46,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 55
    },
    {
      key: 96,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 96",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 245,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 41
    },
    {
      key: 95,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 95",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 381,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 90
    },
    {
      key: 94,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 94",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 466,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 13
    },
    {
      key: 93,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 93",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 558,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 91
    },
    {
      key: 92,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 92",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 970,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 26
    },
    {
      key: 91,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 91",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 945,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 21
    },
    {
      key: 90,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 90",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 186,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 11
    },
    {
      key: 89,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 89",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 95,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 38
    },
    {
      key: 88,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 88",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 843,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 94
    },
    {
      key: 87,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 87",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 134,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 14
    },
    {
      key: 86,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 86",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 768,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 30
    },
    {
      key: 85,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 85",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 937,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 32
    },
    {
      key: 84,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 84",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 478,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 14
    },
    {
      key: 83,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 83",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 32,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 78
    },
    {
      key: 82,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 82",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 500,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 64
    },
    {
      key: 81,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 81",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 244,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 45
    },
    {
      key: 80,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 80",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 570,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 83
    },
    {
      key: 79,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 79",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 426,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 37
    },
    {
      key: 78,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 78",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 896,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 84
    },
    {
      key: 77,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 77",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 646,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 64
    },
    {
      key: 76,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 76",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 518,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 37
    },
    {
      key: 75,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 75",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 291,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 19
    },
    {
      key: 74,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 74",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 588,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 24
    },
    {
      key: 73,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 73",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 340,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 20
    },
    {
      key: 72,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 72",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 55,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 52
    },
    {
      key: 71,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 71",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 301,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 13
    },
    {
      key: 70,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 70",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 593,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 32
    },
    {
      key: 69,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 69",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 375,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 64
    },
    {
      key: 68,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 68",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 198,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 38
    },
    {
      key: 67,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 67",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 226,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 27
    },
    {
      key: 66,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 66",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 169,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 80
    },
    {
      key: 65,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 65",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 382,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 85
    },
    {
      key: 64,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 64",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 740,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 13
    },
    {
      key: 63,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 63",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 1,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 38
    },
    {
      key: 62,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 62",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 834,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 73
    },
    {
      key: 61,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 61",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 323,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 68
    },
    {
      key: 60,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 60",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 398,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 29
    },
    {
      key: 59,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 59",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 745,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 53
    },
    {
      key: 58,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 58",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 548,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 55
    },
    {
      key: 57,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 57",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 806,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 40
    },
    {
      key: 56,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 56",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 174,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 12
    },
    {
      key: 55,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 55",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 907,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 9
    },
    {
      key: 54,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 54",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 517,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 34
    },
    {
      key: 53,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 53",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 365,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 49
    },
    {
      key: 52,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 52",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 790,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 52
    },
    {
      key: 51,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 51",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 631,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 35
    },
    {
      key: 50,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 50",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 674,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 8
    },
    {
      key: 49,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 49",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 844,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 60
    },
    {
      key: 48,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 48",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 677,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 48
    },
    {
      key: 47,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 47",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 110,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 1
    },
    {
      key: 46,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 46",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 129,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 72
    },
    {
      key: 45,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 45",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 905,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 95
    },
    {
      key: 44,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 44",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 62,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 78
    },
    {
      key: 43,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 43",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 202,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 31
    },
    {
      key: 42,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 42",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 595,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 43
    },
    {
      key: 41,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 41",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 218,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 90
    },
    {
      key: 40,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 40",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 469,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 41
    },
    {
      key: 39,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 39",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 239,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 58
    },
    {
      key: 38,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 38",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 137,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 8
    },
    {
      key: 37,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 37",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 913,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 99
    },
    {
      key: 36,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 36",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 401,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 3
    },
    {
      key: 35,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 35",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 730,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 14
    },
    {
      key: 34,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 34",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 552,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 11
    },
    {
      key: 33,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 33",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 931,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 28
    },
    {
      key: 32,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 32",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 538,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 81
    },
    {
      key: 31,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 31",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 861,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 9
    },
    {
      key: 30,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 30",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 381,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 27
    },
    {
      key: 29,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 29",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 915,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 79
    },
    {
      key: 28,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 28",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 178,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 65
    },
    {
      key: 27,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 27",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 804,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 5
    },
    {
      key: 26,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 26",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 226,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 34
    },
    {
      key: 25,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 25",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 584,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 38
    },
    {
      key: 24,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 24",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 199,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 46
    },
    {
      key: 23,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 23",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 285,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 93
    },
    {
      key: 22,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 22",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 325,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 59
    },
    {
      key: 21,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 21",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 496,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 81
    },
    {
      key: 20,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 20",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 780,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 72
    },
    {
      key: 19,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 19",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 668,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 78
    },
    {
      key: 18,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 18",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 655,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 36
    },
    {
      key: 17,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 17",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 964,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 63
    },
    {
      key: 16,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 16",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 486,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 51
    },
    {
      key: 15,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 15",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 48,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 74
    },
    {
      key: 14,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 14",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 340,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 70
    },
    {
      key: 13,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 13",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 548,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 77
    },
    {
      key: 12,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 12",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 712,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 35
    },
    {
      key: 11,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 11",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 14,
      status: "3",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 21
    },
    {
      key: 10,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 10",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 195,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 84
    },
    {
      key: 9,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 9",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 17,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 79
    },
    {
      key: 8,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 8",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 348,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 31
    },
    {
      key: 7,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 7",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 557,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 52
    },
    {
      key: 6,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 6",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 942,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 29
    },
    {
      key: 5,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 5",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 484,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 88
    },
    {
      key: 4,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 4",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 513,
      status: "0",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 45
    },
    {
      key: 3,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 3",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 978,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 11
    },
    {
      key: 2,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 2",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 604,
      status: "2",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 38
    },
    {
      key: 1,
      disabled: false,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png",
      name: "TradeCode 1",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 257,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 41
    },
    {
      key: 0,
      disabled: true,
      href: "https://ant.design",
      avatar: "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      name: "TradeCode 0",
      owner: "曲丽丽",
      desc: "这是一段描述",
      callNo: 616,
      status: "1",
      updatedAt: "2025-07-07T07:29:00.676Z",
      createdAt: "2025-07-07T07:29:00.676Z",
      progress: 90
    }
  ];
  const getQuery = (urlStr) => {
    const startIndex = urlStr.indexOf("?");
    const strSub = urlStr.substring(startIndex + 1);
    const strReplace = strSub.replaceAll("=", ":");
    const arr = strReplace.split("&");
    arr.forEach((it, i2) => {
      const startIndex2 = it.indexOf(":");
      let k2 = it.substring(0, startIndex2), v2 = it.substring(startIndex2 + 1), isNullStr = Object.is(v2, "");
      k2 = `"${k2}"`;
      !isNullStr ? v2 = Number(v2) : v2 = `"${v2}"`;
      arr[i2] = k2 + ":" + v2;
    });
    const arrToStr = arr.join(",");
    const resStr = `{${arrToStr} }`;
    const resObj = JSON.parse(resStr);
    return resObj;
  };
  const getRule = (params2) => {
    const query = getQuery(params2.url);
    let filterData = ruleData;
    if (query.status !== "" && query.status != null) {
      filterData = filterData.filter((val) => val.status === String(query.status));
    }
    const data = filterData.slice(
      (query.current - 1) * query.pageSize,
      query.current * query.pageSize
    );
    return {
      data,
      total: filterData.length,
      success: true,
      pageSize: query.pageSize,
      current: query.current
    };
  };
  Mock.mock(/admin\/v1\/rule/, "get", getRule);
  async function initI18n(I18n2) {
    const lang = "zh";
    {
      await loadLocaleMessages(I18n2, lang);
    }
    setI18nLanguage(I18n2, lang);
  }
  function formatDateTime(dt, type) {
    const formatType = {
      date: "YYYY-MM-DD",
      time: "hh:mm:ss",
      dateTime: "YYYY-MM-DD hh:mm:ss"
    };
    return dayjs(dt).format(formatType[type]);
  }
  const I18n = setupI18n();
  initI18n(I18n);
  let app = null;
  function render$1(props2 = {}) {
    const { container } = props2;
    app = createApp(_sfc_main$4);
    app.use(router);
    app.use(createPinia());
    app.use(I18n);
    installAntd(app);
    app.mount(container ? container.querySelector("#app") : "#app");
  }
  if (!helperExports.qiankunWindow.__POWERED_BY_QIANKUN__) {
    render$1();
  }
  helperExports.renderWithQiankun({
    bootstrap() {
      console.log("[微应用] bootstrap");
      return Promise.resolve();
    },
    mount(props2) {
      console.log("[微应用] mount");
      render$1(props2);
      return Promise.resolve();
    },
    unmount() {
      console.log("[微应用] unmount");
      app.unmount();
      app = null;
      return Promise.resolve();
    }
  });
  const chinese$1 = "中文";
  const english$1 = "English";
  const btn$1 = { "reset": "Reset", "search": "Search" };
  const en = {
    chinese: chinese$1,
    english: english$1,
    btn: btn$1
  };
  const en$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    btn: btn$1,
    chinese: chinese$1,
    default: en,
    english: english$1
  }, Symbol.toStringTag, { value: "Module" }));
  const chinese = "中文";
  const english = "English";
  const btn = { "reset": "重置", "search": "查询" };
  const zh = {
    chinese,
    english,
    btn
  };
  const zh$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    btn,
    chinese,
    default: zh,
    english
  }, Symbol.toStringTag, { value: "Module" }));
  /*! *****************************************************************************
  	Copyright (c) Microsoft Corporation.
  
  	Permission to use, copy, modify, and/or distribute this software for any
  	purpose with or without fee is hereby granted.
  
  	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  	PERFORMANCE OF THIS SOFTWARE.
  	***************************************************************************** */
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var Browser = /* @__PURE__ */ function() {
    function Browser2() {
      this.firefox = false;
      this.ie = false;
      this.edge = false;
      this.newEdge = false;
      this.weChat = false;
    }
    return Browser2;
  }();
  var Env = /* @__PURE__ */ function() {
    function Env2() {
      this.browser = new Browser();
      this.node = false;
      this.wxa = false;
      this.worker = false;
      this.svgSupported = false;
      this.touchEventsSupported = false;
      this.pointerEventsSupported = false;
      this.domSupported = false;
      this.transformSupported = false;
      this.transform3dSupported = false;
      this.hasGlobalWindow = typeof window !== "undefined";
    }
    return Env2;
  }();
  var env = new Env();
  if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
    env.wxa = true;
    env.touchEventsSupported = true;
  } else if (typeof document === "undefined" && typeof self !== "undefined") {
    env.worker = true;
  } else if (!env.hasGlobalWindow || "Deno" in window) {
    env.node = true;
    env.svgSupported = true;
  } else {
    detect(navigator.userAgent, env);
  }
  function detect(ua, env2) {
    var browser = env2.browser;
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge?\/([\d.]+)/);
    var weChat = /micromessenger/i.test(ua);
    if (firefox) {
      browser.firefox = true;
      browser.version = firefox[1];
    }
    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }
    if (edge) {
      browser.edge = true;
      browser.version = edge[1];
      browser.newEdge = +edge[1].split(".")[0] > 18;
    }
    if (weChat) {
      browser.weChat = true;
    }
    env2.svgSupported = typeof SVGRect !== "undefined";
    env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
    env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
    env2.domSupported = typeof document !== "undefined";
    var style = document.documentElement.style;
    env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
    env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
  }
  var DEFAULT_FONT_SIZE = 12;
  var DEFAULT_FONT_FAMILY = "sans-serif";
  var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
  var OFFSET = 20;
  var SCALE = 100;
  var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function getTextWidthMap(mapStr) {
    var map2 = {};
    if (typeof JSON === "undefined") {
      return map2;
    }
    for (var i2 = 0; i2 < mapStr.length; i2++) {
      var char2 = String.fromCharCode(i2 + 32);
      var size = (mapStr.charCodeAt(i2) - OFFSET) / SCALE;
      map2[char2] = size;
    }
    return map2;
  }
  var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
  var platformApi = {
    createCanvas: function() {
      return typeof document !== "undefined" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var _ctx;
      var _cachedFont;
      return function(text, font) {
        if (!_ctx) {
          var canvas = platformApi.createCanvas();
          _ctx = canvas && canvas.getContext("2d");
        }
        if (_ctx) {
          if (_cachedFont !== font) {
            _cachedFont = _ctx.font = font || DEFAULT_FONT;
          }
          return _ctx.measureText(text);
        } else {
          text = text || "";
          font = font || DEFAULT_FONT;
          var res = /((?:\d+)?\.?\d*)px/.exec(font);
          var fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
          var width = 0;
          if (font.indexOf("mono") >= 0) {
            width = fontSize * text.length;
          } else {
            for (var i2 = 0; i2 < text.length; i2++) {
              var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i2]];
              width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
            }
          }
          return { width };
        }
      };
    }(),
    loadImage: function(src, onload, onerror) {
      var image = new Image();
      image.onload = onload;
      image.onerror = onerror;
      image.src = src;
      return image;
    }
  };
  function setPlatformAPI(newPlatformApis) {
    for (var key2 in platformApi) {
      if (newPlatformApis[key2]) {
        platformApi[key2] = newPlatformApis[key2];
      }
    }
  }
  var BUILTIN_OBJECT = reduce([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(obj2, val) {
    obj2["[object " + val + "]"] = true;
    return obj2;
  }, {});
  var TYPED_ARRAY = reduce([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(obj2, val) {
    obj2["[object " + val + "Array]"] = true;
    return obj2;
  }, {});
  var objToString = Object.prototype.toString;
  var arrayProto = Array.prototype;
  var nativeForEach = arrayProto.forEach;
  var nativeFilter = arrayProto.filter;
  var nativeSlice = arrayProto.slice;
  var nativeMap = arrayProto.map;
  var ctorFunction = (function() {
  }).constructor;
  var protoFunction = ctorFunction ? ctorFunction.prototype : null;
  var protoKey = "__proto__";
  var idStart = 2311;
  function guid() {
    return idStart++;
  }
  function logError() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (typeof console !== "undefined") {
      console.error.apply(console, args);
    }
  }
  function clone$4(source) {
    if (source == null || typeof source !== "object") {
      return source;
    }
    var result = source;
    var typeStr = objToString.call(source);
    if (typeStr === "[object Array]") {
      if (!isPrimitive(source)) {
        result = [];
        for (var i2 = 0, len2 = source.length; i2 < len2; i2++) {
          result[i2] = clone$4(source[i2]);
        }
      }
    } else if (TYPED_ARRAY[typeStr]) {
      if (!isPrimitive(source)) {
        var Ctor = source.constructor;
        if (Ctor.from) {
          result = Ctor.from(source);
        } else {
          result = new Ctor(source.length);
          for (var i2 = 0, len2 = source.length; i2 < len2; i2++) {
            result[i2] = source[i2];
          }
        }
      }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
      result = {};
      for (var key2 in source) {
        if (source.hasOwnProperty(key2) && key2 !== protoKey) {
          result[key2] = clone$4(source[key2]);
        }
      }
    }
    return result;
  }
  function merge$1(target, source, overwrite) {
    if (!isObject$3(source) || !isObject$3(target)) {
      return overwrite ? clone$4(source) : target;
    }
    for (var key2 in source) {
      if (source.hasOwnProperty(key2) && key2 !== protoKey) {
        var targetProp = target[key2];
        var sourceProp = source[key2];
        if (isObject$3(sourceProp) && isObject$3(targetProp) && !isArray$1(sourceProp) && !isArray$1(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
          merge$1(targetProp, sourceProp, overwrite);
        } else if (overwrite || !(key2 in target)) {
          target[key2] = clone$4(source[key2]);
        }
      }
    }
    return target;
  }
  function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i2 = 1, len2 = targetAndSources.length; i2 < len2; i2++) {
      result = merge$1(result, targetAndSources[i2], overwrite);
    }
    return result;
  }
  function extend$1(target, source) {
    if (Object.assign) {
      Object.assign(target, source);
    } else {
      for (var key2 in source) {
        if (source.hasOwnProperty(key2) && key2 !== protoKey) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  }
  function defaults$1(target, source, overlay) {
    var keysArr = keys(source);
    for (var i2 = 0, len2 = keysArr.length; i2 < len2; i2++) {
      var key2 = keysArr[i2];
      if (overlay ? source[key2] != null : target[key2] == null) {
        target[key2] = source[key2];
      }
    }
    return target;
  }
  var createCanvas = platformApi.createCanvas;
  function indexOf(array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value);
      }
      for (var i2 = 0, len2 = array.length; i2 < len2; i2++) {
        if (array[i2] === value) {
          return i2;
        }
      }
    }
    return -1;
  }
  function inherits$1(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F2() {
    }
    F2.prototype = baseClazz.prototype;
    clazz.prototype = new F2();
    for (var prop in clazzPrototype) {
      if (clazzPrototype.hasOwnProperty(prop)) {
        clazz.prototype[prop] = clazzPrototype[prop];
      }
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
  }
  function mixin(target, source, override) {
    target = "prototype" in target ? target.prototype : target;
    source = "prototype" in source ? source.prototype : source;
    if (Object.getOwnPropertyNames) {
      var keyList = Object.getOwnPropertyNames(source);
      for (var i2 = 0; i2 < keyList.length; i2++) {
        var key2 = keyList[i2];
        if (key2 !== "constructor") {
          if (override ? source[key2] != null : target[key2] == null) {
            target[key2] = source[key2];
          }
        }
      }
    } else {
      defaults$1(target, source, override);
    }
  }
  function isArrayLike(data) {
    if (!data) {
      return false;
    }
    if (typeof data === "string") {
      return false;
    }
    return typeof data.length === "number";
  }
  function each$4(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    if (arr.forEach && arr.forEach === nativeForEach) {
      arr.forEach(cb, context);
    } else if (arr.length === +arr.length) {
      for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
        cb.call(context, arr[i2], i2, arr);
      }
    } else {
      for (var key2 in arr) {
        if (arr.hasOwnProperty(key2)) {
          cb.call(context, arr[key2], key2, arr);
        }
      }
    }
  }
  function map$1(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.map && arr.map === nativeMap) {
      return arr.map(cb, context);
    } else {
      var result = [];
      for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
        result.push(cb.call(context, arr[i2], i2, arr));
      }
      return result;
    }
  }
  function reduce(arr, cb, memo, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      memo = cb.call(context, memo, arr[i2], i2, arr);
    }
    return memo;
  }
  function filter(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.filter && arr.filter === nativeFilter) {
      return arr.filter(cb, context);
    } else {
      var result = [];
      for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
        if (cb.call(context, arr[i2], i2, arr)) {
          result.push(arr[i2]);
        }
      }
      return result;
    }
  }
  function find(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      if (cb.call(context, arr[i2], i2, arr)) {
        return arr[i2];
      }
    }
  }
  function keys(obj2) {
    if (!obj2) {
      return [];
    }
    if (Object.keys) {
      return Object.keys(obj2);
    }
    var keyList = [];
    for (var key2 in obj2) {
      if (obj2.hasOwnProperty(key2)) {
        keyList.push(key2);
      }
    }
    return keyList;
  }
  function bindPolyfill(func, context) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return function() {
      return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
  }
  var bind$2 = protoFunction && isFunction$1(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
  function curry$1(func) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return function() {
      return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
  }
  function isArray$1(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    return objToString.call(value) === "[object Array]";
  }
  function isFunction$1(value) {
    return typeof value === "function";
  }
  function isString$1(value) {
    return typeof value === "string";
  }
  function isStringSafe(value) {
    return objToString.call(value) === "[object String]";
  }
  function isNumber$1(value) {
    return typeof value === "number";
  }
  function isObject$3(value) {
    var type = typeof value;
    return type === "function" || !!value && type === "object";
  }
  function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
  }
  function isTypedArray$1(value) {
    return !!TYPED_ARRAY[objToString.call(value)];
  }
  function isDom(value) {
    return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
  }
  function isGradientObject(value) {
    return value.colorStops != null;
  }
  function isImagePatternObject(value) {
    return value.image != null;
  }
  function isRegExp$1(value) {
    return objToString.call(value) === "[object RegExp]";
  }
  function eqNaN(value) {
    return value !== value;
  }
  function retrieve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    for (var i2 = 0, len2 = args.length; i2 < len2; i2++) {
      if (args[i2] != null) {
        return args[i2];
      }
    }
  }
  function retrieve2(value0, value1) {
    return value0 != null ? value0 : value1;
  }
  function retrieve3(value0, value1, value2) {
    return value0 != null ? value0 : value1 != null ? value1 : value2;
  }
  function slice(arr) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return nativeSlice.apply(arr, args);
  }
  function normalizeCssArray$1(val) {
    if (typeof val === "number") {
      return [val, val, val, val];
    }
    var len2 = val.length;
    if (len2 === 2) {
      return [val[0], val[1], val[0], val[1]];
    } else if (len2 === 3) {
      return [val[0], val[1], val[2], val[1]];
    }
    return val;
  }
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function trim$1(str) {
    if (str == null) {
      return null;
    } else if (typeof str.trim === "function") {
      return str.trim();
    } else {
      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
  }
  var primitiveKey = "__ec_primitive__";
  function setAsPrimitive(obj2) {
    obj2[primitiveKey] = true;
  }
  function isPrimitive(obj2) {
    return obj2[primitiveKey];
  }
  var MapPolyfill = function() {
    function MapPolyfill2() {
      this.data = {};
    }
    MapPolyfill2.prototype["delete"] = function(key2) {
      var existed = this.has(key2);
      if (existed) {
        delete this.data[key2];
      }
      return existed;
    };
    MapPolyfill2.prototype.has = function(key2) {
      return this.data.hasOwnProperty(key2);
    };
    MapPolyfill2.prototype.get = function(key2) {
      return this.data[key2];
    };
    MapPolyfill2.prototype.set = function(key2, value) {
      this.data[key2] = value;
      return this;
    };
    MapPolyfill2.prototype.keys = function() {
      return keys(this.data);
    };
    MapPolyfill2.prototype.forEach = function(callback) {
      var data = this.data;
      for (var key2 in data) {
        if (data.hasOwnProperty(key2)) {
          callback(data[key2], key2);
        }
      }
    };
    return MapPolyfill2;
  }();
  var isNativeMapSupported = typeof Map === "function";
  function maybeNativeMap() {
    return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
  }
  var HashMap = function() {
    function HashMap2(obj2) {
      var isArr = isArray$1(obj2);
      this.data = maybeNativeMap();
      var thisMap = this;
      obj2 instanceof HashMap2 ? obj2.each(visit) : obj2 && each$4(obj2, visit);
      function visit(value, key2) {
        isArr ? thisMap.set(value, key2) : thisMap.set(key2, value);
      }
    }
    HashMap2.prototype.hasKey = function(key2) {
      return this.data.has(key2);
    };
    HashMap2.prototype.get = function(key2) {
      return this.data.get(key2);
    };
    HashMap2.prototype.set = function(key2, value) {
      this.data.set(key2, value);
      return value;
    };
    HashMap2.prototype.each = function(cb, context) {
      this.data.forEach(function(value, key2) {
        cb.call(context, value, key2);
      });
    };
    HashMap2.prototype.keys = function() {
      var keys2 = this.data.keys();
      return isNativeMapSupported ? Array.from(keys2) : keys2;
    };
    HashMap2.prototype.removeKey = function(key2) {
      this.data["delete"](key2);
    };
    return HashMap2;
  }();
  function createHashMap(obj2) {
    return new HashMap(obj2);
  }
  function concatArray(a2, b2) {
    var newArray = new a2.constructor(a2.length + b2.length);
    for (var i2 = 0; i2 < a2.length; i2++) {
      newArray[i2] = a2[i2];
    }
    var offset2 = a2.length;
    for (var i2 = 0; i2 < b2.length; i2++) {
      newArray[i2 + offset2] = b2[i2];
    }
    return newArray;
  }
  function createObject(proto2, properties) {
    var obj2;
    if (Object.create) {
      obj2 = Object.create(proto2);
    } else {
      var StyleCtor = function() {
      };
      StyleCtor.prototype = proto2;
      obj2 = new StyleCtor();
    }
    if (properties) {
      extend$1(obj2, properties);
    }
    return obj2;
  }
  function disableUserSelect(dom) {
    var domStyle = dom.style;
    domStyle.webkitUserSelect = "none";
    domStyle.userSelect = "none";
    domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
    domStyle["-webkit-touch-callout"] = "none";
  }
  function hasOwn(own, prop) {
    return own.hasOwnProperty(prop);
  }
  function noop$1() {
  }
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  const util$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    HashMap,
    RADIAN_TO_DEGREE,
    assert,
    bind: bind$2,
    clone: clone$4,
    concatArray,
    createCanvas,
    createHashMap,
    createObject,
    curry: curry$1,
    defaults: defaults$1,
    disableUserSelect,
    each: each$4,
    eqNaN,
    extend: extend$1,
    filter,
    find,
    guid,
    hasOwn,
    indexOf,
    inherits: inherits$1,
    isArray: isArray$1,
    isArrayLike,
    isBuiltInObject,
    isDom,
    isFunction: isFunction$1,
    isGradientObject,
    isImagePatternObject,
    isNumber: isNumber$1,
    isObject: isObject$3,
    isPrimitive,
    isRegExp: isRegExp$1,
    isString: isString$1,
    isStringSafe,
    isTypedArray: isTypedArray$1,
    keys,
    logError,
    map: map$1,
    merge: merge$1,
    mergeAll,
    mixin,
    noop: noop$1,
    normalizeCssArray: normalizeCssArray$1,
    reduce,
    retrieve,
    retrieve2,
    retrieve3,
    setAsPrimitive,
    slice,
    trim: trim$1
  }, Symbol.toStringTag, { value: "Module" }));
  function create$1(x2, y2) {
    if (x2 == null) {
      x2 = 0;
    }
    if (y2 == null) {
      y2 = 0;
    }
    return [x2, y2];
  }
  function copy$1(out2, v2) {
    out2[0] = v2[0];
    out2[1] = v2[1];
    return out2;
  }
  function clone$3(v2) {
    return [v2[0], v2[1]];
  }
  function set$1(out2, a2, b2) {
    out2[0] = a2;
    out2[1] = b2;
    return out2;
  }
  function add(out2, v1, v2) {
    out2[0] = v1[0] + v2[0];
    out2[1] = v1[1] + v2[1];
    return out2;
  }
  function scaleAndAdd(out2, v1, v2, a2) {
    out2[0] = v1[0] + v2[0] * a2;
    out2[1] = v1[1] + v2[1] * a2;
    return out2;
  }
  function sub(out2, v1, v2) {
    out2[0] = v1[0] - v2[0];
    out2[1] = v1[1] - v2[1];
    return out2;
  }
  function len(v2) {
    return Math.sqrt(lenSquare(v2));
  }
  var length = len;
  function lenSquare(v2) {
    return v2[0] * v2[0] + v2[1] * v2[1];
  }
  var lengthSquare = lenSquare;
  function mul$1(out2, v1, v2) {
    out2[0] = v1[0] * v2[0];
    out2[1] = v1[1] * v2[1];
    return out2;
  }
  function div(out2, v1, v2) {
    out2[0] = v1[0] / v2[0];
    out2[1] = v1[1] / v2[1];
    return out2;
  }
  function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
  }
  function scale$2(out2, v2, s2) {
    out2[0] = v2[0] * s2;
    out2[1] = v2[1] * s2;
    return out2;
  }
  function normalize$1(out2, v2) {
    var d2 = len(v2);
    if (d2 === 0) {
      out2[0] = 0;
      out2[1] = 0;
    } else {
      out2[0] = v2[0] / d2;
      out2[1] = v2[1] / d2;
    }
    return out2;
  }
  function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
  }
  var dist$1 = distance;
  function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }
  var distSquare = distanceSquare;
  function negate(out2, v2) {
    out2[0] = -v2[0];
    out2[1] = -v2[1];
    return out2;
  }
  function lerp$1(out2, v1, v2, t2) {
    out2[0] = v1[0] + t2 * (v2[0] - v1[0]);
    out2[1] = v1[1] + t2 * (v2[1] - v1[1]);
    return out2;
  }
  function applyTransform$1(out2, v2, m2) {
    var x2 = v2[0];
    var y2 = v2[1];
    out2[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
    out2[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
    return out2;
  }
  function min$1(out2, v1, v2) {
    out2[0] = Math.min(v1[0], v2[0]);
    out2[1] = Math.min(v1[1], v2[1]);
    return out2;
  }
  function max$1(out2, v1, v2) {
    out2[0] = Math.max(v1[0], v2[0]);
    out2[1] = Math.max(v1[1], v2[1]);
    return out2;
  }
  const vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    add,
    applyTransform: applyTransform$1,
    clone: clone$3,
    copy: copy$1,
    create: create$1,
    dist: dist$1,
    distSquare,
    distance,
    distanceSquare,
    div,
    dot,
    len,
    lenSquare,
    length,
    lengthSquare,
    lerp: lerp$1,
    max: max$1,
    min: min$1,
    mul: mul$1,
    negate,
    normalize: normalize$1,
    scale: scale$2,
    scaleAndAdd,
    set: set$1,
    sub
  }, Symbol.toStringTag, { value: "Module" }));
  var Param = /* @__PURE__ */ function() {
    function Param2(target, e2) {
      this.target = target;
      this.topTarget = e2 && e2.topTarget;
    }
    return Param2;
  }();
  var Draggable = function() {
    function Draggable2(handler) {
      this.handler = handler;
      handler.on("mousedown", this._dragStart, this);
      handler.on("mousemove", this._drag, this);
      handler.on("mouseup", this._dragEnd, this);
    }
    Draggable2.prototype._dragStart = function(e2) {
      var draggingTarget = e2.target;
      while (draggingTarget && !draggingTarget.draggable) {
        draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
      }
      if (draggingTarget) {
        this._draggingTarget = draggingTarget;
        draggingTarget.dragging = true;
        this._x = e2.offsetX;
        this._y = e2.offsetY;
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
      }
    };
    Draggable2.prototype._drag = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        var x2 = e2.offsetX;
        var y2 = e2.offsetY;
        var dx = x2 - this._x;
        var dy = y2 - this._y;
        this._x = x2;
        this._y = y2;
        draggingTarget.drift(dx, dy, e2);
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
        var dropTarget = this.handler.findHover(x2, y2, draggingTarget).target;
        var lastDropTarget = this._dropTarget;
        this._dropTarget = dropTarget;
        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
          }
          if (dropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
          }
        }
      }
    };
    Draggable2.prototype._dragEnd = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        draggingTarget.dragging = false;
      }
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
      if (this._dropTarget) {
        this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
      }
      this._draggingTarget = null;
      this._dropTarget = null;
    };
    return Draggable2;
  }();
  var Eventful = function() {
    function Eventful2(eventProcessors) {
      if (eventProcessors) {
        this._$eventProcessor = eventProcessors;
      }
    }
    Eventful2.prototype.on = function(event, query, handler, context) {
      if (!this._$handlers) {
        this._$handlers = {};
      }
      var _h = this._$handlers;
      if (typeof query === "function") {
        context = handler;
        handler = query;
        query = null;
      }
      if (!handler || !event) {
        return this;
      }
      var eventProcessor = this._$eventProcessor;
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i2 = 0; i2 < _h[event].length; i2++) {
        if (_h[event][i2].h === handler) {
          return this;
        }
      }
      var wrap = {
        h: handler,
        query,
        ctx: context || this,
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return this;
    };
    Eventful2.prototype.isSilent = function(eventName) {
      var _h = this._$handlers;
      return !_h || !_h[eventName] || !_h[eventName].length;
    };
    Eventful2.prototype.off = function(eventType2, handler) {
      var _h = this._$handlers;
      if (!_h) {
        return this;
      }
      if (!eventType2) {
        this._$handlers = {};
        return this;
      }
      if (handler) {
        if (_h[eventType2]) {
          var newList = [];
          for (var i2 = 0, l2 = _h[eventType2].length; i2 < l2; i2++) {
            if (_h[eventType2][i2].h !== handler) {
              newList.push(_h[eventType2][i2]);
            }
          }
          _h[eventType2] = newList;
        }
        if (_h[eventType2] && _h[eventType2].length === 0) {
          delete _h[eventType2];
        }
      } else {
        delete _h[eventType2];
      }
      return this;
    };
    Eventful2.prototype.trigger = function(eventType2) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[eventType2];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var len2 = _h.length;
        for (var i2 = 0; i2 < len2; i2++) {
          var hItem = _h[i2];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType2, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(hItem.ctx);
              break;
            case 1:
              hItem.h.call(hItem.ctx, args[0]);
              break;
            case 2:
              hItem.h.call(hItem.ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(hItem.ctx, args);
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType2);
      return this;
    };
    Eventful2.prototype.triggerWithContext = function(type) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[type];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var ctx = args[argLen - 1];
        var len2 = _h.length;
        for (var i2 = 0; i2 < len2; i2++) {
          var hItem = _h[i2];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(ctx);
              break;
            case 1:
              hItem.h.call(ctx, args[0]);
              break;
            case 2:
              hItem.h.call(ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(ctx, args.slice(1, argLen - 1));
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
      return this;
    };
    return Eventful2;
  }();
  var LN2 = Math.log(2);
  function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
    var cacheKey = rowMask + "-" + colMask;
    var fullRank = rows.length;
    if (detCache.hasOwnProperty(cacheKey)) {
      return detCache[cacheKey];
    }
    if (rank === 1) {
      var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
      return rows[rowStart][colStart];
    }
    var subRowMask = rowMask | 1 << rowStart;
    var subRowStart = rowStart + 1;
    while (rowMask & 1 << subRowStart) {
      subRowStart++;
    }
    var sum = 0;
    for (var j2 = 0, colLocalIdx = 0; j2 < fullRank; j2++) {
      var colTag = 1 << j2;
      if (!(colTag & colMask)) {
        sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j2] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
        colLocalIdx++;
      }
    }
    detCache[cacheKey] = sum;
    return sum;
  }
  function buildTransformer(src, dest) {
    var mA = [
      [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
      [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
      [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
      [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
      [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
      [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
      [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
      [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
    ];
    var detCache = {};
    var det = determinant(mA, 8, 0, 0, 0, detCache);
    if (det === 0) {
      return;
    }
    var vh = [];
    for (var i2 = 0; i2 < 8; i2++) {
      for (var j2 = 0; j2 < 8; j2++) {
        vh[j2] == null && (vh[j2] = 0);
        vh[j2] += ((i2 + j2) % 2 ? -1 : 1) * determinant(mA, 7, i2 === 0 ? 1 : 0, 1 << i2, 1 << j2, detCache) / det * dest[i2];
      }
    }
    return function(out2, srcPointX, srcPointY) {
      var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
      out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
      out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
    };
  }
  var EVENT_SAVED_PROP = "___zrEVENTSAVED";
  var _calcOut$1 = [];
  function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
  }
  function transformCoordWithViewport(out2, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
      var markers = prepareCoordMarkers(el, saved);
      var transformer = preparePointerTransformer(markers, saved, inverse);
      if (transformer) {
        transformer(out2, inX, inY);
        return true;
      }
    }
    return false;
  }
  function prepareCoordMarkers(el, saved) {
    var markers = saved.markers;
    if (markers) {
      return markers;
    }
    markers = saved.markers = [];
    var propLR = ["left", "right"];
    var propTB = ["top", "bottom"];
    for (var i2 = 0; i2 < 4; i2++) {
      var marker = document.createElement("div");
      var stl = marker.style;
      var idxLR = i2 % 2;
      var idxTB = (i2 >> 1) % 2;
      stl.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        propLR[idxLR] + ":0",
        propTB[idxTB] + ":0",
        propLR[1 - idxLR] + ":auto",
        propTB[1 - idxTB] + ":auto",
        ""
      ].join("!important;");
      el.appendChild(marker);
      markers.push(marker);
    }
    return markers;
  }
  function preparePointerTransformer(markers, saved, inverse) {
    var transformerName = inverse ? "invTrans" : "trans";
    var transformer = saved[transformerName];
    var oldSrcCoords = saved.srcCoords;
    var srcCoords = [];
    var destCoords = [];
    var oldCoordTheSame = true;
    for (var i2 = 0; i2 < 4; i2++) {
      var rect = markers[i2].getBoundingClientRect();
      var ii = 2 * i2;
      var x2 = rect.left;
      var y2 = rect.top;
      srcCoords.push(x2, y2);
      oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x2 === oldSrcCoords[ii] && y2 === oldSrcCoords[ii + 1];
      destCoords.push(markers[i2].offsetLeft, markers[i2].offsetTop);
    }
    return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
  }
  function isCanvasEl(el) {
    return el.nodeName.toUpperCase() === "CANVAS";
  }
  var replaceReg = /([&<>"'])/g;
  var replaceMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function encodeHTML(source) {
    return source == null ? "" : (source + "").replace(replaceReg, function(str, c2) {
      return replaceMap[c2];
    });
  }
  var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  var _calcOut = [];
  var firefoxNotSupportOffsetXY = env.browser.firefox && +env.browser.version.split(".")[0] < 39;
  function clientToLocal(el, e2, out2, calculate) {
    out2 = out2 || {};
    if (calculate) {
      calculateZrXY(el, e2, out2);
    } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
      out2.zrX = e2.layerX;
      out2.zrY = e2.layerY;
    } else if (e2.offsetX != null) {
      out2.zrX = e2.offsetX;
      out2.zrY = e2.offsetY;
    } else {
      calculateZrXY(el, e2, out2);
    }
    return out2;
  }
  function calculateZrXY(el, e2, out2) {
    if (env.domSupported && el.getBoundingClientRect) {
      var ex = e2.clientX;
      var ey = e2.clientY;
      if (isCanvasEl(el)) {
        var box2 = el.getBoundingClientRect();
        out2.zrX = ex - box2.left;
        out2.zrY = ey - box2.top;
        return;
      } else {
        if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
          out2.zrX = _calcOut[0];
          out2.zrY = _calcOut[1];
          return;
        }
      }
    }
    out2.zrX = out2.zrY = 0;
  }
  function getNativeEvent(e2) {
    return e2 || window.event;
  }
  function normalizeEvent(el, e2, calculate) {
    e2 = getNativeEvent(e2);
    if (e2.zrX != null) {
      return e2;
    }
    var eventType2 = e2.type;
    var isTouch = eventType2 && eventType2.indexOf("touch") >= 0;
    if (!isTouch) {
      clientToLocal(el, e2, e2, calculate);
      var wheelDelta = getWheelDeltaMayPolyfill(e2);
      e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
    } else {
      var touch = eventType2 !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
      touch && clientToLocal(el, touch, e2, calculate);
    }
    var button = e2.button;
    if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
      e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    }
    return e2;
  }
  function getWheelDeltaMayPolyfill(e2) {
    var rawWheelDelta = e2.wheelDelta;
    if (rawWheelDelta) {
      return rawWheelDelta;
    }
    var deltaX = e2.deltaX;
    var deltaY = e2.deltaY;
    if (deltaX == null || deltaY == null) {
      return rawWheelDelta;
    }
    var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
    var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
    return 3 * delta * sign;
  }
  function addEventListener(el, name, handler, opt) {
    el.addEventListener(name, handler, opt);
  }
  function removeEventListener(el, name, handler, opt) {
    el.removeEventListener(name, handler, opt);
  }
  var stop = function(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    e2.cancelBubble = true;
  };
  var GestureMgr = function() {
    function GestureMgr2() {
      this._track = [];
    }
    GestureMgr2.prototype.recognize = function(event, target, root2) {
      this._doTrack(event, target, root2);
      return this._recognize(event);
    };
    GestureMgr2.prototype.clear = function() {
      this._track.length = 0;
      return this;
    };
    GestureMgr2.prototype._doTrack = function(event, target, root2) {
      var touches = event.touches;
      if (!touches) {
        return;
      }
      var trackItem = {
        points: [],
        touches: [],
        target,
        event
      };
      for (var i2 = 0, len2 = touches.length; i2 < len2; i2++) {
        var touch = touches[i2];
        var pos = clientToLocal(root2, touch, {});
        trackItem.points.push([pos.zrX, pos.zrY]);
        trackItem.touches.push(touch);
      }
      this._track.push(trackItem);
    };
    GestureMgr2.prototype._recognize = function(event) {
      for (var eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          var gestureInfo = recognizers[eventName](this._track, event);
          if (gestureInfo) {
            return gestureInfo;
          }
        }
      }
    };
    return GestureMgr2;
  }();
  function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  function center(pointPair) {
    return [
      (pointPair[0][0] + pointPair[1][0]) / 2,
      (pointPair[0][1] + pointPair[1][1]) / 2
    ];
  }
  var recognizers = {
    pinch: function(tracks, event) {
      var trackLen = tracks.length;
      if (!trackLen) {
        return;
      }
      var pinchEnd = (tracks[trackLen - 1] || {}).points;
      var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
      if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
        var pinchScale = dist(pinchEnd) / dist(pinchPre);
        !isFinite(pinchScale) && (pinchScale = 1);
        event.pinchScale = pinchScale;
        var pinchCenter = center(pinchEnd);
        event.pinchX = pinchCenter[0];
        event.pinchY = pinchCenter[1];
        return {
          type: "pinch",
          target: tracks[0].target,
          event
        };
      }
    }
  };
  function create() {
    return [1, 0, 0, 1, 0, 0];
  }
  function identity(out2) {
    out2[0] = 1;
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 1;
    out2[4] = 0;
    out2[5] = 0;
    return out2;
  }
  function copy(out2, m2) {
    out2[0] = m2[0];
    out2[1] = m2[1];
    out2[2] = m2[2];
    out2[3] = m2[3];
    out2[4] = m2[4];
    out2[5] = m2[5];
    return out2;
  }
  function mul(out2, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out22 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out2[0] = out0;
    out2[1] = out1;
    out2[2] = out22;
    out2[3] = out3;
    out2[4] = out4;
    out2[5] = out5;
    return out2;
  }
  function translate(out2, a2, v2) {
    out2[0] = a2[0];
    out2[1] = a2[1];
    out2[2] = a2[2];
    out2[3] = a2[3];
    out2[4] = a2[4] + v2[0];
    out2[5] = a2[5] + v2[1];
    return out2;
  }
  function rotate(out2, a2, rad, pivot) {
    if (pivot === void 0) {
      pivot = [0, 0];
    }
    var aa = a2[0];
    var ac = a2[2];
    var atx = a2[4];
    var ab = a2[1];
    var ad = a2[3];
    var aty = a2[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out2[0] = aa * ct + ab * st;
    out2[1] = -aa * st + ab * ct;
    out2[2] = ac * ct + ad * st;
    out2[3] = -ac * st + ct * ad;
    out2[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
    out2[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
    return out2;
  }
  function scale$1(out2, a2, v2) {
    var vx = v2[0];
    var vy = v2[1];
    out2[0] = a2[0] * vx;
    out2[1] = a2[1] * vy;
    out2[2] = a2[2] * vx;
    out2[3] = a2[3] * vy;
    out2[4] = a2[4] * vx;
    out2[5] = a2[5] * vy;
    return out2;
  }
  function invert(out2, a2) {
    var aa = a2[0];
    var ac = a2[2];
    var atx = a2[4];
    var ab = a2[1];
    var ad = a2[3];
    var aty = a2[5];
    var det = aa * ad - ab * ac;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out2[0] = ad * det;
    out2[1] = -ab * det;
    out2[2] = -ac * det;
    out2[3] = aa * det;
    out2[4] = (ac * aty - ad * atx) * det;
    out2[5] = (ab * atx - aa * aty) * det;
    return out2;
  }
  function clone$2(a2) {
    var b2 = create();
    copy(b2, a2);
    return b2;
  }
  const matrix = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    clone: clone$2,
    copy,
    create,
    identity,
    invert,
    mul,
    rotate,
    scale: scale$1,
    translate
  }, Symbol.toStringTag, { value: "Module" }));
  var Point = function() {
    function Point2(x2, y2) {
      this.x = x2 || 0;
      this.y = y2 || 0;
    }
    Point2.prototype.copy = function(other) {
      this.x = other.x;
      this.y = other.y;
      return this;
    };
    Point2.prototype.clone = function() {
      return new Point2(this.x, this.y);
    };
    Point2.prototype.set = function(x2, y2) {
      this.x = x2;
      this.y = y2;
      return this;
    };
    Point2.prototype.equal = function(other) {
      return other.x === this.x && other.y === this.y;
    };
    Point2.prototype.add = function(other) {
      this.x += other.x;
      this.y += other.y;
      return this;
    };
    Point2.prototype.scale = function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
    };
    Point2.prototype.scaleAndAdd = function(other, scalar) {
      this.x += other.x * scalar;
      this.y += other.y * scalar;
    };
    Point2.prototype.sub = function(other) {
      this.x -= other.x;
      this.y -= other.y;
      return this;
    };
    Point2.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };
    Point2.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Point2.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    };
    Point2.prototype.normalize = function() {
      var len2 = this.len();
      this.x /= len2;
      this.y /= len2;
      return this;
    };
    Point2.prototype.distance = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Point2.prototype.distanceSquare = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return dx * dx + dy * dy;
    };
    Point2.prototype.negate = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    Point2.prototype.transform = function(m2) {
      if (!m2) {
        return;
      }
      var x2 = this.x;
      var y2 = this.y;
      this.x = m2[0] * x2 + m2[2] * y2 + m2[4];
      this.y = m2[1] * x2 + m2[3] * y2 + m2[5];
      return this;
    };
    Point2.prototype.toArray = function(out2) {
      out2[0] = this.x;
      out2[1] = this.y;
      return out2;
    };
    Point2.prototype.fromArray = function(input) {
      this.x = input[0];
      this.y = input[1];
    };
    Point2.set = function(p2, x2, y2) {
      p2.x = x2;
      p2.y = y2;
    };
    Point2.copy = function(p2, p22) {
      p2.x = p22.x;
      p2.y = p22.y;
    };
    Point2.len = function(p2) {
      return Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    };
    Point2.lenSquare = function(p2) {
      return p2.x * p2.x + p2.y * p2.y;
    };
    Point2.dot = function(p0, p1) {
      return p0.x * p1.x + p0.y * p1.y;
    };
    Point2.add = function(out2, p0, p1) {
      out2.x = p0.x + p1.x;
      out2.y = p0.y + p1.y;
    };
    Point2.sub = function(out2, p0, p1) {
      out2.x = p0.x - p1.x;
      out2.y = p0.y - p1.y;
    };
    Point2.scale = function(out2, p0, scalar) {
      out2.x = p0.x * scalar;
      out2.y = p0.y * scalar;
    };
    Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
      out2.x = p0.x + p1.x * scalar;
      out2.y = p0.y + p1.y * scalar;
    };
    Point2.lerp = function(out2, p0, p1, t2) {
      var onet = 1 - t2;
      out2.x = onet * p0.x + t2 * p1.x;
      out2.y = onet * p0.y + t2 * p1.y;
    };
    return Point2;
  }();
  var mathMin$6 = Math.min;
  var mathMax$6 = Math.max;
  var lt = new Point();
  var rb = new Point();
  var lb = new Point();
  var rt = new Point();
  var minTv$1 = new Point();
  var maxTv$1 = new Point();
  var BoundingRect = function() {
    function BoundingRect2(x2, y2, width, height) {
      if (width < 0) {
        x2 = x2 + width;
        width = -width;
      }
      if (height < 0) {
        y2 = y2 + height;
        height = -height;
      }
      this.x = x2;
      this.y = y2;
      this.width = width;
      this.height = height;
    }
    BoundingRect2.prototype.union = function(other) {
      var x2 = mathMin$6(other.x, this.x);
      var y2 = mathMin$6(other.y, this.y);
      if (isFinite(this.x) && isFinite(this.width)) {
        this.width = mathMax$6(other.x + other.width, this.x + this.width) - x2;
      } else {
        this.width = other.width;
      }
      if (isFinite(this.y) && isFinite(this.height)) {
        this.height = mathMax$6(other.y + other.height, this.y + this.height) - y2;
      } else {
        this.height = other.height;
      }
      this.x = x2;
      this.y = y2;
    };
    BoundingRect2.prototype.applyTransform = function(m2) {
      BoundingRect2.applyTransform(this, this, m2);
    };
    BoundingRect2.prototype.calculateTransform = function(b2) {
      var a2 = this;
      var sx = b2.width / a2.width;
      var sy = b2.height / a2.height;
      var m2 = create();
      translate(m2, m2, [-a2.x, -a2.y]);
      scale$1(m2, m2, [sx, sy]);
      translate(m2, m2, [b2.x, b2.y]);
      return m2;
    };
    BoundingRect2.prototype.intersect = function(b2, mtv) {
      if (!b2) {
        return false;
      }
      if (!(b2 instanceof BoundingRect2)) {
        b2 = BoundingRect2.create(b2);
      }
      var a2 = this;
      var ax0 = a2.x;
      var ax1 = a2.x + a2.width;
      var ay0 = a2.y;
      var ay1 = a2.y + a2.height;
      var bx0 = b2.x;
      var bx1 = b2.x + b2.width;
      var by0 = b2.y;
      var by1 = b2.y + b2.height;
      var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      if (mtv) {
        var dMin = Infinity;
        var dMax = 0;
        var d0 = Math.abs(ax1 - bx0);
        var d1 = Math.abs(bx1 - ax0);
        var d2 = Math.abs(ay1 - by0);
        var d3 = Math.abs(by1 - ay0);
        var dx = Math.min(d0, d1);
        var dy = Math.min(d2, d3);
        if (ax1 < bx0 || bx1 < ax0) {
          if (dx > dMax) {
            dMax = dx;
            if (d0 < d1) {
              Point.set(maxTv$1, -d0, 0);
            } else {
              Point.set(maxTv$1, d1, 0);
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx;
            if (d0 < d1) {
              Point.set(minTv$1, d0, 0);
            } else {
              Point.set(minTv$1, -d1, 0);
            }
          }
        }
        if (ay1 < by0 || by1 < ay0) {
          if (dy > dMax) {
            dMax = dy;
            if (d2 < d3) {
              Point.set(maxTv$1, 0, -d2);
            } else {
              Point.set(maxTv$1, 0, d3);
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx;
            if (d2 < d3) {
              Point.set(minTv$1, 0, d2);
            } else {
              Point.set(minTv$1, 0, -d3);
            }
          }
        }
      }
      if (mtv) {
        Point.copy(mtv, overlap ? minTv$1 : maxTv$1);
      }
      return overlap;
    };
    BoundingRect2.prototype.contain = function(x2, y2) {
      var rect = this;
      return x2 >= rect.x && x2 <= rect.x + rect.width && y2 >= rect.y && y2 <= rect.y + rect.height;
    };
    BoundingRect2.prototype.clone = function() {
      return new BoundingRect2(this.x, this.y, this.width, this.height);
    };
    BoundingRect2.prototype.copy = function(other) {
      BoundingRect2.copy(this, other);
    };
    BoundingRect2.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    };
    BoundingRect2.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    };
    BoundingRect2.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    };
    BoundingRect2.create = function(rect) {
      return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
    };
    BoundingRect2.copy = function(target, source) {
      target.x = source.x;
      target.y = source.y;
      target.width = source.width;
      target.height = source.height;
    };
    BoundingRect2.applyTransform = function(target, source, m2) {
      if (!m2) {
        if (target !== source) {
          BoundingRect2.copy(target, source);
        }
        return;
      }
      if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
        var sx = m2[0];
        var sy = m2[3];
        var tx = m2[4];
        var ty = m2[5];
        target.x = source.x * sx + tx;
        target.y = source.y * sy + ty;
        target.width = source.width * sx;
        target.height = source.height * sy;
        if (target.width < 0) {
          target.x += target.width;
          target.width = -target.width;
        }
        if (target.height < 0) {
          target.y += target.height;
          target.height = -target.height;
        }
        return;
      }
      lt.x = lb.x = source.x;
      lt.y = rt.y = source.y;
      rb.x = rt.x = source.x + source.width;
      rb.y = lb.y = source.y + source.height;
      lt.transform(m2);
      rt.transform(m2);
      rb.transform(m2);
      lb.transform(m2);
      target.x = mathMin$6(lt.x, rb.x, lb.x, rt.x);
      target.y = mathMin$6(lt.y, rb.y, lb.y, rt.y);
      var maxX = mathMax$6(lt.x, rb.x, lb.x, rt.x);
      var maxY = mathMax$6(lt.y, rb.y, lb.y, rt.y);
      target.width = maxX - target.x;
      target.height = maxY - target.y;
    };
    return BoundingRect2;
  }();
  var SILENT = "silent";
  function makeEventPacket(eveType, targetInfo, event) {
    return {
      type: eveType,
      event,
      target: targetInfo.target,
      topTarget: targetInfo.topTarget,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta,
      zrByTouch: event.zrByTouch,
      which: event.which,
      stop: stopEvent
    };
  }
  function stopEvent() {
    stop(this.event);
  }
  var EmptyProxy = function(_super) {
    __extends(EmptyProxy2, _super);
    function EmptyProxy2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.handler = null;
      return _this;
    }
    EmptyProxy2.prototype.dispose = function() {
    };
    EmptyProxy2.prototype.setCursor = function() {
    };
    return EmptyProxy2;
  }(Eventful);
  var HoveredResult = /* @__PURE__ */ function() {
    function HoveredResult2(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    return HoveredResult2;
  }();
  var handlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var tmpRect$1 = new BoundingRect(0, 0, 0, 0);
  var Handler = function(_super) {
    __extends(Handler2, _super);
    function Handler2(storage, painter, proxy, painterRoot, pointerSize) {
      var _this = _super.call(this) || this;
      _this._hovered = new HoveredResult(0, 0);
      _this.storage = storage;
      _this.painter = painter;
      _this.painterRoot = painterRoot;
      _this._pointerSize = pointerSize;
      proxy = proxy || new EmptyProxy();
      _this.proxy = null;
      _this.setHandlerProxy(proxy);
      _this._draggingMgr = new Draggable(_this);
      return _this;
    }
    Handler2.prototype.setHandlerProxy = function(proxy) {
      if (this.proxy) {
        this.proxy.dispose();
      }
      if (proxy) {
        each$4(handlerNames, function(name) {
          proxy.on && proxy.on(name, this[name], this);
        }, this);
        proxy.handler = this;
      }
      this.proxy = proxy;
    };
    Handler2.prototype.mousemove = function(event) {
      var x2 = event.zrX;
      var y2 = event.zrY;
      var isOutside = isOutsideBoundary(this, x2, y2);
      var lastHovered = this._hovered;
      var lastHoveredTarget = lastHovered.target;
      if (lastHoveredTarget && !lastHoveredTarget.__zr) {
        lastHovered = this.findHover(lastHovered.x, lastHovered.y);
        lastHoveredTarget = lastHovered.target;
      }
      var hovered = this._hovered = isOutside ? new HoveredResult(x2, y2) : this.findHover(x2, y2);
      var hoveredTarget = hovered.target;
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
      if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(lastHovered, "mouseout", event);
      }
      this.dispatchToElement(hovered, "mousemove", event);
      if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(hovered, "mouseover", event);
      }
    };
    Handler2.prototype.mouseout = function(event) {
      var eventControl = event.zrEventControl;
      if (eventControl !== "only_globalout") {
        this.dispatchToElement(this._hovered, "mouseout", event);
      }
      if (eventControl !== "no_globalout") {
        this.trigger("globalout", { type: "globalout", event });
      }
    };
    Handler2.prototype.resize = function() {
      this._hovered = new HoveredResult(0, 0);
    };
    Handler2.prototype.dispatch = function(eventName, eventArgs) {
      var handler = this[eventName];
      handler && handler.call(this, eventArgs);
    };
    Handler2.prototype.dispose = function() {
      this.proxy.dispose();
      this.storage = null;
      this.proxy = null;
      this.painter = null;
    };
    Handler2.prototype.setCursorStyle = function(cursorStyle) {
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(cursorStyle);
    };
    Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
      targetInfo = targetInfo || {};
      var el = targetInfo.target;
      if (el && el.silent) {
        return;
      }
      var eventKey = "on" + eventName;
      var eventPacket = makeEventPacket(eventName, targetInfo, event);
      while (el) {
        el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
        el.trigger(eventName, eventPacket);
        el = el.__hostTarget ? el.__hostTarget : el.parent;
        if (eventPacket.cancelBubble) {
          break;
        }
      }
      if (!eventPacket.cancelBubble) {
        this.trigger(eventName, eventPacket);
        if (this.painter && this.painter.eachOtherLayer) {
          this.painter.eachOtherLayer(function(layer) {
            if (typeof layer[eventKey] === "function") {
              layer[eventKey].call(layer, eventPacket);
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      }
    };
    Handler2.prototype.findHover = function(x2, y2, exclude) {
      var list2 = this.storage.getDisplayList();
      var out2 = new HoveredResult(x2, y2);
      setHoverTarget(list2, out2, x2, y2, exclude);
      if (this._pointerSize && !out2.target) {
        var candidates = [];
        var pointerSize = this._pointerSize;
        var targetSizeHalf = pointerSize / 2;
        var pointerRect = new BoundingRect(x2 - targetSizeHalf, y2 - targetSizeHalf, pointerSize, pointerSize);
        for (var i2 = list2.length - 1; i2 >= 0; i2--) {
          var el = list2[i2];
          if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
            tmpRect$1.copy(el.getBoundingRect());
            if (el.transform) {
              tmpRect$1.applyTransform(el.transform);
            }
            if (tmpRect$1.intersect(pointerRect)) {
              candidates.push(el);
            }
          }
        }
        if (candidates.length) {
          var rStep = 4;
          var thetaStep = Math.PI / 12;
          var PI22 = Math.PI * 2;
          for (var r2 = 0; r2 < targetSizeHalf; r2 += rStep) {
            for (var theta = 0; theta < PI22; theta += thetaStep) {
              var x1 = x2 + r2 * Math.cos(theta);
              var y1 = y2 + r2 * Math.sin(theta);
              setHoverTarget(candidates, out2, x1, y1, exclude);
              if (out2.target) {
                return out2;
              }
            }
          }
        }
      }
      return out2;
    };
    Handler2.prototype.processGesture = function(event, stage) {
      if (!this._gestureMgr) {
        this._gestureMgr = new GestureMgr();
      }
      var gestureMgr = this._gestureMgr;
      stage === "start" && gestureMgr.clear();
      var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
      stage === "end" && gestureMgr.clear();
      if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;
        var res = new HoveredResult();
        res.target = gestureInfo.target;
        this.dispatchToElement(res, type, gestureInfo.event);
      }
    };
    return Handler2;
  }(Eventful);
  each$4(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
    Handler.prototype[name] = function(event) {
      var x2 = event.zrX;
      var y2 = event.zrY;
      var isOutside = isOutsideBoundary(this, x2, y2);
      var hovered;
      var hoveredTarget;
      if (name !== "mouseup" || !isOutside) {
        hovered = this.findHover(x2, y2);
        hoveredTarget = hovered.target;
      }
      if (name === "mousedown") {
        this._downEl = hoveredTarget;
        this._downPoint = [event.zrX, event.zrY];
        this._upEl = hoveredTarget;
      } else if (name === "mouseup") {
        this._upEl = hoveredTarget;
      } else if (name === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
          return;
        }
        this._downPoint = null;
      }
      this.dispatchToElement(hovered, name, event);
    };
  });
  function isHover(displayable, x2, y2) {
    if (displayable[displayable.rectHover ? "rectContain" : "contain"](x2, y2)) {
      var el = displayable;
      var isSilent = void 0;
      var ignoreClip = false;
      while (el) {
        if (el.ignoreClip) {
          ignoreClip = true;
        }
        if (!ignoreClip) {
          var clipPath = el.getClipPath();
          if (clipPath && !clipPath.contain(x2, y2)) {
            return false;
          }
        }
        if (el.silent) {
          isSilent = true;
        }
        var hostEl = el.__hostTarget;
        el = hostEl ? hostEl : el.parent;
      }
      return isSilent ? SILENT : true;
    }
    return false;
  }
  function setHoverTarget(list2, out2, x2, y2, exclude) {
    for (var i2 = list2.length - 1; i2 >= 0; i2--) {
      var el = list2[i2];
      var hoverCheckResult = void 0;
      if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x2, y2))) {
        !out2.topTarget && (out2.topTarget = el);
        if (hoverCheckResult !== SILENT) {
          out2.target = el;
          break;
        }
      }
    }
  }
  function isOutsideBoundary(handlerInstance, x2, y2) {
    var painter = handlerInstance.painter;
    return x2 < 0 || x2 > painter.getWidth() || y2 < 0 || y2 > painter.getHeight();
  }
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;
  function minRunLength(n2) {
    var r2 = 0;
    while (n2 >= DEFAULT_MIN_MERGE) {
      r2 |= n2 & 1;
      n2 >>= 1;
    }
    return n2 + r2;
  }
  function makeAscendingRun(array, lo, hi, compare2) {
    var runHi = lo + 1;
    if (runHi === hi) {
      return 1;
    }
    if (compare2(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }
      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }
    return runHi - lo;
  }
  function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
      var t2 = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t2;
    }
  }
  function binaryInsertionSort(array, lo, hi, start2, compare2) {
    if (start2 === lo) {
      start2++;
    }
    for (; start2 < hi; start2++) {
      var pivot = array[start2];
      var left = lo;
      var right = start2;
      var mid;
      while (left < right) {
        mid = left + right >>> 1;
        if (compare2(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      var n2 = start2 - left;
      switch (n2) {
        case 3:
          array[left + 3] = array[left + 2];
        case 2:
          array[left + 2] = array[left + 1];
        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n2 > 0) {
            array[left + n2] = array[left + n2 - 1];
            n2--;
          }
      }
      array[left] = pivot;
    }
  }
  function gallopLeft(value, array, start2, length2, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset2 = 1;
    if (compare2(value, array[start2 + hint]) > 0) {
      maxOffset = length2 - hint;
      while (offset2 < maxOffset && compare2(value, array[start2 + hint + offset2]) > 0) {
        lastOffset = offset2;
        offset2 = (offset2 << 1) + 1;
        if (offset2 <= 0) {
          offset2 = maxOffset;
        }
      }
      if (offset2 > maxOffset) {
        offset2 = maxOffset;
      }
      lastOffset += hint;
      offset2 += hint;
    } else {
      maxOffset = hint + 1;
      while (offset2 < maxOffset && compare2(value, array[start2 + hint - offset2]) <= 0) {
        lastOffset = offset2;
        offset2 = (offset2 << 1) + 1;
        if (offset2 <= 0) {
          offset2 = maxOffset;
        }
      }
      if (offset2 > maxOffset) {
        offset2 = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset2;
      offset2 = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset2) {
      var m2 = lastOffset + (offset2 - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) > 0) {
        lastOffset = m2 + 1;
      } else {
        offset2 = m2;
      }
    }
    return offset2;
  }
  function gallopRight(value, array, start2, length2, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset2 = 1;
    if (compare2(value, array[start2 + hint]) < 0) {
      maxOffset = hint + 1;
      while (offset2 < maxOffset && compare2(value, array[start2 + hint - offset2]) < 0) {
        lastOffset = offset2;
        offset2 = (offset2 << 1) + 1;
        if (offset2 <= 0) {
          offset2 = maxOffset;
        }
      }
      if (offset2 > maxOffset) {
        offset2 = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset2;
      offset2 = hint - tmp;
    } else {
      maxOffset = length2 - hint;
      while (offset2 < maxOffset && compare2(value, array[start2 + hint + offset2]) >= 0) {
        lastOffset = offset2;
        offset2 = (offset2 << 1) + 1;
        if (offset2 <= 0) {
          offset2 = maxOffset;
        }
      }
      if (offset2 > maxOffset) {
        offset2 = maxOffset;
      }
      lastOffset += hint;
      offset2 += hint;
    }
    lastOffset++;
    while (lastOffset < offset2) {
      var m2 = lastOffset + (offset2 - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) < 0) {
        offset2 = m2;
      } else {
        lastOffset = m2 + 1;
      }
    }
    return offset2;
  }
  function TimSort(array, compare2) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var runStart;
    var runLength;
    var stackSize = 0;
    var tmp = [];
    runStart = [];
    runLength = [];
    function pushRun(_runStart, _runLength) {
      runStart[stackSize] = _runStart;
      runLength[stackSize] = _runLength;
      stackSize += 1;
    }
    function mergeRuns() {
      while (stackSize > 1) {
        var n2 = stackSize - 2;
        if (n2 >= 1 && runLength[n2 - 1] <= runLength[n2] + runLength[n2 + 1] || n2 >= 2 && runLength[n2 - 2] <= runLength[n2] + runLength[n2 - 1]) {
          if (runLength[n2 - 1] < runLength[n2 + 1]) {
            n2--;
          }
        } else if (runLength[n2] > runLength[n2 + 1]) {
          break;
        }
        mergeAt(n2);
      }
    }
    function forceMergeRuns() {
      while (stackSize > 1) {
        var n2 = stackSize - 2;
        if (n2 > 0 && runLength[n2 - 1] < runLength[n2 + 1]) {
          n2--;
        }
        mergeAt(n2);
      }
    }
    function mergeAt(i2) {
      var start1 = runStart[i2];
      var length1 = runLength[i2];
      var start2 = runStart[i2 + 1];
      var length2 = runLength[i2 + 1];
      runLength[i2] = length1 + length2;
      if (i2 === stackSize - 3) {
        runStart[i2 + 1] = runStart[i2 + 2];
        runLength[i2 + 1] = runLength[i2 + 2];
      }
      stackSize--;
      var k2 = gallopRight(array[start2], array, start1, length1, 0, compare2);
      start1 += k2;
      length1 -= k2;
      if (length1 === 0) {
        return;
      }
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
      if (length2 === 0) {
        return;
      }
      if (length1 <= length2) {
        mergeLow(start1, length1, start2, length2);
      } else {
        mergeHigh(start1, length1, start2, length2);
      }
    }
    function mergeLow(start1, length1, start2, length2) {
      var i2 = 0;
      for (i2 = 0; i2 < length1; i2++) {
        tmp[i2] = array[start1 + i2];
      }
      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];
      if (--length2 === 0) {
        for (i2 = 0; i2 < length1; i2++) {
          array[dest + i2] = tmp[cursor1 + i2];
        }
        return;
      }
      if (length1 === 1) {
        for (i2 = 0; i2 < length2; i2++) {
          array[dest + i2] = array[cursor2 + i2];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }
      var _minGallop = minGallop;
      var count1;
      var count2;
      var exit;
      while (1) {
        count1 = 0;
        count2 = 0;
        exit = false;
        do {
          if (compare2(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;
            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
          if (count1 !== 0) {
            for (i2 = 0; i2 < count1; i2++) {
              array[dest + i2] = tmp[cursor1 + i2];
            }
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest++] = array[cursor2++];
          if (--length2 === 0) {
            exit = true;
            break;
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
          if (count2 !== 0) {
            for (i2 = 0; i2 < count2; i2++) {
              array[dest + i2] = array[cursor2 + i2];
            }
            dest += count2;
            cursor2 += count2;
            length2 -= count2;
            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];
          if (--length1 === 1) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      minGallop < 1 && (minGallop = 1);
      if (length1 === 1) {
        for (i2 = 0; i2 < length2; i2++) {
          array[dest + i2] = array[cursor2 + i2];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error();
      } else {
        for (i2 = 0; i2 < length1; i2++) {
          array[dest + i2] = tmp[cursor1 + i2];
        }
      }
    }
    function mergeHigh(start1, length1, start2, length2) {
      var i2 = 0;
      for (i2 = 0; i2 < length2; i2++) {
        tmp[i2] = array[start2 + i2];
      }
      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];
      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);
        for (i2 = 0; i2 < length2; i2++) {
          array[customCursor + i2] = tmp[i2];
        }
        return;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i2 = length1 - 1; i2 >= 0; i2--) {
          array[customDest + i2] = array[customCursor + i2];
        }
        array[dest] = tmp[cursor2];
        return;
      }
      var _minGallop = minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare2(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i2 = count1 - 1; i2 >= 0; i2--) {
              array[customDest + i2] = array[customCursor + i2];
            }
            if (length1 === 0) {
              exit = true;
              break;
            }
          }
          array[dest--] = tmp[cursor2--];
          if (--length2 === 1) {
            exit = true;
            break;
          }
          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i2 = 0; i2 < count2; i2++) {
              array[customDest + i2] = tmp[customCursor + i2];
            }
            if (length2 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest--] = array[cursor1--];
          if (--length1 === 0) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      if (minGallop < 1) {
        minGallop = 1;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i2 = length1 - 1; i2 >= 0; i2--) {
          array[customDest + i2] = array[customCursor + i2];
        }
        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error();
      } else {
        customCursor = dest - (length2 - 1);
        for (i2 = 0; i2 < length2; i2++) {
          array[customCursor + i2] = tmp[i2];
        }
      }
    }
    return {
      mergeRuns,
      forceMergeRuns,
      pushRun
    };
  }
  function sort(array, compare2, lo, hi) {
    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }
    var remaining = hi - lo;
    if (remaining < 2) {
      return;
    }
    var runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
      return;
    }
    var ts = TimSort(array, compare2);
    var minRun = minRunLength(remaining);
    do {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
        runLength = force;
      }
      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
  }
  var REDRAW_BIT = 1;
  var STYLE_CHANGED_BIT = 2;
  var SHAPE_CHANGED_BIT = 4;
  var invalidZErrorLogged = false;
  function logInvalidZError() {
    if (invalidZErrorLogged) {
      return;
    }
    invalidZErrorLogged = true;
    console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
  }
  function shapeCompareFunc(a2, b2) {
    if (a2.zlevel === b2.zlevel) {
      if (a2.z === b2.z) {
        return a2.z2 - b2.z2;
      }
      return a2.z - b2.z;
    }
    return a2.zlevel - b2.zlevel;
  }
  var Storage = function() {
    function Storage2() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      this.displayableSortFunc = shapeCompareFunc;
    }
    Storage2.prototype.traverse = function(cb, context) {
      for (var i2 = 0; i2 < this._roots.length; i2++) {
        this._roots[i2].traverse(cb, context);
      }
    };
    Storage2.prototype.getDisplayList = function(update, includeIgnore) {
      includeIgnore = includeIgnore || false;
      var displayList = this._displayList;
      if (update || !displayList.length) {
        this.updateDisplayList(includeIgnore);
      }
      return displayList;
    };
    Storage2.prototype.updateDisplayList = function(includeIgnore) {
      this._displayListLen = 0;
      var roots2 = this._roots;
      var displayList = this._displayList;
      for (var i2 = 0, len2 = roots2.length; i2 < len2; i2++) {
        this._updateAndAddDisplayable(roots2[i2], null, includeIgnore);
      }
      displayList.length = this._displayListLen;
      sort(displayList, shapeCompareFunc);
    };
    Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return;
      }
      el.beforeUpdate();
      el.update();
      el.afterUpdate();
      var userSetClipPath = el.getClipPath();
      if (el.ignoreClip) {
        clipPaths = null;
      } else if (userSetClipPath) {
        if (clipPaths) {
          clipPaths = clipPaths.slice();
        } else {
          clipPaths = [];
        }
        var currentClipPath = userSetClipPath;
        var parentClipPath = el;
        while (currentClipPath) {
          currentClipPath.parent = parentClipPath;
          currentClipPath.updateTransform();
          clipPaths.push(currentClipPath);
          parentClipPath = currentClipPath;
          currentClipPath = currentClipPath.getClipPath();
        }
      }
      if (el.childrenRef) {
        var children = el.childrenRef();
        for (var i2 = 0; i2 < children.length; i2++) {
          var child = children[i2];
          if (el.__dirty) {
            child.__dirty |= REDRAW_BIT;
          }
          this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
        }
        el.__dirty = 0;
      } else {
        var disp = el;
        if (clipPaths && clipPaths.length) {
          disp.__clipPaths = clipPaths;
        } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
          disp.__clipPaths = [];
        }
        if (isNaN(disp.z)) {
          logInvalidZError();
          disp.z = 0;
        }
        if (isNaN(disp.z2)) {
          logInvalidZError();
          disp.z2 = 0;
        }
        if (isNaN(disp.zlevel)) {
          logInvalidZError();
          disp.zlevel = 0;
        }
        this._displayList[this._displayListLen++] = disp;
      }
      var decalEl = el.getDecalElement && el.getDecalElement();
      if (decalEl) {
        this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
      }
      var textGuide = el.getTextGuideLine();
      if (textGuide) {
        this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
      }
      var textEl = el.getTextContent();
      if (textEl) {
        this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
      }
    };
    Storage2.prototype.addRoot = function(el) {
      if (el.__zr && el.__zr.storage === this) {
        return;
      }
      this._roots.push(el);
    };
    Storage2.prototype.delRoot = function(el) {
      if (el instanceof Array) {
        for (var i2 = 0, l2 = el.length; i2 < l2; i2++) {
          this.delRoot(el[i2]);
        }
        return;
      }
      var idx = indexOf(this._roots, el);
      if (idx >= 0) {
        this._roots.splice(idx, 1);
      }
    };
    Storage2.prototype.delAllRoots = function() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    };
    Storage2.prototype.getRoots = function() {
      return this._roots;
    };
    Storage2.prototype.dispose = function() {
      this._displayList = null;
      this._roots = null;
    };
    return Storage2;
  }();
  var requestAnimationFrame$1;
  requestAnimationFrame$1 = env.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
    return setTimeout(func, 16);
  };
  var easingFuncs = {
    linear: function(k2) {
      return k2;
    },
    quadraticIn: function(k2) {
      return k2 * k2;
    },
    quadraticOut: function(k2) {
      return k2 * (2 - k2);
    },
    quadraticInOut: function(k2) {
      if ((k2 *= 2) < 1) {
        return 0.5 * k2 * k2;
      }
      return -0.5 * (--k2 * (k2 - 2) - 1);
    },
    cubicIn: function(k2) {
      return k2 * k2 * k2;
    },
    cubicOut: function(k2) {
      return --k2 * k2 * k2 + 1;
    },
    cubicInOut: function(k2) {
      if ((k2 *= 2) < 1) {
        return 0.5 * k2 * k2 * k2;
      }
      return 0.5 * ((k2 -= 2) * k2 * k2 + 2);
    },
    quarticIn: function(k2) {
      return k2 * k2 * k2 * k2;
    },
    quarticOut: function(k2) {
      return 1 - --k2 * k2 * k2 * k2;
    },
    quarticInOut: function(k2) {
      if ((k2 *= 2) < 1) {
        return 0.5 * k2 * k2 * k2 * k2;
      }
      return -0.5 * ((k2 -= 2) * k2 * k2 * k2 - 2);
    },
    quinticIn: function(k2) {
      return k2 * k2 * k2 * k2 * k2;
    },
    quinticOut: function(k2) {
      return --k2 * k2 * k2 * k2 * k2 + 1;
    },
    quinticInOut: function(k2) {
      if ((k2 *= 2) < 1) {
        return 0.5 * k2 * k2 * k2 * k2 * k2;
      }
      return 0.5 * ((k2 -= 2) * k2 * k2 * k2 * k2 + 2);
    },
    sinusoidalIn: function(k2) {
      return 1 - Math.cos(k2 * Math.PI / 2);
    },
    sinusoidalOut: function(k2) {
      return Math.sin(k2 * Math.PI / 2);
    },
    sinusoidalInOut: function(k2) {
      return 0.5 * (1 - Math.cos(Math.PI * k2));
    },
    exponentialIn: function(k2) {
      return k2 === 0 ? 0 : Math.pow(1024, k2 - 1);
    },
    exponentialOut: function(k2) {
      return k2 === 1 ? 1 : 1 - Math.pow(2, -10 * k2);
    },
    exponentialInOut: function(k2) {
      if (k2 === 0) {
        return 0;
      }
      if (k2 === 1) {
        return 1;
      }
      if ((k2 *= 2) < 1) {
        return 0.5 * Math.pow(1024, k2 - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (k2 - 1)) + 2);
    },
    circularIn: function(k2) {
      return 1 - Math.sqrt(1 - k2 * k2);
    },
    circularOut: function(k2) {
      return Math.sqrt(1 - --k2 * k2);
    },
    circularInOut: function(k2) {
      if ((k2 *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k2 * k2) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (k2 -= 2) * k2) + 1);
    },
    elasticIn: function(k2) {
      var s2;
      var a2 = 0.1;
      var p2 = 0.4;
      if (k2 === 0) {
        return 0;
      }
      if (k2 === 1) {
        return 1;
      }
      if (!a2 || a2 < 1) {
        a2 = 1;
        s2 = p2 / 4;
      } else {
        s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
      }
      return -(a2 * Math.pow(2, 10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2));
    },
    elasticOut: function(k2) {
      var s2;
      var a2 = 0.1;
      var p2 = 0.4;
      if (k2 === 0) {
        return 0;
      }
      if (k2 === 1) {
        return 1;
      }
      if (!a2 || a2 < 1) {
        a2 = 1;
        s2 = p2 / 4;
      } else {
        s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
      }
      return a2 * Math.pow(2, -10 * k2) * Math.sin((k2 - s2) * (2 * Math.PI) / p2) + 1;
    },
    elasticInOut: function(k2) {
      var s2;
      var a2 = 0.1;
      var p2 = 0.4;
      if (k2 === 0) {
        return 0;
      }
      if (k2 === 1) {
        return 1;
      }
      if (!a2 || a2 < 1) {
        a2 = 1;
        s2 = p2 / 4;
      } else {
        s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
      }
      if ((k2 *= 2) < 1) {
        return -0.5 * (a2 * Math.pow(2, 10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2));
      }
      return a2 * Math.pow(2, -10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2) * 0.5 + 1;
    },
    backIn: function(k2) {
      var s2 = 1.70158;
      return k2 * k2 * ((s2 + 1) * k2 - s2);
    },
    backOut: function(k2) {
      var s2 = 1.70158;
      return --k2 * k2 * ((s2 + 1) * k2 + s2) + 1;
    },
    backInOut: function(k2) {
      var s2 = 1.70158 * 1.525;
      if ((k2 *= 2) < 1) {
        return 0.5 * (k2 * k2 * ((s2 + 1) * k2 - s2));
      }
      return 0.5 * ((k2 -= 2) * k2 * ((s2 + 1) * k2 + s2) + 2);
    },
    bounceIn: function(k2) {
      return 1 - easingFuncs.bounceOut(1 - k2);
    },
    bounceOut: function(k2) {
      if (k2 < 1 / 2.75) {
        return 7.5625 * k2 * k2;
      } else if (k2 < 2 / 2.75) {
        return 7.5625 * (k2 -= 1.5 / 2.75) * k2 + 0.75;
      } else if (k2 < 2.5 / 2.75) {
        return 7.5625 * (k2 -= 2.25 / 2.75) * k2 + 0.9375;
      } else {
        return 7.5625 * (k2 -= 2.625 / 2.75) * k2 + 0.984375;
      }
    },
    bounceInOut: function(k2) {
      if (k2 < 0.5) {
        return easingFuncs.bounceIn(k2 * 2) * 0.5;
      }
      return easingFuncs.bounceOut(k2 * 2 - 1) * 0.5 + 0.5;
    }
  };
  var mathPow$1 = Math.pow;
  var mathSqrt$3 = Math.sqrt;
  var EPSILON$3 = 1e-8;
  var EPSILON_NUMERIC = 1e-4;
  var THREE_SQRT = mathSqrt$3(3);
  var ONE_THIRD = 1 / 3;
  var _v0 = create$1();
  var _v1 = create$1();
  var _v2 = create$1();
  function isAroundZero(val) {
    return val > -EPSILON$3 && val < EPSILON$3;
  }
  function isNotAroundZero$1(val) {
    return val > EPSILON$3 || val < -EPSILON$3;
  }
  function cubicAt(p0, p1, p2, p3, t2) {
    var onet = 1 - t2;
    return onet * onet * (onet * p0 + 3 * t2 * p1) + t2 * t2 * (t2 * p3 + 3 * onet * p2);
  }
  function cubicDerivativeAt(p0, p1, p2, p3, t2) {
    var onet = 1 - t2;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t2) * onet + (p3 - p2) * t2 * t2);
  }
  function cubicRootAt(p0, p1, p2, p3, val, roots2) {
    var a2 = p3 + 3 * (p1 - p2) - p0;
    var b2 = 3 * (p2 - p1 * 2 + p0);
    var c2 = 3 * (p1 - p0);
    var d2 = p0 - val;
    var A2 = b2 * b2 - 3 * a2 * c2;
    var B2 = b2 * c2 - 9 * a2 * d2;
    var C = c2 * c2 - 3 * b2 * d2;
    var n2 = 0;
    if (isAroundZero(A2) && isAroundZero(B2)) {
      if (isAroundZero(b2)) {
        roots2[0] = 0;
      } else {
        var t1 = -c2 / b2;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
      }
    } else {
      var disc = B2 * B2 - 4 * A2 * C;
      if (isAroundZero(disc)) {
        var K = B2 / A2;
        var t1 = -b2 / a2 + K;
        var t2 = -K / 2;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n2++] = t2;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var Y1 = A2 * b2 + 1.5 * a2 * (-B2 + discSqrt);
        var Y2 = A2 * b2 + 1.5 * a2 * (-B2 - discSqrt);
        if (Y1 < 0) {
          Y1 = -mathPow$1(-Y1, ONE_THIRD);
        } else {
          Y1 = mathPow$1(Y1, ONE_THIRD);
        }
        if (Y2 < 0) {
          Y2 = -mathPow$1(-Y2, ONE_THIRD);
        } else {
          Y2 = mathPow$1(Y2, ONE_THIRD);
        }
        var t1 = (-b2 - (Y1 + Y2)) / (3 * a2);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
      } else {
        var T2 = (2 * A2 * b2 - 3 * a2 * B2) / (2 * mathSqrt$3(A2 * A2 * A2));
        var theta = Math.acos(T2) / 3;
        var ASqrt = mathSqrt$3(A2);
        var tmp = Math.cos(theta);
        var t1 = (-b2 - 2 * ASqrt * tmp) / (3 * a2);
        var t2 = (-b2 + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a2);
        var t3 = (-b2 + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a2);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n2++] = t2;
        }
        if (t3 >= 0 && t3 <= 1) {
          roots2[n2++] = t3;
        }
      }
    }
    return n2;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema2) {
    var b2 = 6 * p2 - 12 * p1 + 6 * p0;
    var a2 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c2 = 3 * p1 - 3 * p0;
    var n2 = 0;
    if (isAroundZero(a2)) {
      if (isNotAroundZero$1(b2)) {
        var t1 = -c2 / b2;
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n2++] = t1;
        }
      }
    } else {
      var disc = b2 * b2 - 4 * a2 * c2;
      if (isAroundZero(disc)) {
        extrema2[0] = -b2 / (2 * a2);
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var t1 = (-b2 + discSqrt) / (2 * a2);
        var t2 = (-b2 - discSqrt) / (2 * a2);
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n2++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          extrema2[n2++] = t2;
        }
      }
    }
    return n2;
  }
  function cubicSubdivide(p0, p1, p2, p3, t2, out2) {
    var p01 = (p1 - p0) * t2 + p0;
    var p12 = (p2 - p1) * t2 + p1;
    var p23 = (p3 - p2) * t2 + p2;
    var p012 = (p12 - p01) * t2 + p01;
    var p123 = (p23 - p12) * t2 + p12;
    var p0123 = (p123 - p012) * t2 + p012;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p0123;
    out2[4] = p0123;
    out2[5] = p123;
    out2[6] = p23;
    out2[7] = p3;
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, out2) {
    var t2;
    var interval = 5e-3;
    var d2 = Infinity;
    var prev2;
    var next2;
    var d1;
    var d22;
    _v0[0] = x4;
    _v0[1] = y4;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t);
      _v1[1] = cubicAt(y0, y1, y2, y3, _t);
      d1 = distSquare(_v0, _v1);
      if (d1 < d2) {
        t2 = _t;
        d2 = d1;
      }
    }
    d2 = Infinity;
    for (var i2 = 0; i2 < 32; i2++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      prev2 = t2 - interval;
      next2 = t2 + interval;
      _v1[0] = cubicAt(x0, x1, x2, x3, prev2);
      _v1[1] = cubicAt(y0, y1, y2, y3, prev2);
      d1 = distSquare(_v1, _v0);
      if (prev2 >= 0 && d1 < d2) {
        t2 = prev2;
        d2 = d1;
      } else {
        _v2[0] = cubicAt(x0, x1, x2, x3, next2);
        _v2[1] = cubicAt(y0, y1, y2, y3, next2);
        d22 = distSquare(_v2, _v0);
        if (next2 <= 1 && d22 < d2) {
          t2 = next2;
          d2 = d22;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out2) {
      out2[0] = cubicAt(x0, x1, x2, x3, t2);
      out2[1] = cubicAt(y0, y1, y2, y3, t2);
    }
    return mathSqrt$3(d2);
  }
  function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
    var px = x0;
    var py = y0;
    var d2 = 0;
    var step = 1 / iteration;
    for (var i2 = 1; i2 <= iteration; i2++) {
      var t2 = i2 * step;
      var x4 = cubicAt(x0, x1, x2, x3, t2);
      var y4 = cubicAt(y0, y1, y2, y3, t2);
      var dx = x4 - px;
      var dy = y4 - py;
      d2 += Math.sqrt(dx * dx + dy * dy);
      px = x4;
      py = y4;
    }
    return d2;
  }
  function quadraticAt(p0, p1, p2, t2) {
    var onet = 1 - t2;
    return onet * (onet * p0 + 2 * t2 * p1) + t2 * t2 * p2;
  }
  function quadraticDerivativeAt(p0, p1, p2, t2) {
    return 2 * ((1 - t2) * (p1 - p0) + t2 * (p2 - p1));
  }
  function quadraticRootAt(p0, p1, p2, val, roots2) {
    var a2 = p0 - 2 * p1 + p2;
    var b2 = 2 * (p1 - p0);
    var c2 = p0 - val;
    var n2 = 0;
    if (isAroundZero(a2)) {
      if (isNotAroundZero$1(b2)) {
        var t1 = -c2 / b2;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
      }
    } else {
      var disc = b2 * b2 - 4 * a2 * c2;
      if (isAroundZero(disc)) {
        var t1 = -b2 / (2 * a2);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt$3(disc);
        var t1 = (-b2 + discSqrt) / (2 * a2);
        var t2 = (-b2 - discSqrt) / (2 * a2);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n2++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n2++] = t2;
        }
      }
    }
    return n2;
  }
  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
      return 0.5;
    } else {
      return (p0 - p1) / divider;
    }
  }
  function quadraticSubdivide(p0, p1, p2, t2, out2) {
    var p01 = (p1 - p0) * t2 + p0;
    var p12 = (p2 - p1) * t2 + p1;
    var p012 = (p12 - p01) * t2 + p01;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p012;
    out2[4] = p12;
    out2[5] = p2;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, out2) {
    var t2;
    var interval = 5e-3;
    var d2 = Infinity;
    _v0[0] = x3;
    _v0[1] = y3;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t);
      _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = distSquare(_v0, _v1);
      if (d1 < d2) {
        t2 = _t;
        d2 = d1;
      }
    }
    d2 = Infinity;
    for (var i2 = 0; i2 < 32; i2++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      var prev2 = t2 - interval;
      var next2 = t2 + interval;
      _v1[0] = quadraticAt(x0, x1, x2, prev2);
      _v1[1] = quadraticAt(y0, y1, y2, prev2);
      var d1 = distSquare(_v1, _v0);
      if (prev2 >= 0 && d1 < d2) {
        t2 = prev2;
        d2 = d1;
      } else {
        _v2[0] = quadraticAt(x0, x1, x2, next2);
        _v2[1] = quadraticAt(y0, y1, y2, next2);
        var d22 = distSquare(_v2, _v0);
        if (next2 <= 1 && d22 < d2) {
          t2 = next2;
          d2 = d22;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out2) {
      out2[0] = quadraticAt(x0, x1, x2, t2);
      out2[1] = quadraticAt(y0, y1, y2, t2);
    }
    return mathSqrt$3(d2);
  }
  function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
    var px = x0;
    var py = y0;
    var d2 = 0;
    var step = 1 / iteration;
    for (var i2 = 1; i2 <= iteration; i2++) {
      var t2 = i2 * step;
      var x3 = quadraticAt(x0, x1, x2, t2);
      var y3 = quadraticAt(y0, y1, y2, t2);
      var dx = x3 - px;
      var dy = y3 - py;
      d2 += Math.sqrt(dx * dx + dy * dy);
      px = x3;
      py = y3;
    }
    return d2;
  }
  var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function createCubicEasingFunc(cubicEasingStr) {
    var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
    if (cubic) {
      var points2 = cubic[1].split(",");
      var a_1 = +trim$1(points2[0]);
      var b_1 = +trim$1(points2[1]);
      var c_1 = +trim$1(points2[2]);
      var d_1 = +trim$1(points2[3]);
      if (isNaN(a_1 + b_1 + c_1 + d_1)) {
        return;
      }
      var roots_1 = [];
      return function(p2) {
        return p2 <= 0 ? 0 : p2 >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p2, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
      };
    }
  }
  var Clip = function() {
    function Clip2(opts) {
      this._inited = false;
      this._startTime = 0;
      this._pausedTime = 0;
      this._paused = false;
      this._life = opts.life || 1e3;
      this._delay = opts.delay || 0;
      this.loop = opts.loop || false;
      this.onframe = opts.onframe || noop$1;
      this.ondestroy = opts.ondestroy || noop$1;
      this.onrestart = opts.onrestart || noop$1;
      opts.easing && this.setEasing(opts.easing);
    }
    Clip2.prototype.step = function(globalTime, deltaTime) {
      if (!this._inited) {
        this._startTime = globalTime + this._delay;
        this._inited = true;
      }
      if (this._paused) {
        this._pausedTime += deltaTime;
        return;
      }
      var life = this._life;
      var elapsedTime = globalTime - this._startTime - this._pausedTime;
      var percent = elapsedTime / life;
      if (percent < 0) {
        percent = 0;
      }
      percent = Math.min(percent, 1);
      var easingFunc = this.easingFunc;
      var schedule = easingFunc ? easingFunc(percent) : percent;
      this.onframe(schedule);
      if (percent === 1) {
        if (this.loop) {
          var remainder = elapsedTime % life;
          this._startTime = globalTime - remainder;
          this._pausedTime = 0;
          this.onrestart();
        } else {
          return true;
        }
      }
      return false;
    };
    Clip2.prototype.pause = function() {
      this._paused = true;
    };
    Clip2.prototype.resume = function() {
      this._paused = false;
    };
    Clip2.prototype.setEasing = function(easing) {
      this.easing = easing;
      this.easingFunc = isFunction$1(easing) ? easing : easingFuncs[easing] || createCubicEasingFunc(easing);
    };
    return Clip2;
  }();
  var Entry = /* @__PURE__ */ function() {
    function Entry2(val) {
      this.value = val;
    }
    return Entry2;
  }();
  var LinkedList = function() {
    function LinkedList2() {
      this._len = 0;
    }
    LinkedList2.prototype.insert = function(val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    LinkedList2.prototype.insertEntry = function(entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }
      this._len++;
    };
    LinkedList2.prototype.remove = function(entry) {
      var prev2 = entry.prev;
      var next2 = entry.next;
      if (prev2) {
        prev2.next = next2;
      } else {
        this.head = next2;
      }
      if (next2) {
        next2.prev = prev2;
      } else {
        this.tail = prev2;
      }
      entry.next = entry.prev = null;
      this._len--;
    };
    LinkedList2.prototype.len = function() {
      return this._len;
    };
    LinkedList2.prototype.clear = function() {
      this.head = this.tail = null;
      this._len = 0;
    };
    return LinkedList2;
  }();
  var LRU = function() {
    function LRU2(maxSize) {
      this._list = new LinkedList();
      this._maxSize = 10;
      this._map = {};
      this._maxSize = maxSize;
    }
    LRU2.prototype.put = function(key2, value) {
      var list2 = this._list;
      var map2 = this._map;
      var removed = null;
      if (map2[key2] == null) {
        var len2 = list2.len();
        var entry = this._lastRemovedEntry;
        if (len2 >= this._maxSize && len2 > 0) {
          var leastUsedEntry = list2.head;
          list2.remove(leastUsedEntry);
          delete map2[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }
        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }
        entry.key = key2;
        list2.insertEntry(entry);
        map2[key2] = entry;
      }
      return removed;
    };
    LRU2.prototype.get = function(key2) {
      var entry = this._map[key2];
      var list2 = this._list;
      if (entry != null) {
        if (entry !== list2.tail) {
          list2.remove(entry);
          list2.insertEntry(entry);
        }
        return entry.value;
      }
    };
    LRU2.prototype.clear = function() {
      this._list.clear();
      this._map = {};
    };
    LRU2.prototype.len = function() {
      return this._list.len();
    };
    return LRU2;
  }();
  var kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };
  function clampCssByte(i2) {
    i2 = Math.round(i2);
    return i2 < 0 ? 0 : i2 > 255 ? 255 : i2;
  }
  function clampCssAngle(i2) {
    i2 = Math.round(i2);
    return i2 < 0 ? 0 : i2 > 360 ? 360 : i2;
  }
  function clampCssFloat(f2) {
    return f2 < 0 ? 0 : f2 > 1 ? 1 : f2;
  }
  function parseCssInt(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
  }
  function parseCssFloat(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
  }
  function cssHueToRgb(m1, m2, h2) {
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
    if (h2 * 6 < 1) {
      return m1 + (m2 - m1) * h2 * 6;
    }
    if (h2 * 2 < 1) {
      return m2;
    }
    if (h2 * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h2) * 6;
    }
    return m1;
  }
  function lerpNumber(a2, b2, p2) {
    return a2 + (b2 - a2) * p2;
  }
  function setRgba(out2, r2, g2, b2, a2) {
    out2[0] = r2;
    out2[1] = g2;
    out2[2] = b2;
    out2[3] = a2;
    return out2;
  }
  function copyRgba(out2, a2) {
    out2[0] = a2[0];
    out2[1] = a2[1];
    out2[2] = a2[2];
    out2[3] = a2[3];
    return out2;
  }
  var colorCache = new LRU(20);
  var lastRemovedArr = null;
  function putToCache(colorStr, rgbaArr) {
    if (lastRemovedArr) {
      copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
  }
  function parse(colorStr, rgbaArr) {
    if (!colorStr) {
      return;
    }
    rgbaArr = rgbaArr || [];
    var cached2 = colorCache.get(colorStr);
    if (cached2) {
      return copyRgba(rgbaArr, cached2);
    }
    colorStr = colorStr + "";
    var str = colorStr.replace(/ /g, "").toLowerCase();
    if (str in kCSSColorTable) {
      copyRgba(rgbaArr, kCSSColorTable[str]);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    var strLen = str.length;
    if (str.charAt(0) === "#") {
      if (strLen === 4 || strLen === 5) {
        var iv = parseInt(str.slice(1, 4), 16);
        if (!(iv >= 0 && iv <= 4095)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } else if (strLen === 7 || strLen === 9) {
        var iv = parseInt(str.slice(1, 7), 16);
        if (!(iv >= 0 && iv <= 16777215)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }
      return;
    }
    var op = str.indexOf("(");
    var ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === strLen) {
      var fname = str.substr(0, op);
      var params2 = str.substr(op + 1, ep - (op + 1)).split(",");
      var alpha = 1;
      switch (fname) {
        case "rgba":
          if (params2.length !== 4) {
            return params2.length === 3 ? setRgba(rgbaArr, +params2[0], +params2[1], +params2[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
          }
          alpha = parseCssFloat(params2.pop());
        case "rgb":
          if (params2.length >= 3) {
            setRgba(rgbaArr, parseCssInt(params2[0]), parseCssInt(params2[1]), parseCssInt(params2[2]), params2.length === 3 ? alpha : parseCssFloat(params2[3]));
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          } else {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
        case "hsla":
          if (params2.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          params2[3] = parseCssFloat(params2[3]);
          hsla2rgba(params2, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        case "hsl":
          if (params2.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          hsla2rgba(params2, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        default:
          return;
      }
    }
    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
  }
  function hsla2rgba(hsla, rgba) {
    var h2 = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
    var s2 = parseCssFloat(hsla[1]);
    var l2 = parseCssFloat(hsla[2]);
    var m2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
    var m1 = l2 * 2 - m2;
    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h2 + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h2) * 255), clampCssByte(cssHueToRgb(m1, m2, h2 - 1 / 3) * 255), 1);
    if (hsla.length === 4) {
      rgba[3] = hsla[3];
    }
    return rgba;
  }
  function rgba2hsla(rgba) {
    if (!rgba) {
      return;
    }
    var R2 = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B2 = rgba[2] / 255;
    var vMin = Math.min(R2, G, B2);
    var vMax = Math.max(R2, G, B2);
    var delta = vMax - vMin;
    var L2 = (vMax + vMin) / 2;
    var H;
    var S2;
    if (delta === 0) {
      H = 0;
      S2 = 0;
    } else {
      if (L2 < 0.5) {
        S2 = delta / (vMax + vMin);
      } else {
        S2 = delta / (2 - vMax - vMin);
      }
      var deltaR = ((vMax - R2) / 6 + delta / 2) / delta;
      var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
      var deltaB = ((vMax - B2) / 6 + delta / 2) / delta;
      if (R2 === vMax) {
        H = deltaB - deltaG;
      } else if (G === vMax) {
        H = 1 / 3 + deltaR - deltaB;
      } else if (B2 === vMax) {
        H = 2 / 3 + deltaG - deltaR;
      }
      if (H < 0) {
        H += 1;
      }
      if (H > 1) {
        H -= 1;
      }
    }
    var hsla = [H * 360, S2, L2];
    if (rgba[3] != null) {
      hsla.push(rgba[3]);
    }
    return hsla;
  }
  function lift(color2, level) {
    var colorArr = parse(color2);
    if (colorArr) {
      for (var i2 = 0; i2 < 3; i2++) {
        if (level < 0) {
          colorArr[i2] = colorArr[i2] * (1 - level) | 0;
        } else {
          colorArr[i2] = (255 - colorArr[i2]) * level + colorArr[i2] | 0;
        }
        if (colorArr[i2] > 255) {
          colorArr[i2] = 255;
        } else if (colorArr[i2] < 0) {
          colorArr[i2] = 0;
        }
      }
      return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
    }
  }
  function toHex(color2) {
    var colorArr = parse(color2);
    if (colorArr) {
      return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
    }
  }
  function fastLerp(normalizedValue, colors, out2) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    out2 = out2 || [];
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
    return out2;
  }
  var fastMapToColor = fastLerp;
  function lerp(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color2 = stringify([
      clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
      clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
      clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
      clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    ], "rgba");
    return fullOutput ? {
      color: color2,
      leftIndex,
      rightIndex,
      value
    } : color2;
  }
  var mapToColor = lerp;
  function modifyHSL(color2, h2, s2, l2) {
    var colorArr = parse(color2);
    if (color2) {
      colorArr = rgba2hsla(colorArr);
      h2 != null && (colorArr[0] = clampCssAngle(h2));
      s2 != null && (colorArr[1] = parseCssFloat(s2));
      l2 != null && (colorArr[2] = parseCssFloat(l2));
      return stringify(hsla2rgba(colorArr), "rgba");
    }
  }
  function modifyAlpha(color2, alpha) {
    var colorArr = parse(color2);
    if (colorArr && alpha != null) {
      colorArr[3] = clampCssFloat(alpha);
      return stringify(colorArr, "rgba");
    }
  }
  function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
      return;
    }
    var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
    if (type === "rgba" || type === "hsva" || type === "hsla") {
      colorStr += "," + arrColor[3];
    }
    return type + "(" + colorStr + ")";
  }
  function lum(color2, backgroundLum) {
    var arr = parse(color2);
    return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
  }
  function random() {
    return stringify([
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255)
    ], "rgb");
  }
  var liftedColorCache = new LRU(100);
  function liftColor(color2) {
    if (isString$1(color2)) {
      var liftedColor = liftedColorCache.get(color2);
      if (!liftedColor) {
        liftedColor = lift(color2, -0.1);
        liftedColorCache.put(color2, liftedColor);
      }
      return liftedColor;
    } else if (isGradientObject(color2)) {
      var ret = extend$1({}, color2);
      ret.colorStops = map$1(color2.colorStops, function(stop2) {
        return {
          offset: stop2.offset,
          color: lift(stop2.color, -0.1)
        };
      });
      return ret;
    }
    return color2;
  }
  const color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    fastLerp,
    fastMapToColor,
    lerp,
    lift,
    liftColor,
    lum,
    mapToColor,
    modifyAlpha,
    modifyHSL,
    parse,
    random,
    stringify,
    toHex
  }, Symbol.toStringTag, { value: "Module" }));
  function isLinearGradient(val) {
    return val.type === "linear";
  }
  function isRadialGradient(val) {
    return val.type === "radial";
  }
  (function() {
    if (env.hasGlobalWindow && isFunction$1(window.btoa)) {
      return function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    }
    if (typeof Buffer !== "undefined") {
      return function(str) {
        return Buffer.from(str).toString("base64");
      };
    }
    return function(str) {
      return null;
    };
  })();
  var arraySlice = Array.prototype.slice;
  function interpolateNumber$1(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  function interpolate1DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    for (var i2 = 0; i2 < len2; i2++) {
      out2[i2] = interpolateNumber$1(p0[i2], p1[i2], percent);
    }
    return out2;
  }
  function interpolate2DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i2 = 0; i2 < len2; i2++) {
      if (!out2[i2]) {
        out2[i2] = [];
      }
      for (var j2 = 0; j2 < len22; j2++) {
        out2[i2][j2] = interpolateNumber$1(p0[i2][j2], p1[i2][j2], percent);
      }
    }
    return out2;
  }
  function add1DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    for (var i2 = 0; i2 < len2; i2++) {
      out2[i2] = p0[i2] + p1[i2] * sign;
    }
    return out2;
  }
  function add2DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i2 = 0; i2 < len2; i2++) {
      if (!out2[i2]) {
        out2[i2] = [];
      }
      for (var j2 = 0; j2 < len22; j2++) {
        out2[i2][j2] = p0[i2][j2] + p1[i2][j2] * sign;
      }
    }
    return out2;
  }
  function fillColorStops(val0, val1) {
    var len0 = val0.length;
    var len1 = val1.length;
    var shorterArr = len0 > len1 ? val1 : val0;
    var shorterLen = Math.min(len0, len1);
    var last2 = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
    for (var i2 = shorterLen; i2 < Math.max(len0, len1); i2++) {
      shorterArr.push({
        offset: last2.offset,
        color: last2.color.slice()
      });
    }
  }
  function fillArray(val0, val1, arrDim) {
    var arr0 = val0;
    var arr1 = val1;
    if (!arr0.push || !arr1.push) {
      return;
    }
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
      var isPreviousLarger = arr0Len > arr1Len;
      if (isPreviousLarger) {
        arr0.length = arr1Len;
      } else {
        for (var i2 = arr0Len; i2 < arr1Len; i2++) {
          arr0.push(arrDim === 1 ? arr1[i2] : arraySlice.call(arr1[i2]));
        }
      }
    }
    var len2 = arr0[0] && arr0[0].length;
    for (var i2 = 0; i2 < arr0.length; i2++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i2])) {
          arr0[i2] = arr1[i2];
        }
      } else {
        for (var j2 = 0; j2 < len2; j2++) {
          if (isNaN(arr0[i2][j2])) {
            arr0[i2][j2] = arr1[i2][j2];
          }
        }
      }
    }
  }
  function cloneValue(value) {
    if (isArrayLike(value)) {
      var len2 = value.length;
      if (isArrayLike(value[0])) {
        var ret = [];
        for (var i2 = 0; i2 < len2; i2++) {
          ret.push(arraySlice.call(value[i2]));
        }
        return ret;
      }
      return arraySlice.call(value);
    }
    return value;
  }
  function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]) || 0;
    rgba[1] = Math.floor(rgba[1]) || 0;
    rgba[2] = Math.floor(rgba[2]) || 0;
    rgba[3] = rgba[3] == null ? 1 : rgba[3];
    return "rgba(" + rgba.join(",") + ")";
  }
  function guessArrayDim(value) {
    return isArrayLike(value && value[0]) ? 2 : 1;
  }
  var VALUE_TYPE_NUMBER = 0;
  var VALUE_TYPE_1D_ARRAY = 1;
  var VALUE_TYPE_2D_ARRAY = 2;
  var VALUE_TYPE_COLOR = 3;
  var VALUE_TYPE_LINEAR_GRADIENT = 4;
  var VALUE_TYPE_RADIAL_GRADIENT = 5;
  var VALUE_TYPE_UNKOWN = 6;
  function isGradientValueType(valType) {
    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
  }
  function isArrayValueType(valType) {
    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
  }
  var tmpRgba = [0, 0, 0, 0];
  var Track = function() {
    function Track2(propName) {
      this.keyframes = [];
      this.discrete = false;
      this._invalid = false;
      this._needsSort = false;
      this._lastFr = 0;
      this._lastFrP = 0;
      this.propName = propName;
    }
    Track2.prototype.isFinished = function() {
      return this._finished;
    };
    Track2.prototype.setFinished = function() {
      this._finished = true;
      if (this._additiveTrack) {
        this._additiveTrack.setFinished();
      }
    };
    Track2.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    };
    Track2.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    };
    Track2.prototype.addKeyframe = function(time2, rawValue, easing) {
      this._needsSort = true;
      var keyframes = this.keyframes;
      var len2 = keyframes.length;
      var discrete = false;
      var valType = VALUE_TYPE_UNKOWN;
      var value = rawValue;
      if (isArrayLike(rawValue)) {
        var arrayDim = guessArrayDim(rawValue);
        valType = arrayDim;
        if (arrayDim === 1 && !isNumber$1(rawValue[0]) || arrayDim === 2 && !isNumber$1(rawValue[0][0])) {
          discrete = true;
        }
      } else {
        if (isNumber$1(rawValue) && !eqNaN(rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else if (isString$1(rawValue)) {
          if (!isNaN(+rawValue)) {
            valType = VALUE_TYPE_NUMBER;
          } else {
            var colorArray = parse(rawValue);
            if (colorArray) {
              value = colorArray;
              valType = VALUE_TYPE_COLOR;
            }
          }
        } else if (isGradientObject(rawValue)) {
          var parsedGradient = extend$1({}, value);
          parsedGradient.colorStops = map$1(rawValue.colorStops, function(colorStop) {
            return {
              offset: colorStop.offset,
              color: parse(colorStop.color)
            };
          });
          if (isLinearGradient(rawValue)) {
            valType = VALUE_TYPE_LINEAR_GRADIENT;
          } else if (isRadialGradient(rawValue)) {
            valType = VALUE_TYPE_RADIAL_GRADIENT;
          }
          value = parsedGradient;
        }
      }
      if (len2 === 0) {
        this.valType = valType;
      } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
        discrete = true;
      }
      this.discrete = this.discrete || discrete;
      var kf = {
        time: time2,
        value,
        rawValue,
        percent: 0
      };
      if (easing) {
        kf.easing = easing;
        kf.easingFunc = isFunction$1(easing) ? easing : easingFuncs[easing] || createCubicEasingFunc(easing);
      }
      keyframes.push(kf);
      return kf;
    };
    Track2.prototype.prepare = function(maxTime, additiveTrack) {
      var kfs = this.keyframes;
      if (this._needsSort) {
        kfs.sort(function(a2, b2) {
          return a2.time - b2.time;
        });
      }
      var valType = this.valType;
      var kfsLen = kfs.length;
      var lastKf = kfs[kfsLen - 1];
      var isDiscrete = this.discrete;
      var isArr = isArrayValueType(valType);
      var isGradient = isGradientValueType(valType);
      for (var i2 = 0; i2 < kfsLen; i2++) {
        var kf = kfs[i2];
        var value = kf.value;
        var lastValue = lastKf.value;
        kf.percent = kf.time / maxTime;
        if (!isDiscrete) {
          if (isArr && i2 !== kfsLen - 1) {
            fillArray(value, lastValue, valType);
          } else if (isGradient) {
            fillColorStops(value.colorStops, lastValue.colorStops);
          }
        }
      }
      if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
        this._additiveTrack = additiveTrack;
        var startValue = kfs[0].value;
        for (var i2 = 0; i2 < kfsLen; i2++) {
          if (valType === VALUE_TYPE_NUMBER) {
            kfs[i2].additiveValue = kfs[i2].value - startValue;
          } else if (valType === VALUE_TYPE_COLOR) {
            kfs[i2].additiveValue = add1DArray([], kfs[i2].value, startValue, -1);
          } else if (isArrayValueType(valType)) {
            kfs[i2].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i2].value, startValue, -1) : add2DArray([], kfs[i2].value, startValue, -1);
          }
        }
      }
    };
    Track2.prototype.step = function(target, percent) {
      if (this._finished) {
        return;
      }
      if (this._additiveTrack && this._additiveTrack._finished) {
        this._additiveTrack = null;
      }
      var isAdditive = this._additiveTrack != null;
      var valueKey = isAdditive ? "additiveValue" : "value";
      var valType = this.valType;
      var keyframes = this.keyframes;
      var kfsNum = keyframes.length;
      var propName = this.propName;
      var isValueColor = valType === VALUE_TYPE_COLOR;
      var frameIdx;
      var lastFrame = this._lastFr;
      var mathMin2 = Math.min;
      var frame;
      var nextFrame2;
      if (kfsNum === 1) {
        frame = nextFrame2 = keyframes[0];
      } else {
        if (percent < 0) {
          frameIdx = 0;
        } else if (percent < this._lastFrP) {
          var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
          for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
            if (keyframes[frameIdx].percent <= percent) {
              break;
            }
          }
          frameIdx = mathMin2(frameIdx, kfsNum - 2);
        } else {
          for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
            if (keyframes[frameIdx].percent > percent) {
              break;
            }
          }
          frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
        }
        nextFrame2 = keyframes[frameIdx + 1];
        frame = keyframes[frameIdx];
      }
      if (!(frame && nextFrame2)) {
        return;
      }
      this._lastFr = frameIdx;
      this._lastFrP = percent;
      var interval = nextFrame2.percent - frame.percent;
      var w2 = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
      if (nextFrame2.easingFunc) {
        w2 = nextFrame2.easingFunc(w2);
      }
      var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
      if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
        targetArr = this._additiveValue = [];
      }
      if (this.discrete) {
        target[propName] = w2 < 1 ? frame.rawValue : nextFrame2.rawValue;
      } else if (isArrayValueType(valType)) {
        valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2) : interpolate2DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2);
      } else if (isGradientValueType(valType)) {
        var val = frame[valueKey];
        var nextVal_1 = nextFrame2[valueKey];
        var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
        target[propName] = {
          type: isLinearGradient_1 ? "linear" : "radial",
          x: interpolateNumber$1(val.x, nextVal_1.x, w2),
          y: interpolateNumber$1(val.y, nextVal_1.y, w2),
          colorStops: map$1(val.colorStops, function(colorStop, idx) {
            var nextColorStop = nextVal_1.colorStops[idx];
            return {
              offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w2),
              color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w2))
            };
          }),
          global: nextVal_1.global
        };
        if (isLinearGradient_1) {
          target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w2);
          target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w2);
        } else {
          target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w2);
        }
      } else if (isValueColor) {
        interpolate1DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2);
        if (!isAdditive) {
          target[propName] = rgba2String(targetArr);
        }
      } else {
        var value = interpolateNumber$1(frame[valueKey], nextFrame2[valueKey], w2);
        if (isAdditive) {
          this._additiveValue = value;
        } else {
          target[propName] = value;
        }
      }
      if (isAdditive) {
        this._addToTarget(target);
      }
    };
    Track2.prototype._addToTarget = function(target) {
      var valType = this.valType;
      var propName = this.propName;
      var additiveValue = this._additiveValue;
      if (valType === VALUE_TYPE_NUMBER) {
        target[propName] = target[propName] + additiveValue;
      } else if (valType === VALUE_TYPE_COLOR) {
        parse(target[propName], tmpRgba);
        add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
        target[propName] = rgba2String(tmpRgba);
      } else if (valType === VALUE_TYPE_1D_ARRAY) {
        add1DArray(target[propName], target[propName], additiveValue, 1);
      } else if (valType === VALUE_TYPE_2D_ARRAY) {
        add2DArray(target[propName], target[propName], additiveValue, 1);
      }
    };
    return Track2;
  }();
  var Animator = function() {
    function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
      this._tracks = {};
      this._trackKeys = [];
      this._maxTime = 0;
      this._started = 0;
      this._clip = null;
      this._target = target;
      this._loop = loop;
      if (loop && additiveTo) {
        logError("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = additiveTo;
      this._allowDiscrete = allowDiscreteAnimation;
    }
    Animator2.prototype.getMaxTime = function() {
      return this._maxTime;
    };
    Animator2.prototype.getDelay = function() {
      return this._delay;
    };
    Animator2.prototype.getLoop = function() {
      return this._loop;
    };
    Animator2.prototype.getTarget = function() {
      return this._target;
    };
    Animator2.prototype.changeTarget = function(target) {
      this._target = target;
    };
    Animator2.prototype.when = function(time2, props2, easing) {
      return this.whenWithKeys(time2, props2, keys(props2), easing);
    };
    Animator2.prototype.whenWithKeys = function(time2, props2, propNames, easing) {
      var tracks = this._tracks;
      for (var i2 = 0; i2 < propNames.length; i2++) {
        var propName = propNames[i2];
        var track2 = tracks[propName];
        if (!track2) {
          track2 = tracks[propName] = new Track(propName);
          var initialValue = void 0;
          var additiveTrack = this._getAdditiveTrack(propName);
          if (additiveTrack) {
            var addtiveTrackKfs = additiveTrack.keyframes;
            var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
            initialValue = lastFinalKf && lastFinalKf.value;
            if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
              initialValue = rgba2String(initialValue);
            }
          } else {
            initialValue = this._target[propName];
          }
          if (initialValue == null) {
            continue;
          }
          if (time2 > 0) {
            track2.addKeyframe(0, cloneValue(initialValue), easing);
          }
          this._trackKeys.push(propName);
        }
        track2.addKeyframe(time2, cloneValue(props2[propName]), easing);
      }
      this._maxTime = Math.max(this._maxTime, time2);
      return this;
    };
    Animator2.prototype.pause = function() {
      this._clip.pause();
      this._paused = true;
    };
    Animator2.prototype.resume = function() {
      this._clip.resume();
      this._paused = false;
    };
    Animator2.prototype.isPaused = function() {
      return !!this._paused;
    };
    Animator2.prototype.duration = function(duration) {
      this._maxTime = duration;
      this._force = true;
      return this;
    };
    Animator2.prototype._doneCallback = function() {
      this._setTracksFinished();
      this._clip = null;
      var doneList = this._doneCbs;
      if (doneList) {
        var len2 = doneList.length;
        for (var i2 = 0; i2 < len2; i2++) {
          doneList[i2].call(this);
        }
      }
    };
    Animator2.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var animation = this.animation;
      var abortedList = this._abortedCbs;
      if (animation) {
        animation.removeClip(this._clip);
      }
      this._clip = null;
      if (abortedList) {
        for (var i2 = 0; i2 < abortedList.length; i2++) {
          abortedList[i2].call(this);
        }
      }
    };
    Animator2.prototype._setTracksFinished = function() {
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i2 = 0; i2 < tracksKeys.length; i2++) {
        tracks[tracksKeys[i2]].setFinished();
      }
    };
    Animator2.prototype._getAdditiveTrack = function(trackName) {
      var additiveTrack;
      var additiveAnimators = this._additiveAnimators;
      if (additiveAnimators) {
        for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
          var track2 = additiveAnimators[i2].getTrack(trackName);
          if (track2) {
            additiveTrack = track2;
          }
        }
      }
      return additiveTrack;
    };
    Animator2.prototype.start = function(easing) {
      if (this._started > 0) {
        return;
      }
      this._started = 1;
      var self2 = this;
      var tracks = [];
      var maxTime = this._maxTime || 0;
      for (var i2 = 0; i2 < this._trackKeys.length; i2++) {
        var propName = this._trackKeys[i2];
        var track2 = this._tracks[propName];
        var additiveTrack = this._getAdditiveTrack(propName);
        var kfs = track2.keyframes;
        var kfsNum = kfs.length;
        track2.prepare(maxTime, additiveTrack);
        if (track2.needsAnimate()) {
          if (!this._allowDiscrete && track2.discrete) {
            var lastKf = kfs[kfsNum - 1];
            if (lastKf) {
              self2._target[track2.propName] = lastKf.rawValue;
            }
            track2.setFinished();
          } else {
            tracks.push(track2);
          }
        }
      }
      if (tracks.length || this._force) {
        var clip2 = new Clip({
          life: maxTime,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(percent) {
            self2._started = 2;
            var additiveAnimators = self2._additiveAnimators;
            if (additiveAnimators) {
              var stillHasAdditiveAnimator = false;
              for (var i3 = 0; i3 < additiveAnimators.length; i3++) {
                if (additiveAnimators[i3]._clip) {
                  stillHasAdditiveAnimator = true;
                  break;
                }
              }
              if (!stillHasAdditiveAnimator) {
                self2._additiveAnimators = null;
              }
            }
            for (var i3 = 0; i3 < tracks.length; i3++) {
              tracks[i3].step(self2._target, percent);
            }
            var onframeList = self2._onframeCbs;
            if (onframeList) {
              for (var i3 = 0; i3 < onframeList.length; i3++) {
                onframeList[i3](self2._target, percent);
              }
            }
          },
          ondestroy: function() {
            self2._doneCallback();
          }
        });
        this._clip = clip2;
        if (this.animation) {
          this.animation.addClip(clip2);
        }
        if (easing) {
          clip2.setEasing(easing);
        }
      } else {
        this._doneCallback();
      }
      return this;
    };
    Animator2.prototype.stop = function(forwardToLast) {
      if (!this._clip) {
        return;
      }
      var clip2 = this._clip;
      if (forwardToLast) {
        clip2.onframe(1);
      }
      this._abortedCallback();
    };
    Animator2.prototype.delay = function(time2) {
      this._delay = time2;
      return this;
    };
    Animator2.prototype.during = function(cb) {
      if (cb) {
        if (!this._onframeCbs) {
          this._onframeCbs = [];
        }
        this._onframeCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.done = function(cb) {
      if (cb) {
        if (!this._doneCbs) {
          this._doneCbs = [];
        }
        this._doneCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.aborted = function(cb) {
      if (cb) {
        if (!this._abortedCbs) {
          this._abortedCbs = [];
        }
        this._abortedCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.getClip = function() {
      return this._clip;
    };
    Animator2.prototype.getTrack = function(propName) {
      return this._tracks[propName];
    };
    Animator2.prototype.getTracks = function() {
      var _this = this;
      return map$1(this._trackKeys, function(key2) {
        return _this._tracks[key2];
      });
    };
    Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
      if (!propNames.length || !this._clip) {
        return true;
      }
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i2 = 0; i2 < propNames.length; i2++) {
        var track2 = tracks[propNames[i2]];
        if (track2 && !track2.isFinished()) {
          if (forwardToLast) {
            track2.step(this._target, 1);
          } else if (this._started === 1) {
            track2.step(this._target, 0);
          }
          track2.setFinished();
        }
      }
      var allAborted = true;
      for (var i2 = 0; i2 < tracksKeys.length; i2++) {
        if (!tracks[tracksKeys[i2]].isFinished()) {
          allAborted = false;
          break;
        }
      }
      if (allAborted) {
        this._abortedCallback();
      }
      return allAborted;
    };
    Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
      if (!target) {
        return;
      }
      trackKeys = trackKeys || this._trackKeys;
      for (var i2 = 0; i2 < trackKeys.length; i2++) {
        var propName = trackKeys[i2];
        var track2 = this._tracks[propName];
        if (!track2 || track2.isFinished()) {
          continue;
        }
        var kfs = track2.keyframes;
        var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
        if (kf) {
          target[propName] = cloneValue(kf.rawValue);
        }
      }
    };
    Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
      trackKeys = trackKeys || keys(finalProps);
      for (var i2 = 0; i2 < trackKeys.length; i2++) {
        var propName = trackKeys[i2];
        var track2 = this._tracks[propName];
        if (!track2) {
          continue;
        }
        var kfs = track2.keyframes;
        if (kfs.length > 1) {
          var lastKf = kfs.pop();
          track2.addKeyframe(lastKf.time, finalProps[propName]);
          track2.prepare(this._maxTime, track2.getAdditiveTrack());
        }
      }
    };
    return Animator2;
  }();
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var Animation = function(_super) {
    __extends(Animation2, _super);
    function Animation2(opts) {
      var _this = _super.call(this) || this;
      _this._running = false;
      _this._time = 0;
      _this._pausedTime = 0;
      _this._pauseStart = 0;
      _this._paused = false;
      opts = opts || {};
      _this.stage = opts.stage || {};
      return _this;
    }
    Animation2.prototype.addClip = function(clip2) {
      if (clip2.animation) {
        this.removeClip(clip2);
      }
      if (!this._head) {
        this._head = this._tail = clip2;
      } else {
        this._tail.next = clip2;
        clip2.prev = this._tail;
        clip2.next = null;
        this._tail = clip2;
      }
      clip2.animation = this;
    };
    Animation2.prototype.addAnimator = function(animator) {
      animator.animation = this;
      var clip2 = animator.getClip();
      if (clip2) {
        this.addClip(clip2);
      }
    };
    Animation2.prototype.removeClip = function(clip2) {
      if (!clip2.animation) {
        return;
      }
      var prev2 = clip2.prev;
      var next2 = clip2.next;
      if (prev2) {
        prev2.next = next2;
      } else {
        this._head = next2;
      }
      if (next2) {
        next2.prev = prev2;
      } else {
        this._tail = prev2;
      }
      clip2.next = clip2.prev = clip2.animation = null;
    };
    Animation2.prototype.removeAnimator = function(animator) {
      var clip2 = animator.getClip();
      if (clip2) {
        this.removeClip(clip2);
      }
      animator.animation = null;
    };
    Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
      var time2 = getTime() - this._pausedTime;
      var delta = time2 - this._time;
      var clip2 = this._head;
      while (clip2) {
        var nextClip = clip2.next;
        var finished = clip2.step(time2, delta);
        if (finished) {
          clip2.ondestroy();
          this.removeClip(clip2);
          clip2 = nextClip;
        } else {
          clip2 = nextClip;
        }
      }
      this._time = time2;
      if (!notTriggerFrameAndStageUpdate) {
        this.trigger("frame", delta);
        this.stage.update && this.stage.update();
      }
    };
    Animation2.prototype._startLoop = function() {
      var self2 = this;
      this._running = true;
      function step() {
        if (self2._running) {
          requestAnimationFrame$1(step);
          !self2._paused && self2.update();
        }
      }
      requestAnimationFrame$1(step);
    };
    Animation2.prototype.start = function() {
      if (this._running) {
        return;
      }
      this._time = getTime();
      this._pausedTime = 0;
      this._startLoop();
    };
    Animation2.prototype.stop = function() {
      this._running = false;
    };
    Animation2.prototype.pause = function() {
      if (!this._paused) {
        this._pauseStart = getTime();
        this._paused = true;
      }
    };
    Animation2.prototype.resume = function() {
      if (this._paused) {
        this._pausedTime += getTime() - this._pauseStart;
        this._paused = false;
      }
    };
    Animation2.prototype.clear = function() {
      var clip2 = this._head;
      while (clip2) {
        var nextClip = clip2.next;
        clip2.prev = clip2.next = clip2.animation = null;
        clip2 = nextClip;
      }
      this._head = this._tail = null;
    };
    Animation2.prototype.isFinished = function() {
      return this._head == null;
    };
    Animation2.prototype.animate = function(target, options2) {
      options2 = options2 || {};
      this.start();
      var animator = new Animator(target, options2.loop);
      this.addAnimator(animator);
      return animator;
    };
    return Animation2;
  }(Eventful);
  var TOUCH_CLICK_DELAY = 300;
  var globalEventSupported = env.domSupported;
  var localNativeListenerNames = function() {
    var mouseHandlerNames = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ];
    var touchHandlerNames = [
      "touchstart",
      "touchend",
      "touchmove"
    ];
    var pointerEventNameMap = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    };
    var pointerHandlerNames = map$1(mouseHandlerNames, function(name) {
      var nm = name.replace("mouse", "pointer");
      return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
    });
    return {
      mouse: mouseHandlerNames,
      touch: touchHandlerNames,
      pointer: pointerHandlerNames
    };
  }();
  var globalNativeListenerNames = {
    mouse: ["mousemove", "mouseup"],
    pointer: ["pointermove", "pointerup"]
  };
  var wheelEventSupported = false;
  function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === "pen" || pointerType === "touch";
  }
  function setTouchTimer(scope) {
    scope.touching = true;
    if (scope.touchTimer != null) {
      clearTimeout(scope.touchTimer);
      scope.touchTimer = null;
    }
    scope.touchTimer = setTimeout(function() {
      scope.touching = false;
      scope.touchTimer = null;
    }, 700);
  }
  function markTouch(event) {
    event && (event.zrByTouch = true);
  }
  function normalizeGlobalEvent(instance, event) {
    return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
  }
  function isLocalEl(instance, el) {
    var elTmp = el;
    var isLocal = false;
    while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
      elTmp = elTmp.parentNode;
    }
    return isLocal;
  }
  var FakeGlobalEvent = /* @__PURE__ */ function() {
    function FakeGlobalEvent2(instance, event) {
      this.stopPropagation = noop$1;
      this.stopImmediatePropagation = noop$1;
      this.preventDefault = noop$1;
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType;
      this.clientX = event.clientX;
      this.clientY = event.clientY;
    }
    return FakeGlobalEvent2;
  }();
  var localDOMHandlers = {
    mousedown: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__mayPointerCapture = [event.zrX, event.zrY];
      this.trigger("mousedown", event);
    },
    mousemove: function(event) {
      event = normalizeEvent(this.dom, event);
      var downPoint = this.__mayPointerCapture;
      if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
        this.__togglePointerCapture(true);
      }
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
    },
    mouseout: function(event) {
      event = normalizeEvent(this.dom, event);
      var element = event.toElement || event.relatedTarget;
      if (!isLocalEl(this, element)) {
        if (this.__pointerCapturing) {
          event.zrEventControl = "no_globalout";
        }
        this.trigger("mouseout", event);
      }
    },
    wheel: function(event) {
      wheelEventSupported = true;
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    mousewheel: function(event) {
      if (wheelEventSupported) {
        return;
      }
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    touchstart: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.__lastTouchMoment = /* @__PURE__ */ new Date();
      this.handler.processGesture(event, "start");
      localDOMHandlers.mousemove.call(this, event);
      localDOMHandlers.mousedown.call(this, event);
    },
    touchmove: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "change");
      localDOMHandlers.mousemove.call(this, event);
    },
    touchend: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "end");
      localDOMHandlers.mouseup.call(this, event);
      if (+/* @__PURE__ */ new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
        localDOMHandlers.click.call(this, event);
      }
    },
    pointerdown: function(event) {
      localDOMHandlers.mousedown.call(this, event);
    },
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      localDOMHandlers.mouseup.call(this, event);
    },
    pointerout: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mouseout.call(this, event);
      }
    }
  };
  each$4(["click", "dblclick", "contextmenu"], function(name) {
    localDOMHandlers[name] = function(event) {
      event = normalizeEvent(this.dom, event);
      this.trigger(name, event);
    };
  });
  var globalDOMHandlers = {
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        globalDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      globalDOMHandlers.mouseup.call(this, event);
    },
    mousemove: function(event) {
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      var pointerCaptureReleasing = this.__pointerCapturing;
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
      if (pointerCaptureReleasing) {
        event.zrEventControl = "only_globalout";
        this.trigger("mouseout", event);
      }
    }
  };
  function mountLocalDOMEventListeners(instance, scope) {
    var domHandlers = scope.domHandlers;
    if (env.pointerEventsSupported) {
      each$4(localNativeListenerNames.pointer, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
        });
      });
    } else {
      if (env.touchEventsSupported) {
        each$4(localNativeListenerNames.touch, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            domHandlers[nativeEventName].call(instance, event);
            setTouchTimer(scope);
          });
        });
      }
      each$4(localNativeListenerNames.mouse, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          event = getNativeEvent(event);
          if (!scope.touching) {
            domHandlers[nativeEventName].call(instance, event);
          }
        });
      });
    }
  }
  function mountGlobalDOMEventListeners(instance, scope) {
    if (env.pointerEventsSupported) {
      each$4(globalNativeListenerNames.pointer, mount);
    } else if (!env.touchEventsSupported) {
      each$4(globalNativeListenerNames.mouse, mount);
    }
    function mount(nativeEventName) {
      function nativeEventListener(event) {
        event = getNativeEvent(event);
        if (!isLocalEl(instance, event.target)) {
          event = normalizeGlobalEvent(instance, event);
          scope.domHandlers[nativeEventName].call(instance, event);
        }
      }
      mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
    }
  }
  function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener;
    scope.listenerOpts[nativeEventName] = opt;
    addEventListener(scope.domTarget, nativeEventName, listener, opt);
  }
  function unmountDOMEventListeners(scope) {
    var mounted = scope.mounted;
    for (var nativeEventName in mounted) {
      if (mounted.hasOwnProperty(nativeEventName)) {
        removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
      }
    }
    scope.mounted = {};
  }
  var DOMHandlerScope = /* @__PURE__ */ function() {
    function DOMHandlerScope2(domTarget, domHandlers) {
      this.mounted = {};
      this.listenerOpts = {};
      this.touching = false;
      this.domTarget = domTarget;
      this.domHandlers = domHandlers;
    }
    return DOMHandlerScope2;
  }();
  var HandlerDomProxy = function(_super) {
    __extends(HandlerDomProxy2, _super);
    function HandlerDomProxy2(dom, painterRoot) {
      var _this = _super.call(this) || this;
      _this.__pointerCapturing = false;
      _this.dom = dom;
      _this.painterRoot = painterRoot;
      _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
      if (globalEventSupported) {
        _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      mountLocalDOMEventListeners(_this, _this._localHandlerScope);
      return _this;
    }
    HandlerDomProxy2.prototype.dispose = function() {
      unmountDOMEventListeners(this._localHandlerScope);
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };
    HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
    };
    HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
      this.__mayPointerCapture = null;
      if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
        this.__pointerCapturing = isPointerCapturing;
        var globalHandlerScope = this._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    };
    return HandlerDomProxy2;
  }(Eventful);
  var dpr = 1;
  if (env.hasGlobalWindow) {
    dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
  }
  var devicePixelRatio = dpr;
  var DARK_MODE_THRESHOLD = 0.4;
  var DARK_LABEL_COLOR = "#333";
  var LIGHT_LABEL_COLOR = "#ccc";
  var LIGHTER_LABEL_COLOR = "#eee";
  var mIdentity = identity;
  var EPSILON$2 = 5e-5;
  function isNotAroundZero(val) {
    return val > EPSILON$2 || val < -EPSILON$2;
  }
  var scaleTmp = [];
  var tmpTransform = [];
  var originTransform = create();
  var abs = Math.abs;
  var Transformable = function() {
    function Transformable2() {
    }
    Transformable2.prototype.getLocalTransform = function(m2) {
      return Transformable2.getLocalTransform(this, m2);
    };
    Transformable2.prototype.setPosition = function(arr) {
      this.x = arr[0];
      this.y = arr[1];
    };
    Transformable2.prototype.setScale = function(arr) {
      this.scaleX = arr[0];
      this.scaleY = arr[1];
    };
    Transformable2.prototype.setSkew = function(arr) {
      this.skewX = arr[0];
      this.skewY = arr[1];
    };
    Transformable2.prototype.setOrigin = function(arr) {
      this.originX = arr[0];
      this.originY = arr[1];
    };
    Transformable2.prototype.needLocalTransform = function() {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
    };
    Transformable2.prototype.updateTransform = function() {
      var parentTransform = this.parent && this.parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m2 = this.transform;
      if (!(needLocalTransform || parentTransform)) {
        if (m2) {
          mIdentity(m2);
          this.invTransform = null;
        }
        return;
      }
      m2 = m2 || create();
      if (needLocalTransform) {
        this.getLocalTransform(m2);
      } else {
        mIdentity(m2);
      }
      if (parentTransform) {
        if (needLocalTransform) {
          mul(m2, parentTransform, m2);
        } else {
          copy(m2, parentTransform);
        }
      }
      this.transform = m2;
      this._resolveGlobalScaleRatio(m2);
    };
    Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
      var globalScaleRatio = this.globalScaleRatio;
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m2[0] *= sx;
        m2[1] *= sx;
        m2[2] *= sy;
        m2[3] *= sy;
      }
      this.invTransform = this.invTransform || create();
      invert(this.invTransform, m2);
    };
    Transformable2.prototype.getComputedTransform = function() {
      var transformNode = this;
      var ancestors = [];
      while (transformNode) {
        ancestors.push(transformNode);
        transformNode = transformNode.parent;
      }
      while (transformNode = ancestors.pop()) {
        transformNode.updateTransform();
      }
      return this.transform;
    };
    Transformable2.prototype.setLocalTransform = function(m2) {
      if (!m2) {
        return;
      }
      var sx = m2[0] * m2[0] + m2[1] * m2[1];
      var sy = m2[2] * m2[2] + m2[3] * m2[3];
      var rotation = Math.atan2(m2[1], m2[0]);
      var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
      sy = Math.sqrt(sy) * Math.cos(shearX);
      sx = Math.sqrt(sx);
      this.skewX = shearX;
      this.skewY = 0;
      this.rotation = -rotation;
      this.x = +m2[4];
      this.y = +m2[5];
      this.scaleX = sx;
      this.scaleY = sy;
      this.originX = 0;
      this.originY = 0;
    };
    Transformable2.prototype.decomposeTransform = function() {
      if (!this.transform) {
        return;
      }
      var parent2 = this.parent;
      var m2 = this.transform;
      if (parent2 && parent2.transform) {
        parent2.invTransform = parent2.invTransform || create();
        mul(tmpTransform, parent2.invTransform, m2);
        m2 = tmpTransform;
      }
      var ox = this.originX;
      var oy = this.originY;
      if (ox || oy) {
        originTransform[4] = ox;
        originTransform[5] = oy;
        mul(tmpTransform, m2, originTransform);
        tmpTransform[4] -= ox;
        tmpTransform[5] -= oy;
        m2 = tmpTransform;
      }
      this.setLocalTransform(m2);
    };
    Transformable2.prototype.getGlobalScale = function(out2) {
      var m2 = this.transform;
      out2 = out2 || [];
      if (!m2) {
        out2[0] = 1;
        out2[1] = 1;
        return out2;
      }
      out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
      out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
      if (m2[0] < 0) {
        out2[0] = -out2[0];
      }
      if (m2[3] < 0) {
        out2[1] = -out2[1];
      }
      return out2;
    };
    Transformable2.prototype.transformCoordToLocal = function(x2, y2) {
      var v2 = [x2, y2];
      var invTransform = this.invTransform;
      if (invTransform) {
        applyTransform$1(v2, v2, invTransform);
      }
      return v2;
    };
    Transformable2.prototype.transformCoordToGlobal = function(x2, y2) {
      var v2 = [x2, y2];
      var transform2 = this.transform;
      if (transform2) {
        applyTransform$1(v2, v2, transform2);
      }
      return v2;
    };
    Transformable2.prototype.getLineScale = function() {
      var m2 = this.transform;
      return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
    };
    Transformable2.prototype.copyTransform = function(source) {
      copyTransform(this, source);
    };
    Transformable2.getLocalTransform = function(target, m2) {
      m2 = m2 || [];
      var ox = target.originX || 0;
      var oy = target.originY || 0;
      var sx = target.scaleX;
      var sy = target.scaleY;
      var ax = target.anchorX;
      var ay = target.anchorY;
      var rotation = target.rotation || 0;
      var x2 = target.x;
      var y2 = target.y;
      var skewX = target.skewX ? Math.tan(target.skewX) : 0;
      var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
      if (ox || oy || ax || ay) {
        var dx = ox + ax;
        var dy = oy + ay;
        m2[4] = -dx * sx - skewX * dy * sy;
        m2[5] = -dy * sy - skewY * dx * sx;
      } else {
        m2[4] = m2[5] = 0;
      }
      m2[0] = sx;
      m2[3] = sy;
      m2[1] = skewY * sx;
      m2[2] = skewX * sy;
      rotation && rotate(m2, m2, rotation);
      m2[4] += ox + x2;
      m2[5] += oy + y2;
      return m2;
    };
    Transformable2.initDefaultProps = function() {
      var proto2 = Transformable2.prototype;
      proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
      proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
    }();
    return Transformable2;
  }();
  var TRANSFORMABLE_PROPS = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function copyTransform(target, source) {
    for (var i2 = 0; i2 < TRANSFORMABLE_PROPS.length; i2++) {
      var propName = TRANSFORMABLE_PROPS[i2];
      target[propName] = source[propName];
    }
  }
  var textWidthCache = {};
  function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var cacheOfFont = textWidthCache[font];
    if (!cacheOfFont) {
      cacheOfFont = textWidthCache[font] = new LRU(500);
    }
    var width = cacheOfFont.get(text);
    if (width == null) {
      width = platformApi.measureText(text, font).width;
      cacheOfFont.put(text, width);
    }
    return width;
  }
  function innerGetBoundingRect(text, font, textAlign, textBaseline) {
    var width = getWidth(text, font);
    var height = getLineHeight(font);
    var x2 = adjustTextX(0, width, textAlign);
    var y2 = adjustTextY(0, height, textBaseline);
    var rect = new BoundingRect(x2, y2, width, height);
    return rect;
  }
  function getBoundingRect(text, font, textAlign, textBaseline) {
    var textLines = ((text || "") + "").split("\n");
    var len2 = textLines.length;
    if (len2 === 1) {
      return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
    } else {
      var uniondRect = new BoundingRect(0, 0, 0, 0);
      for (var i2 = 0; i2 < textLines.length; i2++) {
        var rect = innerGetBoundingRect(textLines[i2], font, textAlign, textBaseline);
        i2 === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
      }
      return uniondRect;
    }
  }
  function adjustTextX(x2, width, textAlign) {
    if (textAlign === "right") {
      x2 -= width;
    } else if (textAlign === "center") {
      x2 -= width / 2;
    }
    return x2;
  }
  function adjustTextY(y2, height, verticalAlign) {
    if (verticalAlign === "middle") {
      y2 -= height / 2;
    } else if (verticalAlign === "bottom") {
      y2 -= height;
    }
    return y2;
  }
  function getLineHeight(font) {
    return getWidth("国", font);
  }
  function parsePercent$1(value, maxValue) {
    if (typeof value === "string") {
      if (value.lastIndexOf("%") >= 0) {
        return parseFloat(value) / 100 * maxValue;
      }
      return parseFloat(value);
    }
    return value;
  }
  function calculateTextPosition(out2, opts, rect) {
    var textPosition = opts.position || "inside";
    var distance2 = opts.distance != null ? opts.distance : 5;
    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;
    var x2 = rect.x;
    var y2 = rect.y;
    var textAlign = "left";
    var textVerticalAlign = "top";
    if (textPosition instanceof Array) {
      x2 += parsePercent$1(textPosition[0], rect.width);
      y2 += parsePercent$1(textPosition[1], rect.height);
      textAlign = null;
      textVerticalAlign = null;
    } else {
      switch (textPosition) {
        case "left":
          x2 -= distance2;
          y2 += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "right":
          x2 += distance2 + width;
          y2 += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "top":
          x2 += width / 2;
          y2 -= distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "bottom":
          x2 += width / 2;
          y2 += height + distance2;
          textAlign = "center";
          break;
        case "inside":
          x2 += width / 2;
          y2 += halfHeight;
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "insideLeft":
          x2 += distance2;
          y2 += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "insideRight":
          x2 += width - distance2;
          y2 += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideTop":
          x2 += width / 2;
          y2 += distance2;
          textAlign = "center";
          break;
        case "insideBottom":
          x2 += width / 2;
          y2 += height - distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideTopLeft":
          x2 += distance2;
          y2 += distance2;
          break;
        case "insideTopRight":
          x2 += width - distance2;
          y2 += distance2;
          textAlign = "right";
          break;
        case "insideBottomLeft":
          x2 += distance2;
          y2 += height - distance2;
          textVerticalAlign = "bottom";
          break;
        case "insideBottomRight":
          x2 += width - distance2;
          y2 += height - distance2;
          textAlign = "right";
          textVerticalAlign = "bottom";
          break;
      }
    }
    out2 = out2 || {};
    out2.x = x2;
    out2.y = y2;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  }
  var PRESERVED_NORMAL_STATE = "__zr_normal__";
  var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
  var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj2, key2) {
    obj2[key2] = true;
    return obj2;
  }, { ignore: false });
  var tmpTextPosCalcRes = {};
  var tmpBoundingRect = new BoundingRect(0, 0, 0, 0);
  var Element$1 = function() {
    function Element2(props2) {
      this.id = guid();
      this.animators = [];
      this.currentStates = [];
      this.states = {};
      this._init(props2);
    }
    Element2.prototype._init = function(props2) {
      this.attr(props2);
    };
    Element2.prototype.drift = function(dx, dy, e2) {
      switch (this.draggable) {
        case "horizontal":
          dy = 0;
          break;
        case "vertical":
          dx = 0;
          break;
      }
      var m2 = this.transform;
      if (!m2) {
        m2 = this.transform = [1, 0, 0, 1, 0, 0];
      }
      m2[4] += dx;
      m2[5] += dy;
      this.decomposeTransform();
      this.markRedraw();
    };
    Element2.prototype.beforeUpdate = function() {
    };
    Element2.prototype.afterUpdate = function() {
    };
    Element2.prototype.update = function() {
      this.updateTransform();
      if (this.__dirty) {
        this.updateInnerText();
      }
    };
    Element2.prototype.updateInnerText = function(forceUpdate) {
      var textEl = this._textContent;
      if (textEl && (!textEl.ignore || forceUpdate)) {
        if (!this.textConfig) {
          this.textConfig = {};
        }
        var textConfig = this.textConfig;
        var isLocal = textConfig.local;
        var innerTransformable = textEl.innerTransformable;
        var textAlign = void 0;
        var textVerticalAlign = void 0;
        var textStyleChanged = false;
        innerTransformable.parent = isLocal ? this : null;
        var innerOrigin = false;
        innerTransformable.copyTransform(textEl);
        if (textConfig.position != null) {
          var layoutRect = tmpBoundingRect;
          if (textConfig.layoutRect) {
            layoutRect.copy(textConfig.layoutRect);
          } else {
            layoutRect.copy(this.getBoundingRect());
          }
          if (!isLocal) {
            layoutRect.applyTransform(this.transform);
          }
          if (this.calculateTextPosition) {
            this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          } else {
            calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          }
          innerTransformable.x = tmpTextPosCalcRes.x;
          innerTransformable.y = tmpTextPosCalcRes.y;
          textAlign = tmpTextPosCalcRes.align;
          textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
          var textOrigin = textConfig.origin;
          if (textOrigin && textConfig.rotation != null) {
            var relOriginX = void 0;
            var relOriginY = void 0;
            if (textOrigin === "center") {
              relOriginX = layoutRect.width * 0.5;
              relOriginY = layoutRect.height * 0.5;
            } else {
              relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
              relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
            }
            innerOrigin = true;
            innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
            innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
          }
        }
        if (textConfig.rotation != null) {
          innerTransformable.rotation = textConfig.rotation;
        }
        var textOffset = textConfig.offset;
        if (textOffset) {
          innerTransformable.x += textOffset[0];
          innerTransformable.y += textOffset[1];
          if (!innerOrigin) {
            innerTransformable.originX = -textOffset[0];
            innerTransformable.originY = -textOffset[1];
          }
        }
        var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
        var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
        var textFill = void 0;
        var textStroke = void 0;
        var autoStroke = void 0;
        if (isInside && this.canBeInsideText()) {
          textFill = textConfig.insideFill;
          textStroke = textConfig.insideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getInsideTextFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getInsideTextStroke(textFill);
            autoStroke = true;
          }
        } else {
          textFill = textConfig.outsideFill;
          textStroke = textConfig.outsideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getOutsideFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getOutsideStroke(textFill);
            autoStroke = true;
          }
        }
        textFill = textFill || "#000";
        if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
          textStyleChanged = true;
          innerTextDefaultStyle.fill = textFill;
          innerTextDefaultStyle.stroke = textStroke;
          innerTextDefaultStyle.autoStroke = autoStroke;
          innerTextDefaultStyle.align = textAlign;
          innerTextDefaultStyle.verticalAlign = textVerticalAlign;
          textEl.setDefaultTextStyle(innerTextDefaultStyle);
        }
        textEl.__dirty |= REDRAW_BIT;
        if (textStyleChanged) {
          textEl.dirtyStyle(true);
        }
      }
    };
    Element2.prototype.canBeInsideText = function() {
      return true;
    };
    Element2.prototype.getInsideTextFill = function() {
      return "#fff";
    };
    Element2.prototype.getInsideTextStroke = function(textFill) {
      return "#000";
    };
    Element2.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
    };
    Element2.prototype.getOutsideStroke = function(textFill) {
      var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
      var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
      if (!colorArr) {
        colorArr = [255, 255, 255, 1];
      }
      var alpha = colorArr[3];
      var isDark = this.__zr.isDarkMode();
      for (var i2 = 0; i2 < 3; i2++) {
        colorArr[i2] = colorArr[i2] * alpha + (isDark ? 0 : 255) * (1 - alpha);
      }
      colorArr[3] = 1;
      return stringify(colorArr, "rgba");
    };
    Element2.prototype.traverse = function(cb, context) {
    };
    Element2.prototype.attrKV = function(key2, value) {
      if (key2 === "textConfig") {
        this.setTextConfig(value);
      } else if (key2 === "textContent") {
        this.setTextContent(value);
      } else if (key2 === "clipPath") {
        this.setClipPath(value);
      } else if (key2 === "extra") {
        this.extra = this.extra || {};
        extend$1(this.extra, value);
      } else {
        this[key2] = value;
      }
    };
    Element2.prototype.hide = function() {
      this.ignore = true;
      this.markRedraw();
    };
    Element2.prototype.show = function() {
      this.ignore = false;
      this.markRedraw();
    };
    Element2.prototype.attr = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.attrKV(keyOrObj, value);
      } else if (isObject$3(keyOrObj)) {
        var obj2 = keyOrObj;
        var keysArr = keys(obj2);
        for (var i2 = 0; i2 < keysArr.length; i2++) {
          var key2 = keysArr[i2];
          this.attrKV(key2, keyOrObj[key2]);
        }
      }
      this.markRedraw();
      return this;
    };
    Element2.prototype.saveCurrentToNormalState = function(toState) {
      this._innerSaveToNormal(toState);
      var normalState = this._normalState;
      for (var i2 = 0; i2 < this.animators.length; i2++) {
        var animator = this.animators[i2];
        var fromStateTransition = animator.__fromStateTransition;
        if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
          continue;
        }
        var targetName = animator.targetName;
        var target = targetName ? normalState[targetName] : normalState;
        animator.saveTo(target);
      }
    };
    Element2.prototype._innerSaveToNormal = function(toState) {
      var normalState = this._normalState;
      if (!normalState) {
        normalState = this._normalState = {};
      }
      if (toState.textConfig && !normalState.textConfig) {
        normalState.textConfig = this.textConfig;
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
    };
    Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
      for (var i2 = 0; i2 < primaryKeys.length; i2++) {
        var key2 = primaryKeys[i2];
        if (toState[key2] != null && !(key2 in normalState)) {
          normalState[key2] = this[key2];
        }
      }
    };
    Element2.prototype.hasState = function() {
      return this.currentStates.length > 0;
    };
    Element2.prototype.getState = function(name) {
      return this.states[name];
    };
    Element2.prototype.ensureState = function(name) {
      var states = this.states;
      if (!states[name]) {
        states[name] = {};
      }
      return states[name];
    };
    Element2.prototype.clearStates = function(noAnimation) {
      this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
    };
    Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
      var toNormalState = stateName === PRESERVED_NORMAL_STATE;
      var hasStates = this.hasState();
      if (!hasStates && toNormalState) {
        return;
      }
      var currentStates = this.currentStates;
      var animationCfg = this.stateTransition;
      if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
        return;
      }
      var state;
      if (this.stateProxy && !toNormalState) {
        state = this.stateProxy(stateName);
      }
      if (!state) {
        state = this.states && this.states[stateName];
      }
      if (!state && !toNormalState) {
        logError("State " + stateName + " not exists.");
        return;
      }
      if (!toNormalState) {
        this.saveCurrentToNormalState(state);
      }
      var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (toNormalState) {
        this.currentStates = [];
        this._normalState = {};
      } else {
        if (!keepCurrentStates) {
          this.currentStates = [stateName];
        } else {
          this.currentStates.push(stateName);
        }
      }
      this._updateAnimationTargets();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
      return state;
    };
    Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
      if (!states.length) {
        this.clearStates();
      } else {
        var stateObjects = [];
        var currentStates = this.currentStates;
        var len2 = states.length;
        var notChange = len2 === currentStates.length;
        if (notChange) {
          for (var i2 = 0; i2 < len2; i2++) {
            if (states[i2] !== currentStates[i2]) {
              notChange = false;
              break;
            }
          }
        }
        if (notChange) {
          return;
        }
        for (var i2 = 0; i2 < len2; i2++) {
          var stateName = states[i2];
          var stateObj = void 0;
          if (this.stateProxy) {
            stateObj = this.stateProxy(stateName, states);
          }
          if (!stateObj) {
            stateObj = this.states[stateName];
          }
          if (stateObj) {
            stateObjects.push(stateObj);
          }
        }
        var lastStateObj = stateObjects[len2 - 1];
        var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
        if (useHoverLayer) {
          this._toggleHoverLayerFlag(true);
        }
        var mergedState = this._mergeStates(stateObjects);
        var animationCfg = this.stateTransition;
        this.saveCurrentToNormalState(mergedState);
        this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
        var textContent = this._textContent;
        var textGuide = this._textGuide;
        if (textContent) {
          textContent.useStates(states, noAnimation, useHoverLayer);
        }
        if (textGuide) {
          textGuide.useStates(states, noAnimation, useHoverLayer);
        }
        this._updateAnimationTargets();
        this.currentStates = states.slice();
        this.markRedraw();
        if (!useHoverLayer && this.__inHover) {
          this._toggleHoverLayerFlag(false);
          this.__dirty &= ~REDRAW_BIT;
        }
      }
    };
    Element2.prototype.isSilent = function() {
      var isSilent = this.silent;
      var ancestor = this.parent;
      while (!isSilent && ancestor) {
        if (ancestor.silent) {
          isSilent = true;
          break;
        }
        ancestor = ancestor.parent;
      }
      return isSilent;
    };
    Element2.prototype._updateAnimationTargets = function() {
      for (var i2 = 0; i2 < this.animators.length; i2++) {
        var animator = this.animators[i2];
        if (animator.targetName) {
          animator.changeTarget(this[animator.targetName]);
        }
      }
    };
    Element2.prototype.removeState = function(state) {
      var idx = indexOf(this.currentStates, state);
      if (idx >= 0) {
        var currentStates = this.currentStates.slice();
        currentStates.splice(idx, 1);
        this.useStates(currentStates);
      }
    };
    Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
      var currentStates = this.currentStates.slice();
      var idx = indexOf(currentStates, oldState);
      var newStateExists = indexOf(currentStates, newState) >= 0;
      if (idx >= 0) {
        if (!newStateExists) {
          currentStates[idx] = newState;
        } else {
          currentStates.splice(idx, 1);
        }
      } else if (forceAdd && !newStateExists) {
        currentStates.push(newState);
      }
      this.useStates(currentStates);
    };
    Element2.prototype.toggleState = function(state, enable) {
      if (enable) {
        this.useState(state, true);
      } else {
        this.removeState(state);
      }
    };
    Element2.prototype._mergeStates = function(states) {
      var mergedState = {};
      var mergedTextConfig;
      for (var i2 = 0; i2 < states.length; i2++) {
        var state = states[i2];
        extend$1(mergedState, state);
        if (state.textConfig) {
          mergedTextConfig = mergedTextConfig || {};
          extend$1(mergedTextConfig, state.textConfig);
        }
      }
      if (mergedTextConfig) {
        mergedState.textConfig = mergedTextConfig;
      }
      return mergedState;
    };
    Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      var needsRestoreToNormal = !(state && keepCurrentStates);
      if (state && state.textConfig) {
        this.textConfig = extend$1({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
        extend$1(this.textConfig, state.textConfig);
      } else if (needsRestoreToNormal) {
        if (normalState.textConfig) {
          this.textConfig = normalState.textConfig;
        }
      }
      var transitionTarget = {};
      var hasTransition = false;
      for (var i2 = 0; i2 < PRIMARY_STATES_KEYS$1.length; i2++) {
        var key2 = PRIMARY_STATES_KEYS$1[i2];
        var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key2];
        if (state && state[key2] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key2] = state[key2];
          } else {
            this[key2] = state[key2];
          }
        } else if (needsRestoreToNormal) {
          if (normalState[key2] != null) {
            if (propNeedsTransition) {
              hasTransition = true;
              transitionTarget[key2] = normalState[key2];
            } else {
              this[key2] = normalState[key2];
            }
          }
        }
      }
      if (!transition) {
        for (var i2 = 0; i2 < this.animators.length; i2++) {
          var animator = this.animators[i2];
          var targetName = animator.targetName;
          if (!animator.getLoop()) {
            animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
          }
        }
      }
      if (hasTransition) {
        this._transitionState(stateName, transitionTarget, animationCfg);
      }
    };
    Element2.prototype._attachComponent = function(componentEl) {
      if (componentEl.__zr && !componentEl.__hostTarget) {
        return;
      }
      if (componentEl === this) {
        return;
      }
      var zr = this.__zr;
      if (zr) {
        componentEl.addSelfToZr(zr);
      }
      componentEl.__zr = zr;
      componentEl.__hostTarget = this;
    };
    Element2.prototype._detachComponent = function(componentEl) {
      if (componentEl.__zr) {
        componentEl.removeSelfFromZr(componentEl.__zr);
      }
      componentEl.__zr = null;
      componentEl.__hostTarget = null;
    };
    Element2.prototype.getClipPath = function() {
      return this._clipPath;
    };
    Element2.prototype.setClipPath = function(clipPath) {
      if (this._clipPath && this._clipPath !== clipPath) {
        this.removeClipPath();
      }
      this._attachComponent(clipPath);
      this._clipPath = clipPath;
      this.markRedraw();
    };
    Element2.prototype.removeClipPath = function() {
      var clipPath = this._clipPath;
      if (clipPath) {
        this._detachComponent(clipPath);
        this._clipPath = null;
        this.markRedraw();
      }
    };
    Element2.prototype.getTextContent = function() {
      return this._textContent;
    };
    Element2.prototype.setTextContent = function(textEl) {
      var previousTextContent = this._textContent;
      if (previousTextContent === textEl) {
        return;
      }
      if (previousTextContent && previousTextContent !== textEl) {
        this.removeTextContent();
      }
      textEl.innerTransformable = new Transformable();
      this._attachComponent(textEl);
      this._textContent = textEl;
      this.markRedraw();
    };
    Element2.prototype.setTextConfig = function(cfg) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      extend$1(this.textConfig, cfg);
      this.markRedraw();
    };
    Element2.prototype.removeTextConfig = function() {
      this.textConfig = null;
      this.markRedraw();
    };
    Element2.prototype.removeTextContent = function() {
      var textEl = this._textContent;
      if (textEl) {
        textEl.innerTransformable = null;
        this._detachComponent(textEl);
        this._textContent = null;
        this._innerTextDefaultStyle = null;
        this.markRedraw();
      }
    };
    Element2.prototype.getTextGuideLine = function() {
      return this._textGuide;
    };
    Element2.prototype.setTextGuideLine = function(guideLine) {
      if (this._textGuide && this._textGuide !== guideLine) {
        this.removeTextGuideLine();
      }
      this._attachComponent(guideLine);
      this._textGuide = guideLine;
      this.markRedraw();
    };
    Element2.prototype.removeTextGuideLine = function() {
      var textGuide = this._textGuide;
      if (textGuide) {
        this._detachComponent(textGuide);
        this._textGuide = null;
        this.markRedraw();
      }
    };
    Element2.prototype.markRedraw = function() {
      this.__dirty |= REDRAW_BIT;
      var zr = this.__zr;
      if (zr) {
        if (this.__inHover) {
          zr.refreshHover();
        } else {
          zr.refresh();
        }
      }
      if (this.__hostTarget) {
        this.__hostTarget.markRedraw();
      }
    };
    Element2.prototype.dirty = function() {
      this.markRedraw();
    };
    Element2.prototype._toggleHoverLayerFlag = function(inHover) {
      this.__inHover = inHover;
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.__inHover = inHover;
      }
      if (textGuide) {
        textGuide.__inHover = inHover;
      }
    };
    Element2.prototype.addSelfToZr = function(zr) {
      if (this.__zr === zr) {
        return;
      }
      this.__zr = zr;
      var animators = this.animators;
      if (animators) {
        for (var i2 = 0; i2 < animators.length; i2++) {
          zr.animation.addAnimator(animators[i2]);
        }
      }
      if (this._clipPath) {
        this._clipPath.addSelfToZr(zr);
      }
      if (this._textContent) {
        this._textContent.addSelfToZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.addSelfToZr(zr);
      }
    };
    Element2.prototype.removeSelfFromZr = function(zr) {
      if (!this.__zr) {
        return;
      }
      this.__zr = null;
      var animators = this.animators;
      if (animators) {
        for (var i2 = 0; i2 < animators.length; i2++) {
          zr.animation.removeAnimator(animators[i2]);
        }
      }
      if (this._clipPath) {
        this._clipPath.removeSelfFromZr(zr);
      }
      if (this._textContent) {
        this._textContent.removeSelfFromZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.removeSelfFromZr(zr);
      }
    };
    Element2.prototype.animate = function(key2, loop, allowDiscreteAnimation) {
      var target = key2 ? this[key2] : this;
      var animator = new Animator(target, loop, allowDiscreteAnimation);
      key2 && (animator.targetName = key2);
      this.addAnimator(animator, key2);
      return animator;
    };
    Element2.prototype.addAnimator = function(animator, key2) {
      var zr = this.__zr;
      var el = this;
      animator.during(function() {
        el.updateDuringAnimation(key2);
      }).done(function() {
        var animators = el.animators;
        var idx = indexOf(animators, animator);
        if (idx >= 0) {
          animators.splice(idx, 1);
        }
      });
      this.animators.push(animator);
      if (zr) {
        zr.animation.addAnimator(animator);
      }
      zr && zr.wakeUp();
    };
    Element2.prototype.updateDuringAnimation = function(key2) {
      this.markRedraw();
    };
    Element2.prototype.stopAnimation = function(scope, forwardToLast) {
      var animators = this.animators;
      var len2 = animators.length;
      var leftAnimators = [];
      for (var i2 = 0; i2 < len2; i2++) {
        var animator = animators[i2];
        if (!scope || scope === animator.scope) {
          animator.stop(forwardToLast);
        } else {
          leftAnimators.push(animator);
        }
      }
      this.animators = leftAnimators;
      return this;
    };
    Element2.prototype.animateTo = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps);
    };
    Element2.prototype.animateFrom = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps, true);
    };
    Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
      var animators = animateTo(this, target, cfg, animationProps);
      for (var i2 = 0; i2 < animators.length; i2++) {
        animators[i2].__fromStateTransition = stateName;
      }
    };
    Element2.prototype.getBoundingRect = function() {
      return null;
    };
    Element2.prototype.getPaintRect = function() {
      return null;
    };
    Element2.initDefaultProps = function() {
      var elProto = Element2.prototype;
      elProto.type = "element";
      elProto.name = "";
      elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
      elProto.__dirty = REDRAW_BIT;
      function createLegacyProperty(key2, privateKey, xKey, yKey) {
        Object.defineProperty(elProto, key2, {
          get: function() {
            if (!this[privateKey]) {
              var pos = this[privateKey] = [];
              enhanceArray(this, pos);
            }
            return this[privateKey];
          },
          set: function(pos) {
            this[xKey] = pos[0];
            this[yKey] = pos[1];
            this[privateKey] = pos;
            enhanceArray(this, pos);
          }
        });
        function enhanceArray(self2, pos) {
          Object.defineProperty(pos, 0, {
            get: function() {
              return self2[xKey];
            },
            set: function(val) {
              self2[xKey] = val;
            }
          });
          Object.defineProperty(pos, 1, {
            get: function() {
              return self2[yKey];
            },
            set: function(val) {
              self2[yKey] = val;
            }
          });
        }
      }
      if (Object.defineProperty) {
        createLegacyProperty("position", "_legacyPos", "x", "y");
        createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
        createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
      }
    }();
    return Element2;
  }();
  mixin(Element$1, Eventful);
  mixin(Element$1, Transformable);
  function animateTo(animatable, target, cfg, animationProps, reverse2) {
    cfg = cfg || {};
    var animators = [];
    animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
    var finishCount = animators.length;
    var doneHappened = false;
    var cfgDone = cfg.done;
    var cfgAborted = cfg.aborted;
    var doneCb = function() {
      doneHappened = true;
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    var abortedCb = function() {
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    if (!finishCount) {
      cfgDone && cfgDone();
    }
    if (animators.length > 0 && cfg.during) {
      animators[0].during(function(target2, percent) {
        cfg.during(percent);
      });
    }
    for (var i2 = 0; i2 < animators.length; i2++) {
      var animator = animators[i2];
      if (doneCb) {
        animator.done(doneCb);
      }
      if (abortedCb) {
        animator.aborted(abortedCb);
      }
      if (cfg.force) {
        animator.duration(cfg.duration);
      }
      animator.start(cfg.easing);
    }
    return animators;
  }
  function copyArrShallow(source, target, len2) {
    for (var i2 = 0; i2 < len2; i2++) {
      source[i2] = target[i2];
    }
  }
  function is2DArray(value) {
    return isArrayLike(value[0]);
  }
  function copyValue(target, source, key2) {
    if (isArrayLike(source[key2])) {
      if (!isArrayLike(target[key2])) {
        target[key2] = [];
      }
      if (isTypedArray$1(source[key2])) {
        var len2 = source[key2].length;
        if (target[key2].length !== len2) {
          target[key2] = new source[key2].constructor(len2);
          copyArrShallow(target[key2], source[key2], len2);
        }
      } else {
        var sourceArr = source[key2];
        var targetArr = target[key2];
        var len0 = sourceArr.length;
        if (is2DArray(sourceArr)) {
          var len1 = sourceArr[0].length;
          for (var i2 = 0; i2 < len0; i2++) {
            if (!targetArr[i2]) {
              targetArr[i2] = Array.prototype.slice.call(sourceArr[i2]);
            } else {
              copyArrShallow(targetArr[i2], sourceArr[i2], len1);
            }
          }
        } else {
          copyArrShallow(targetArr, sourceArr, len0);
        }
        targetArr.length = sourceArr.length;
      }
    } else {
      target[key2] = source[key2];
    }
  }
  function isValueSame(val1, val2) {
    return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
  }
  function is1DArraySame(arr0, arr1) {
    var len2 = arr0.length;
    if (len2 !== arr1.length) {
      return false;
    }
    for (var i2 = 0; i2 < len2; i2++) {
      if (arr0[i2] !== arr1[i2]) {
        return false;
      }
    }
    return true;
  }
  function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
    var targetKeys = keys(target);
    var duration = cfg.duration;
    var delay = cfg.delay;
    var additive = cfg.additive;
    var setToFinal = cfg.setToFinal;
    var animateAll = !isObject$3(animationProps);
    var existsAnimators = animatable.animators;
    var animationKeys = [];
    for (var k2 = 0; k2 < targetKeys.length; k2++) {
      var innerKey = targetKeys[k2];
      var targetVal = target[innerKey];
      if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
        if (isObject$3(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
          if (topKey) {
            if (!reverse2) {
              animateObj[innerKey] = targetVal;
              animatable.updateDuringAnimation(topKey);
            }
            continue;
          }
          animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
        } else {
          animationKeys.push(innerKey);
        }
      } else if (!reverse2) {
        animateObj[innerKey] = targetVal;
        animatable.updateDuringAnimation(topKey);
        animationKeys.push(innerKey);
      }
    }
    var keyLen = animationKeys.length;
    if (!additive && keyLen) {
      for (var i2 = 0; i2 < existsAnimators.length; i2++) {
        var animator = existsAnimators[i2];
        if (animator.targetName === topKey) {
          var allAborted = animator.stopTracks(animationKeys);
          if (allAborted) {
            var idx = indexOf(existsAnimators, animator);
            existsAnimators.splice(idx, 1);
          }
        }
      }
    }
    if (!cfg.force) {
      animationKeys = filter(animationKeys, function(key2) {
        return !isValueSame(target[key2], animateObj[key2]);
      });
      keyLen = animationKeys.length;
    }
    if (keyLen > 0 || cfg.force && !animators.length) {
      var revertedSource = void 0;
      var reversedTarget = void 0;
      var sourceClone = void 0;
      if (reverse2) {
        reversedTarget = {};
        if (setToFinal) {
          revertedSource = {};
        }
        for (var i2 = 0; i2 < keyLen; i2++) {
          var innerKey = animationKeys[i2];
          reversedTarget[innerKey] = animateObj[innerKey];
          if (setToFinal) {
            revertedSource[innerKey] = target[innerKey];
          } else {
            animateObj[innerKey] = target[innerKey];
          }
        }
      } else if (setToFinal) {
        sourceClone = {};
        for (var i2 = 0; i2 < keyLen; i2++) {
          var innerKey = animationKeys[i2];
          sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
          copyValue(animateObj, target, innerKey);
        }
      }
      var animator = new Animator(animateObj, false, false, additive ? filter(existsAnimators, function(animator2) {
        return animator2.targetName === topKey;
      }) : null);
      animator.targetName = topKey;
      if (cfg.scope) {
        animator.scope = cfg.scope;
      }
      if (setToFinal && revertedSource) {
        animator.whenWithKeys(0, revertedSource, animationKeys);
      }
      if (sourceClone) {
        animator.whenWithKeys(0, sourceClone, animationKeys);
      }
      animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay || 0);
      animatable.addAnimator(animator, topKey);
      animators.push(animator);
    }
  }
  var Group$2 = function(_super) {
    __extends(Group2, _super);
    function Group2(opts) {
      var _this = _super.call(this) || this;
      _this.isGroup = true;
      _this._children = [];
      _this.attr(opts);
      return _this;
    }
    Group2.prototype.childrenRef = function() {
      return this._children;
    };
    Group2.prototype.children = function() {
      return this._children.slice();
    };
    Group2.prototype.childAt = function(idx) {
      return this._children[idx];
    };
    Group2.prototype.childOfName = function(name) {
      var children = this._children;
      for (var i2 = 0; i2 < children.length; i2++) {
        if (children[i2].name === name) {
          return children[i2];
        }
      }
    };
    Group2.prototype.childCount = function() {
      return this._children.length;
    };
    Group2.prototype.add = function(child) {
      if (child) {
        if (child !== this && child.parent !== this) {
          this._children.push(child);
          this._doAdd(child);
        }
      }
      return this;
    };
    Group2.prototype.addBefore = function(child, nextSibling) {
      if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
        var children = this._children;
        var idx = children.indexOf(nextSibling);
        if (idx >= 0) {
          children.splice(idx, 0, child);
          this._doAdd(child);
        }
      }
      return this;
    };
    Group2.prototype.replace = function(oldChild, newChild) {
      var idx = indexOf(this._children, oldChild);
      if (idx >= 0) {
        this.replaceAt(newChild, idx);
      }
      return this;
    };
    Group2.prototype.replaceAt = function(child, index2) {
      var children = this._children;
      var old = children[index2];
      if (child && child !== this && child.parent !== this && child !== old) {
        children[index2] = child;
        old.parent = null;
        var zr = this.__zr;
        if (zr) {
          old.removeSelfFromZr(zr);
        }
        this._doAdd(child);
      }
      return this;
    };
    Group2.prototype._doAdd = function(child) {
      if (child.parent) {
        child.parent.remove(child);
      }
      child.parent = this;
      var zr = this.__zr;
      if (zr && zr !== child.__zr) {
        child.addSelfToZr(zr);
      }
      zr && zr.refresh();
    };
    Group2.prototype.remove = function(child) {
      var zr = this.__zr;
      var children = this._children;
      var idx = indexOf(children, child);
      if (idx < 0) {
        return this;
      }
      children.splice(idx, 1);
      child.parent = null;
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      zr && zr.refresh();
      return this;
    };
    Group2.prototype.removeAll = function() {
      var children = this._children;
      var zr = this.__zr;
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        if (zr) {
          child.removeSelfFromZr(zr);
        }
        child.parent = null;
      }
      children.length = 0;
      return this;
    };
    Group2.prototype.eachChild = function(cb, context) {
      var children = this._children;
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        cb.call(context, child, i2);
      }
      return this;
    };
    Group2.prototype.traverse = function(cb, context) {
      for (var i2 = 0; i2 < this._children.length; i2++) {
        var child = this._children[i2];
        var stopped = cb.call(context, child);
        if (child.isGroup && !stopped) {
          child.traverse(cb, context);
        }
      }
      return this;
    };
    Group2.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i2 = 0; i2 < this._children.length; i2++) {
        var child = this._children[i2];
        child.addSelfToZr(zr);
      }
    };
    Group2.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i2 = 0; i2 < this._children.length; i2++) {
        var child = this._children[i2];
        child.removeSelfFromZr(zr);
      }
    };
    Group2.prototype.getBoundingRect = function(includeChildren) {
      var tmpRect2 = new BoundingRect(0, 0, 0, 0);
      var children = includeChildren || this._children;
      var tmpMat = [];
      var rect = null;
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        if (child.ignore || child.invisible) {
          continue;
        }
        var childRect = child.getBoundingRect();
        var transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          BoundingRect.applyTransform(tmpRect2, childRect, transform2);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      return rect || tmpRect2;
    };
    return Group2;
  }(Element$1);
  Group$2.prototype.type = "group";
  /*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  */
  var painterCtors = {};
  var instances$1 = {};
  function delInstance(id) {
    delete instances$1[id];
  }
  function isDarkMode(backgroundColor2) {
    if (!backgroundColor2) {
      return false;
    }
    if (typeof backgroundColor2 === "string") {
      return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
    } else if (backgroundColor2.colorStops) {
      var colorStops = backgroundColor2.colorStops;
      var totalLum = 0;
      var len2 = colorStops.length;
      for (var i2 = 0; i2 < len2; i2++) {
        totalLum += lum(colorStops[i2].color, 1);
      }
      totalLum /= len2;
      return totalLum < DARK_MODE_THRESHOLD;
    }
    return false;
  }
  var ZRender = function() {
    function ZRender2(id, dom, opts) {
      var _this = this;
      this._sleepAfterStill = 10;
      this._stillFrameAccum = 0;
      this._needsRefresh = true;
      this._needsRefreshHover = true;
      this._darkMode = false;
      opts = opts || {};
      this.dom = dom;
      this.id = id;
      var storage = new Storage();
      var rendererType = opts.renderer || "canvas";
      if (!painterCtors[rendererType]) {
        rendererType = keys(painterCtors)[0];
      }
      opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      var ssrMode = opts.ssr || painter.ssrOnly;
      this.storage = storage;
      this.painter = painter;
      var handlerProxy = !env.node && !env.worker && !ssrMode ? new HandlerDomProxy(painter.getViewportRoot(), painter.root) : null;
      var useCoarsePointer = opts.useCoarsePointer;
      var usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env.touchEventsSupported : !!useCoarsePointer;
      var defaultPointerSize = 44;
      var pointerSize;
      if (usePointerSize) {
        pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
      }
      this.handler = new Handler(storage, painter, handlerProxy, painter.root, pointerSize);
      this.animation = new Animation({
        stage: {
          update: ssrMode ? null : function() {
            return _this._flush(true);
          }
        }
      });
      if (!ssrMode) {
        this.animation.start();
      }
    }
    ZRender2.prototype.add = function(el) {
      if (this._disposed || !el) {
        return;
      }
      this.storage.addRoot(el);
      el.addSelfToZr(this);
      this.refresh();
    };
    ZRender2.prototype.remove = function(el) {
      if (this._disposed || !el) {
        return;
      }
      this.storage.delRoot(el);
      el.removeSelfFromZr(this);
      this.refresh();
    };
    ZRender2.prototype.configLayer = function(zLevel, config) {
      if (this._disposed) {
        return;
      }
      if (this.painter.configLayer) {
        this.painter.configLayer(zLevel, config);
      }
      this.refresh();
    };
    ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
      if (this._disposed) {
        return;
      }
      if (this.painter.setBackgroundColor) {
        this.painter.setBackgroundColor(backgroundColor2);
      }
      this.refresh();
      this._backgroundColor = backgroundColor2;
      this._darkMode = isDarkMode(backgroundColor2);
    };
    ZRender2.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    };
    ZRender2.prototype.setDarkMode = function(darkMode) {
      this._darkMode = darkMode;
    };
    ZRender2.prototype.isDarkMode = function() {
      return this._darkMode;
    };
    ZRender2.prototype.refreshImmediately = function(fromInside) {
      if (this._disposed) {
        return;
      }
      if (!fromInside) {
        this.animation.update(true);
      }
      this._needsRefresh = false;
      this.painter.refresh();
      this._needsRefresh = false;
    };
    ZRender2.prototype.refresh = function() {
      if (this._disposed) {
        return;
      }
      this._needsRefresh = true;
      this.animation.start();
    };
    ZRender2.prototype.flush = function() {
      if (this._disposed) {
        return;
      }
      this._flush(false);
    };
    ZRender2.prototype._flush = function(fromInside) {
      var triggerRendered;
      var start2 = getTime();
      if (this._needsRefresh) {
        triggerRendered = true;
        this.refreshImmediately(fromInside);
      }
      if (this._needsRefreshHover) {
        triggerRendered = true;
        this.refreshHoverImmediately();
      }
      var end2 = getTime();
      if (triggerRendered) {
        this._stillFrameAccum = 0;
        this.trigger("rendered", {
          elapsedTime: end2 - start2
        });
      } else if (this._sleepAfterStill > 0) {
        this._stillFrameAccum++;
        if (this._stillFrameAccum > this._sleepAfterStill) {
          this.animation.stop();
        }
      }
    };
    ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
      this._sleepAfterStill = stillFramesCount;
    };
    ZRender2.prototype.wakeUp = function() {
      if (this._disposed) {
        return;
      }
      this.animation.start();
      this._stillFrameAccum = 0;
    };
    ZRender2.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    };
    ZRender2.prototype.refreshHoverImmediately = function() {
      if (this._disposed) {
        return;
      }
      this._needsRefreshHover = false;
      if (this.painter.refreshHover && this.painter.getType() === "canvas") {
        this.painter.refreshHover();
      }
    };
    ZRender2.prototype.resize = function(opts) {
      if (this._disposed) {
        return;
      }
      opts = opts || {};
      this.painter.resize(opts.width, opts.height);
      this.handler.resize();
    };
    ZRender2.prototype.clearAnimation = function() {
      if (this._disposed) {
        return;
      }
      this.animation.clear();
    };
    ZRender2.prototype.getWidth = function() {
      if (this._disposed) {
        return;
      }
      return this.painter.getWidth();
    };
    ZRender2.prototype.getHeight = function() {
      if (this._disposed) {
        return;
      }
      return this.painter.getHeight();
    };
    ZRender2.prototype.setCursorStyle = function(cursorStyle) {
      if (this._disposed) {
        return;
      }
      this.handler.setCursorStyle(cursorStyle);
    };
    ZRender2.prototype.findHover = function(x2, y2) {
      if (this._disposed) {
        return;
      }
      return this.handler.findHover(x2, y2);
    };
    ZRender2.prototype.on = function(eventName, eventHandler, context) {
      if (!this._disposed) {
        this.handler.on(eventName, eventHandler, context);
      }
      return this;
    };
    ZRender2.prototype.off = function(eventName, eventHandler) {
      if (this._disposed) {
        return;
      }
      this.handler.off(eventName, eventHandler);
    };
    ZRender2.prototype.trigger = function(eventName, event) {
      if (this._disposed) {
        return;
      }
      this.handler.trigger(eventName, event);
    };
    ZRender2.prototype.clear = function() {
      if (this._disposed) {
        return;
      }
      var roots2 = this.storage.getRoots();
      for (var i2 = 0; i2 < roots2.length; i2++) {
        if (roots2[i2] instanceof Group$2) {
          roots2[i2].removeSelfFromZr(this);
        }
      }
      this.storage.delAllRoots();
      this.painter.clear();
    };
    ZRender2.prototype.dispose = function() {
      if (this._disposed) {
        return;
      }
      this.animation.stop();
      this.clear();
      this.storage.dispose();
      this.painter.dispose();
      this.handler.dispose();
      this.animation = this.storage = this.painter = this.handler = null;
      this._disposed = true;
      delInstance(this.id);
    };
    return ZRender2;
  }();
  function init$1(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances$1[zr.id] = zr;
    return zr;
  }
  function dispose$1(zr) {
    zr.dispose();
  }
  function disposeAll() {
    for (var key2 in instances$1) {
      if (instances$1.hasOwnProperty(key2)) {
        instances$1[key2].dispose();
      }
    }
    instances$1 = {};
  }
  function getInstance(id) {
    return instances$1[id];
  }
  function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
  }
  var ssrDataGetter;
  function getElementSSRData(el) {
    if (typeof ssrDataGetter === "function") {
      return ssrDataGetter(el);
    }
  }
  function registerSSRDataGetter(getter) {
    ssrDataGetter = getter;
  }
  var version$1 = "5.6.1";
  const zrender = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    dispose: dispose$1,
    disposeAll,
    getElementSSRData,
    getInstance,
    init: init$1,
    registerPainter,
    registerSSRDataGetter,
    version: version$1
  }, Symbol.toStringTag, { value: "Module" }));
  var RADIAN_EPSILON = 1e-4;
  var ROUND_SUPPORTED_PRECISION_MAX = 20;
  function _trim(str) {
    return str.replace(/^\s+|\s+$/g, "");
  }
  function linearMap(val, domain, range2, clamp2) {
    var d0 = domain[0];
    var d1 = domain[1];
    var r0 = range2[0];
    var r1 = range2[1];
    var subDomain = d1 - d0;
    var subRange = r1 - r0;
    if (subDomain === 0) {
      return subRange === 0 ? r0 : (r0 + r1) / 2;
    }
    if (clamp2) {
      if (subDomain > 0) {
        if (val <= d0) {
          return r0;
        } else if (val >= d1) {
          return r1;
        }
      } else {
        if (val >= d0) {
          return r0;
        } else if (val <= d1) {
          return r1;
        }
      }
    } else {
      if (val === d0) {
        return r0;
      }
      if (val === d1) {
        return r1;
      }
    }
    return (val - d0) / subDomain * subRange + r0;
  }
  function parsePercent(percent, all2) {
    switch (percent) {
      case "center":
      case "middle":
        percent = "50%";
        break;
      case "left":
      case "top":
        percent = "0%";
        break;
      case "right":
      case "bottom":
        percent = "100%";
        break;
    }
    if (isString$1(percent)) {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all2;
      }
      return parseFloat(percent);
    }
    return percent == null ? NaN : +percent;
  }
  function round$1(x2, precision, returnStr) {
    if (precision == null) {
      precision = 10;
    }
    precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
    x2 = (+x2).toFixed(precision);
    return returnStr ? x2 : +x2;
  }
  function asc(arr) {
    arr.sort(function(a2, b2) {
      return a2 - b2;
    });
    return arr;
  }
  function getPrecision(val) {
    val = +val;
    if (isNaN(val)) {
      return 0;
    }
    if (val > 1e-14) {
      var e2 = 1;
      for (var i2 = 0; i2 < 15; i2++, e2 *= 10) {
        if (Math.round(val * e2) / e2 === val) {
          return i2;
        }
      }
    }
    return getPrecisionSafe(val);
  }
  function getPrecisionSafe(val) {
    var str = val.toString().toLowerCase();
    var eIndex = str.indexOf("e");
    var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
    var significandPartLen = eIndex > 0 ? eIndex : str.length;
    var dotIndex = str.indexOf(".");
    var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
    return Math.max(0, decimalPartLen - exp);
  }
  function getPixelPrecision(dataExtent, pixelExtent) {
    var log = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
  }
  function getPercentWithPrecision(valueList, idx, precision) {
    if (!valueList[idx]) {
      return 0;
    }
    var seats = getPercentSeats(valueList, precision);
    return seats[idx] || 0;
  }
  function getPercentSeats(valueList, precision) {
    var sum = reduce(valueList, function(acc, val) {
      return acc + (isNaN(val) ? 0 : val);
    }, 0);
    if (sum === 0) {
      return [];
    }
    var digits = Math.pow(10, precision);
    var votesPerQuota = map$1(valueList, function(val) {
      return (isNaN(val) ? 0 : val) / sum * digits * 100;
    });
    var targetSeats = digits * 100;
    var seats = map$1(votesPerQuota, function(votes) {
      return Math.floor(votes);
    });
    var currentSum = reduce(seats, function(acc, val) {
      return acc + val;
    }, 0);
    var remainder = map$1(votesPerQuota, function(votes, idx) {
      return votes - seats[idx];
    });
    while (currentSum < targetSeats) {
      var max3 = Number.NEGATIVE_INFINITY;
      var maxId = null;
      for (var i2 = 0, len2 = remainder.length; i2 < len2; ++i2) {
        if (remainder[i2] > max3) {
          max3 = remainder[i2];
          maxId = i2;
        }
      }
      ++seats[maxId];
      remainder[maxId] = 0;
      ++currentSum;
    }
    return map$1(seats, function(seat) {
      return seat / digits;
    });
  }
  function addSafe(val0, val1) {
    var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
    var sum = val0 + val1;
    return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round$1(sum, maxPrecision);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  }
  function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  }
  var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function parseDate(value) {
    if (value instanceof Date) {
      return value;
    } else if (isString$1(value)) {
      var match2 = TIME_REG.exec(value);
      if (!match2) {
        return /* @__PURE__ */ new Date(NaN);
      }
      if (!match2[8]) {
        return new Date(+match2[1], +(match2[2] || 1) - 1, +match2[3] || 1, +match2[4] || 0, +(match2[5] || 0), +match2[6] || 0, match2[7] ? +match2[7].substring(0, 3) : 0);
      } else {
        var hour = +match2[4] || 0;
        if (match2[8].toUpperCase() !== "Z") {
          hour -= +match2[8].slice(0, 3);
        }
        return new Date(Date.UTC(+match2[1], +(match2[2] || 1) - 1, +match2[3] || 1, hour, +(match2[5] || 0), +match2[6] || 0, match2[7] ? +match2[7].substring(0, 3) : 0));
      }
    } else if (value == null) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return new Date(Math.round(value));
  }
  function quantity(val) {
    return Math.pow(10, quantityExponent(val));
  }
  function quantityExponent(val) {
    if (val === 0) {
      return 0;
    }
    var exp = Math.floor(Math.log(val) / Math.LN10);
    if (val / Math.pow(10, exp) >= 10) {
      exp++;
    }
    return exp;
  }
  function nice(val, round2) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f2 = val / exp10;
    var nf;
    if (round2) {
      if (f2 < 1.5) {
        nf = 1;
      } else if (f2 < 2.5) {
        nf = 2;
      } else if (f2 < 4) {
        nf = 3;
      } else if (f2 < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    } else {
      if (f2 < 1) {
        nf = 1;
      } else if (f2 < 2) {
        nf = 2;
      } else if (f2 < 3) {
        nf = 3;
      } else if (f2 < 5) {
        nf = 5;
      } else {
        nf = 10;
      }
    }
    val = nf * exp10;
    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
  }
  function quantile(ascArr, p2) {
    var H = (ascArr.length - 1) * p2 + 1;
    var h2 = Math.floor(H);
    var v2 = +ascArr[h2 - 1];
    var e2 = H - h2;
    return e2 ? v2 + e2 * (ascArr[h2] - v2) : v2;
  }
  function reformIntervals(list2) {
    list2.sort(function(a2, b2) {
      return littleThan(a2, b2, 0) ? -1 : 1;
    });
    var curr = -Infinity;
    var currClose = 1;
    for (var i2 = 0; i2 < list2.length; ) {
      var interval = list2[i2].interval;
      var close_1 = list2[i2].close;
      for (var lg = 0; lg < 2; lg++) {
        if (interval[lg] <= curr) {
          interval[lg] = curr;
          close_1[lg] = !lg ? 1 - currClose : 1;
        }
        curr = interval[lg];
        currClose = close_1[lg];
      }
      if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
        list2.splice(i2, 1);
      } else {
        i2++;
      }
    }
    return list2;
    function littleThan(a2, b2, lg2) {
      return a2.interval[lg2] < b2.interval[lg2] || a2.interval[lg2] === b2.interval[lg2] && (a2.close[lg2] - b2.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan(a2, b2, 1));
    }
  }
  function numericToNumber(val) {
    var valFloat = parseFloat(val);
    return valFloat == val && (valFloat !== 0 || !isString$1(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
  }
  function isNumeric(val) {
    return !isNaN(numericToNumber(val));
  }
  function getRandomIdBase() {
    return Math.round(Math.random() * 9);
  }
  function getGreatestCommonDividor(a2, b2) {
    if (b2 === 0) {
      return a2;
    }
    return getGreatestCommonDividor(b2, a2 % b2);
  }
  function getLeastCommonMultiple(a2, b2) {
    if (a2 == null) {
      return b2;
    }
    if (b2 == null) {
      return a2;
    }
    return a2 * b2 / getGreatestCommonDividor(a2, b2);
  }
  function throwError(msg) {
    throw new Error(msg);
  }
  function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
  var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
  function normalizeToArray(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
  }
  function defaultEmphasis(opt, key2, subOpts) {
    if (opt) {
      opt[key2] = opt[key2] || {};
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[key2] = opt.emphasis[key2] || {};
      for (var i2 = 0, len2 = subOpts.length; i2 < len2; i2++) {
        var subOptName = subOpts[i2];
        if (!opt.emphasis[key2].hasOwnProperty(subOptName) && opt[key2].hasOwnProperty(subOptName)) {
          opt.emphasis[key2][subOptName] = opt[key2][subOptName];
        }
      }
    }
  }
  var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
  function getDataItemValue(dataItem) {
    return isObject$3(dataItem) && !isArray$1(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
  }
  function isDataItemOption(dataItem) {
    return isObject$3(dataItem) && !(dataItem instanceof Array);
  }
  function mappingToExists(existings, newCmptOptions, mode) {
    var isNormalMergeMode = mode === "normalMerge";
    var isReplaceMergeMode = mode === "replaceMerge";
    var isReplaceAllMode = mode === "replaceAll";
    existings = existings || [];
    newCmptOptions = (newCmptOptions || []).slice();
    var existingIdIdxMap = createHashMap();
    each$4(newCmptOptions, function(cmptOption, index2) {
      if (!isObject$3(cmptOption)) {
        newCmptOptions[index2] = null;
        return;
      }
    });
    var result = prepareResult(existings, existingIdIdxMap, mode);
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingById(result, existings, existingIdIdxMap, newCmptOptions);
    }
    if (isNormalMergeMode) {
      mappingByName(result, newCmptOptions);
    }
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
    } else if (isReplaceAllMode) {
      mappingInReplaceAllMode(result, newCmptOptions);
    }
    makeIdAndName(result);
    return result;
  }
  function prepareResult(existings, existingIdIdxMap, mode) {
    var result = [];
    if (mode === "replaceAll") {
      return result;
    }
    for (var index2 = 0; index2 < existings.length; index2++) {
      var existing = existings[index2];
      if (existing && existing.id != null) {
        existingIdIdxMap.set(existing.id, index2);
      }
      result.push({
        existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return result;
  }
  function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
    each$4(newCmptOptions, function(cmptOption, index2) {
      if (!cmptOption || cmptOption.id == null) {
        return;
      }
      var optionId = makeComparableKey(cmptOption.id);
      var existingIdx = existingIdIdxMap.get(optionId);
      if (existingIdx != null) {
        var resultItem = result[existingIdx];
        assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
        resultItem.newOption = cmptOption;
        resultItem.existing = existings[existingIdx];
        newCmptOptions[index2] = null;
      }
    });
  }
  function mappingByName(result, newCmptOptions) {
    each$4(newCmptOptions, function(cmptOption, index2) {
      if (!cmptOption || cmptOption.name == null) {
        return;
      }
      for (var i2 = 0; i2 < result.length; i2++) {
        var existing = result[i2].existing;
        if (!result[i2].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
          result[i2].newOption = cmptOption;
          newCmptOptions[index2] = null;
          return;
        }
      }
    });
  }
  function mappingByIndex(result, newCmptOptions, brandNew) {
    each$4(newCmptOptions, function(cmptOption) {
      if (!cmptOption) {
        return;
      }
      var resultItem;
      var nextIdx = 0;
      while (
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))
      ) {
        nextIdx++;
      }
      if (resultItem) {
        resultItem.newOption = cmptOption;
        resultItem.brandNew = brandNew;
      } else {
        result.push({
          newOption: cmptOption,
          brandNew,
          existing: null,
          keyInfo: null
        });
      }
      nextIdx++;
    });
  }
  function mappingInReplaceAllMode(result, newCmptOptions) {
    each$4(newCmptOptions, function(cmptOption) {
      result.push({
        newOption: cmptOption,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function makeIdAndName(mapResult) {
    var idMap = createHashMap();
    each$4(mapResult, function(item) {
      var existing = item.existing;
      existing && idMap.set(existing.id, item);
    });
    each$4(mapResult, function(item) {
      var opt = item.newOption;
      assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
      opt && opt.id != null && idMap.set(opt.id, item);
      !item.keyInfo && (item.keyInfo = {});
    });
    each$4(mapResult, function(item, index2) {
      var existing = item.existing;
      var opt = item.newOption;
      var keyInfo = item.keyInfo;
      if (!isObject$3(opt)) {
        return;
      }
      keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index2;
      if (existing) {
        keyInfo.id = makeComparableKey(existing.id);
      } else if (opt.id != null) {
        keyInfo.id = makeComparableKey(opt.id);
      } else {
        var idNum = 0;
        do {
          keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
        } while (idMap.get(keyInfo.id));
      }
      idMap.set(keyInfo.id, item);
    });
  }
  function keyExistAndEqual(attr, obj1, obj2) {
    var key1 = convertOptionIdName(obj1[attr], null);
    var key2 = convertOptionIdName(obj2[attr], null);
    return key1 != null && key2 != null && key1 === key2;
  }
  function makeComparableKey(val) {
    return convertOptionIdName(val, "");
  }
  function convertOptionIdName(idOrName, defaultValue) {
    if (idOrName == null) {
      return defaultValue;
    }
    return isString$1(idOrName) ? idOrName : isNumber$1(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
  }
  function isNameSpecified(componentModel) {
    var name = componentModel.name;
    return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
  }
  function isComponentIdInternal(cmptOption) {
    return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
  }
  function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
    each$4(mappingResult, function(item) {
      var newOption = item.newOption;
      if (isObject$3(newOption)) {
        item.keyInfo.mainType = mainType;
        item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
      }
    });
  }
  function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
    var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
    return subType;
  }
  function queryDataIndex(data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
      return isArray$1(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
        return data.indexOfRawIndex(value);
      }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
      return isArray$1(payload.name) ? map$1(payload.name, function(value) {
        return data.indexOfName(value);
      }) : data.indexOfName(payload.name);
    }
  }
  function makeInner() {
    var key2 = "__ec_inner_" + innerUniqueIndex++;
    return function(hostObj) {
      return hostObj[key2] || (hostObj[key2] = {});
    };
  }
  var innerUniqueIndex = getRandomIdBase();
  function parseFinder(ecModel, finderInput, opt) {
    var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
    var result = others;
    var defaultMainType = opt ? opt.defaultMainType : null;
    if (!mainTypeSpecified && defaultMainType) {
      queryOptionMap.set(defaultMainType, {});
    }
    queryOptionMap.each(function(queryOption, mainType) {
      var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
        useDefault: defaultMainType === mainType,
        enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
        enableNone: opt && opt.enableNone != null ? opt.enableNone : true
      });
      result[mainType + "Models"] = queryResult.models;
      result[mainType + "Model"] = queryResult.models[0];
    });
    return result;
  }
  function preParseFinder(finderInput, opt) {
    var finder;
    if (isString$1(finderInput)) {
      var obj2 = {};
      obj2[finderInput + "Index"] = 0;
      finder = obj2;
    } else {
      finder = finderInput;
    }
    var queryOptionMap = createHashMap();
    var others = {};
    var mainTypeSpecified = false;
    each$4(finder, function(value, key2) {
      if (key2 === "dataIndex" || key2 === "dataIndexInside") {
        others[key2] = value;
        return;
      }
      var parsedKey = key2.match(/^(\w+)(Index|Id|Name)$/) || [];
      var mainType = parsedKey[1];
      var queryType = (parsedKey[2] || "").toLowerCase();
      if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
        return;
      }
      mainTypeSpecified = mainTypeSpecified || !!mainType;
      var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
      queryOption[queryType] = value;
    });
    return {
      mainTypeSpecified,
      queryOptionMap,
      others
    };
  }
  var SINGLE_REFERRING = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  };
  function queryReferringComponents(ecModel, mainType, userOption, opt) {
    opt = opt || SINGLE_REFERRING;
    var indexOption = userOption.index;
    var idOption = userOption.id;
    var nameOption = userOption.name;
    var result = {
      models: null,
      specified: indexOption != null || idOption != null || nameOption != null
    };
    if (!result.specified) {
      var firstCmpt = void 0;
      result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
      return result;
    }
    if (indexOption === "none" || indexOption === false) {
      assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
      result.models = [];
      return result;
    }
    if (indexOption === "all") {
      assert(opt.enableAll, '`"all"` is not a valid value on index option.');
      indexOption = idOption = nameOption = null;
    }
    result.models = ecModel.queryComponents({
      mainType,
      index: indexOption,
      id: idOption,
      name: nameOption
    });
    return result;
  }
  function setAttribute(dom, key2, value) {
    dom.setAttribute ? dom.setAttribute(key2, value) : dom[key2] = value;
  }
  function getAttribute(dom, key2) {
    return dom.getAttribute ? dom.getAttribute(key2) : dom[key2];
  }
  function getTooltipRenderMode(renderModeOption) {
    if (renderModeOption === "auto") {
      return env.domSupported ? "html" : "richText";
    } else {
      return renderModeOption || "html";
    }
  }
  function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
    var isAutoPrecision = precision == null || precision === "auto";
    if (targetValue == null) {
      return targetValue;
    }
    if (isNumber$1(targetValue)) {
      var value = interpolateNumber(sourceValue || 0, targetValue, percent);
      return round$1(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
    } else if (isString$1(targetValue)) {
      return percent < 1 ? sourceValue : targetValue;
    } else {
      var interpolated = [];
      var leftArr = sourceValue;
      var rightArr = targetValue;
      var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
      for (var i2 = 0; i2 < length_1; ++i2) {
        var info = data.getDimensionInfo(i2);
        if (info && info.type === "ordinal") {
          interpolated[i2] = (percent < 1 && leftArr ? leftArr : rightArr)[i2];
        } else {
          var leftVal = leftArr && leftArr[i2] ? leftArr[i2] : 0;
          var rightVal = rightArr[i2];
          var value = interpolateNumber(leftVal, rightVal, percent);
          interpolated[i2] = round$1(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
        }
      }
      return interpolated;
    }
  }
  var TYPE_DELIMITER = ".";
  var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
  var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
  function parseClassType(componentType) {
    var ret = {
      main: "",
      sub: ""
    };
    if (componentType) {
      var typeArr = componentType.split(TYPE_DELIMITER);
      ret.main = typeArr[0] || "";
      ret.sub = typeArr[1] || "";
    }
    return ret;
  }
  function checkClassType(componentType) {
    assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
  }
  function isExtendedClass(clz) {
    return !!(clz && clz[IS_EXTENDED_CLASS]);
  }
  function enableClassExtend(rootClz, mandatoryMethods) {
    rootClz.$constructor = rootClz;
    rootClz.extend = function(proto2) {
      var superClass = this;
      var ExtendedClass;
      if (isESClass(superClass)) {
        ExtendedClass = /** @class */
        function(_super) {
          __extends(class_1, _super);
          function class_1() {
            return _super.apply(this, arguments) || this;
          }
          return class_1;
        }(superClass);
      } else {
        ExtendedClass = function() {
          (proto2.$constructor || superClass).apply(this, arguments);
        };
        inherits$1(ExtendedClass, this);
      }
      extend$1(ExtendedClass.prototype, proto2);
      ExtendedClass[IS_EXTENDED_CLASS] = true;
      ExtendedClass.extend = this.extend;
      ExtendedClass.superCall = superCall;
      ExtendedClass.superApply = superApply;
      ExtendedClass.superClass = superClass;
      return ExtendedClass;
    };
  }
  function isESClass(fn) {
    return isFunction$1(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
  }
  function mountExtend(SubClz, SupperClz) {
    SubClz.extend = SupperClz.extend;
  }
  var classBase = Math.round(Math.random() * 10);
  function enableClassCheck(target) {
    var classAttr = ["__\0is_clz", classBase++].join("_");
    target.prototype[classAttr] = true;
    target.isInstance = function(obj2) {
      return !!(obj2 && obj2[classAttr]);
    };
  }
  function superCall(context, methodName) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function enableClassManagement(target) {
    var storage = {};
    target.registerClass = function(clz) {
      var componentFullType = clz.type || clz.prototype.type;
      if (componentFullType) {
        checkClassType(componentFullType);
        clz.prototype.type = componentFullType;
        var componentTypeInfo = parseClassType(componentFullType);
        if (!componentTypeInfo.sub) {
          storage[componentTypeInfo.main] = clz;
        } else if (componentTypeInfo.sub !== IS_CONTAINER) {
          var container = makeContainer(componentTypeInfo);
          container[componentTypeInfo.sub] = clz;
        }
      }
      return clz;
    };
    target.getClass = function(mainType, subType, throwWhenNotFound) {
      var clz = storage[mainType];
      if (clz && clz[IS_CONTAINER]) {
        clz = subType ? clz[subType] : null;
      }
      if (throwWhenNotFound && !clz) {
        throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
      }
      return clz;
    };
    target.getClassesByMainType = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var result = [];
      var obj2 = storage[componentTypeInfo.main];
      if (obj2 && obj2[IS_CONTAINER]) {
        each$4(obj2, function(o2, type) {
          type !== IS_CONTAINER && result.push(o2);
        });
      } else {
        result.push(obj2);
      }
      return result;
    };
    target.hasClass = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      return !!storage[componentTypeInfo.main];
    };
    target.getAllClassMainTypes = function() {
      var types2 = [];
      each$4(storage, function(obj2, type) {
        types2.push(type);
      });
      return types2;
    };
    target.hasSubTypes = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var obj2 = storage[componentTypeInfo.main];
      return obj2 && obj2[IS_CONTAINER];
    };
    function makeContainer(componentTypeInfo) {
      var container = storage[componentTypeInfo.main];
      if (!container || !container[IS_CONTAINER]) {
        container = storage[componentTypeInfo.main] = {};
        container[IS_CONTAINER] = true;
      }
      return container;
    }
  }
  function makeStyleMapper(properties, ignoreParent) {
    for (var i2 = 0; i2 < properties.length; i2++) {
      if (!properties[i2][1]) {
        properties[i2][1] = properties[i2][0];
      }
    }
    ignoreParent = ignoreParent || false;
    return function(model, excludes, includes2) {
      var style = {};
      for (var i3 = 0; i3 < properties.length; i3++) {
        var propName = properties[i3][1];
        if (excludes && indexOf(excludes, propName) >= 0 || includes2 && indexOf(includes2, propName) < 0) {
          continue;
        }
        var val = model.getShallow(propName, ignoreParent);
        if (val != null) {
          style[properties[i3][0]] = val;
        }
      }
      return style;
    };
  }
  var AREA_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["opacity"],
    ["shadowColor"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
  var AreaStyleMixin = (
    /** @class */
    function() {
      function AreaStyleMixin2() {
      }
      AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes2) {
        return getAreaStyle(this, excludes, includes2);
      };
      return AreaStyleMixin2;
    }()
  );
  var globalImageCache = new LRU(50);
  function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === "string") {
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      return cachedImgObj && cachedImgObj.image;
    } else {
      return newImageOrSrc;
    }
  }
  function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
    if (!newImageOrSrc) {
      return image;
    } else if (typeof newImageOrSrc === "string") {
      if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
        return image;
      }
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      var pendingWrap = { hostEl, cb: onload, cbPayload };
      if (cachedImgObj) {
        image = cachedImgObj.image;
        !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
      } else {
        image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
        image.__zrImageSrc = newImageOrSrc;
        globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
          image,
          pending: [pendingWrap]
        });
      }
      return image;
    } else {
      return newImageOrSrc;
    }
  }
  function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var i2 = 0; i2 < cachedImgObj.pending.length; i2++) {
      var pendingWrap = cachedImgObj.pending[i2];
      var cb = pendingWrap.cb;
      cb && cb(this, pendingWrap.cbPayload);
      pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
  }
  function isImageReady(image) {
    return image && image.width && image.height;
  }
  var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function truncateText(text, containerWidth, font, ellipsis, options2) {
    var out2 = {};
    truncateText2(out2, text, containerWidth, font, ellipsis, options2);
    return out2.text;
  }
  function truncateText2(out2, text, containerWidth, font, ellipsis, options2) {
    if (!containerWidth) {
      out2.text = "";
      out2.isTruncated = false;
      return;
    }
    var textLines = (text + "").split("\n");
    options2 = prepareTruncateOptions(containerWidth, font, ellipsis, options2);
    var isTruncated = false;
    var truncateOut = {};
    for (var i2 = 0, len2 = textLines.length; i2 < len2; i2++) {
      truncateSingleLine(truncateOut, textLines[i2], options2);
      textLines[i2] = truncateOut.textLine;
      isTruncated = isTruncated || truncateOut.isTruncated;
    }
    out2.text = textLines.join("\n");
    out2.isTruncated = isTruncated;
  }
  function prepareTruncateOptions(containerWidth, font, ellipsis, options2) {
    options2 = options2 || {};
    var preparedOpts = extend$1({}, options2);
    preparedOpts.font = font;
    ellipsis = retrieve2(ellipsis, "...");
    preparedOpts.maxIterations = retrieve2(options2.maxIterations, 2);
    var minChar = preparedOpts.minChar = retrieve2(options2.minChar, 0);
    preparedOpts.cnCharWidth = getWidth("国", font);
    var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
    preparedOpts.placeholder = retrieve2(options2.placeholder, "");
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i2 = 0; i2 < minChar && contentWidth >= ascCharWidth; i2++) {
      contentWidth -= ascCharWidth;
    }
    var ellipsisWidth = getWidth(ellipsis, font);
    if (ellipsisWidth > contentWidth) {
      ellipsis = "";
      ellipsisWidth = 0;
    }
    contentWidth = containerWidth - ellipsisWidth;
    preparedOpts.ellipsis = ellipsis;
    preparedOpts.ellipsisWidth = ellipsisWidth;
    preparedOpts.contentWidth = contentWidth;
    preparedOpts.containerWidth = containerWidth;
    return preparedOpts;
  }
  function truncateSingleLine(out2, textLine, options2) {
    var containerWidth = options2.containerWidth;
    var font = options2.font;
    var contentWidth = options2.contentWidth;
    if (!containerWidth) {
      out2.textLine = "";
      out2.isTruncated = false;
      return;
    }
    var lineWidth = getWidth(textLine, font);
    if (lineWidth <= containerWidth) {
      out2.textLine = textLine;
      out2.isTruncated = false;
      return;
    }
    for (var j2 = 0; ; j2++) {
      if (lineWidth <= contentWidth || j2 >= options2.maxIterations) {
        textLine += options2.ellipsis;
        break;
      }
      var subLength = j2 === 0 ? estimateLength(textLine, contentWidth, options2.ascCharWidth, options2.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
      textLine = textLine.substr(0, subLength);
      lineWidth = getWidth(textLine, font);
    }
    if (textLine === "") {
      textLine = options2.placeholder;
    }
    out2.textLine = textLine;
    out2.isTruncated = true;
  }
  function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i2 = 0;
    for (var len2 = text.length; i2 < len2 && width < contentWidth; i2++) {
      var charCode = text.charCodeAt(i2);
      width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
    }
    return i2;
  }
  function parsePlainText(text, style) {
    text != null && (text += "");
    var overflow = style.overflow;
    var padding = style.padding;
    var font = style.font;
    var truncate = overflow === "truncate";
    var calculatedLineHeight = getLineHeight(font);
    var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
    var bgColorDrawn = !!style.backgroundColor;
    var truncateLineOverflow = style.lineOverflow === "truncate";
    var isTruncated = false;
    var width = style.width;
    var lines;
    if (width != null && (overflow === "break" || overflow === "breakAll")) {
      lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
    } else {
      lines = text ? text.split("\n") : [];
    }
    var contentHeight = lines.length * lineHeight;
    var height = retrieve2(style.height, contentHeight);
    if (contentHeight > height && truncateLineOverflow) {
      var lineCount = Math.floor(height / lineHeight);
      isTruncated = isTruncated || lines.length > lineCount;
      lines = lines.slice(0, lineCount);
    }
    if (text && truncate && width != null) {
      var options2 = prepareTruncateOptions(width, font, style.ellipsis, {
        minChar: style.truncateMinChar,
        placeholder: style.placeholder
      });
      var singleOut = {};
      for (var i2 = 0; i2 < lines.length; i2++) {
        truncateSingleLine(singleOut, lines[i2], options2);
        lines[i2] = singleOut.textLine;
        isTruncated = isTruncated || singleOut.isTruncated;
      }
    }
    var outerHeight = height;
    var contentWidth = 0;
    for (var i2 = 0; i2 < lines.length; i2++) {
      contentWidth = Math.max(getWidth(lines[i2], font), contentWidth);
    }
    if (width == null) {
      width = contentWidth;
    }
    var outerWidth = contentWidth;
    if (padding) {
      outerHeight += padding[0] + padding[2];
      outerWidth += padding[1] + padding[3];
      width += padding[1] + padding[3];
    }
    if (bgColorDrawn) {
      outerWidth = width;
    }
    return {
      lines,
      height,
      outerWidth,
      outerHeight,
      lineHeight,
      calculatedLineHeight,
      contentWidth,
      contentHeight,
      width,
      isTruncated
    };
  }
  var RichTextToken = /* @__PURE__ */ function() {
    function RichTextToken2() {
    }
    return RichTextToken2;
  }();
  var RichTextLine = /* @__PURE__ */ function() {
    function RichTextLine2(tokens) {
      this.tokens = [];
      if (tokens) {
        this.tokens = tokens;
      }
    }
    return RichTextLine2;
  }();
  var RichTextContentBlock = /* @__PURE__ */ function() {
    function RichTextContentBlock2() {
      this.width = 0;
      this.height = 0;
      this.contentWidth = 0;
      this.contentHeight = 0;
      this.outerWidth = 0;
      this.outerHeight = 0;
      this.lines = [];
      this.isTruncated = false;
    }
    return RichTextContentBlock2;
  }();
  function parseRichText(text, style) {
    var contentBlock = new RichTextContentBlock();
    text != null && (text += "");
    if (!text) {
      return contentBlock;
    }
    var topWidth = style.width;
    var topHeight = style.height;
    var overflow = style.overflow;
    var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
      var matchedIndex = result.index;
      if (matchedIndex > lastIndex) {
        pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
      }
      pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
      lastIndex = STYLE_REG.lastIndex;
    }
    if (lastIndex < text.length) {
      pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
    }
    var pendingList = [];
    var calculatedHeight = 0;
    var calculatedWidth = 0;
    var stlPadding = style.padding;
    var truncate = overflow === "truncate";
    var truncateLine = style.lineOverflow === "truncate";
    var tmpTruncateOut = {};
    function finishLine(line3, lineWidth2, lineHeight2) {
      line3.width = lineWidth2;
      line3.lineHeight = lineHeight2;
      calculatedHeight += lineHeight2;
      calculatedWidth = Math.max(calculatedWidth, lineWidth2);
    }
    outer: for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
      var line2 = contentBlock.lines[i2];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j2 = 0; j2 < line2.tokens.length; j2++) {
        var token2 = line2.tokens[j2];
        var tokenStyle = token2.styleName && style.rich[token2.styleName] || {};
        var textPadding = token2.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token2.font = tokenStyle.font || style.font;
        token2.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token2.contentHeight);
        token2.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token2.height = tokenHeight;
        token2.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token2.align = tokenStyle && tokenStyle.align || style.align;
        token2.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token2.lineHeight > topHeight) {
          var originalLength = contentBlock.lines.length;
          if (j2 > 0) {
            line2.tokens = line2.tokens.slice(0, j2);
            finishLine(line2, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i2 + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i2);
          }
          contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token2.percentWidth = styleTokenWidth;
          pendingList.push(token2);
          token2.contentWidth = getWidth(token2.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token2.width = Math.max(token2.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token2.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token2.text = "";
              token2.width = token2.contentWidth = 0;
            } else {
              truncateText2(tmpTruncateOut, token2.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token2.text = tmpTruncateOut.text;
              contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;
              token2.width = token2.contentWidth = getWidth(token2.text, font);
            }
          } else {
            token2.contentWidth = getWidth(token2.text, font);
          }
        }
        token2.width += paddingH;
        lineWidth += token2.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token2.lineHeight));
      }
      finishLine(line2, lineWidth, lineHeight);
    }
    contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
    contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
    contentBlock.contentHeight = calculatedHeight;
    contentBlock.contentWidth = calculatedWidth;
    if (stlPadding) {
      contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
      contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }
    for (var i2 = 0; i2 < pendingList.length; i2++) {
      var token2 = pendingList[i2];
      var percentWidth = token2.percentWidth;
      token2.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
    }
    return contentBlock;
  }
  function pushTokens(block, str, style, wrapInfo, styleName) {
    var isEmptyStr = str === "";
    var tokenStyle = styleName && style.rich[styleName] || {};
    var lines = block.lines;
    var font = tokenStyle.font || style.font;
    var newLine = false;
    var strLines;
    var linesWidths;
    if (wrapInfo) {
      var tokenPadding = tokenStyle.padding;
      var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
      if (tokenStyle.width != null && tokenStyle.width !== "auto") {
        var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
        if (lines.length > 0) {
          if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
            strLines = str.split("\n");
            newLine = true;
          }
        }
        wrapInfo.accumWidth = outerWidth_1;
      } else {
        var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
        wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
        linesWidths = res.linesWidths;
        strLines = res.lines;
      }
    } else {
      strLines = str.split("\n");
    }
    for (var i2 = 0; i2 < strLines.length; i2++) {
      var text = strLines[i2];
      var token2 = new RichTextToken();
      token2.styleName = styleName;
      token2.text = text;
      token2.isLineHolder = !text && !isEmptyStr;
      if (typeof tokenStyle.width === "number") {
        token2.width = tokenStyle.width;
      } else {
        token2.width = linesWidths ? linesWidths[i2] : getWidth(text, font);
      }
      if (!i2 && !newLine) {
        var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
        var tokensLen = tokens.length;
        tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token2 : (text || !tokensLen || isEmptyStr) && tokens.push(token2);
      } else {
        lines.push(new RichTextLine([token2]));
      }
    }
  }
  function isAlphabeticLetter(ch) {
    var code2 = ch.charCodeAt(0);
    return code2 >= 32 && code2 <= 591 || code2 >= 880 && code2 <= 4351 || code2 >= 4608 && code2 <= 5119 || code2 >= 7680 && code2 <= 8303;
  }
  var breakCharMap = reduce(",&?/;] ".split(""), function(obj2, ch) {
    obj2[ch] = true;
    return obj2;
  }, {});
  function isWordBreakChar(ch) {
    if (isAlphabeticLetter(ch)) {
      if (breakCharMap[ch]) {
        return true;
      }
      return false;
    }
    return true;
  }
  function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
    var lines = [];
    var linesWidths = [];
    var line2 = "";
    var currentWord = "";
    var currentWordWidth = 0;
    var accumWidth = 0;
    for (var i2 = 0; i2 < text.length; i2++) {
      var ch = text.charAt(i2);
      if (ch === "\n") {
        if (currentWord) {
          line2 += currentWord;
          accumWidth += currentWordWidth;
        }
        lines.push(line2);
        linesWidths.push(accumWidth);
        line2 = "";
        currentWord = "";
        currentWordWidth = 0;
        accumWidth = 0;
        continue;
      }
      var chWidth = getWidth(ch, font);
      var inWord = isBreakAll ? false : !isWordBreakChar(ch);
      if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
        if (!accumWidth) {
          if (inWord) {
            lines.push(currentWord);
            linesWidths.push(currentWordWidth);
            currentWord = ch;
            currentWordWidth = chWidth;
          } else {
            lines.push(ch);
            linesWidths.push(chWidth);
          }
        } else if (line2 || currentWord) {
          if (inWord) {
            if (!line2) {
              line2 = currentWord;
              currentWord = "";
              currentWordWidth = 0;
              accumWidth = currentWordWidth;
            }
            lines.push(line2);
            linesWidths.push(accumWidth - currentWordWidth);
            currentWord += ch;
            currentWordWidth += chWidth;
            line2 = "";
            accumWidth = currentWordWidth;
          } else {
            if (currentWord) {
              line2 += currentWord;
              currentWord = "";
              currentWordWidth = 0;
            }
            lines.push(line2);
            linesWidths.push(accumWidth);
            line2 = ch;
            accumWidth = chWidth;
          }
        }
        continue;
      }
      accumWidth += chWidth;
      if (inWord) {
        currentWord += ch;
        currentWordWidth += chWidth;
      } else {
        if (currentWord) {
          line2 += currentWord;
          currentWord = "";
          currentWordWidth = 0;
        }
        line2 += ch;
      }
    }
    if (!lines.length && !line2) {
      line2 = text;
      currentWord = "";
      currentWordWidth = 0;
    }
    if (currentWord) {
      line2 += currentWord;
    }
    if (line2) {
      lines.push(line2);
      linesWidths.push(accumWidth);
    }
    if (lines.length === 1) {
      accumWidth += lastAccumWidth;
    }
    return {
      accumWidth,
      lines,
      linesWidths
    };
  }
  var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
  var DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  };
  var DEFAULT_COMMON_ANIMATION_PROPS = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
  var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
  var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
  var Displayable = function(_super) {
    __extends(Displayable2, _super);
    function Displayable2(props2) {
      return _super.call(this, props2) || this;
    }
    Displayable2.prototype._init = function(props2) {
      var keysArr = keys(props2);
      for (var i2 = 0; i2 < keysArr.length; i2++) {
        var key2 = keysArr[i2];
        if (key2 === "style") {
          this.useStyle(props2[key2]);
        } else {
          _super.prototype.attrKV.call(this, key2, props2[key2]);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Displayable2.prototype.beforeBrush = function() {
    };
    Displayable2.prototype.afterBrush = function() {
    };
    Displayable2.prototype.innerBeforeBrush = function() {
    };
    Displayable2.prototype.innerAfterBrush = function() {
    };
    Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
      var m2 = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
        return false;
      }
      if (considerClipPath && this.__clipPaths) {
        for (var i2 = 0; i2 < this.__clipPaths.length; ++i2) {
          if (this.__clipPaths[i2].isZeroArea()) {
            return false;
          }
        }
      }
      if (considerAncestors && this.parent) {
        var parent_1 = this.parent;
        while (parent_1) {
          if (parent_1.ignore) {
            return false;
          }
          parent_1 = parent_1.parent;
        }
      }
      return true;
    };
    Displayable2.prototype.contain = function(x2, y2) {
      return this.rectContain(x2, y2);
    };
    Displayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    Displayable2.prototype.rectContain = function(x2, y2) {
      var coord = this.transformCoordToLocal(x2, y2);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    };
    Displayable2.prototype.getPaintRect = function() {
      var rect = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var transform2 = this.transform;
        var elRect = this.getBoundingRect();
        var style = this.style;
        var shadowSize = style.shadowBlur || 0;
        var shadowOffsetX = style.shadowOffsetX || 0;
        var shadowOffsetY = style.shadowOffsetY || 0;
        rect = this._paintRect || (this._paintRect = new BoundingRect(0, 0, 0, 0));
        if (transform2) {
          BoundingRect.applyTransform(rect, elRect, transform2);
        } else {
          rect.copy(elRect);
        }
        if (shadowSize || shadowOffsetX || shadowOffsetY) {
          rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
          rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
          rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
          rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
        }
        var tolerance = this.dirtyRectTolerance;
        if (!rect.isZero()) {
          rect.x = Math.floor(rect.x - tolerance);
          rect.y = Math.floor(rect.y - tolerance);
          rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
          rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
        }
      }
      return rect;
    };
    Displayable2.prototype.setPrevPaintRect = function(paintRect) {
      if (paintRect) {
        this._prevPaintRect = this._prevPaintRect || new BoundingRect(0, 0, 0, 0);
        this._prevPaintRect.copy(paintRect);
      } else {
        this._prevPaintRect = null;
      }
    };
    Displayable2.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    };
    Displayable2.prototype.animateStyle = function(loop) {
      return this.animate("style", loop);
    };
    Displayable2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else {
        this.markRedraw();
      }
    };
    Displayable2.prototype.attrKV = function(key2, value) {
      if (key2 !== "style") {
        _super.prototype.attrKV.call(this, key2, value);
      } else {
        if (!this.style) {
          this.useStyle(value);
        } else {
          this.setStyle(value);
        }
      }
    };
    Displayable2.prototype.setStyle = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.style[keyOrObj] = value;
      } else {
        extend$1(this.style, keyOrObj);
      }
      this.dirtyStyle();
      return this;
    };
    Displayable2.prototype.dirtyStyle = function(notRedraw) {
      if (!notRedraw) {
        this.markRedraw();
      }
      this.__dirty |= STYLE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
    };
    Displayable2.prototype.dirty = function() {
      this.dirtyStyle();
    };
    Displayable2.prototype.styleChanged = function() {
      return !!(this.__dirty & STYLE_CHANGED_BIT);
    };
    Displayable2.prototype.styleUpdated = function() {
      this.__dirty &= ~STYLE_CHANGED_BIT;
    };
    Displayable2.prototype.createStyle = function(obj2) {
      return createObject(DEFAULT_COMMON_STYLE, obj2);
    };
    Displayable2.prototype.useStyle = function(obj2) {
      if (!obj2[STYLE_MAGIC_KEY]) {
        obj2 = this.createStyle(obj2);
      }
      if (this.__inHover) {
        this.__hoverStyle = obj2;
      } else {
        this.style = obj2;
      }
      this.dirtyStyle();
    };
    Displayable2.prototype.isStyleObject = function(obj2) {
      return obj2[STYLE_MAGIC_KEY];
    };
    Displayable2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.style && !normalState.style) {
        normalState.style = this._mergeStyle(this.createStyle(), this.style);
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
    };
    Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetStyle;
      if (state && state.style) {
        if (transition) {
          if (keepCurrentStates) {
            targetStyle = state.style;
          } else {
            targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
            this._mergeStyle(targetStyle, state.style);
          }
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else if (needsRestoreToNormal) {
        targetStyle = normalState.style;
      }
      if (targetStyle) {
        if (transition) {
          var sourceStyle = this.style;
          this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
          if (needsRestoreToNormal) {
            var changedKeys = keys(sourceStyle);
            for (var i2 = 0; i2 < changedKeys.length; i2++) {
              var key2 = changedKeys[i2];
              if (key2 in targetStyle) {
                targetStyle[key2] = targetStyle[key2];
                this.style[key2] = sourceStyle[key2];
              }
            }
          }
          var targetKeys = keys(targetStyle);
          for (var i2 = 0; i2 < targetKeys.length; i2++) {
            var key2 = targetKeys[i2];
            this.style[key2] = this.style[key2];
          }
          this._transitionState(stateName, {
            style: targetStyle
          }, animationCfg, this.getAnimationStyleProps());
        } else {
          this.useStyle(targetStyle);
        }
      }
      var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
      for (var i2 = 0; i2 < statesKeys.length; i2++) {
        var key2 = statesKeys[i2];
        if (state && state[key2] != null) {
          this[key2] = state[key2];
        } else if (needsRestoreToNormal) {
          if (normalState[key2] != null) {
            this[key2] = normalState[key2];
          }
        }
      }
    };
    Displayable2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedStyle;
      for (var i2 = 0; i2 < states.length; i2++) {
        var state = states[i2];
        if (state.style) {
          mergedStyle = mergedStyle || {};
          this._mergeStyle(mergedStyle, state.style);
        }
      }
      if (mergedStyle) {
        mergedState.style = mergedStyle;
      }
      return mergedState;
    };
    Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      extend$1(targetStyle, sourceStyle);
      return targetStyle;
    };
    Displayable2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_COMMON_ANIMATION_PROPS;
    };
    Displayable2.initDefaultProps = function() {
      var dispProto = Displayable2.prototype;
      dispProto.type = "displayable";
      dispProto.invisible = false;
      dispProto.z = 0;
      dispProto.z2 = 0;
      dispProto.zlevel = 0;
      dispProto.culling = false;
      dispProto.cursor = "pointer";
      dispProto.rectHover = false;
      dispProto.incremental = false;
      dispProto._rect = null;
      dispProto.dirtyRectTolerance = 0;
      dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
    }();
    return Displayable2;
  }(Element$1);
  var tmpRect = new BoundingRect(0, 0, 0, 0);
  var viewRect = new BoundingRect(0, 0, 0, 0);
  function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
      tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
  }
  var mathMin$5 = Math.min;
  var mathMax$5 = Math.max;
  var mathSin$3 = Math.sin;
  var mathCos$3 = Math.cos;
  var PI2$7 = Math.PI * 2;
  var start = create$1();
  var end = create$1();
  var extremity = create$1();
  function fromPoints(points2, min3, max3) {
    if (points2.length === 0) {
      return;
    }
    var p2 = points2[0];
    var left = p2[0];
    var right = p2[0];
    var top = p2[1];
    var bottom = p2[1];
    for (var i2 = 1; i2 < points2.length; i2++) {
      p2 = points2[i2];
      left = mathMin$5(left, p2[0]);
      right = mathMax$5(right, p2[0]);
      top = mathMin$5(top, p2[1]);
      bottom = mathMax$5(bottom, p2[1]);
    }
    min3[0] = left;
    min3[1] = top;
    max3[0] = right;
    max3[1] = bottom;
  }
  function fromLine(x0, y0, x1, y1, min3, max3) {
    min3[0] = mathMin$5(x0, x1);
    min3[1] = mathMin$5(y0, y1);
    max3[0] = mathMax$5(x0, x1);
    max3[1] = mathMax$5(y0, y1);
  }
  var xDim = [];
  var yDim = [];
  function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
    var cubicExtrema$1 = cubicExtrema;
    var cubicAt$1 = cubicAt;
    var n2 = cubicExtrema$1(x0, x1, x2, x3, xDim);
    min3[0] = Infinity;
    min3[1] = Infinity;
    max3[0] = -Infinity;
    max3[1] = -Infinity;
    for (var i2 = 0; i2 < n2; i2++) {
      var x4 = cubicAt$1(x0, x1, x2, x3, xDim[i2]);
      min3[0] = mathMin$5(x4, min3[0]);
      max3[0] = mathMax$5(x4, max3[0]);
    }
    n2 = cubicExtrema$1(y0, y1, y2, y3, yDim);
    for (var i2 = 0; i2 < n2; i2++) {
      var y4 = cubicAt$1(y0, y1, y2, y3, yDim[i2]);
      min3[1] = mathMin$5(y4, min3[1]);
      max3[1] = mathMax$5(y4, max3[1]);
    }
    min3[0] = mathMin$5(x0, min3[0]);
    max3[0] = mathMax$5(x0, max3[0]);
    min3[0] = mathMin$5(x3, min3[0]);
    max3[0] = mathMax$5(x3, max3[0]);
    min3[1] = mathMin$5(y0, min3[1]);
    max3[1] = mathMax$5(y0, max3[1]);
    min3[1] = mathMin$5(y3, min3[1]);
    max3[1] = mathMax$5(y3, max3[1]);
  }
  function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
    var quadraticExtremum$1 = quadraticExtremum;
    var quadraticAt$1 = quadraticAt;
    var tx = mathMax$5(mathMin$5(quadraticExtremum$1(x0, x1, x2), 1), 0);
    var ty = mathMax$5(mathMin$5(quadraticExtremum$1(y0, y1, y2), 1), 0);
    var x3 = quadraticAt$1(x0, x1, x2, tx);
    var y3 = quadraticAt$1(y0, y1, y2, ty);
    min3[0] = mathMin$5(x0, x2, x3);
    min3[1] = mathMin$5(y0, y2, y3);
    max3[0] = mathMax$5(x0, x2, x3);
    max3[1] = mathMax$5(y0, y2, y3);
  }
  function fromArc(x2, y2, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
    var vec2Min = min$1;
    var vec2Max = max$1;
    var diff = Math.abs(startAngle - endAngle);
    if (diff % PI2$7 < 1e-4 && diff > 1e-4) {
      min3[0] = x2 - rx;
      min3[1] = y2 - ry;
      max3[0] = x2 + rx;
      max3[1] = y2 + ry;
      return;
    }
    start[0] = mathCos$3(startAngle) * rx + x2;
    start[1] = mathSin$3(startAngle) * ry + y2;
    end[0] = mathCos$3(endAngle) * rx + x2;
    end[1] = mathSin$3(endAngle) * ry + y2;
    vec2Min(min3, start, end);
    vec2Max(max3, start, end);
    startAngle = startAngle % PI2$7;
    if (startAngle < 0) {
      startAngle = startAngle + PI2$7;
    }
    endAngle = endAngle % PI2$7;
    if (endAngle < 0) {
      endAngle = endAngle + PI2$7;
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2$7;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2$7;
    }
    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos$3(angle) * rx + x2;
        extremity[1] = mathSin$3(angle) * ry + y2;
        vec2Min(min3, extremity, min3);
        vec2Max(max3, extremity, max3);
      }
    }
  }
  var CMD$4 = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  };
  var tmpOutX = [];
  var tmpOutY = [];
  var min = [];
  var max = [];
  var min2 = [];
  var max2 = [];
  var mathMin$4 = Math.min;
  var mathMax$4 = Math.max;
  var mathCos$2 = Math.cos;
  var mathSin$2 = Math.sin;
  var mathAbs$1 = Math.abs;
  var PI$4 = Math.PI;
  var PI2$6 = PI$4 * 2;
  var hasTypedArray = typeof Float32Array !== "undefined";
  var tmpAngles = [];
  function modPI2(radian) {
    var n2 = Math.round(radian / PI$4 * 1e8) / 1e8;
    return n2 % 2 * PI$4;
  }
  function normalizeArcAngles(angles, anticlockwise) {
    var newStartAngle = modPI2(angles[0]);
    if (newStartAngle < 0) {
      newStartAngle += PI2$6;
    }
    var delta = newStartAngle - angles[0];
    var newEndAngle = angles[1];
    newEndAngle += delta;
    if (!anticlockwise && newEndAngle - newStartAngle >= PI2$6) {
      newEndAngle = newStartAngle + PI2$6;
    } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$6) {
      newEndAngle = newStartAngle - PI2$6;
    } else if (!anticlockwise && newStartAngle > newEndAngle) {
      newEndAngle = newStartAngle + (PI2$6 - modPI2(newStartAngle - newEndAngle));
    } else if (anticlockwise && newStartAngle < newEndAngle) {
      newEndAngle = newStartAngle - (PI2$6 - modPI2(newEndAngle - newStartAngle));
    }
    angles[0] = newStartAngle;
    angles[1] = newEndAngle;
  }
  var PathProxy = function() {
    function PathProxy2(notSaveData) {
      this.dpr = 1;
      this._xi = 0;
      this._yi = 0;
      this._x0 = 0;
      this._y0 = 0;
      this._len = 0;
      if (notSaveData) {
        this._saveData = false;
      }
      if (this._saveData) {
        this.data = [];
      }
    }
    PathProxy2.prototype.increaseVersion = function() {
      this._version++;
    };
    PathProxy2.prototype.getVersion = function() {
      return this._version;
    };
    PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
      segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
      if (segmentIgnoreThreshold > 0) {
        this._ux = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
        this._uy = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
      }
    };
    PathProxy2.prototype.setDPR = function(dpr2) {
      this.dpr = dpr2;
    };
    PathProxy2.prototype.setContext = function(ctx) {
      this._ctx = ctx;
    };
    PathProxy2.prototype.getContext = function() {
      return this._ctx;
    };
    PathProxy2.prototype.beginPath = function() {
      this._ctx && this._ctx.beginPath();
      this.reset();
      return this;
    };
    PathProxy2.prototype.reset = function() {
      if (this._saveData) {
        this._len = 0;
      }
      if (this._pathSegLen) {
        this._pathSegLen = null;
        this._pathLen = 0;
      }
      this._version++;
    };
    PathProxy2.prototype.moveTo = function(x2, y2) {
      this._drawPendingPt();
      this.addData(CMD$4.M, x2, y2);
      this._ctx && this._ctx.moveTo(x2, y2);
      this._x0 = x2;
      this._y0 = y2;
      this._xi = x2;
      this._yi = y2;
      return this;
    };
    PathProxy2.prototype.lineTo = function(x2, y2) {
      var dx = mathAbs$1(x2 - this._xi);
      var dy = mathAbs$1(y2 - this._yi);
      var exceedUnit = dx > this._ux || dy > this._uy;
      this.addData(CMD$4.L, x2, y2);
      if (this._ctx && exceedUnit) {
        this._ctx.lineTo(x2, y2);
      }
      if (exceedUnit) {
        this._xi = x2;
        this._yi = y2;
        this._pendingPtDist = 0;
      } else {
        var d2 = dx * dx + dy * dy;
        if (d2 > this._pendingPtDist) {
          this._pendingPtX = x2;
          this._pendingPtY = y2;
          this._pendingPtDist = d2;
        }
      }
      return this;
    };
    PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
      this._drawPendingPt();
      this.addData(CMD$4.C, x1, y1, x2, y2, x3, y3);
      if (this._ctx) {
        this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }
      this._xi = x3;
      this._yi = y3;
      return this;
    };
    PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
      this._drawPendingPt();
      this.addData(CMD$4.Q, x1, y1, x2, y2);
      if (this._ctx) {
        this._ctx.quadraticCurveTo(x1, y1, x2, y2);
      }
      this._xi = x2;
      this._yi = y2;
      return this;
    };
    PathProxy2.prototype.arc = function(cx, cy, r2, startAngle, endAngle, anticlockwise) {
      this._drawPendingPt();
      tmpAngles[0] = startAngle;
      tmpAngles[1] = endAngle;
      normalizeArcAngles(tmpAngles, anticlockwise);
      startAngle = tmpAngles[0];
      endAngle = tmpAngles[1];
      var delta = endAngle - startAngle;
      this.addData(CMD$4.A, cx, cy, r2, r2, startAngle, delta, 0, anticlockwise ? 0 : 1);
      this._ctx && this._ctx.arc(cx, cy, r2, startAngle, endAngle, anticlockwise);
      this._xi = mathCos$2(endAngle) * r2 + cx;
      this._yi = mathSin$2(endAngle) * r2 + cy;
      return this;
    };
    PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      this._drawPendingPt();
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius);
      }
      return this;
    };
    PathProxy2.prototype.rect = function(x2, y2, w2, h2) {
      this._drawPendingPt();
      this._ctx && this._ctx.rect(x2, y2, w2, h2);
      this.addData(CMD$4.R, x2, y2, w2, h2);
      return this;
    };
    PathProxy2.prototype.closePath = function() {
      this._drawPendingPt();
      this.addData(CMD$4.Z);
      var ctx = this._ctx;
      var x0 = this._x0;
      var y0 = this._y0;
      if (ctx) {
        ctx.closePath();
      }
      this._xi = x0;
      this._yi = y0;
      return this;
    };
    PathProxy2.prototype.fill = function(ctx) {
      ctx && ctx.fill();
      this.toStatic();
    };
    PathProxy2.prototype.stroke = function(ctx) {
      ctx && ctx.stroke();
      this.toStatic();
    };
    PathProxy2.prototype.len = function() {
      return this._len;
    };
    PathProxy2.prototype.setData = function(data) {
      var len2 = data.length;
      if (!(this.data && this.data.length === len2) && hasTypedArray) {
        this.data = new Float32Array(len2);
      }
      for (var i2 = 0; i2 < len2; i2++) {
        this.data[i2] = data[i2];
      }
      this._len = len2;
    };
    PathProxy2.prototype.appendPath = function(path) {
      if (!(path instanceof Array)) {
        path = [path];
      }
      var len2 = path.length;
      var appendSize = 0;
      var offset2 = this._len;
      for (var i2 = 0; i2 < len2; i2++) {
        appendSize += path[i2].len();
      }
      if (hasTypedArray && this.data instanceof Float32Array) {
        this.data = new Float32Array(offset2 + appendSize);
      }
      for (var i2 = 0; i2 < len2; i2++) {
        var appendPathData = path[i2].data;
        for (var k2 = 0; k2 < appendPathData.length; k2++) {
          this.data[offset2++] = appendPathData[k2];
        }
      }
      this._len = offset2;
    };
    PathProxy2.prototype.addData = function(cmd, a2, b2, c2, d2, e2, f2, g2, h2) {
      if (!this._saveData) {
        return;
      }
      var data = this.data;
      if (this._len + arguments.length > data.length) {
        this._expandData();
        data = this.data;
      }
      for (var i2 = 0; i2 < arguments.length; i2++) {
        data[this._len++] = arguments[i2];
      }
    };
    PathProxy2.prototype._drawPendingPt = function() {
      if (this._pendingPtDist > 0) {
        this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
        this._pendingPtDist = 0;
      }
    };
    PathProxy2.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        var newData = [];
        for (var i2 = 0; i2 < this._len; i2++) {
          newData[i2] = this.data[i2];
        }
        this.data = newData;
      }
    };
    PathProxy2.prototype.toStatic = function() {
      if (!this._saveData) {
        return;
      }
      this._drawPendingPt();
      var data = this.data;
      if (data instanceof Array) {
        data.length = this._len;
        if (hasTypedArray && this._len > 11) {
          this.data = new Float32Array(data);
        }
      }
    };
    PathProxy2.prototype.getBoundingRect = function() {
      min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
      max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
      var data = this.data;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      var i2;
      for (i2 = 0; i2 < this._len; ) {
        var cmd = data[i2++];
        var isFirst = i2 === 1;
        if (isFirst) {
          xi = data[i2];
          yi = data[i2 + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD$4.M:
            xi = x0 = data[i2++];
            yi = y0 = data[i2++];
            min2[0] = x0;
            min2[1] = y0;
            max2[0] = x0;
            max2[1] = y0;
            break;
          case CMD$4.L:
            fromLine(xi, yi, data[i2], data[i2 + 1], min2, max2);
            xi = data[i2++];
            yi = data[i2++];
            break;
          case CMD$4.C:
            fromCubic(xi, yi, data[i2++], data[i2++], data[i2++], data[i2++], data[i2], data[i2 + 1], min2, max2);
            xi = data[i2++];
            yi = data[i2++];
            break;
          case CMD$4.Q:
            fromQuadratic(xi, yi, data[i2++], data[i2++], data[i2], data[i2 + 1], min2, max2);
            xi = data[i2++];
            yi = data[i2++];
            break;
          case CMD$4.A:
            var cx = data[i2++];
            var cy = data[i2++];
            var rx = data[i2++];
            var ry = data[i2++];
            var startAngle = data[i2++];
            var endAngle = data[i2++] + startAngle;
            i2 += 1;
            var anticlockwise = !data[i2++];
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$4.R:
            x0 = xi = data[i2++];
            y0 = yi = data[i2++];
            var width = data[i2++];
            var height = data[i2++];
            fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
            break;
          case CMD$4.Z:
            xi = x0;
            yi = y0;
            break;
        }
        min$1(min, min, min2);
        max$1(max, max, max2);
      }
      if (i2 === 0) {
        min[0] = min[1] = max[0] = max[1] = 0;
      }
      return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    };
    PathProxy2.prototype._calculateLength = function() {
      var data = this.data;
      var len2 = this._len;
      var ux = this._ux;
      var uy = this._uy;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      if (!this._pathSegLen) {
        this._pathSegLen = [];
      }
      var pathSegLen = this._pathSegLen;
      var pathTotalLen = 0;
      var segCount = 0;
      for (var i2 = 0; i2 < len2; ) {
        var cmd = data[i2++];
        var isFirst = i2 === 1;
        if (isFirst) {
          xi = data[i2];
          yi = data[i2 + 1];
          x0 = xi;
          y0 = yi;
        }
        var l2 = -1;
        switch (cmd) {
          case CMD$4.M:
            xi = x0 = data[i2++];
            yi = y0 = data[i2++];
            break;
          case CMD$4.L: {
            var x2 = data[i2++];
            var y2 = data[i2++];
            var dx = x2 - xi;
            var dy = y2 - yi;
            if (mathAbs$1(dx) > ux || mathAbs$1(dy) > uy || i2 === len2 - 1) {
              l2 = Math.sqrt(dx * dx + dy * dy);
              xi = x2;
              yi = y2;
            }
            break;
          }
          case CMD$4.C: {
            var x1 = data[i2++];
            var y1 = data[i2++];
            var x2 = data[i2++];
            var y2 = data[i2++];
            var x3 = data[i2++];
            var y3 = data[i2++];
            l2 = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$4.Q: {
            var x1 = data[i2++];
            var y1 = data[i2++];
            var x2 = data[i2++];
            var y2 = data[i2++];
            l2 = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD$4.A:
            var cx = data[i2++];
            var cy = data[i2++];
            var rx = data[i2++];
            var ry = data[i2++];
            var startAngle = data[i2++];
            var delta = data[i2++];
            var endAngle = delta + startAngle;
            i2 += 1;
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            l2 = mathMax$4(rx, ry) * mathMin$4(PI2$6, Math.abs(delta));
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$4.R: {
            x0 = xi = data[i2++];
            y0 = yi = data[i2++];
            var width = data[i2++];
            var height = data[i2++];
            l2 = width * 2 + height * 2;
            break;
          }
          case CMD$4.Z: {
            var dx = x0 - xi;
            var dy = y0 - yi;
            l2 = Math.sqrt(dx * dx + dy * dy);
            xi = x0;
            yi = y0;
            break;
          }
        }
        if (l2 >= 0) {
          pathSegLen[segCount++] = l2;
          pathTotalLen += l2;
        }
      }
      this._pathLen = pathTotalLen;
      return pathTotalLen;
    };
    PathProxy2.prototype.rebuildPath = function(ctx, percent) {
      var d2 = this.data;
      var ux = this._ux;
      var uy = this._uy;
      var len2 = this._len;
      var x0;
      var y0;
      var xi;
      var yi;
      var x2;
      var y2;
      var drawPart = percent < 1;
      var pathSegLen;
      var pathTotalLen;
      var accumLength = 0;
      var segCount = 0;
      var displayedLength;
      var pendingPtDist = 0;
      var pendingPtX;
      var pendingPtY;
      if (drawPart) {
        if (!this._pathSegLen) {
          this._calculateLength();
        }
        pathSegLen = this._pathSegLen;
        pathTotalLen = this._pathLen;
        displayedLength = percent * pathTotalLen;
        if (!displayedLength) {
          return;
        }
      }
      lo: for (var i2 = 0; i2 < len2; ) {
        var cmd = d2[i2++];
        var isFirst = i2 === 1;
        if (isFirst) {
          xi = d2[i2];
          yi = d2[i2 + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD$4.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$4.M:
            x0 = xi = d2[i2++];
            y0 = yi = d2[i2++];
            ctx.moveTo(xi, yi);
            break;
          case CMD$4.L: {
            x2 = d2[i2++];
            y2 = d2[i2++];
            var dx = mathAbs$1(x2 - xi);
            var dy = mathAbs$1(y2 - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l2 = pathSegLen[segCount++];
                if (accumLength + l2 > displayedLength) {
                  var t2 = (displayedLength - accumLength) / l2;
                  ctx.lineTo(xi * (1 - t2) + x2 * t2, yi * (1 - t2) + y2 * t2);
                  break lo;
                }
                accumLength += l2;
              }
              ctx.lineTo(x2, y2);
              xi = x2;
              yi = y2;
              pendingPtDist = 0;
            } else {
              var d22 = dx * dx + dy * dy;
              if (d22 > pendingPtDist) {
                pendingPtX = x2;
                pendingPtY = y2;
                pendingPtDist = d22;
              }
            }
            break;
          }
          case CMD$4.C: {
            var x1 = d2[i2++];
            var y1 = d2[i2++];
            var x22 = d2[i2++];
            var y22 = d2[i2++];
            var x3 = d2[i2++];
            var y3 = d2[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                cubicSubdivide(xi, x1, x22, x3, t2, tmpOutX);
                cubicSubdivide(yi, y1, y22, y3, t2, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.bezierCurveTo(x1, y1, x22, y22, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$4.Q: {
            var x1 = d2[i2++];
            var y1 = d2[i2++];
            var x22 = d2[i2++];
            var y22 = d2[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                quadraticSubdivide(xi, x1, x22, t2, tmpOutX);
                quadraticSubdivide(yi, y1, y22, t2, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.quadraticCurveTo(x1, y1, x22, y22);
            xi = x22;
            yi = y22;
            break;
          }
          case CMD$4.A:
            var cx = d2[i2++];
            var cy = d2[i2++];
            var rx = d2[i2++];
            var ry = d2[i2++];
            var startAngle = d2[i2++];
            var delta = d2[i2++];
            var psi = d2[i2++];
            var anticlockwise = !d2[i2++];
            var r2 = rx > ry ? rx : ry;
            var isEllipse = mathAbs$1(rx - ry) > 1e-3;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l2;
                breakBuild = true;
              }
              accumLength += l2;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r2, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            xi = mathCos$2(endAngle) * rx + cx;
            yi = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$4.R:
            x0 = xi = d2[i2];
            y0 = yi = d2[i2 + 1];
            x2 = d2[i2++];
            y2 = d2[i2++];
            var width = d2[i2++];
            var height = d2[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + mathMin$4(d_1, width), y2);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + width, y2 + mathMin$4(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + mathMax$4(width - d_1, 0), y2 + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2, y2 + mathMax$4(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l2;
            }
            ctx.rect(x2, y2, width, height);
            break;
          case CMD$4.Z:
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                ctx.lineTo(xi * (1 - t2) + x0 * t2, yi * (1 - t2) + y0 * t2);
                break lo;
              }
              accumLength += l2;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
    };
    PathProxy2.prototype.clone = function() {
      var newProxy = new PathProxy2();
      var data = this.data;
      newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
      newProxy._len = this._len;
      return newProxy;
    };
    PathProxy2.CMD = CMD$4;
    PathProxy2.initDefaultProps = function() {
      var proto2 = PathProxy2.prototype;
      proto2._saveData = true;
      proto2._ux = 0;
      proto2._uy = 0;
      proto2._pendingPtDist = 0;
      proto2._version = 0;
    }();
    return PathProxy2;
  }();
  function containStroke$4(x0, y0, x1, y1, lineWidth, x2, y2) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    var _a2 = 0;
    var _b2 = x0;
    if (y2 > y0 + _l && y2 > y1 + _l || y2 < y0 - _l && y2 < y1 - _l || x2 > x0 + _l && x2 > x1 + _l || x2 < x0 - _l && x2 < x1 - _l) {
      return false;
    }
    if (x0 !== x1) {
      _a2 = (y0 - y1) / (x0 - x1);
      _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
      return Math.abs(x2 - x0) <= _l / 2;
    }
    var tmp = _a2 * x2 - y2 + _b2;
    var _s = tmp * tmp / (_a2 * _a2 + 1);
    return _s <= _l / 2 * _l / 2;
  }
  function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x4, y4) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y4 > y0 + _l && y4 > y1 + _l && y4 > y2 + _l && y4 > y3 + _l || y4 < y0 - _l && y4 < y1 - _l && y4 < y2 - _l && y4 < y3 - _l || x4 > x0 + _l && x4 > x1 + _l && x4 > x2 + _l && x4 > x3 + _l || x4 < x0 - _l && x4 < x1 - _l && x4 < x2 - _l && x4 < x3 - _l) {
      return false;
    }
    var d2 = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, null);
    return d2 <= _l / 2;
  }
  function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x3, y3) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y3 > y0 + _l && y3 > y1 + _l && y3 > y2 + _l || y3 < y0 - _l && y3 < y1 - _l && y3 < y2 - _l || x3 > x0 + _l && x3 > x1 + _l && x3 > x2 + _l || x3 < x0 - _l && x3 < x1 - _l && x3 < x2 - _l) {
      return false;
    }
    var d2 = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, null);
    return d2 <= _l / 2;
  }
  var PI2$5 = Math.PI * 2;
  function normalizeRadian(angle) {
    angle %= PI2$5;
    if (angle < 0) {
      angle += PI2$5;
    }
    return angle;
  }
  var PI2$4 = Math.PI * 2;
  function containStroke$1(cx, cy, r2, startAngle, endAngle, anticlockwise, lineWidth, x2, y2) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    x2 -= cx;
    y2 -= cy;
    var d2 = Math.sqrt(x2 * x2 + y2 * y2);
    if (d2 - _l > r2 || d2 + _l < r2) {
      return false;
    }
    if (Math.abs(startAngle - endAngle) % PI2$4 < 1e-4) {
      return true;
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI2$4;
    }
    var angle = Math.atan2(y2, x2);
    if (angle < 0) {
      angle += PI2$4;
    }
    return angle >= startAngle && angle <= endAngle || angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle;
  }
  function windingLine(x0, y0, x1, y1, x2, y2) {
    if (y2 > y0 && y2 > y1 || y2 < y0 && y2 < y1) {
      return 0;
    }
    if (y1 === y0) {
      return 0;
    }
    var t2 = (y2 - y0) / (y1 - y0);
    var dir3 = y1 < y0 ? 1 : -1;
    if (t2 === 1 || t2 === 0) {
      dir3 = y1 < y0 ? 0.5 : -0.5;
    }
    var x_ = t2 * (x1 - x0) + x0;
    return x_ === x2 ? Infinity : x_ > x2 ? dir3 : 0;
  }
  var CMD$3 = PathProxy.CMD;
  var PI2$3 = Math.PI * 2;
  var EPSILON$1 = 1e-4;
  function isAroundEqual$1(a2, b2) {
    return Math.abs(a2 - b2) < EPSILON$1;
  }
  var roots = [-1, -1, -1];
  var extrema = [-1, -1];
  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4) {
    if (y4 > y0 && y4 > y1 && y4 > y2 && y4 > y3 || y4 < y0 && y4 < y1 && y4 < y2 && y4 < y3) {
      return 0;
    }
    var nRoots = cubicRootAt(y0, y1, y2, y3, y4, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var w2 = 0;
      var nExtrema = -1;
      var y0_ = void 0;
      var y1_ = void 0;
      for (var i2 = 0; i2 < nRoots; i2++) {
        var t2 = roots[i2];
        var unit = t2 === 0 || t2 === 1 ? 0.5 : 1;
        var x_ = cubicAt(x0, x1, x2, x3, t2);
        if (x_ < x4) {
          continue;
        }
        if (nExtrema < 0) {
          nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema();
          }
          y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
          if (nExtrema > 1) {
            y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
          }
        }
        if (nExtrema === 2) {
          if (t2 < extrema[0]) {
            w2 += y0_ < y0 ? unit : -unit;
          } else if (t2 < extrema[1]) {
            w2 += y1_ < y0_ ? unit : -unit;
          } else {
            w2 += y3 < y1_ ? unit : -unit;
          }
        } else {
          if (t2 < extrema[0]) {
            w2 += y0_ < y0 ? unit : -unit;
          } else {
            w2 += y3 < y0_ ? unit : -unit;
          }
        }
      }
      return w2;
    }
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x3, y3) {
    if (y3 > y0 && y3 > y1 && y3 > y2 || y3 < y0 && y3 < y1 && y3 < y2) {
      return 0;
    }
    var nRoots = quadraticRootAt(y0, y1, y2, y3, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var t2 = quadraticExtremum(y0, y1, y2);
      if (t2 >= 0 && t2 <= 1) {
        var w2 = 0;
        var y_ = quadraticAt(y0, y1, y2, t2);
        for (var i2 = 0; i2 < nRoots; i2++) {
          var unit = roots[i2] === 0 || roots[i2] === 1 ? 0.5 : 1;
          var x_ = quadraticAt(x0, x1, x2, roots[i2]);
          if (x_ < x3) {
            continue;
          }
          if (roots[i2] < t2) {
            w2 += y_ < y0 ? unit : -unit;
          } else {
            w2 += y2 < y_ ? unit : -unit;
          }
        }
        return w2;
      } else {
        var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x2, roots[0]);
        if (x_ < x3) {
          return 0;
        }
        return y2 < y0 ? unit : -unit;
      }
    }
  }
  function windingArc(cx, cy, r2, startAngle, endAngle, anticlockwise, x2, y2) {
    y2 -= cy;
    if (y2 > r2 || y2 < -r2) {
      return 0;
    }
    var tmp = Math.sqrt(r2 * r2 - y2 * y2);
    roots[0] = -tmp;
    roots[1] = tmp;
    var dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) {
      return 0;
    }
    if (dTheta >= PI2$3 - 1e-4) {
      startAngle = 0;
      endAngle = PI2$3;
      var dir3 = anticlockwise ? 1 : -1;
      if (x2 >= roots[0] + cx && x2 <= roots[1] + cx) {
        return dir3;
      } else {
        return 0;
      }
    }
    if (startAngle > endAngle) {
      var tmp_1 = startAngle;
      startAngle = endAngle;
      endAngle = tmp_1;
    }
    if (startAngle < 0) {
      startAngle += PI2$3;
      endAngle += PI2$3;
    }
    var w2 = 0;
    for (var i2 = 0; i2 < 2; i2++) {
      var x_ = roots[i2];
      if (x_ + cx > x2) {
        var angle = Math.atan2(y2, x_);
        var dir3 = anticlockwise ? 1 : -1;
        if (angle < 0) {
          angle = PI2$3 + angle;
        }
        if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir3 = -dir3;
          }
          w2 += dir3;
        }
      }
    }
    return w2;
  }
  function containPath(path, lineWidth, isStroke, x2, y2) {
    var data = path.data;
    var len2 = path.len();
    var w2 = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    for (var i2 = 0; i2 < len2; ) {
      var cmd = data[i2++];
      var isFirst = i2 === 1;
      if (cmd === CMD$3.M && i2 > 1) {
        if (!isStroke) {
          w2 += windingLine(xi, yi, x0, y0, x2, y2);
        }
      }
      if (isFirst) {
        xi = data[i2];
        yi = data[i2 + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$3.M:
          x0 = data[i2++];
          y0 = data[i2++];
          xi = x0;
          yi = y0;
          break;
        case CMD$3.L:
          if (isStroke) {
            if (containStroke$4(xi, yi, data[i2], data[i2 + 1], lineWidth, x2, y2)) {
              return true;
            }
          } else {
            w2 += windingLine(xi, yi, data[i2], data[i2 + 1], x2, y2) || 0;
          }
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$3.C:
          if (isStroke) {
            if (containStroke$3(xi, yi, data[i2++], data[i2++], data[i2++], data[i2++], data[i2], data[i2 + 1], lineWidth, x2, y2)) {
              return true;
            }
          } else {
            w2 += windingCubic(xi, yi, data[i2++], data[i2++], data[i2++], data[i2++], data[i2], data[i2 + 1], x2, y2) || 0;
          }
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$3.Q:
          if (isStroke) {
            if (containStroke$2(xi, yi, data[i2++], data[i2++], data[i2], data[i2 + 1], lineWidth, x2, y2)) {
              return true;
            }
          } else {
            w2 += windingQuadratic(xi, yi, data[i2++], data[i2++], data[i2], data[i2 + 1], x2, y2) || 0;
          }
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$3.A:
          var cx = data[i2++];
          var cy = data[i2++];
          var rx = data[i2++];
          var ry = data[i2++];
          var theta = data[i2++];
          var dTheta = data[i2++];
          i2 += 1;
          var anticlockwise = !!(1 - data[i2++]);
          x1 = Math.cos(theta) * rx + cx;
          y1 = Math.sin(theta) * ry + cy;
          if (!isFirst) {
            w2 += windingLine(xi, yi, x1, y1, x2, y2);
          } else {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x2 - cx) * ry / rx + cx;
          if (isStroke) {
            if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y2)) {
              return true;
            }
          } else {
            w2 += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2);
          }
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD$3.R:
          x0 = xi = data[i2++];
          y0 = yi = data[i2++];
          var width = data[i2++];
          var height = data[i2++];
          x1 = x0 + width;
          y1 = y0 + height;
          if (isStroke) {
            if (containStroke$4(x0, y0, x1, y0, lineWidth, x2, y2) || containStroke$4(x1, y0, x1, y1, lineWidth, x2, y2) || containStroke$4(x1, y1, x0, y1, lineWidth, x2, y2) || containStroke$4(x0, y1, x0, y0, lineWidth, x2, y2)) {
              return true;
            }
          } else {
            w2 += windingLine(x1, y0, x1, y1, x2, y2);
            w2 += windingLine(x0, y1, x0, y0, x2, y2);
          }
          break;
        case CMD$3.Z:
          if (isStroke) {
            if (containStroke$4(xi, yi, x0, y0, lineWidth, x2, y2)) {
              return true;
            }
          } else {
            w2 += windingLine(xi, yi, x0, y0, x2, y2);
          }
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (!isStroke && !isAroundEqual$1(yi, y0)) {
      w2 += windingLine(xi, yi, x0, y0, x2, y2) || 0;
    }
    return w2 !== 0;
  }
  function contain$2(pathProxy, x2, y2) {
    return containPath(pathProxy, 0, false, x2, y2);
  }
  function containStroke(pathProxy, lineWidth, x2, y2) {
    return containPath(pathProxy, lineWidth, true, x2, y2);
  }
  var DEFAULT_PATH_STYLE = defaults$1({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults$1({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var pathCopyParams = TRANSFORMABLE_PROPS.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]);
  var Path = function(_super) {
    __extends(Path2, _super);
    function Path2(opts) {
      return _super.call(this, opts) || this;
    }
    Path2.prototype.update = function() {
      var _this = this;
      _super.prototype.update.call(this);
      var style = this.style;
      if (style.decal) {
        var decalEl = this._decalEl = this._decalEl || new Path2();
        if (decalEl.buildPath === Path2.prototype.buildPath) {
          decalEl.buildPath = function(ctx) {
            _this.buildPath(ctx, _this.shape);
          };
        }
        decalEl.silent = true;
        var decalElStyle = decalEl.style;
        for (var key2 in style) {
          if (decalElStyle[key2] !== style[key2]) {
            decalElStyle[key2] = style[key2];
          }
        }
        decalElStyle.fill = style.fill ? style.decal : null;
        decalElStyle.decal = null;
        decalElStyle.shadowColor = null;
        style.strokeFirst && (decalElStyle.stroke = null);
        for (var i2 = 0; i2 < pathCopyParams.length; ++i2) {
          decalEl[pathCopyParams[i2]] = this[pathCopyParams[i2]];
        }
        decalEl.__dirty |= REDRAW_BIT;
      } else if (this._decalEl) {
        this._decalEl = null;
      }
    };
    Path2.prototype.getDecalElement = function() {
      return this._decalEl;
    };
    Path2.prototype._init = function(props2) {
      var keysArr = keys(props2);
      this.shape = this.getDefaultShape();
      var defaultStyle = this.getDefaultStyle();
      if (defaultStyle) {
        this.useStyle(defaultStyle);
      }
      for (var i2 = 0; i2 < keysArr.length; i2++) {
        var key2 = keysArr[i2];
        var value = props2[key2];
        if (key2 === "style") {
          if (!this.style) {
            this.useStyle(value);
          } else {
            extend$1(this.style, value);
          }
        } else if (key2 === "shape") {
          extend$1(this.shape, value);
        } else {
          _super.prototype.attrKV.call(this, key2, value);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Path2.prototype.getDefaultStyle = function() {
      return null;
    };
    Path2.prototype.getDefaultShape = function() {
      return {};
    };
    Path2.prototype.canBeInsideText = function() {
      return this.hasFill();
    };
    Path2.prototype.getInsideTextFill = function() {
      var pathFill = this.style.fill;
      if (pathFill !== "none") {
        if (isString$1(pathFill)) {
          var fillLum = lum(pathFill, 0);
          if (fillLum > 0.5) {
            return DARK_LABEL_COLOR;
          } else if (fillLum > 0.2) {
            return LIGHTER_LABEL_COLOR;
          }
          return LIGHT_LABEL_COLOR;
        } else if (pathFill) {
          return LIGHT_LABEL_COLOR;
        }
      }
      return DARK_LABEL_COLOR;
    };
    Path2.prototype.getInsideTextStroke = function(textFill) {
      var pathFill = this.style.fill;
      if (isString$1(pathFill)) {
        var zr = this.__zr;
        var isDarkMode2 = !!(zr && zr.isDarkMode());
        var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
        if (isDarkMode2 === isDarkLabel) {
          return pathFill;
        }
      }
    };
    Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
    };
    Path2.prototype.pathUpdated = function() {
      this.__dirty &= ~SHAPE_CHANGED_BIT;
    };
    Path2.prototype.getUpdatedPathProxy = function(inBatch) {
      !this.path && this.createPathProxy();
      this.path.beginPath();
      this.buildPath(this.path, this.shape, inBatch);
      return this.path;
    };
    Path2.prototype.createPathProxy = function() {
      this.path = new PathProxy(false);
    };
    Path2.prototype.hasStroke = function() {
      var style = this.style;
      var stroke = style.stroke;
      return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
    };
    Path2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    Path2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      var style = this.style;
      var needsUpdateRect = !rect;
      if (needsUpdateRect) {
        var firstInvoke = false;
        if (!this.path) {
          firstInvoke = true;
          this.createPathProxy();
        }
        var path = this.path;
        if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
          path.beginPath();
          this.buildPath(path, this.shape, false);
          this.pathUpdated();
        }
        rect = path.getBoundingRect();
      }
      this._rect = rect;
      if (this.hasStroke() && this.path && this.path.len() > 0) {
        var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
        if (this.__dirty || needsUpdateRect) {
          rectStroke.copy(rect);
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          var w2 = style.lineWidth;
          if (!this.hasFill()) {
            var strokeContainThreshold = this.strokeContainThreshold;
            w2 = Math.max(w2, strokeContainThreshold == null ? 4 : strokeContainThreshold);
          }
          if (lineScale > 1e-10) {
            rectStroke.width += w2 / lineScale;
            rectStroke.height += w2 / lineScale;
            rectStroke.x -= w2 / lineScale / 2;
            rectStroke.y -= w2 / lineScale / 2;
          }
        }
        return rectStroke;
      }
      return rect;
    };
    Path2.prototype.contain = function(x2, y2) {
      var localPos = this.transformCoordToLocal(x2, y2);
      var rect = this.getBoundingRect();
      var style = this.style;
      x2 = localPos[0];
      y2 = localPos[1];
      if (rect.contain(x2, y2)) {
        var pathProxy = this.path;
        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          if (lineScale > 1e-10) {
            if (!this.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
            }
            if (containStroke(pathProxy, lineWidth / lineScale, x2, y2)) {
              return true;
            }
          }
        }
        if (this.hasFill()) {
          return contain$2(pathProxy, x2, y2);
        }
      }
      return false;
    };
    Path2.prototype.dirtyShape = function() {
      this.__dirty |= SHAPE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
      if (this._decalEl) {
        this._decalEl.dirtyShape();
      }
      this.markRedraw();
    };
    Path2.prototype.dirty = function() {
      this.dirtyStyle();
      this.dirtyShape();
    };
    Path2.prototype.animateShape = function(loop) {
      return this.animate("shape", loop);
    };
    Path2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else if (targetKey === "shape") {
        this.dirtyShape();
      } else {
        this.markRedraw();
      }
    };
    Path2.prototype.attrKV = function(key2, value) {
      if (key2 === "shape") {
        this.setShape(value);
      } else {
        _super.prototype.attrKV.call(this, key2, value);
      }
    };
    Path2.prototype.setShape = function(keyOrObj, value) {
      var shape = this.shape;
      if (!shape) {
        shape = this.shape = {};
      }
      if (typeof keyOrObj === "string") {
        shape[keyOrObj] = value;
      } else {
        extend$1(shape, keyOrObj);
      }
      this.dirtyShape();
      return this;
    };
    Path2.prototype.shapeChanged = function() {
      return !!(this.__dirty & SHAPE_CHANGED_BIT);
    };
    Path2.prototype.createStyle = function(obj2) {
      return createObject(DEFAULT_PATH_STYLE, obj2);
    };
    Path2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.shape && !normalState.shape) {
        normalState.shape = extend$1({}, this.shape);
      }
    };
    Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetShape;
      if (state && state.shape) {
        if (transition) {
          if (keepCurrentStates) {
            targetShape = state.shape;
          } else {
            targetShape = extend$1({}, normalState.shape);
            extend$1(targetShape, state.shape);
          }
        } else {
          targetShape = extend$1({}, keepCurrentStates ? this.shape : normalState.shape);
          extend$1(targetShape, state.shape);
        }
      } else if (needsRestoreToNormal) {
        targetShape = normalState.shape;
      }
      if (targetShape) {
        if (transition) {
          this.shape = extend$1({}, this.shape);
          var targetShapePrimaryProps = {};
          var shapeKeys = keys(targetShape);
          for (var i2 = 0; i2 < shapeKeys.length; i2++) {
            var key2 = shapeKeys[i2];
            if (typeof targetShape[key2] === "object") {
              this.shape[key2] = targetShape[key2];
            } else {
              targetShapePrimaryProps[key2] = targetShape[key2];
            }
          }
          this._transitionState(stateName, {
            shape: targetShapePrimaryProps
          }, animationCfg);
        } else {
          this.shape = targetShape;
          this.dirtyShape();
        }
      }
    };
    Path2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedShape;
      for (var i2 = 0; i2 < states.length; i2++) {
        var state = states[i2];
        if (state.shape) {
          mergedShape = mergedShape || {};
          this._mergeStyle(mergedShape, state.shape);
        }
      }
      if (mergedShape) {
        mergedState.shape = mergedShape;
      }
      return mergedState;
    };
    Path2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_PATH_ANIMATION_PROPS;
    };
    Path2.prototype.isZeroArea = function() {
      return false;
    };
    Path2.extend = function(defaultProps) {
      var Sub = function(_super2) {
        __extends(Sub2, _super2);
        function Sub2(opts) {
          var _this = _super2.call(this, opts) || this;
          defaultProps.init && defaultProps.init.call(_this, opts);
          return _this;
        }
        Sub2.prototype.getDefaultStyle = function() {
          return clone$4(defaultProps.style);
        };
        Sub2.prototype.getDefaultShape = function() {
          return clone$4(defaultProps.shape);
        };
        return Sub2;
      }(Path2);
      for (var key2 in defaultProps) {
        if (typeof defaultProps[key2] === "function") {
          Sub.prototype[key2] = defaultProps[key2];
        }
      }
      return Sub;
    };
    Path2.initDefaultProps = function() {
      var pathProto = Path2.prototype;
      pathProto.type = "path";
      pathProto.strokeContainThreshold = 5;
      pathProto.segmentIgnoreThreshold = 0;
      pathProto.subPixelOptimize = false;
      pathProto.autoBatch = false;
      pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
    }();
    return Path2;
  }(Displayable);
  var DEFAULT_TSPAN_STYLE = defaults$1({
    strokeFirst: true,
    font: DEFAULT_FONT,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, DEFAULT_PATH_STYLE);
  var TSpan = function(_super) {
    __extends(TSpan2, _super);
    function TSpan2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TSpan2.prototype.hasStroke = function() {
      var style = this.style;
      var stroke = style.stroke;
      return stroke != null && stroke !== "none" && style.lineWidth > 0;
    };
    TSpan2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    TSpan2.prototype.createStyle = function(obj2) {
      return createObject(DEFAULT_TSPAN_STYLE, obj2);
    };
    TSpan2.prototype.setBoundingRect = function(rect) {
      this._rect = rect;
    };
    TSpan2.prototype.getBoundingRect = function() {
      var style = this.style;
      if (!this._rect) {
        var text = style.text;
        text != null ? text += "" : text = "";
        var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
        rect.x += style.x || 0;
        rect.y += style.y || 0;
        if (this.hasStroke()) {
          var w2 = style.lineWidth;
          rect.x -= w2 / 2;
          rect.y -= w2 / 2;
          rect.width += w2;
          rect.height += w2;
        }
        this._rect = rect;
      }
      return this._rect;
    };
    TSpan2.initDefaultProps = function() {
      var tspanProto = TSpan2.prototype;
      tspanProto.dirtyRectTolerance = 10;
    }();
    return TSpan2;
  }(Displayable);
  TSpan.prototype.type = "tspan";
  var DEFAULT_IMAGE_STYLE = defaults$1({
    x: 0,
    y: 0
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults$1({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  function isImageLike(source) {
    return !!(source && typeof source !== "string" && source.width && source.height);
  }
  var ZRImage = function(_super) {
    __extends(ZRImage2, _super);
    function ZRImage2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ZRImage2.prototype.createStyle = function(obj2) {
      return createObject(DEFAULT_IMAGE_STYLE, obj2);
    };
    ZRImage2.prototype._getSize = function(dim) {
      var style = this.style;
      var size = style[dim];
      if (size != null) {
        return size;
      }
      var imageSource = isImageLike(style.image) ? style.image : this.__image;
      if (!imageSource) {
        return 0;
      }
      var otherDim = dim === "width" ? "height" : "width";
      var otherDimSize = style[otherDim];
      if (otherDimSize == null) {
        return imageSource[dim];
      } else {
        return imageSource[dim] / imageSource[otherDim] * otherDimSize;
      }
    };
    ZRImage2.prototype.getWidth = function() {
      return this._getSize("width");
    };
    ZRImage2.prototype.getHeight = function() {
      return this._getSize("height");
    };
    ZRImage2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_IMAGE_ANIMATION_PROPS;
    };
    ZRImage2.prototype.getBoundingRect = function() {
      var style = this.style;
      if (!this._rect) {
        this._rect = new BoundingRect(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
      }
      return this._rect;
    };
    return ZRImage2;
  }(Displayable);
  ZRImage.prototype.type = "image";
  function buildPath$2(ctx, shape) {
    var x2 = shape.x;
    var y2 = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r2 = shape.r;
    var r1;
    var r22;
    var r3;
    var r4;
    if (width < 0) {
      x2 = x2 + width;
      width = -width;
    }
    if (height < 0) {
      y2 = y2 + height;
      height = -height;
    }
    if (typeof r2 === "number") {
      r1 = r22 = r3 = r4 = r2;
    } else if (r2 instanceof Array) {
      if (r2.length === 1) {
        r1 = r22 = r3 = r4 = r2[0];
      } else if (r2.length === 2) {
        r1 = r3 = r2[0];
        r22 = r4 = r2[1];
      } else if (r2.length === 3) {
        r1 = r2[0];
        r22 = r4 = r2[1];
        r3 = r2[2];
      } else {
        r1 = r2[0];
        r22 = r2[1];
        r3 = r2[2];
        r4 = r2[3];
      }
    } else {
      r1 = r22 = r3 = r4 = 0;
    }
    var total;
    if (r1 + r22 > width) {
      total = r1 + r22;
      r1 *= width / total;
      r22 *= width / total;
    }
    if (r3 + r4 > width) {
      total = r3 + r4;
      r3 *= width / total;
      r4 *= width / total;
    }
    if (r22 + r3 > height) {
      total = r22 + r3;
      r22 *= height / total;
      r3 *= height / total;
    }
    if (r1 + r4 > height) {
      total = r1 + r4;
      r1 *= height / total;
      r4 *= height / total;
    }
    ctx.moveTo(x2 + r1, y2);
    ctx.lineTo(x2 + width - r22, y2);
    r22 !== 0 && ctx.arc(x2 + width - r22, y2 + r22, r22, -Math.PI / 2, 0);
    ctx.lineTo(x2 + width, y2 + height - r3);
    r3 !== 0 && ctx.arc(x2 + width - r3, y2 + height - r3, r3, 0, Math.PI / 2);
    ctx.lineTo(x2 + r4, y2 + height);
    r4 !== 0 && ctx.arc(x2 + r4, y2 + height - r4, r4, Math.PI / 2, Math.PI);
    ctx.lineTo(x2, y2 + r1);
    r1 !== 0 && ctx.arc(x2 + r1, y2 + r1, r1, Math.PI, Math.PI * 1.5);
  }
  var round = Math.round;
  function subPixelOptimizeLine$1(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var x1 = inputShape.x1;
    var x2 = inputShape.x2;
    var y1 = inputShape.y1;
    var y2 = inputShape.y2;
    outputShape.x1 = x1;
    outputShape.x2 = x2;
    outputShape.y1 = y1;
    outputShape.y2 = y2;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    if (round(x1 * 2) === round(x2 * 2)) {
      outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
    }
    if (round(y1 * 2) === round(y2 * 2)) {
      outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
    }
    return outputShape;
  }
  function subPixelOptimizeRect$1(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var originX = inputShape.x;
    var originY = inputShape.y;
    var originWidth = inputShape.width;
    var originHeight = inputShape.height;
    outputShape.x = originX;
    outputShape.y = originY;
    outputShape.width = originWidth;
    outputShape.height = originHeight;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
    outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
    outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
    outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    return outputShape;
  }
  function subPixelOptimize$1(position2, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
      return position2;
    }
    var doubledPosition = round(position2 * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
  }
  var RectShape = /* @__PURE__ */ function() {
    function RectShape2() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
    }
    return RectShape2;
  }();
  var subPixelOptimizeOutputShape$1 = {};
  var Rect = function(_super) {
    __extends(Rect2, _super);
    function Rect2(opts) {
      return _super.call(this, opts) || this;
    }
    Rect2.prototype.getDefaultShape = function() {
      return new RectShape();
    };
    Rect2.prototype.buildPath = function(ctx, shape) {
      var x2;
      var y2;
      var width;
      var height;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
        x2 = optimizedShape.x;
        y2 = optimizedShape.y;
        width = optimizedShape.width;
        height = optimizedShape.height;
        optimizedShape.r = shape.r;
        shape = optimizedShape;
      } else {
        x2 = shape.x;
        y2 = shape.y;
        width = shape.width;
        height = shape.height;
      }
      if (!shape.r) {
        ctx.rect(x2, y2, width, height);
      } else {
        buildPath$2(ctx, shape);
      }
    };
    Rect2.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    };
    return Rect2;
  }(Path);
  Rect.prototype.type = "rect";
  var DEFAULT_RICH_TEXT_COLOR = {
    fill: "#000"
  };
  var DEFAULT_STROKE_LINE_WIDTH = 2;
  var DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults$1({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var ZRText = function(_super) {
    __extends(ZRText2, _super);
    function ZRText2(opts) {
      var _this = _super.call(this) || this;
      _this.type = "text";
      _this._children = [];
      _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
      _this.attr(opts);
      return _this;
    }
    ZRText2.prototype.childrenRef = function() {
      return this._children;
    };
    ZRText2.prototype.update = function() {
      _super.prototype.update.call(this);
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      for (var i2 = 0; i2 < this._children.length; i2++) {
        var child = this._children[i2];
        child.zlevel = this.zlevel;
        child.z = this.z;
        child.z2 = this.z2;
        child.culling = this.culling;
        child.cursor = this.cursor;
        child.invisible = this.invisible;
      }
    };
    ZRText2.prototype.updateTransform = function() {
      var innerTransformable = this.innerTransformable;
      if (innerTransformable) {
        innerTransformable.updateTransform();
        if (innerTransformable.transform) {
          this.transform = innerTransformable.transform;
        }
      } else {
        _super.prototype.updateTransform.call(this);
      }
    };
    ZRText2.prototype.getLocalTransform = function(m2) {
      var innerTransformable = this.innerTransformable;
      return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
    };
    ZRText2.prototype.getComputedTransform = function() {
      if (this.__hostTarget) {
        this.__hostTarget.getComputedTransform();
        this.__hostTarget.updateInnerText(true);
      }
      return _super.prototype.getComputedTransform.call(this);
    };
    ZRText2.prototype._updateSubTexts = function() {
      this._childCursor = 0;
      normalizeTextStyle(this.style);
      this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
      this._children.length = this._childCursor;
      this.styleUpdated();
    };
    ZRText2.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i2 = 0; i2 < this._children.length; i2++) {
        this._children[i2].__zr = zr;
      }
    };
    ZRText2.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i2 = 0; i2 < this._children.length; i2++) {
        this._children[i2].__zr = null;
      }
    };
    ZRText2.prototype.getBoundingRect = function() {
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      if (!this._rect) {
        var tmpRect2 = new BoundingRect(0, 0, 0, 0);
        var children = this._children;
        var tmpMat = [];
        var rect = null;
        for (var i2 = 0; i2 < children.length; i2++) {
          var child = children[i2];
          var childRect = child.getBoundingRect();
          var transform2 = child.getLocalTransform(tmpMat);
          if (transform2) {
            tmpRect2.copy(childRect);
            tmpRect2.applyTransform(transform2);
            rect = rect || tmpRect2.clone();
            rect.union(tmpRect2);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }
        this._rect = rect || tmpRect2;
      }
      return this._rect;
    };
    ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
      this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
    };
    ZRText2.prototype.setTextContent = function(textContent) {
    };
    ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      if (!sourceStyle) {
        return targetStyle;
      }
      var sourceRich = sourceStyle.rich;
      var targetRich = targetStyle.rich || sourceRich && {};
      extend$1(targetStyle, sourceStyle);
      if (sourceRich && targetRich) {
        this._mergeRich(targetRich, sourceRich);
        targetStyle.rich = targetRich;
      } else if (targetRich) {
        targetStyle.rich = targetRich;
      }
      return targetStyle;
    };
    ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
      var richNames = keys(sourceRich);
      for (var i2 = 0; i2 < richNames.length; i2++) {
        var richName = richNames[i2];
        targetRich[richName] = targetRich[richName] || {};
        extend$1(targetRich[richName], sourceRich[richName]);
      }
    };
    ZRText2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_TEXT_ANIMATION_PROPS;
    };
    ZRText2.prototype._getOrCreateChild = function(Ctor) {
      var child = this._children[this._childCursor];
      if (!child || !(child instanceof Ctor)) {
        child = new Ctor();
      }
      this._children[this._childCursor++] = child;
      child.__zr = this.__zr;
      child.parent = this;
      return child;
    };
    ZRText2.prototype._updatePlainTexts = function() {
      var style = this.style;
      var textFont = style.font || DEFAULT_FONT;
      var textPadding = style.padding;
      var text = getStyleText(style);
      var contentBlock = parsePlainText(text, style);
      var needDrawBg = needDrawBackground(style);
      var bgColorDrawn = !!style.backgroundColor;
      var outerHeight = contentBlock.outerHeight;
      var outerWidth = contentBlock.outerWidth;
      var contentWidth = contentBlock.contentWidth;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var defaultStyle = this._defaultStyle;
      this.isTruncated = !!contentBlock.isTruncated;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.align || defaultStyle.align || "left";
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
      var textX = baseX;
      var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
      if (needDrawBg || textPadding) {
        var boxX = adjustTextX(baseX, outerWidth, textAlign);
        var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
        needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      textY += lineHeight / 2;
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        if (verticalAlign === "top") {
          textY += textPadding[0];
        } else if (verticalAlign === "bottom") {
          textY -= textPadding[2];
        }
      }
      var defaultLineWidth = 0;
      var useDefaultFill = false;
      var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
      var hasShadow = style.textShadowBlur > 0;
      var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
      var calculatedLineHeight = contentBlock.calculatedLineHeight;
      for (var i2 = 0; i2 < textLines.length; i2++) {
        var el = this._getOrCreateChild(TSpan);
        var subElStyle = el.createStyle();
        el.useStyle(subElStyle);
        subElStyle.text = textLines[i2];
        subElStyle.x = textX;
        subElStyle.y = textY;
        {
          subElStyle.textAlign = textAlign;
        }
        subElStyle.textBaseline = "middle";
        subElStyle.opacity = style.opacity;
        subElStyle.strokeFirst = true;
        if (hasShadow) {
          subElStyle.shadowBlur = style.textShadowBlur || 0;
          subElStyle.shadowColor = style.textShadowColor || "transparent";
          subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
          subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
        }
        subElStyle.stroke = textStroke;
        subElStyle.fill = textFill;
        if (textStroke) {
          subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
          subElStyle.lineDash = style.lineDash;
          subElStyle.lineDashOffset = style.lineDashOffset || 0;
        }
        subElStyle.font = textFont;
        setSeparateFont(subElStyle, style);
        textY += lineHeight;
        if (fixedBoundingRect) {
          el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, contentWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
        }
      }
    };
    ZRText2.prototype._updateRichTexts = function() {
      var style = this.style;
      var text = getStyleText(style);
      var contentBlock = parseRichText(text, style);
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.padding;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var defaultStyle = this._defaultStyle;
      var textAlign = style.align || defaultStyle.align;
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
      this.isTruncated = !!contentBlock.isTruncated;
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;
      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }
      var xRight = xLeft + contentWidth;
      if (needDrawBackground(style)) {
        this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      var bgColorDrawn = !!style.backgroundColor;
      for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
        var line2 = contentBlock.lines[i2];
        var tokens = line2.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line2.lineHeight;
        var remainedWidth = line2.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token2 = void 0;
        while (leftIndex < tokenCount && (token2 = tokens[leftIndex], !token2.align || token2.align === "left")) {
          this._placeToken(token2, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
          remainedWidth -= token2.width;
          lineXLeft += token2.width;
          leftIndex++;
        }
        while (rightIndex >= 0 && (token2 = tokens[rightIndex], token2.align === "right")) {
          this._placeToken(token2, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
          remainedWidth -= token2.width;
          lineXRight -= token2.width;
          rightIndex--;
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
        while (leftIndex <= rightIndex) {
          token2 = tokens[leftIndex];
          this._placeToken(token2, style, lineHeight, lineTop, lineXLeft + token2.width / 2, "center", bgColorDrawn);
          lineXLeft += token2.width;
          leftIndex++;
        }
        lineTop += lineHeight;
      }
    };
    ZRText2.prototype._placeToken = function(token2, style, lineHeight, lineTop, x2, textAlign, parentBgColorDrawn) {
      var tokenStyle = style.rich[token2.styleName] || {};
      tokenStyle.text = token2.text;
      var verticalAlign = token2.verticalAlign;
      var y2 = lineTop + lineHeight / 2;
      if (verticalAlign === "top") {
        y2 = lineTop + token2.height / 2;
      } else if (verticalAlign === "bottom") {
        y2 = lineTop + lineHeight - token2.height / 2;
      }
      var needDrawBg = !token2.isLineHolder && needDrawBackground(tokenStyle);
      needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x2 - token2.width : textAlign === "center" ? x2 - token2.width / 2 : x2, y2 - token2.height / 2, token2.width, token2.height);
      var bgColorDrawn = !!tokenStyle.backgroundColor;
      var textPadding = token2.textPadding;
      if (textPadding) {
        x2 = getTextXForPadding(x2, textAlign, textPadding);
        y2 -= token2.height / 2 - textPadding[0] - token2.innerHeight / 2;
      }
      var el = this._getOrCreateChild(TSpan);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      var defaultStyle = this._defaultStyle;
      var useDefaultFill = false;
      var defaultLineWidth = 0;
      var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
      var hasShadow = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
      subElStyle.text = token2.text;
      subElStyle.x = x2;
      subElStyle.y = y2;
      if (hasShadow) {
        subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
        subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
      }
      subElStyle.textAlign = textAlign;
      subElStyle.textBaseline = "middle";
      subElStyle.font = token2.font || DEFAULT_FONT;
      subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
      setSeparateFont(subElStyle, tokenStyle);
      if (textStroke) {
        subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
        subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
        subElStyle.stroke = textStroke;
      }
      if (textFill) {
        subElStyle.fill = textFill;
      }
      var textWidth = token2.contentWidth;
      var textHeight = token2.contentHeight;
      el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
    };
    ZRText2.prototype._renderBackground = function(style, topStyle, x2, y2, width, height) {
      var textBackgroundColor = style.backgroundColor;
      var textBorderWidth = style.borderWidth;
      var textBorderColor = style.borderColor;
      var isImageBg = textBackgroundColor && textBackgroundColor.image;
      var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
      var textBorderRadius = style.borderRadius;
      var self2 = this;
      var rectEl;
      var imgEl;
      if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
        rectEl = this._getOrCreateChild(Rect);
        rectEl.useStyle(rectEl.createStyle());
        rectEl.style.fill = null;
        var rectShape = rectEl.shape;
        rectShape.x = x2;
        rectShape.y = y2;
        rectShape.width = width;
        rectShape.height = height;
        rectShape.r = textBorderRadius;
        rectEl.dirtyShape();
      }
      if (isPlainOrGradientBg) {
        var rectStyle = rectEl.style;
        rectStyle.fill = textBackgroundColor || null;
        rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
      } else if (isImageBg) {
        imgEl = this._getOrCreateChild(ZRImage);
        imgEl.onload = function() {
          self2.dirtyStyle();
        };
        var imgStyle = imgEl.style;
        imgStyle.image = textBackgroundColor.image;
        imgStyle.x = x2;
        imgStyle.y = y2;
        imgStyle.width = width;
        imgStyle.height = height;
      }
      if (textBorderWidth && textBorderColor) {
        var rectStyle = rectEl.style;
        rectStyle.lineWidth = textBorderWidth;
        rectStyle.stroke = textBorderColor;
        rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
        rectStyle.lineDash = style.borderDash;
        rectStyle.lineDashOffset = style.borderDashOffset || 0;
        rectEl.strokeContainThreshold = 0;
        if (rectEl.hasFill() && rectEl.hasStroke()) {
          rectStyle.strokeFirst = true;
          rectStyle.lineWidth *= 2;
        }
      }
      var commonStyle = (rectEl || imgEl).style;
      commonStyle.shadowBlur = style.shadowBlur || 0;
      commonStyle.shadowColor = style.shadowColor || "transparent";
      commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
      commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
      commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
    };
    ZRText2.makeFont = function(style) {
      var font = "";
      if (hasSeparateFont(style)) {
        font = [
          style.fontStyle,
          style.fontWeight,
          parseFontSize(style.fontSize),
          style.fontFamily || "sans-serif"
        ].join(" ");
      }
      return font && trim$1(font) || style.textFont || style.font;
    };
    return ZRText2;
  }(Displayable);
  var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
  var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
  var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
  function parseFontSize(fontSize) {
    if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
      return fontSize;
    } else if (!isNaN(+fontSize)) {
      return fontSize + "px";
    } else {
      return DEFAULT_FONT_SIZE + "px";
    }
  }
  function setSeparateFont(targetStyle, sourceStyle) {
    for (var i2 = 0; i2 < FONT_PARTS.length; i2++) {
      var fontProp = FONT_PARTS[i2];
      var val = sourceStyle[fontProp];
      if (val != null) {
        targetStyle[fontProp] = val;
      }
    }
  }
  function hasSeparateFont(style) {
    return style.fontSize != null || style.fontFamily || style.fontWeight;
  }
  function normalizeTextStyle(style) {
    normalizeStyle(style);
    each$4(style.rich, normalizeStyle);
    return style;
  }
  function normalizeStyle(style) {
    if (style) {
      style.font = ZRText.makeFont(style);
      var textAlign = style.align;
      textAlign === "middle" && (textAlign = "center");
      style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
      var verticalAlign = style.verticalAlign;
      verticalAlign === "center" && (verticalAlign = "middle");
      style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
      var textPadding = style.padding;
      if (textPadding) {
        style.padding = normalizeCssArray$1(style.padding);
      }
    }
  }
  function getStroke(stroke, lineWidth) {
    return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
  }
  function getFill(fill) {
    return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
  }
  function getTextXForPadding(x2, textAlign, textPadding) {
    return textAlign === "right" ? x2 - textPadding[1] : textAlign === "center" ? x2 + textPadding[3] / 2 - textPadding[1] / 2 : x2 + textPadding[3];
  }
  function getStyleText(style) {
    var text = style.text;
    text != null && (text += "");
    return text;
  }
  function needDrawBackground(style) {
    return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
  }
  var getECData = makeInner();
  var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
    if (el) {
      var ecData = getECData(el);
      ecData.dataIndex = dataIdx;
      ecData.dataType = dataType;
      ecData.seriesIndex = seriesIndex;
      ecData.ssrType = "chart";
      if (el.type === "group") {
        el.traverse(function(child) {
          var childECData = getECData(child);
          childECData.seriesIndex = seriesIndex;
          childECData.dataIndex = dataIdx;
          childECData.dataType = dataType;
          childECData.ssrType = "chart";
        });
      }
    }
  };
  var _highlightNextDigit = 1;
  var _highlightKeyMap = {};
  var getSavedStates = makeInner();
  var getComponentStates = makeInner();
  var HOVER_STATE_NORMAL = 0;
  var HOVER_STATE_BLUR = 1;
  var HOVER_STATE_EMPHASIS = 2;
  var SPECIAL_STATES = ["emphasis", "blur", "select"];
  var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
  var Z2_EMPHASIS_LIFT = 10;
  var Z2_SELECT_LIFT = 9;
  var HIGHLIGHT_ACTION_TYPE = "highlight";
  var DOWNPLAY_ACTION_TYPE = "downplay";
  var SELECT_ACTION_TYPE = "select";
  var UNSELECT_ACTION_TYPE = "unselect";
  var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
  function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke !== "none";
  }
  function doChangeHoverState(el, stateName, hoverStateEnum) {
    if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
      el.onHoverStateChange(stateName);
    }
    el.hoverState = hoverStateEnum;
  }
  function singleEnterEmphasis(el) {
    doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
  }
  function singleLeaveEmphasis(el) {
    if (el.hoverState === HOVER_STATE_EMPHASIS) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterBlur(el) {
    doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
  }
  function singleLeaveBlur(el) {
    if (el.hoverState === HOVER_STATE_BLUR) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterSelect(el) {
    el.selected = true;
  }
  function singleLeaveSelect(el) {
    el.selected = false;
  }
  function updateElementState(el, updater, commonParam) {
    updater(el, commonParam);
  }
  function traverseUpdateState(el, updater, commonParam) {
    updateElementState(el, updater, commonParam);
    el.isGroup && el.traverse(function(child) {
      updateElementState(child, updater, commonParam);
    });
  }
  function setStatesFlag(el, stateName) {
    switch (stateName) {
      case "emphasis":
        el.hoverState = HOVER_STATE_EMPHASIS;
        break;
      case "normal":
        el.hoverState = HOVER_STATE_NORMAL;
        break;
      case "blur":
        el.hoverState = HOVER_STATE_BLUR;
        break;
      case "select":
        el.selected = true;
    }
  }
  function getFromStateStyle(el, props2, toStateName, defaultValue) {
    var style = el.style;
    var fromState = {};
    for (var i2 = 0; i2 < props2.length; i2++) {
      var propName = props2[i2];
      var val = style[propName];
      fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
    }
    for (var i2 = 0; i2 < el.animators.length; i2++) {
      var animator = el.animators[i2];
      if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
        animator.saveTo(fromState, props2);
      }
    }
    return fromState;
  }
  function createEmphasisDefaultState(el, stateName, targetStates, state) {
    var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
    var cloned = false;
    if (el instanceof Path) {
      var store = getSavedStates(el);
      var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
      var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
      if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
        state = state || {};
        var emphasisStyle = state.style || {};
        if (emphasisStyle.fill === "inherit") {
          cloned = true;
          state = extend$1({}, state);
          emphasisStyle = extend$1({}, emphasisStyle);
          emphasisStyle.fill = fromFill;
        } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
          cloned = true;
          state = extend$1({}, state);
          emphasisStyle = extend$1({}, emphasisStyle);
          emphasisStyle.fill = liftColor(fromFill);
        } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
          if (!cloned) {
            state = extend$1({}, state);
            emphasisStyle = extend$1({}, emphasisStyle);
          }
          emphasisStyle.stroke = liftColor(fromStroke);
        }
        state.style = emphasisStyle;
      }
    }
    if (state) {
      if (state.z2 == null) {
        if (!cloned) {
          state = extend$1({}, state);
        }
        var z2EmphasisLift = el.z2EmphasisLift;
        state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
      }
    }
    return state;
  }
  function createSelectDefaultState(el, stateName, state) {
    if (state) {
      if (state.z2 == null) {
        state = extend$1({}, state);
        var z2SelectLift = el.z2SelectLift;
        state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
      }
    }
    return state;
  }
  function createBlurDefaultState(el, stateName, state) {
    var hasBlur = indexOf(el.currentStates, stateName) >= 0;
    var currentOpacity = el.style.opacity;
    var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
      opacity: 1
    }) : null;
    state = state || {};
    var blurStyle = state.style || {};
    if (blurStyle.opacity == null) {
      state = extend$1({}, state);
      blurStyle = extend$1({
        // Already being applied 'emphasis'. DON'T mul opacity multiple times.
        opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
      }, blurStyle);
      state.style = blurStyle;
    }
    return state;
  }
  function elementStateProxy(stateName, targetStates) {
    var state = this.states[stateName];
    if (this.style) {
      if (stateName === "emphasis") {
        return createEmphasisDefaultState(this, stateName, targetStates, state);
      } else if (stateName === "blur") {
        return createBlurDefaultState(this, stateName, state);
      } else if (stateName === "select") {
        return createSelectDefaultState(this, stateName, state);
      }
    }
    return state;
  }
  function setDefaultStateProxy(el) {
    el.stateProxy = elementStateProxy;
    var textContent = el.getTextContent();
    var textGuide = el.getTextGuideLine();
    if (textContent) {
      textContent.stateProxy = elementStateProxy;
    }
    if (textGuide) {
      textGuide.stateProxy = elementStateProxy;
    }
  }
  function enterEmphasisWhenMouseOver(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasisWhenMouseOut(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterEmphasis(el, highlightDigit) {
    el.__highByOuter |= 1 << (highlightDigit || 0);
    traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasis(el, highlightDigit) {
    !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterBlur(el) {
    traverseUpdateState(el, singleEnterBlur);
  }
  function leaveBlur(el) {
    traverseUpdateState(el, singleLeaveBlur);
  }
  function enterSelect(el) {
    traverseUpdateState(el, singleEnterSelect);
  }
  function leaveSelect(el) {
    traverseUpdateState(el, singleLeaveSelect);
  }
  function shouldSilent(el, e2) {
    return el.__highDownSilentOnTouch && e2.zrByTouch;
  }
  function allLeaveBlur(api2) {
    var model = api2.getModel();
    var leaveBlurredSeries = [];
    var allComponentViews = [];
    model.eachComponent(function(componentType, componentModel) {
      var componentStates = getComponentStates(componentModel);
      var isSeries2 = componentType === "series";
      var view = isSeries2 ? api2.getViewOfSeriesModel(componentModel) : api2.getViewOfComponentModel(componentModel);
      !isSeries2 && allComponentViews.push(view);
      if (componentStates.isBlured) {
        view.group.traverse(function(child) {
          singleLeaveBlur(child);
        });
        isSeries2 && leaveBlurredSeries.push(componentModel);
      }
      componentStates.isBlured = false;
    });
    each$4(allComponentViews, function(view) {
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(leaveBlurredSeries, false, model);
      }
    });
  }
  function blurSeries(targetSeriesIndex, focus, blurScope, api2) {
    var ecModel = api2.getModel();
    blurScope = blurScope || "coordinateSystem";
    function leaveBlurOfIndices(data, dataIndices) {
      for (var i2 = 0; i2 < dataIndices.length; i2++) {
        var itemEl = data.getItemGraphicEl(dataIndices[i2]);
        itemEl && leaveBlur(itemEl);
      }
    }
    if (targetSeriesIndex == null) {
      return;
    }
    if (!focus || focus === "none") {
      return;
    }
    var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
    var targetCoordSys = targetSeriesModel.coordinateSystem;
    if (targetCoordSys && targetCoordSys.master) {
      targetCoordSys = targetCoordSys.master;
    }
    var blurredSeries = [];
    ecModel.eachSeries(function(seriesModel) {
      var sameSeries = targetSeriesModel === seriesModel;
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.master) {
        coordSys = coordSys.master;
      }
      var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
      if (!// Not blur other series if blurScope series
      (blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
        var view = api2.getViewOfSeriesModel(seriesModel);
        view.group.traverse(function(child) {
          if (child.__highByOuter && sameSeries && focus === "self") {
            return;
          }
          singleEnterBlur(child);
        });
        if (isArrayLike(focus)) {
          leaveBlurOfIndices(seriesModel.getData(), focus);
        } else if (isObject$3(focus)) {
          var dataTypes = keys(focus);
          for (var d2 = 0; d2 < dataTypes.length; d2++) {
            leaveBlurOfIndices(seriesModel.getData(dataTypes[d2]), focus[dataTypes[d2]]);
          }
        }
        blurredSeries.push(seriesModel);
        getComponentStates(seriesModel).isBlured = true;
      }
    });
    ecModel.eachComponent(function(componentType, componentModel) {
      if (componentType === "series") {
        return;
      }
      var view = api2.getViewOfComponentModel(componentModel);
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(blurredSeries, true, ecModel);
      }
    });
  }
  function blurComponent(componentMainType, componentIndex, api2) {
    if (componentMainType == null || componentIndex == null) {
      return;
    }
    var componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return;
    }
    getComponentStates(componentModel).isBlured = true;
    var view = api2.getViewOfComponentModel(componentModel);
    if (!view || !view.focusBlurEnabled) {
      return;
    }
    view.group.traverse(function(child) {
      singleEnterBlur(child);
    });
  }
  function blurSeriesFromHighlightPayload(seriesModel, payload, api2) {
    var seriesIndex = seriesModel.seriesIndex;
    var data = seriesModel.getData(payload.dataType);
    if (!data) {
      return;
    }
    var dataIndex = queryDataIndex(data, payload);
    dataIndex = (isArray$1(dataIndex) ? dataIndex[0] : dataIndex) || 0;
    var el = data.getItemGraphicEl(dataIndex);
    if (!el) {
      var count = data.count();
      var current = 0;
      while (!el && current < count) {
        el = data.getItemGraphicEl(current++);
      }
    }
    if (el) {
      var ecData = getECData(el);
      blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api2);
    } else {
      var focus_1 = seriesModel.get(["emphasis", "focus"]);
      var blurScope = seriesModel.get(["emphasis", "blurScope"]);
      if (focus_1 != null) {
        blurSeries(seriesIndex, focus_1, blurScope, api2);
      }
    }
  }
  function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api2) {
    var ret = {
      focusSelf: false,
      dispatchers: null
    };
    if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
      return ret;
    }
    var componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return ret;
    }
    var view = api2.getViewOfComponentModel(componentModel);
    if (!view || !view.findHighDownDispatchers) {
      return ret;
    }
    var dispatchers = view.findHighDownDispatchers(name);
    var focusSelf;
    for (var i2 = 0; i2 < dispatchers.length; i2++) {
      if (getECData(dispatchers[i2]).focus === "self") {
        focusSelf = true;
        break;
      }
    }
    return {
      focusSelf,
      dispatchers
    };
  }
  function handleGlobalMouseOverForHighDown(dispatcher, e2, api2) {
    var ecData = getECData(dispatcher);
    var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
    if (dispatchers) {
      if (focusSelf) {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
      }
      each$4(dispatchers, function(dispatcher2) {
        return enterEmphasisWhenMouseOver(dispatcher2, e2);
      });
    } else {
      blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api2);
      if (ecData.focus === "self") {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
      }
      enterEmphasisWhenMouseOver(dispatcher, e2);
    }
  }
  function handleGlobalMouseOutForHighDown(dispatcher, e2, api2) {
    allLeaveBlur(api2);
    var ecData = getECData(dispatcher);
    var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2).dispatchers;
    if (dispatchers) {
      each$4(dispatchers, function(dispatcher2) {
        return leaveEmphasisWhenMouseOut(dispatcher2, e2);
      });
    } else {
      leaveEmphasisWhenMouseOut(dispatcher, e2);
    }
  }
  function toggleSelectionFromPayload(seriesModel, payload, api2) {
    if (!isSelectChangePayload(payload)) {
      return;
    }
    var dataType = payload.dataType;
    var data = seriesModel.getData(dataType);
    var dataIndex = queryDataIndex(data, payload);
    if (!isArray$1(dataIndex)) {
      dataIndex = [dataIndex];
    }
    seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
  }
  function updateSeriesElementSelection(seriesModel) {
    var allData = seriesModel.getAllData();
    each$4(allData, function(_a2) {
      var data = _a2.data, type = _a2.type;
      data.eachItemGraphicEl(function(el, idx) {
        seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
      });
    });
  }
  function getAllSelectedIndices(ecModel) {
    var ret = [];
    ecModel.eachSeries(function(seriesModel) {
      var allData = seriesModel.getAllData();
      each$4(allData, function(_a2) {
        _a2.data;
        var type = _a2.type;
        var dataIndices = seriesModel.getSelectedDataIndices();
        if (dataIndices.length > 0) {
          var item = {
            dataIndex: dataIndices,
            seriesIndex: seriesModel.seriesIndex
          };
          if (type != null) {
            item.dataType = type;
          }
          ret.push(item);
        }
      });
    });
    return ret;
  }
  function enableHoverEmphasis(el, focus, blurScope) {
    setAsHighDownDispatcher(el, true);
    traverseUpdateState(el, setDefaultStateProxy);
    enableHoverFocus(el, focus, blurScope);
  }
  function disableHoverEmphasis(el) {
    setAsHighDownDispatcher(el, false);
  }
  function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
    isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
  }
  function enableHoverFocus(el, focus, blurScope) {
    var ecData = getECData(el);
    if (focus != null) {
      ecData.focus = focus;
      ecData.blurScope = blurScope;
    } else if (ecData.focus) {
      ecData.focus = null;
    }
  }
  var OTHER_STATES = ["emphasis", "blur", "select"];
  var defaultStyleGetterMap = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function setStatesStylesFromModel(el, itemModel, styleType, getter) {
    styleType = styleType || "itemStyle";
    for (var i2 = 0; i2 < OTHER_STATES.length; i2++) {
      var stateName = OTHER_STATES[i2];
      var model = itemModel.getModel([stateName, styleType]);
      var state = el.ensureState(stateName);
      state.style = model[defaultStyleGetterMap[styleType]]();
    }
  }
  function setAsHighDownDispatcher(el, asDispatcher) {
    var disable = asDispatcher === false;
    var extendedEl = el;
    if (el.highDownSilentOnTouch) {
      extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
    }
    if (!disable || extendedEl.__highDownDispatcher) {
      extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
      extendedEl.__highDownDispatcher = !disable;
    }
  }
  function isHighDownDispatcher(el) {
    return !!(el && el.__highDownDispatcher);
  }
  function getHighlightDigit(highlightKey) {
    var highlightDigit = _highlightKeyMap[highlightKey];
    if (highlightDigit == null && _highlightNextDigit <= 32) {
      highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
    }
    return highlightDigit;
  }
  function isSelectChangePayload(payload) {
    var payloadType = payload.type;
    return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
  }
  function isHighDownPayload(payload) {
    var payloadType = payload.type;
    return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
  }
  function savePathStates(el) {
    var store = getSavedStates(el);
    store.normalFill = el.style.fill;
    store.normalStroke = el.style.stroke;
    var selectState = el.states.select || {};
    store.selectFill = selectState.style && selectState.style.fill || null;
    store.selectStroke = selectState.style && selectState.style.stroke || null;
  }
  var CMD$2 = PathProxy.CMD;
  var points = [[], [], []];
  var mathSqrt$2 = Math.sqrt;
  var mathAtan2 = Math.atan2;
  function transformPath(path, m2) {
    if (!m2) {
      return;
    }
    var data = path.data;
    var len2 = path.len();
    var cmd;
    var nPoint;
    var i2;
    var j2;
    var k2;
    var p2;
    var M2 = CMD$2.M;
    var C = CMD$2.C;
    var L2 = CMD$2.L;
    var R2 = CMD$2.R;
    var A2 = CMD$2.A;
    var Q = CMD$2.Q;
    for (i2 = 0, j2 = 0; i2 < len2; ) {
      cmd = data[i2++];
      j2 = i2;
      nPoint = 0;
      switch (cmd) {
        case M2:
          nPoint = 1;
          break;
        case L2:
          nPoint = 1;
          break;
        case C:
          nPoint = 3;
          break;
        case Q:
          nPoint = 2;
          break;
        case A2:
          var x2 = m2[4];
          var y2 = m2[5];
          var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
          var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
          var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
          data[i2] *= sx;
          data[i2++] += x2;
          data[i2] *= sy;
          data[i2++] += y2;
          data[i2++] *= sx;
          data[i2++] *= sy;
          data[i2++] += angle;
          data[i2++] += angle;
          i2 += 2;
          j2 = i2;
          break;
        case R2:
          p2[0] = data[i2++];
          p2[1] = data[i2++];
          applyTransform$1(p2, p2, m2);
          data[j2++] = p2[0];
          data[j2++] = p2[1];
          p2[0] += data[i2++];
          p2[1] += data[i2++];
          applyTransform$1(p2, p2, m2);
          data[j2++] = p2[0];
          data[j2++] = p2[1];
      }
      for (k2 = 0; k2 < nPoint; k2++) {
        var p_1 = points[k2];
        p_1[0] = data[i2++];
        p_1[1] = data[i2++];
        applyTransform$1(p_1, p_1, m2);
        data[j2++] = p_1[0];
        data[j2++] = p_1[1];
      }
    }
    path.increaseVersion();
  }
  var mathSqrt$1 = Math.sqrt;
  var mathSin$1 = Math.sin;
  var mathCos$1 = Math.cos;
  var PI$3 = Math.PI;
  function vMag(v2) {
    return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
  }
  function vRatio(u2, v2) {
    return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
  }
  function vAngle(u2, v2) {
    return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
  }
  function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI$3 / 180);
    var xp = mathCos$1(psi) * (x1 - x2) / 2 + mathSin$1(psi) * (y1 - y2) / 2;
    var yp = -1 * mathSin$1(psi) * (x1 - x2) / 2 + mathCos$1(psi) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= mathSqrt$1(lambda);
      ry *= mathSqrt$1(lambda);
    }
    var f2 = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
    var cxp = f2 * rx * yp / ry;
    var cyp = f2 * -ry * xp / rx;
    var cx = (x1 + x2) / 2 + mathCos$1(psi) * cxp - mathSin$1(psi) * cyp;
    var cy = (y1 + y2) / 2 + mathSin$1(psi) * cxp + mathCos$1(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u2, v2);
    if (vRatio(u2, v2) <= -1) {
      dTheta = PI$3;
    }
    if (vRatio(u2, v2) >= 1) {
      dTheta = 0;
    }
    if (dTheta < 0) {
      var n2 = Math.round(dTheta / PI$3 * 1e6) / 1e6;
      dTheta = PI$3 * 2 + n2 % 2 * PI$3;
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
  }
  var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
  var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function createPathProxyFromString(data) {
    var path = new PathProxy();
    if (!data) {
      return path;
    }
    var cpx = 0;
    var cpy = 0;
    var subpathX = cpx;
    var subpathY = cpy;
    var prevCmd;
    var CMD2 = PathProxy.CMD;
    var cmdList = data.match(commandReg);
    if (!cmdList) {
      return path;
    }
    for (var l2 = 0; l2 < cmdList.length; l2++) {
      var cmdText = cmdList[l2];
      var cmdStr = cmdText.charAt(0);
      var cmd = void 0;
      var p2 = cmdText.match(numberReg) || [];
      var pLen = p2.length;
      for (var i2 = 0; i2 < pLen; i2++) {
        p2[i2] = parseFloat(p2[i2]);
      }
      var off = 0;
      while (off < pLen) {
        var ctlPtx = void 0;
        var ctlPty = void 0;
        var rx = void 0;
        var ry = void 0;
        var psi = void 0;
        var fa = void 0;
        var fs = void 0;
        var x1 = cpx;
        var y1 = cpy;
        var len2 = void 0;
        var pathData = void 0;
        switch (cmdStr) {
          case "l":
            cpx += p2[off++];
            cpy += p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "L":
            cpx = p2[off++];
            cpy = p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "m":
            cpx += p2[off++];
            cpy += p2[off++];
            cmd = CMD2.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "l";
            break;
          case "M":
            cpx = p2[off++];
            cpy = p2[off++];
            cmd = CMD2.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "L";
            break;
          case "h":
            cpx += p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "H":
            cpx = p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "v":
            cpy += p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "V":
            cpy = p2[off++];
            cmd = CMD2.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "C":
            cmd = CMD2.C;
            path.addData(cmd, p2[off++], p2[off++], p2[off++], p2[off++], p2[off++], p2[off++]);
            cpx = p2[off - 2];
            cpy = p2[off - 1];
            break;
          case "c":
            cmd = CMD2.C;
            path.addData(cmd, p2[off++] + cpx, p2[off++] + cpy, p2[off++] + cpx, p2[off++] + cpy, p2[off++] + cpx, p2[off++] + cpy);
            cpx += p2[off - 2];
            cpy += p2[off - 1];
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD2.C;
            x1 = p2[off++];
            y1 = p2[off++];
            cpx = p2[off++];
            cpy = p2[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD2.C;
            x1 = cpx + p2[off++];
            y1 = cpy + p2[off++];
            cpx += p2[off++];
            cpy += p2[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "Q":
            x1 = p2[off++];
            y1 = p2[off++];
            cpx = p2[off++];
            cpy = p2[off++];
            cmd = CMD2.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "q":
            x1 = p2[off++] + cpx;
            y1 = p2[off++] + cpy;
            cpx += p2[off++];
            cpy += p2[off++];
            cmd = CMD2.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx = p2[off++];
            cpy = p2[off++];
            cmd = CMD2.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD2.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx += p2[off++];
            cpy += p2[off++];
            cmd = CMD2.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p2[off++];
            ry = p2[off++];
            psi = p2[off++];
            fa = p2[off++];
            fs = p2[off++];
            x1 = cpx, y1 = cpy;
            cpx = p2[off++];
            cpy = p2[off++];
            cmd = CMD2.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
          case "a":
            rx = p2[off++];
            ry = p2[off++];
            psi = p2[off++];
            fa = p2[off++];
            fs = p2[off++];
            x1 = cpx, y1 = cpy;
            cpx += p2[off++];
            cpy += p2[off++];
            cmd = CMD2.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
        }
      }
      if (cmdStr === "z" || cmdStr === "Z") {
        cmd = CMD2.Z;
        path.addData(cmd);
        cpx = subpathX;
        cpy = subpathY;
      }
      prevCmd = cmd;
    }
    path.toStatic();
    return path;
  }
  var SVGPath = function(_super) {
    __extends(SVGPath2, _super);
    function SVGPath2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SVGPath2.prototype.applyTransform = function(m2) {
    };
    return SVGPath2;
  }(Path);
  function isPathProxy(path) {
    return path.setData != null;
  }
  function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    var innerOpts = extend$1({}, opts);
    innerOpts.buildPath = function(path) {
      if (isPathProxy(path)) {
        path.setData(pathProxy.data);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      } else {
        var ctx = path;
        pathProxy.rebuildPath(ctx, 1);
      }
    };
    innerOpts.applyTransform = function(m2) {
      transformPath(pathProxy, m2);
      this.dirtyShape();
    };
    return innerOpts;
  }
  function createFromString(str, opts) {
    return new SVGPath(createPathOptions(str, opts));
  }
  function extendFromString(str, defaultOpts) {
    var innerOpts = createPathOptions(str, defaultOpts);
    var Sub = function(_super) {
      __extends(Sub2, _super);
      function Sub2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.applyTransform = innerOpts.applyTransform;
        _this.buildPath = innerOpts.buildPath;
        return _this;
      }
      return Sub2;
    }(SVGPath);
    return Sub;
  }
  function mergePath$1(pathEls, opts) {
    var pathList = [];
    var len2 = pathEls.length;
    for (var i2 = 0; i2 < len2; i2++) {
      var pathEl = pathEls[i2];
      pathList.push(pathEl.getUpdatedPathProxy(true));
    }
    var pathBundle = new Path(opts);
    pathBundle.createPathProxy();
    pathBundle.buildPath = function(path) {
      if (isPathProxy(path)) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      }
    };
    return pathBundle;
  }
  function clonePath(sourcePath, opts) {
    opts = opts || {};
    var path = new Path();
    if (sourcePath.shape) {
      path.setShape(sourcePath.shape);
    }
    path.setStyle(sourcePath.style);
    if (opts.bakeTransform) {
      transformPath(path.path, sourcePath.getComputedTransform());
    } else {
      if (opts.toLocal) {
        path.setLocalTransform(sourcePath.getComputedTransform());
      } else {
        path.copyTransform(sourcePath);
      }
    }
    path.buildPath = sourcePath.buildPath;
    path.applyTransform = path.applyTransform;
    path.z = sourcePath.z;
    path.z2 = sourcePath.z2;
    path.zlevel = sourcePath.zlevel;
    return path;
  }
  var CircleShape = /* @__PURE__ */ function() {
    function CircleShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
    }
    return CircleShape2;
  }();
  var Circle = function(_super) {
    __extends(Circle2, _super);
    function Circle2(opts) {
      return _super.call(this, opts) || this;
    }
    Circle2.prototype.getDefaultShape = function() {
      return new CircleShape();
    };
    Circle2.prototype.buildPath = function(ctx, shape) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
    };
    return Circle2;
  }(Path);
  Circle.prototype.type = "circle";
  var EllipseShape = /* @__PURE__ */ function() {
    function EllipseShape2() {
      this.cx = 0;
      this.cy = 0;
      this.rx = 0;
      this.ry = 0;
    }
    return EllipseShape2;
  }();
  var Ellipse = function(_super) {
    __extends(Ellipse2, _super);
    function Ellipse2(opts) {
      return _super.call(this, opts) || this;
    }
    Ellipse2.prototype.getDefaultShape = function() {
      return new EllipseShape();
    };
    Ellipse2.prototype.buildPath = function(ctx, shape) {
      var k2 = 0.5522848;
      var x2 = shape.cx;
      var y2 = shape.cy;
      var a2 = shape.rx;
      var b2 = shape.ry;
      var ox = a2 * k2;
      var oy = b2 * k2;
      ctx.moveTo(x2 - a2, y2);
      ctx.bezierCurveTo(x2 - a2, y2 - oy, x2 - ox, y2 - b2, x2, y2 - b2);
      ctx.bezierCurveTo(x2 + ox, y2 - b2, x2 + a2, y2 - oy, x2 + a2, y2);
      ctx.bezierCurveTo(x2 + a2, y2 + oy, x2 + ox, y2 + b2, x2, y2 + b2);
      ctx.bezierCurveTo(x2 - ox, y2 + b2, x2 - a2, y2 + oy, x2 - a2, y2);
      ctx.closePath();
    };
    return Ellipse2;
  }(Path);
  Ellipse.prototype.type = "ellipse";
  var PI$2 = Math.PI;
  var PI2$2 = PI$2 * 2;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var mathACos = Math.acos;
  var mathATan2 = Math.atan2;
  var mathAbs = Math.abs;
  var mathSqrt = Math.sqrt;
  var mathMax$3 = Math.max;
  var mathMin$3 = Math.min;
  var e = 1e-4;
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx10 = x1 - x0;
    var dy10 = y1 - y0;
    var dx32 = x3 - x2;
    var dy32 = y3 - y2;
    var t2 = dy32 * dx10 - dx32 * dy10;
    if (t2 * t2 < e) {
      return;
    }
    t2 = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t2;
    return [x0 + t2 * dx10, y0 + t2 * dy10];
  }
  function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
    var x01 = x0 - x1;
    var y01 = y0 - y1;
    var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
    var ox = lo * y01;
    var oy = -lo * x01;
    var x11 = x0 + ox;
    var y11 = y0 + oy;
    var x10 = x1 + ox;
    var y10 = y1 + oy;
    var x00 = (x11 + x10) / 2;
    var y00 = (y11 + y10) / 2;
    var dx = x10 - x11;
    var dy = y10 - y11;
    var d2 = dx * dx + dy * dy;
    var r2 = radius - cr;
    var s2 = x11 * y10 - x10 * y11;
    var d3 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$3(0, r2 * r2 * d2 - s2 * s2));
    var cx0 = (s2 * dy - dx * d3) / d2;
    var cy0 = (-s2 * dx - dy * d3) / d2;
    var cx1 = (s2 * dy + dx * d3) / d2;
    var cy1 = (-s2 * dx + dy * d3) / d2;
    var dx0 = cx0 - x00;
    var dy0 = cy0 - y00;
    var dx1 = cx1 - x00;
    var dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
      cx0 = cx1;
      cy0 = cy1;
    }
    return {
      cx: cx0,
      cy: cy0,
      x0: -ox,
      y0: -oy,
      x1: cx0 * (radius / r2 - 1),
      y1: cy0 * (radius / r2 - 1)
    };
  }
  function normalizeCornerRadius(cr) {
    var arr;
    if (isArray$1(cr)) {
      var len2 = cr.length;
      if (!len2) {
        return cr;
      }
      if (len2 === 1) {
        arr = [cr[0], cr[0], 0, 0];
      } else if (len2 === 2) {
        arr = [cr[0], cr[0], cr[1], cr[1]];
      } else if (len2 === 3) {
        arr = cr.concat(cr[2]);
      } else {
        arr = cr;
      }
    } else {
      arr = [cr, cr, cr, cr];
    }
    return arr;
  }
  function buildPath$1(ctx, shape) {
    var _a2;
    var radius = mathMax$3(shape.r, 0);
    var innerRadius = mathMax$3(shape.r0 || 0, 0);
    var hasRadius = radius > 0;
    var hasInnerRadius = innerRadius > 0;
    if (!hasRadius && !hasInnerRadius) {
      return;
    }
    if (!hasRadius) {
      radius = innerRadius;
      innerRadius = 0;
    }
    if (innerRadius > radius) {
      var tmp = radius;
      radius = innerRadius;
      innerRadius = tmp;
    }
    var startAngle = shape.startAngle, endAngle = shape.endAngle;
    if (isNaN(startAngle) || isNaN(endAngle)) {
      return;
    }
    var cx = shape.cx, cy = shape.cy;
    var clockwise = !!shape.clockwise;
    var arc = mathAbs(endAngle - startAngle);
    var mod = arc > PI2$2 && arc % PI2$2;
    mod > e && (arc = mod);
    if (!(radius > e)) {
      ctx.moveTo(cx, cy);
    } else if (arc > PI2$2 - e) {
      ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      if (innerRadius > e) {
        ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    } else {
      var icrStart = void 0;
      var icrEnd = void 0;
      var ocrStart = void 0;
      var ocrEnd = void 0;
      var ocrs = void 0;
      var ocre = void 0;
      var icrs = void 0;
      var icre = void 0;
      var ocrMax = void 0;
      var icrMax = void 0;
      var limitedOcrMax = void 0;
      var limitedIcrMax = void 0;
      var xre = void 0;
      var yre = void 0;
      var xirs = void 0;
      var yirs = void 0;
      var xrs = radius * mathCos(startAngle);
      var yrs = radius * mathSin(startAngle);
      var xire = innerRadius * mathCos(endAngle);
      var yire = innerRadius * mathSin(endAngle);
      var hasArc = arc > e;
      if (hasArc) {
        var cornerRadius = shape.cornerRadius;
        if (cornerRadius) {
          _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
        }
        var halfRd = mathAbs(radius - innerRadius) / 2;
        ocrs = mathMin$3(halfRd, ocrStart);
        ocre = mathMin$3(halfRd, ocrEnd);
        icrs = mathMin$3(halfRd, icrStart);
        icre = mathMin$3(halfRd, icrEnd);
        limitedOcrMax = ocrMax = mathMax$3(ocrs, ocre);
        limitedIcrMax = icrMax = mathMax$3(icrs, icre);
        if (ocrMax > e || icrMax > e) {
          xre = radius * mathCos(endAngle);
          yre = radius * mathSin(endAngle);
          xirs = innerRadius * mathCos(startAngle);
          yirs = innerRadius * mathSin(startAngle);
          if (arc < PI$2) {
            var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
            if (it_1) {
              var x0 = xrs - it_1[0];
              var y0 = yrs - it_1[1];
              var x1 = xre - it_1[0];
              var y1 = yre - it_1[1];
              var a2 = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
              var b2 = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
              limitedOcrMax = mathMin$3(ocrMax, (radius - b2) / (a2 + 1));
              limitedIcrMax = mathMin$3(icrMax, (innerRadius - b2) / (a2 - 1));
            }
          }
        }
      }
      if (!hasArc) {
        ctx.moveTo(cx + xrs, cy + yrs);
      } else if (limitedOcrMax > e) {
        var crStart = mathMin$3(ocrStart, limitedOcrMax);
        var crEnd = mathMin$3(ocrEnd, limitedOcrMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
        ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedOcrMax < ocrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
          crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.moveTo(cx + xrs, cy + yrs);
        ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      }
      if (!(innerRadius > e) || !hasArc) {
        ctx.lineTo(cx + xire, cy + yire);
      } else if (limitedIcrMax > e) {
        var crStart = mathMin$3(icrStart, limitedIcrMax);
        var crEnd = mathMin$3(icrEnd, limitedIcrMax);
        var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
        ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedIcrMax < icrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
          crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.lineTo(cx + xire, cy + yire);
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    }
    ctx.closePath();
  }
  var SectorShape = /* @__PURE__ */ function() {
    function SectorShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r0 = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
      this.cornerRadius = 0;
    }
    return SectorShape2;
  }();
  var Sector = function(_super) {
    __extends(Sector2, _super);
    function Sector2(opts) {
      return _super.call(this, opts) || this;
    }
    Sector2.prototype.getDefaultShape = function() {
      return new SectorShape();
    };
    Sector2.prototype.buildPath = function(ctx, shape) {
      buildPath$1(ctx, shape);
    };
    Sector2.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    };
    return Sector2;
  }(Path);
  Sector.prototype.type = "sector";
  var RingShape = /* @__PURE__ */ function() {
    function RingShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.r0 = 0;
    }
    return RingShape2;
  }();
  var Ring = function(_super) {
    __extends(Ring2, _super);
    function Ring2(opts) {
      return _super.call(this, opts) || this;
    }
    Ring2.prototype.getDefaultShape = function() {
      return new RingShape();
    };
    Ring2.prototype.buildPath = function(ctx, shape) {
      var x2 = shape.cx;
      var y2 = shape.cy;
      var PI22 = Math.PI * 2;
      ctx.moveTo(x2 + shape.r, y2);
      ctx.arc(x2, y2, shape.r, 0, PI22, false);
      ctx.moveTo(x2 + shape.r0, y2);
      ctx.arc(x2, y2, shape.r0, 0, PI22, true);
    };
    return Ring2;
  }(Path);
  Ring.prototype.type = "ring";
  function smoothBezier(points2, smooth, isLoop, constraint) {
    var cps = [];
    var v2 = [];
    var v1 = [];
    var v22 = [];
    var prevPoint;
    var nextPoint;
    var min3;
    var max3;
    if (constraint) {
      min3 = [Infinity, Infinity];
      max3 = [-Infinity, -Infinity];
      for (var i2 = 0, len2 = points2.length; i2 < len2; i2++) {
        min$1(min3, min3, points2[i2]);
        max$1(max3, max3, points2[i2]);
      }
      min$1(min3, min3, constraint[0]);
      max$1(max3, max3, constraint[1]);
    }
    for (var i2 = 0, len2 = points2.length; i2 < len2; i2++) {
      var point = points2[i2];
      if (isLoop) {
        prevPoint = points2[i2 ? i2 - 1 : len2 - 1];
        nextPoint = points2[(i2 + 1) % len2];
      } else {
        if (i2 === 0 || i2 === len2 - 1) {
          cps.push(clone$3(points2[i2]));
          continue;
        } else {
          prevPoint = points2[i2 - 1];
          nextPoint = points2[i2 + 1];
        }
      }
      sub(v2, nextPoint, prevPoint);
      scale$2(v2, v2, smooth);
      var d0 = distance(point, prevPoint);
      var d1 = distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      scale$2(v1, v2, -d0);
      scale$2(v22, v2, d1);
      var cp0 = add([], point, v1);
      var cp1 = add([], point, v22);
      if (constraint) {
        max$1(cp0, cp0, min3);
        min$1(cp0, cp0, max3);
        max$1(cp1, cp1, min3);
        min$1(cp1, cp1, max3);
      }
      cps.push(cp0);
      cps.push(cp1);
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function buildPath(ctx, shape, closePath) {
    var smooth = shape.smooth;
    var points2 = shape.points;
    if (points2 && points2.length >= 2) {
      if (smooth) {
        var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
        ctx.moveTo(points2[0][0], points2[0][1]);
        var len2 = points2.length;
        for (var i2 = 0; i2 < (closePath ? len2 : len2 - 1); i2++) {
          var cp1 = controlPoints[i2 * 2];
          var cp2 = controlPoints[i2 * 2 + 1];
          var p2 = points2[(i2 + 1) % len2];
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]);
        }
      } else {
        ctx.moveTo(points2[0][0], points2[0][1]);
        for (var i2 = 1, l2 = points2.length; i2 < l2; i2++) {
          ctx.lineTo(points2[i2][0], points2[i2][1]);
        }
      }
      closePath && ctx.closePath();
    }
  }
  var PolygonShape = /* @__PURE__ */ function() {
    function PolygonShape2() {
      this.points = null;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolygonShape2;
  }();
  var Polygon = function(_super) {
    __extends(Polygon2, _super);
    function Polygon2(opts) {
      return _super.call(this, opts) || this;
    }
    Polygon2.prototype.getDefaultShape = function() {
      return new PolygonShape();
    };
    Polygon2.prototype.buildPath = function(ctx, shape) {
      buildPath(ctx, shape, true);
    };
    return Polygon2;
  }(Path);
  Polygon.prototype.type = "polygon";
  var PolylineShape = /* @__PURE__ */ function() {
    function PolylineShape2() {
      this.points = null;
      this.percent = 1;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolylineShape2;
  }();
  var Polyline = function(_super) {
    __extends(Polyline2, _super);
    function Polyline2(opts) {
      return _super.call(this, opts) || this;
    }
    Polyline2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Polyline2.prototype.getDefaultShape = function() {
      return new PolylineShape();
    };
    Polyline2.prototype.buildPath = function(ctx, shape) {
      buildPath(ctx, shape, false);
    };
    return Polyline2;
  }(Path);
  Polyline.prototype.type = "polyline";
  var subPixelOptimizeOutputShape = {};
  var LineShape = /* @__PURE__ */ function() {
    function LineShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.percent = 1;
    }
    return LineShape2;
  }();
  var Line = function(_super) {
    __extends(Line2, _super);
    function Line2(opts) {
      return _super.call(this, opts) || this;
    }
    Line2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Line2.prototype.getDefaultShape = function() {
      return new LineShape();
    };
    Line2.prototype.buildPath = function(ctx, shape) {
      var x1;
      var y1;
      var x2;
      var y2;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
        x1 = optimizedShape.x1;
        y1 = optimizedShape.y1;
        x2 = optimizedShape.x2;
        y2 = optimizedShape.y2;
      } else {
        x1 = shape.x1;
        y1 = shape.y1;
        x2 = shape.x2;
        y2 = shape.y2;
      }
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent;
        y2 = y1 * (1 - percent) + y2 * percent;
      }
      ctx.lineTo(x2, y2);
    };
    Line2.prototype.pointAt = function(p2) {
      var shape = this.shape;
      return [
        shape.x1 * (1 - p2) + shape.x2 * p2,
        shape.y1 * (1 - p2) + shape.y2 * p2
      ];
    };
    return Line2;
  }(Path);
  Line.prototype.type = "line";
  var out = [];
  var BezierCurveShape = /* @__PURE__ */ function() {
    function BezierCurveShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.cpx1 = 0;
      this.cpy1 = 0;
      this.percent = 1;
    }
    return BezierCurveShape2;
  }();
  function someVectorAt(shape, t2, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 != null || cpy2 != null) {
      return [
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t2),
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t2)
      ];
    } else {
      return [
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t2),
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t2)
      ];
    }
  }
  var BezierCurve = function(_super) {
    __extends(BezierCurve2, _super);
    function BezierCurve2(opts) {
      return _super.call(this, opts) || this;
    }
    BezierCurve2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    BezierCurve2.prototype.getDefaultShape = function() {
      return new BezierCurveShape();
    };
    BezierCurve2.prototype.buildPath = function(ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var cpx1 = shape.cpx1;
      var cpy1 = shape.cpy1;
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide(x1, cpx1, x2, percent, out);
          cpx1 = out[1];
          x2 = out[2];
          quadraticSubdivide(y1, cpy1, y2, percent, out);
          cpy1 = out[1];
          y2 = out[2];
        }
        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
      } else {
        if (percent < 1) {
          cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
          cpx1 = out[1];
          cpx2 = out[2];
          x2 = out[3];
          cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
          cpy1 = out[1];
          cpy2 = out[2];
          y2 = out[3];
        }
        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
      }
    };
    BezierCurve2.prototype.pointAt = function(t2) {
      return someVectorAt(this.shape, t2, false);
    };
    BezierCurve2.prototype.tangentAt = function(t2) {
      var p2 = someVectorAt(this.shape, t2, true);
      return normalize$1(p2, p2);
    };
    return BezierCurve2;
  }(Path);
  BezierCurve.prototype.type = "bezier-curve";
  var ArcShape = /* @__PURE__ */ function() {
    function ArcShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
    }
    return ArcShape2;
  }();
  var Arc = function(_super) {
    __extends(Arc2, _super);
    function Arc2(opts) {
      return _super.call(this, opts) || this;
    }
    Arc2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Arc2.prototype.getDefaultShape = function() {
      return new ArcShape();
    };
    Arc2.prototype.buildPath = function(ctx, shape) {
      var x2 = shape.cx;
      var y2 = shape.cy;
      var r2 = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r2 + x2, unitY * r2 + y2);
      ctx.arc(x2, y2, r2, startAngle, endAngle, !clockwise);
    };
    return Arc2;
  }(Path);
  Arc.prototype.type = "arc";
  var CompoundPath = function(_super) {
    __extends(CompoundPath2, _super);
    function CompoundPath2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "compound";
      return _this;
    }
    CompoundPath2.prototype._updatePathDirty = function() {
      var paths = this.shape.paths;
      var dirtyPath = this.shapeChanged();
      for (var i2 = 0; i2 < paths.length; i2++) {
        dirtyPath = dirtyPath || paths[i2].shapeChanged();
      }
      if (dirtyPath) {
        this.dirtyShape();
      }
    };
    CompoundPath2.prototype.beforeBrush = function() {
      this._updatePathDirty();
      var paths = this.shape.paths || [];
      var scale2 = this.getGlobalScale();
      for (var i2 = 0; i2 < paths.length; i2++) {
        if (!paths[i2].path) {
          paths[i2].createPathProxy();
        }
        paths[i2].path.setScale(scale2[0], scale2[1], paths[i2].segmentIgnoreThreshold);
      }
    };
    CompoundPath2.prototype.buildPath = function(ctx, shape) {
      var paths = shape.paths || [];
      for (var i2 = 0; i2 < paths.length; i2++) {
        paths[i2].buildPath(ctx, paths[i2].shape, true);
      }
    };
    CompoundPath2.prototype.afterBrush = function() {
      var paths = this.shape.paths || [];
      for (var i2 = 0; i2 < paths.length; i2++) {
        paths[i2].pathUpdated();
      }
    };
    CompoundPath2.prototype.getBoundingRect = function() {
      this._updatePathDirty.call(this);
      return Path.prototype.getBoundingRect.call(this);
    };
    return CompoundPath2;
  }(Path);
  var Gradient = function() {
    function Gradient2(colorStops) {
      this.colorStops = colorStops || [];
    }
    Gradient2.prototype.addColorStop = function(offset2, color2) {
      this.colorStops.push({
        offset: offset2,
        color: color2
      });
    };
    return Gradient2;
  }();
  var LinearGradient = function(_super) {
    __extends(LinearGradient2, _super);
    function LinearGradient2(x2, y2, x22, y22, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x2 == null ? 0 : x2;
      _this.y = y2 == null ? 0 : y2;
      _this.x2 = x22 == null ? 1 : x22;
      _this.y2 = y22 == null ? 0 : y22;
      _this.type = "linear";
      _this.global = globalCoord || false;
      return _this;
    }
    return LinearGradient2;
  }(Gradient);
  var RadialGradient = function(_super) {
    __extends(RadialGradient2, _super);
    function RadialGradient2(x2, y2, r2, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x2 == null ? 0.5 : x2;
      _this.y = y2 == null ? 0.5 : y2;
      _this.r = r2 == null ? 0.5 : r2;
      _this.type = "radial";
      _this.global = globalCoord || false;
      return _this;
    }
    return RadialGradient2;
  }(Gradient);
  var extent = [0, 0];
  var extent2 = [0, 0];
  var minTv = new Point();
  var maxTv = new Point();
  var OrientedBoundingRect = function() {
    function OrientedBoundingRect2(rect, transform2) {
      this._corners = [];
      this._axes = [];
      this._origin = [0, 0];
      for (var i2 = 0; i2 < 4; i2++) {
        this._corners[i2] = new Point();
      }
      for (var i2 = 0; i2 < 2; i2++) {
        this._axes[i2] = new Point();
      }
      if (rect) {
        this.fromBoundingRect(rect, transform2);
      }
    }
    OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform2) {
      var corners = this._corners;
      var axes = this._axes;
      var x2 = rect.x;
      var y2 = rect.y;
      var x22 = x2 + rect.width;
      var y22 = y2 + rect.height;
      corners[0].set(x2, y2);
      corners[1].set(x22, y2);
      corners[2].set(x22, y22);
      corners[3].set(x2, y22);
      if (transform2) {
        for (var i2 = 0; i2 < 4; i2++) {
          corners[i2].transform(transform2);
        }
      }
      Point.sub(axes[0], corners[1], corners[0]);
      Point.sub(axes[1], corners[3], corners[0]);
      axes[0].normalize();
      axes[1].normalize();
      for (var i2 = 0; i2 < 2; i2++) {
        this._origin[i2] = axes[i2].dot(corners[0]);
      }
    };
    OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
      var overlapped = true;
      var noMtv = !mtv;
      minTv.set(Infinity, Infinity);
      maxTv.set(0, 0);
      if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!noMtv) {
        Point.copy(mtv, overlapped ? minTv : maxTv);
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv2, maxTv2, noMtv, inverse) {
      var overlapped = true;
      for (var i2 = 0; i2 < 2; i2++) {
        var axis = this._axes[i2];
        this._getProjMinMaxOnAxis(i2, self2._corners, extent);
        this._getProjMinMaxOnAxis(i2, other._corners, extent2);
        if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
          overlapped = false;
          if (noMtv) {
            return overlapped;
          }
          var dist0 = Math.abs(extent2[0] - extent[1]);
          var dist1 = Math.abs(extent[0] - extent2[1]);
          if (Math.min(dist0, dist1) > maxTv2.len()) {
            if (dist0 < dist1) {
              Point.scale(maxTv2, axis, -dist0 * inverse);
            } else {
              Point.scale(maxTv2, axis, dist1 * inverse);
            }
          }
        } else if (minTv2) {
          var dist0 = Math.abs(extent2[0] - extent[1]);
          var dist1 = Math.abs(extent[0] - extent2[1]);
          if (Math.min(dist0, dist1) < minTv2.len()) {
            if (dist0 < dist1) {
              Point.scale(minTv2, axis, dist0 * inverse);
            } else {
              Point.scale(minTv2, axis, -dist1 * inverse);
            }
          }
        }
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
      var axis = this._axes[dim];
      var origin2 = this._origin;
      var proj = corners[0].dot(axis) + origin2[dim];
      var min3 = proj;
      var max3 = proj;
      for (var i2 = 1; i2 < corners.length; i2++) {
        var proj_1 = corners[i2].dot(axis) + origin2[dim];
        min3 = Math.min(proj_1, min3);
        max3 = Math.max(proj_1, max3);
      }
      out2[0] = min3;
      out2[1] = max3;
    };
    return OrientedBoundingRect2;
  }();
  var m = [];
  var IncrementalDisplayable = function(_super) {
    __extends(IncrementalDisplayable2, _super);
    function IncrementalDisplayable2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.notClear = true;
      _this.incremental = true;
      _this._displayables = [];
      _this._temporaryDisplayables = [];
      _this._cursor = 0;
      return _this;
    }
    IncrementalDisplayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    IncrementalDisplayable2.prototype.useStyle = function() {
      this.style = {};
    };
    IncrementalDisplayable2.prototype.getCursor = function() {
      return this._cursor;
    };
    IncrementalDisplayable2.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    };
    IncrementalDisplayable2.prototype.clearDisplaybles = function() {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.markRedraw();
      this.notClear = false;
    };
    IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    };
    IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }
      this.markRedraw();
    };
    IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
      notPersistent = notPersistent || false;
      for (var i2 = 0; i2 < displayables.length; i2++) {
        this.addDisplayable(displayables[i2], notPersistent);
      }
    };
    IncrementalDisplayable2.prototype.getDisplayables = function() {
      return this._displayables;
    };
    IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    };
    IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
      for (var i2 = this._cursor; i2 < this._displayables.length; i2++) {
        cb && cb(this._displayables[i2]);
      }
      for (var i2 = 0; i2 < this._temporaryDisplayables.length; i2++) {
        cb && cb(this._temporaryDisplayables[i2]);
      }
    };
    IncrementalDisplayable2.prototype.update = function() {
      this.updateTransform();
      for (var i2 = this._cursor; i2 < this._displayables.length; i2++) {
        var displayable = this._displayables[i2];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
      for (var i2 = 0; i2 < this._temporaryDisplayables.length; i2++) {
        var displayable = this._temporaryDisplayables[i2];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };
    IncrementalDisplayable2.prototype.getBoundingRect = function() {
      if (!this._rect) {
        var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);
        for (var i2 = 0; i2 < this._displayables.length; i2++) {
          var displayable = this._displayables[i2];
          var childRect = displayable.getBoundingRect().clone();
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }
          rect.union(childRect);
        }
        this._rect = rect;
      }
      return this._rect;
    };
    IncrementalDisplayable2.prototype.contain = function(x2, y2) {
      var localPos = this.transformCoordToLocal(x2, y2);
      var rect = this.getBoundingRect();
      if (rect.contain(localPos[0], localPos[1])) {
        for (var i2 = 0; i2 < this._displayables.length; i2++) {
          var displayable = this._displayables[i2];
          if (displayable.contain(x2, y2)) {
            return true;
          }
        }
      }
      return false;
    };
    return IncrementalDisplayable2;
  }(Displayable);
  var transitionStore = makeInner();
  function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
    var animationPayload;
    if (animatableModel && animatableModel.ecModel) {
      var updatePayload = animatableModel.ecModel.getUpdatePayload();
      animationPayload = updatePayload && updatePayload.animation;
    }
    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
    var isUpdate = animationType === "update";
    if (animationEnabled) {
      var duration = void 0;
      var easing = void 0;
      var delay = void 0;
      if (extraOpts) {
        duration = retrieve2(extraOpts.duration, 200);
        easing = retrieve2(extraOpts.easing, "cubicOut");
        delay = 0;
      } else {
        duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
        easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
        delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
      }
      if (animationPayload) {
        animationPayload.duration != null && (duration = animationPayload.duration);
        animationPayload.easing != null && (easing = animationPayload.easing);
        animationPayload.delay != null && (delay = animationPayload.delay);
      }
      if (isFunction$1(delay)) {
        delay = delay(dataIndex, extraDelayParams);
      }
      if (isFunction$1(duration)) {
        duration = duration(dataIndex);
      }
      var config = {
        duration: duration || 0,
        delay,
        easing
      };
      return config;
    } else {
      return null;
    }
  }
  function animateOrSetProps(animationType, el, props2, animatableModel, dataIndex, cb, during) {
    var isFrom = false;
    var removeOpt;
    if (isFunction$1(dataIndex)) {
      during = cb;
      cb = dataIndex;
      dataIndex = null;
    } else if (isObject$3(dataIndex)) {
      cb = dataIndex.cb;
      during = dataIndex.during;
      isFrom = dataIndex.isFrom;
      removeOpt = dataIndex.removeOpt;
      dataIndex = dataIndex.dataIndex;
    }
    var isRemove = animationType === "leave";
    if (!isRemove) {
      el.stopAnimation("leave");
    }
    var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    if (animationConfig && animationConfig.duration > 0) {
      var duration = animationConfig.duration;
      var animationDelay = animationConfig.delay;
      var animationEasing = animationConfig.easing;
      var animateConfig = {
        duration,
        delay: animationDelay || 0,
        easing: animationEasing,
        done: cb,
        force: !!cb || !!during,
        // Set to final state in update/init animation.
        // So the post processing based on the path shape can be done correctly.
        setToFinal: !isRemove,
        scope: animationType,
        during
      };
      isFrom ? el.animateFrom(props2, animateConfig) : el.animateTo(props2, animateConfig);
    } else {
      el.stopAnimation();
      !isFrom && el.attr(props2);
      during && during(1);
      cb && cb();
    }
  }
  function updateProps$1(el, props2, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("update", el, props2, animatableModel, dataIndex, cb, during);
  }
  function initProps(el, props2, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("enter", el, props2, animatableModel, dataIndex, cb, during);
  }
  function isElementRemoved(el) {
    if (!el.__zr) {
      return true;
    }
    for (var i2 = 0; i2 < el.animators.length; i2++) {
      var animator = el.animators[i2];
      if (animator.scope === "leave") {
        return true;
      }
    }
    return false;
  }
  function removeElement(el, props2, animatableModel, dataIndex, cb, during) {
    if (isElementRemoved(el)) {
      return;
    }
    animateOrSetProps("leave", el, props2, animatableModel, dataIndex, cb, during);
  }
  function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
    el.removeTextContent();
    el.removeTextGuideLine();
    removeElement(el, {
      style: {
        opacity: 0
      }
    }, animatableModel, dataIndex, done);
  }
  function removeElementWithFadeOut(el, animatableModel, dataIndex) {
    function doRemove() {
      el.parent && el.parent.remove(el);
    }
    if (!el.isGroup) {
      fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
    } else {
      el.traverse(function(disp) {
        if (!disp.isGroup) {
          fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
        }
      });
    }
  }
  function saveOldStyle(el) {
    transitionStore(el).oldStyle = el.style;
  }
  function getOldStyle(el) {
    return transitionStore(el).oldStyle;
  }
  var mathMax$2 = Math.max;
  var mathMin$2 = Math.min;
  var _customShapeMap = {};
  function extendShape(opts) {
    return Path.extend(opts);
  }
  var extendPathFromString = extendFromString;
  function extendPath(pathData, opts) {
    return extendPathFromString(pathData, opts);
  }
  function registerShape(name, ShapeClass) {
    _customShapeMap[name] = ShapeClass;
  }
  function getShapeClass(name) {
    if (_customShapeMap.hasOwnProperty(name)) {
      return _customShapeMap[name];
    }
  }
  function makePath(pathData, opts, rect, layout2) {
    var path = createFromString(pathData, opts);
    if (rect) {
      if (layout2 === "center") {
        rect = centerGraphic(rect, path.getBoundingRect());
      }
      resizePath(path, rect);
    }
    return path;
  }
  function makeImage(imageUrl, rect, layout2) {
    var zrImg = new ZRImage({
      style: {
        image: imageUrl,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      onload: function(img) {
        if (layout2 === "center") {
          var boundingRect = {
            width: img.width,
            height: img.height
          };
          zrImg.setStyle(centerGraphic(rect, boundingRect));
        }
      }
    });
    return zrImg;
  }
  function centerGraphic(rect, boundingRect) {
    var aspect = boundingRect.width / boundingRect.height;
    var width = rect.height * aspect;
    var height;
    if (width <= rect.width) {
      height = rect.height;
    } else {
      width = rect.width;
      height = width / aspect;
    }
    var cx = rect.x + rect.width / 2;
    var cy = rect.y + rect.height / 2;
    return {
      x: cx - width / 2,
      y: cy - height / 2,
      width,
      height
    };
  }
  var mergePath = mergePath$1;
  function resizePath(path, rect) {
    if (!path.applyTransform) {
      return;
    }
    var pathRect = path.getBoundingRect();
    var m2 = pathRect.calculateTransform(rect);
    path.applyTransform(m2);
  }
  function subPixelOptimizeLine(shape, lineWidth) {
    subPixelOptimizeLine$1(shape, shape, {
      lineWidth
    });
    return shape;
  }
  function subPixelOptimizeRect(param) {
    subPixelOptimizeRect$1(param.shape, param.shape, param.style);
    return param;
  }
  var subPixelOptimize = subPixelOptimize$1;
  function getTransform(target, ancestor) {
    var mat = identity([]);
    while (target && target !== ancestor) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    return mat;
  }
  function applyTransform(target, transform2, invert$1) {
    if (transform2 && !isArrayLike(transform2)) {
      transform2 = Transformable.getLocalTransform(transform2);
    }
    if (invert$1) {
      transform2 = invert([], transform2);
    }
    return applyTransform$1([], target, transform2);
  }
  function transformDirection(direction, transform2, invert2) {
    var hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[0]);
    var vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[2]);
    var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
    vertex = applyTransform(vertex, transform2, invert2);
    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
  }
  function isNotGroup(el) {
    return !el.isGroup;
  }
  function isPath$1(el) {
    return el.shape != null;
  }
  function groupTransition(g1, g2, animatableModel) {
    if (!g1 || !g2) {
      return;
    }
    function getElMap(g3) {
      var elMap = {};
      g3.traverse(function(el) {
        if (isNotGroup(el) && el.anid) {
          elMap[el.anid] = el;
        }
      });
      return elMap;
    }
    function getAnimatableProps(el) {
      var obj2 = {
        x: el.x,
        y: el.y,
        rotation: el.rotation
      };
      if (isPath$1(el)) {
        obj2.shape = extend$1({}, el.shape);
      }
      return obj2;
    }
    var elMap1 = getElMap(g1);
    g2.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        var oldEl = elMap1[el.anid];
        if (oldEl) {
          var newProp = getAnimatableProps(el);
          el.attr(getAnimatableProps(oldEl));
          updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
        }
      }
    });
  }
  function clipPointsByRect(points2, rect) {
    return map$1(points2, function(point) {
      var x2 = point[0];
      x2 = mathMax$2(x2, rect.x);
      x2 = mathMin$2(x2, rect.x + rect.width);
      var y2 = point[1];
      y2 = mathMax$2(y2, rect.y);
      y2 = mathMin$2(y2, rect.y + rect.height);
      return [x2, y2];
    });
  }
  function clipRectByRect(targetRect, rect) {
    var x2 = mathMax$2(targetRect.x, rect.x);
    var x22 = mathMin$2(targetRect.x + targetRect.width, rect.x + rect.width);
    var y2 = mathMax$2(targetRect.y, rect.y);
    var y22 = mathMin$2(targetRect.y + targetRect.height, rect.y + rect.height);
    if (x22 >= x2 && y22 >= y2) {
      return {
        x: x2,
        y: y2,
        width: x22 - x2,
        height: y22 - y2
      };
    }
  }
  function createIcon(iconStr, opt, rect) {
    var innerOpts = extend$1({
      rectHover: true
    }, opt);
    var style = innerOpts.style = {
      strokeNoScale: true
    };
    rect = rect || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    };
    if (iconStr) {
      return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults$1(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
    }
  }
  function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
    for (var i2 = 0, p2 = points2[points2.length - 1]; i2 < points2.length; i2++) {
      var p3 = points2[i2];
      if (lineLineIntersect$1(a1x, a1y, a2x, a2y, p3[0], p3[1], p2[0], p2[1])) {
        return true;
      }
      p2 = p3;
    }
  }
  function lineLineIntersect$1(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y;
    var nmCrossProduct = crossProduct2d$1(nx, ny, mx, my);
    if (nearZero(nmCrossProduct)) {
      return false;
    }
    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var q2 = crossProduct2d$1(b1a1x, b1a1y, mx, my) / nmCrossProduct;
    if (q2 < 0 || q2 > 1) {
      return false;
    }
    var p2 = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
    if (p2 < 0 || p2 > 1) {
      return false;
    }
    return true;
  }
  function crossProduct2d$1(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }
  function nearZero(val) {
    return val <= 1e-6 && val >= -1e-6;
  }
  function setTooltipConfig(opt) {
    var itemTooltipOption = opt.itemTooltipOption;
    var componentModel = opt.componentModel;
    var itemName = opt.itemName;
    var itemTooltipOptionObj = isString$1(itemTooltipOption) ? {
      formatter: itemTooltipOption
    } : itemTooltipOption;
    var mainType = componentModel.mainType;
    var componentIndex = componentModel.componentIndex;
    var formatterParams = {
      componentType: mainType,
      name: itemName,
      $vars: ["name"]
    };
    formatterParams[mainType + "Index"] = componentIndex;
    var formatterParamsExtra = opt.formatterParamsExtra;
    if (formatterParamsExtra) {
      each$4(keys(formatterParamsExtra), function(key2) {
        if (!hasOwn(formatterParams, key2)) {
          formatterParams[key2] = formatterParamsExtra[key2];
          formatterParams.$vars.push(key2);
        }
      });
    }
    var ecData = getECData(opt.el);
    ecData.componentMainType = mainType;
    ecData.componentIndex = componentIndex;
    ecData.tooltipConfig = {
      name: itemName,
      option: defaults$1({
        content: itemName,
        encodeHTMLContent: true,
        formatterParams
      }, itemTooltipOptionObj)
    };
  }
  function traverseElement(el, cb) {
    var stopped;
    if (el.isGroup) {
      stopped = cb(el);
    }
    if (!stopped) {
      el.traverse(cb);
    }
  }
  function traverseElements(els, cb) {
    if (els) {
      if (isArray$1(els)) {
        for (var i2 = 0; i2 < els.length; i2++) {
          traverseElement(els[i2], cb);
        }
      } else {
        traverseElement(els, cb);
      }
    }
  }
  registerShape("circle", Circle);
  registerShape("ellipse", Ellipse);
  registerShape("sector", Sector);
  registerShape("ring", Ring);
  registerShape("polygon", Polygon);
  registerShape("polyline", Polyline);
  registerShape("rect", Rect);
  registerShape("line", Line);
  registerShape("bezierCurve", BezierCurve);
  registerShape("arc", Arc);
  const graphic$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Arc,
    BezierCurve,
    BoundingRect,
    Circle,
    CompoundPath,
    Ellipse,
    Group: Group$2,
    Image: ZRImage,
    IncrementalDisplayable,
    Line,
    LinearGradient,
    OrientedBoundingRect,
    Path,
    Point,
    Polygon,
    Polyline,
    RadialGradient,
    Rect,
    Ring,
    Sector,
    Text: ZRText,
    applyTransform,
    clipPointsByRect,
    clipRectByRect,
    createIcon,
    extendPath,
    extendShape,
    getShapeClass,
    getTransform,
    groupTransition,
    initProps,
    isElementRemoved,
    lineLineIntersect: lineLineIntersect$1,
    linePolygonIntersect,
    makeImage,
    makePath,
    mergePath,
    registerShape,
    removeElement,
    removeElementWithFadeOut,
    resizePath,
    setTooltipConfig,
    subPixelOptimize,
    subPixelOptimizeLine,
    subPixelOptimizeRect,
    transformDirection,
    traverseElements,
    updateProps: updateProps$1
  }, Symbol.toStringTag, { value: "Module" }));
  var EMPTY_OBJ = {};
  function setLabelText(label, labelTexts) {
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      var stateName = SPECIAL_STATES[i2];
      var text = labelTexts[stateName];
      var state = label.ensureState(stateName);
      state.style = state.style || {};
      state.style.text = text;
    }
    var oldStates = label.currentStates.slice();
    label.clearStates(true);
    label.setStyle({
      text: labelTexts.normal
    });
    label.useStates(oldStates, true);
  }
  function getLabelText(opt, stateModels, interpolatedValue) {
    var labelFetcher = opt.labelFetcher;
    var labelDataIndex = opt.labelDataIndex;
    var labelDimIndex = opt.labelDimIndex;
    var normalModel = stateModels.normal;
    var baseText;
    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
        interpolatedValue
      } : null);
    }
    if (baseText == null) {
      baseText = isFunction$1(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
    }
    var statesText = {
      normal: baseText
    };
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      var stateName = SPECIAL_STATES[i2];
      var stateModel = stateModels[stateName];
      statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
    }
    return statesText;
  }
  function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
    opt = opt || EMPTY_OBJ;
    var isSetOnText = targetEl instanceof ZRText;
    var needsCreateText = false;
    for (var i2 = 0; i2 < DISPLAY_STATES.length; i2++) {
      var stateModel = labelStatesModels[DISPLAY_STATES[i2]];
      if (stateModel && stateModel.getShallow("show")) {
        needsCreateText = true;
        break;
      }
    }
    var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
    if (needsCreateText) {
      if (!isSetOnText) {
        if (!textContent) {
          textContent = new ZRText();
          targetEl.setTextContent(textContent);
        }
        if (targetEl.stateProxy) {
          textContent.stateProxy = targetEl.stateProxy;
        }
      }
      var labelStatesTexts = getLabelText(opt, labelStatesModels);
      var normalModel = labelStatesModels.normal;
      var showNormal = !!normalModel.getShallow("show");
      var normalStyle = createTextStyle$1(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
      normalStyle.text = labelStatesTexts.normal;
      if (!isSetOnText) {
        targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
      }
      for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
        var stateName = SPECIAL_STATES[i2];
        var stateModel = labelStatesModels[stateName];
        if (stateModel) {
          var stateObj = textContent.ensureState(stateName);
          var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
          if (stateShow !== showNormal) {
            stateObj.ignore = !stateShow;
          }
          stateObj.style = createTextStyle$1(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
          stateObj.style.text = labelStatesTexts[stateName];
          if (!isSetOnText) {
            var targetElEmphasisState = targetEl.ensureState(stateName);
            targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
          }
        }
      }
      textContent.silent = !!normalModel.getShallow("silent");
      if (textContent.style.x != null) {
        normalStyle.x = textContent.style.x;
      }
      if (textContent.style.y != null) {
        normalStyle.y = textContent.style.y;
      }
      textContent.ignore = !showNormal;
      textContent.useStyle(normalStyle);
      textContent.dirty();
      if (opt.enableTextSetter) {
        labelInner(textContent).setLabelText = function(interpolatedValue) {
          var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
          setLabelText(textContent, labelStatesTexts2);
        };
      }
    } else if (textContent) {
      textContent.ignore = true;
    }
    targetEl.dirty();
  }
  function getLabelStatesModels(itemModel, labelName) {
    labelName = labelName || "label";
    var statesModels = {
      normal: itemModel.getModel(labelName)
    };
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      var stateName = SPECIAL_STATES[i2];
      statesModels[stateName] = itemModel.getModel([stateName, labelName]);
    }
    return statesModels;
  }
  function createTextStyle$1(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
    var textStyle = {};
    setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
    specifiedTextStyle && extend$1(textStyle, specifiedTextStyle);
    return textStyle;
  }
  function createTextConfig(textStyleModel, opt, isNotNormal) {
    opt = opt || {};
    var textConfig = {};
    var labelPosition;
    var labelRotate = textStyleModel.getShallow("rotate");
    var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
    var labelOffset = textStyleModel.getShallow("offset");
    labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
    labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
    if (labelPosition != null) {
      textConfig.position = labelPosition;
    }
    if (labelOffset != null) {
      textConfig.offset = labelOffset;
    }
    if (labelRotate != null) {
      labelRotate *= Math.PI / 180;
      textConfig.rotation = labelRotate;
    }
    if (labelDistance != null) {
      textConfig.distance = labelDistance;
    }
    textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
    return textConfig;
  }
  function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
    opt = opt || EMPTY_OBJ;
    var ecModel = textStyleModel.ecModel;
    var globalTextStyle = ecModel && ecModel.option.textStyle;
    var richItemNames = getRichItemNames(textStyleModel);
    var richResult;
    if (richItemNames) {
      richResult = {};
      for (var name_1 in richItemNames) {
        if (richItemNames.hasOwnProperty(name_1)) {
          var richTextStyle = textStyleModel.getModel(["rich", name_1]);
          setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
        }
      }
    }
    if (richResult) {
      textStyle.rich = richResult;
    }
    var overflow = textStyleModel.get("overflow");
    if (overflow) {
      textStyle.overflow = overflow;
    }
    var margin = textStyleModel.get("minMargin");
    if (margin != null) {
      textStyle.margin = margin;
    }
    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
  }
  function getRichItemNames(textStyleModel) {
    var richItemNameMap;
    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
      var rich = (textStyleModel.option || EMPTY_OBJ).rich;
      if (rich) {
        richItemNameMap = richItemNameMap || {};
        var richKeys = keys(rich);
        for (var i2 = 0; i2 < richKeys.length; i2++) {
          var richKey = richKeys[i2];
          richItemNameMap[richKey] = 1;
        }
      }
      textStyleModel = textStyleModel.parentModel;
    }
    return richItemNameMap;
  }
  var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
  var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"];
  var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
    globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
    var inheritColor = opt && opt.inheritColor;
    var fillColor = textStyleModel.getShallow("color");
    var strokeColor = textStyleModel.getShallow("textBorderColor");
    var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
    if (fillColor === "inherit" || fillColor === "auto") {
      if (inheritColor) {
        fillColor = inheritColor;
      } else {
        fillColor = null;
      }
    }
    if (strokeColor === "inherit" || strokeColor === "auto") {
      if (inheritColor) {
        strokeColor = inheritColor;
      } else {
        strokeColor = null;
      }
    }
    if (!isAttached) {
      fillColor = fillColor || globalTextStyle.color;
      strokeColor = strokeColor || globalTextStyle.textBorderColor;
    }
    if (fillColor != null) {
      textStyle.fill = fillColor;
    }
    if (strokeColor != null) {
      textStyle.stroke = strokeColor;
    }
    var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
    if (textBorderWidth != null) {
      textStyle.lineWidth = textBorderWidth;
    }
    var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
    if (textBorderType != null) {
      textStyle.lineDash = textBorderType;
    }
    var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
    if (textBorderDashOffset != null) {
      textStyle.lineDashOffset = textBorderDashOffset;
    }
    if (!isNotNormal && opacity == null && !inRich) {
      opacity = opt && opt.defaultOpacity;
    }
    if (opacity != null) {
      textStyle.opacity = opacity;
    }
    if (!isNotNormal && !isAttached) {
      if (textStyle.fill == null && opt.inheritColor) {
        textStyle.fill = opt.inheritColor;
      }
    }
    for (var i2 = 0; i2 < TEXT_PROPS_WITH_GLOBAL.length; i2++) {
      var key2 = TEXT_PROPS_WITH_GLOBAL[i2];
      var val = retrieve2(textStyleModel.getShallow(key2), globalTextStyle[key2]);
      if (val != null) {
        textStyle[key2] = val;
      }
    }
    for (var i2 = 0; i2 < TEXT_PROPS_SELF.length; i2++) {
      var key2 = TEXT_PROPS_SELF[i2];
      var val = textStyleModel.getShallow(key2);
      if (val != null) {
        textStyle[key2] = val;
      }
    }
    if (textStyle.verticalAlign == null) {
      var baseline = textStyleModel.getShallow("baseline");
      if (baseline != null) {
        textStyle.verticalAlign = baseline;
      }
    }
    if (!isBlock || !opt.disableBox) {
      for (var i2 = 0; i2 < TEXT_PROPS_BOX.length; i2++) {
        var key2 = TEXT_PROPS_BOX[i2];
        var val = textStyleModel.getShallow(key2);
        if (val != null) {
          textStyle[key2] = val;
        }
      }
      var borderType = textStyleModel.getShallow("borderType");
      if (borderType != null) {
        textStyle.borderDash = borderType;
      }
      if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
        textStyle.backgroundColor = inheritColor;
      }
      if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
        textStyle.borderColor = inheritColor;
      }
    }
  }
  function getFont(opt, ecModel) {
    var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
    return trim$1([
      // FIXME in node-canvas fontWeight is before fontStyle
      opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
      opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
      (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
      opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var labelInner = makeInner();
  function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
    if (!label) {
      return;
    }
    var obj2 = labelInner(label);
    obj2.prevValue = obj2.value;
    obj2.value = value;
    var normalLabelModel = labelStatesModels.normal;
    obj2.valueAnimation = normalLabelModel.get("valueAnimation");
    if (obj2.valueAnimation) {
      obj2.precision = normalLabelModel.get("precision");
      obj2.defaultInterpolatedText = getDefaultText;
      obj2.statesModels = labelStatesModels;
    }
  }
  function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
    var labelInnerStore = labelInner(textEl);
    if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
      return;
    }
    var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
    var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
    var targetValue = labelInnerStore.value;
    function during(percent) {
      var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
      labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
      var labelText = getLabelText({
        labelDataIndex: dataIndex,
        labelFetcher,
        defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
      }, labelInnerStore.statesModels, interpolated);
      setLabelText(textEl, labelText);
    }
    textEl.percent = 0;
    (labelInnerStore.prevValue == null ? initProps : updateProps$1)(textEl, {
      // percent is used to prevent animation from being aborted #15916
      percent: 1
    }, animatableModel, dataIndex, null, during);
  }
  var PATH_COLOR = ["textStyle", "color"];
  var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
  var tmpText = new ZRText();
  var TextStyleMixin = (
    /** @class */
    function() {
      function TextStyleMixin2() {
      }
      TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
      };
      TextStyleMixin2.prototype.getFont = function() {
        return getFont({
          fontStyle: this.getShallow("fontStyle"),
          fontWeight: this.getShallow("fontWeight"),
          fontSize: this.getShallow("fontSize"),
          fontFamily: this.getShallow("fontFamily")
        }, this.ecModel);
      };
      TextStyleMixin2.prototype.getTextRect = function(text) {
        var style = {
          text,
          verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
        };
        for (var i2 = 0; i2 < textStyleParams.length; i2++) {
          style[textStyleParams[i2]] = this.getShallow(textStyleParams[i2]);
        }
        tmpText.useStyle(style);
        tmpText.update();
        return tmpText.getBoundingRect();
      };
      return TextStyleMixin2;
    }()
  );
  var LINE_STYLE_KEY_MAP = [
    ["lineWidth", "width"],
    ["stroke", "color"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "type"],
    ["lineDashOffset", "dashOffset"],
    ["lineCap", "cap"],
    ["lineJoin", "join"],
    ["miterLimit"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
  var LineStyleMixin = (
    /** @class */
    function() {
      function LineStyleMixin2() {
      }
      LineStyleMixin2.prototype.getLineStyle = function(excludes) {
        return getLineStyle(this, excludes);
      };
      return LineStyleMixin2;
    }()
  );
  var ITEM_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["stroke", "borderColor"],
    ["lineWidth", "borderWidth"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "borderType"],
    ["lineDashOffset", "borderDashOffset"],
    ["lineCap", "borderCap"],
    ["lineJoin", "borderJoin"],
    ["miterLimit", "borderMiterLimit"]
    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ];
  var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
  var ItemStyleMixin = (
    /** @class */
    function() {
      function ItemStyleMixin2() {
      }
      ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes2) {
        return getItemStyle(this, excludes, includes2);
      };
      return ItemStyleMixin2;
    }()
  );
  var Model = (
    /** @class */
    function() {
      function Model2(option, parentModel, ecModel) {
        this.parentModel = parentModel;
        this.ecModel = ecModel;
        this.option = option;
      }
      Model2.prototype.init = function(option, parentModel, ecModel) {
      };
      Model2.prototype.mergeOption = function(option, ecModel) {
        merge$1(this.option, option, true);
      };
      Model2.prototype.get = function(path, ignoreParent) {
        if (path == null) {
          return this.option;
        }
        return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
      };
      Model2.prototype.getShallow = function(key2, ignoreParent) {
        var option = this.option;
        var val = option == null ? option : option[key2];
        if (val == null && !ignoreParent) {
          var parentModel = this.parentModel;
          if (parentModel) {
            val = parentModel.getShallow(key2);
          }
        }
        return val;
      };
      Model2.prototype.getModel = function(path, parentModel) {
        var hasPath2 = path != null;
        var pathFinal = hasPath2 ? this.parsePath(path) : null;
        var obj2 = hasPath2 ? this._doGet(pathFinal) : this.option;
        parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
        return new Model2(obj2, parentModel, this.ecModel);
      };
      Model2.prototype.isEmpty = function() {
        return this.option == null;
      };
      Model2.prototype.restoreData = function() {
      };
      Model2.prototype.clone = function() {
        var Ctor = this.constructor;
        return new Ctor(clone$4(this.option));
      };
      Model2.prototype.parsePath = function(path) {
        if (typeof path === "string") {
          return path.split(".");
        }
        return path;
      };
      Model2.prototype.resolveParentPath = function(path) {
        return path;
      };
      Model2.prototype.isAnimationEnabled = function() {
        if (!env.node && this.option) {
          if (this.option.animation != null) {
            return !!this.option.animation;
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled();
          }
        }
      };
      Model2.prototype._doGet = function(pathArr, parentModel) {
        var obj2 = this.option;
        if (!pathArr) {
          return obj2;
        }
        for (var i2 = 0; i2 < pathArr.length; i2++) {
          if (!pathArr[i2]) {
            continue;
          }
          obj2 = obj2 && typeof obj2 === "object" ? obj2[pathArr[i2]] : null;
          if (obj2 == null) {
            break;
          }
        }
        if (obj2 == null && parentModel) {
          obj2 = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
        }
        return obj2;
      };
      return Model2;
    }()
  );
  enableClassExtend(Model);
  enableClassCheck(Model);
  mixin(Model, LineStyleMixin);
  mixin(Model, ItemStyleMixin);
  mixin(Model, AreaStyleMixin);
  mixin(Model, TextStyleMixin);
  var base = Math.round(Math.random() * 10);
  function getUID(type) {
    return [type || "", base++].join("_");
  }
  function enableSubTypeDefaulter(target) {
    var subTypeDefaulters = {};
    target.registerSubTypeDefaulter = function(componentType, defaulter) {
      var componentTypeInfo = parseClassType(componentType);
      subTypeDefaulters[componentTypeInfo.main] = defaulter;
    };
    target.determineSubType = function(componentType, option) {
      var type = option.type;
      if (!type) {
        var componentTypeMain = parseClassType(componentType).main;
        if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option);
        }
      }
      return type;
    };
  }
  function enableTopologicalTravel(entity, dependencyGetter) {
    entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return;
      }
      var result = makeDepndencyGraph(fullNameList);
      var graph = result.graph;
      var noEntryList = result.noEntryList;
      var targetNameSet = {};
      each$4(targetNameList, function(name) {
        targetNameSet[name] = true;
      });
      while (noEntryList.length) {
        var currComponentType = noEntryList.pop();
        var currVertex = graph[currComponentType];
        var isInTargetNameSet = !!targetNameSet[currComponentType];
        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice());
          delete targetNameSet[currComponentType];
        }
        each$4(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
      }
      each$4(targetNameSet, function() {
        var errMsg = "";
        throw new Error(errMsg);
      });
      function removeEdge(succComponentType) {
        graph[succComponentType].entryCount--;
        if (graph[succComponentType].entryCount === 0) {
          noEntryList.push(succComponentType);
        }
      }
      function removeEdgeAndAdd(succComponentType) {
        targetNameSet[succComponentType] = true;
        removeEdge(succComponentType);
      }
    };
    function makeDepndencyGraph(fullNameList) {
      var graph = {};
      var noEntryList = [];
      each$4(fullNameList, function(name) {
        var thisItem = createDependencyGraphItem(graph, name);
        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
        thisItem.entryCount = availableDeps.length;
        if (thisItem.entryCount === 0) {
          noEntryList.push(name);
        }
        each$4(availableDeps, function(dependentName) {
          if (indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName);
          }
          var thatItem = createDependencyGraphItem(graph, dependentName);
          if (indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name);
          }
        });
      });
      return {
        graph,
        noEntryList
      };
    }
    function createDependencyGraphItem(graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        };
      }
      return graph[name];
    }
    function getAvailableDependencies(originalDeps, fullNameList) {
      var availableDeps = [];
      each$4(originalDeps, function(dep) {
        indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
      });
      return availableDeps;
    }
  }
  function inheritDefaultOption(superOption, subOption) {
    return merge$1(merge$1({}, superOption, true), subOption, true);
  }
  const langEN = {
    time: {
      month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: ["Data View", "Close", "Refresh"]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: ["Right Click to Save Image"]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  };
  const langZH = {
    time: {
      month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
      monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
      dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
      dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
    },
    legend: {
      selector: {
        all: "全选",
        inverse: "反选"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "矩形选择",
          polygon: "圈选",
          lineX: "横向选择",
          lineY: "纵向选择",
          keep: "保持选择",
          clear: "清除选择"
        }
      },
      dataView: {
        title: "数据视图",
        lang: ["数据视图", "关闭", "刷新"]
      },
      dataZoom: {
        title: {
          zoom: "区域缩放",
          back: "区域缩放还原"
        }
      },
      magicType: {
        title: {
          line: "切换为折线图",
          bar: "切换为柱状图",
          stack: "切换为堆叠",
          tiled: "切换为平铺"
        }
      },
      restore: {
        title: "还原"
      },
      saveAsImage: {
        title: "保存为图片",
        lang: ["右键另存为图片"]
      }
    },
    series: {
      typeNames: {
        pie: "饼图",
        bar: "柱状图",
        line: "折线图",
        scatter: "散点图",
        effectScatter: "涟漪散点图",
        radar: "雷达图",
        tree: "树图",
        treemap: "矩形树图",
        boxplot: "箱型图",
        candlestick: "K线图",
        k: "K线图",
        heatmap: "热力图",
        map: "地图",
        parallel: "平行坐标图",
        lines: "线图",
        graph: "关系图",
        sankey: "桑基图",
        funnel: "漏斗图",
        gauge: "仪表盘图",
        pictorialBar: "象形柱图",
        themeRiver: "主题河流图",
        sunburst: "旭日图",
        custom: "自定义图表",
        chart: "图表"
      }
    },
    aria: {
      general: {
        withTitle: "这是一个关于“{title}”的图表。",
        withoutTitle: "这是一个图表，"
      },
      series: {
        single: {
          prefix: "",
          withName: "图表类型是{seriesType}，表示{seriesName}。",
          withoutName: "图表类型是{seriesType}。"
        },
        multiple: {
          prefix: "它由{seriesCount}个图表系列组成。",
          withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
          withoutName: "第{seriesId}个系列是一个{seriesType}，",
          separator: {
            middle: "；",
            end: "。"
          }
        }
      },
      data: {
        allData: "其数据是——",
        partialData: "其中，前{displayCnt}项是——",
        withName: "{name}的数据是{value}",
        withoutName: "{value}",
        separator: {
          middle: "，",
          end: ""
        }
      }
    }
  };
  var LOCALE_ZH = "ZH";
  var LOCALE_EN = "EN";
  var DEFAULT_LOCALE = LOCALE_EN;
  var localeStorage = {};
  var localeModels = {};
  var SYSTEM_LANG = !env.domSupported ? DEFAULT_LOCALE : function() {
    var langStr = (
      /* eslint-disable-next-line */
      (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase()
    );
    return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
  }();
  function registerLocale(locale2, localeObj) {
    locale2 = locale2.toUpperCase();
    localeModels[locale2] = new Model(localeObj);
    localeStorage[locale2] = localeObj;
  }
  function createLocaleObject(locale2) {
    if (isString$1(locale2)) {
      var localeObj = localeStorage[locale2.toUpperCase()] || {};
      if (locale2 === LOCALE_ZH || locale2 === LOCALE_EN) {
        return clone$4(localeObj);
      } else {
        return merge$1(clone$4(localeObj), clone$4(localeStorage[DEFAULT_LOCALE]), false);
      }
    } else {
      return merge$1(clone$4(locale2), clone$4(localeStorage[DEFAULT_LOCALE]), false);
    }
  }
  function getLocaleModel(lang) {
    return localeModels[lang];
  }
  function getDefaultLocaleModel() {
    return localeModels[DEFAULT_LOCALE];
  }
  registerLocale(LOCALE_EN, langEN);
  registerLocale(LOCALE_ZH, langZH);
  var ONE_SECOND = 1e3;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24;
  var ONE_YEAR = ONE_DAY * 365;
  var defaultLeveledFormatter = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  };
  var fullDayFormatter = "{yyyy}-{MM}-{dd}";
  var fullLeveledFormatter = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: fullDayFormatter,
    hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
    minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
    second: fullDayFormatter + " " + defaultLeveledFormatter.second,
    millisecond: defaultLeveledFormatter.none
  };
  var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
  function pad(str, len2) {
    str += "";
    return "0000".substr(0, len2 - str.length) + str;
  }
  function getPrimaryTimeUnit(timeUnit) {
    switch (timeUnit) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return timeUnit;
    }
  }
  function isPrimaryTimeUnit(timeUnit) {
    return timeUnit === getPrimaryTimeUnit(timeUnit);
  }
  function getDefaultFormatPrecisionOfInterval(timeUnit) {
    switch (timeUnit) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function format$1(time2, template, isUTC, lang) {
    var date = parseDate(time2);
    var y2 = date[fullYearGetterName(isUTC)]();
    var M2 = date[monthGetterName(isUTC)]() + 1;
    var q2 = Math.floor((M2 - 1) / 3) + 1;
    var d2 = date[dateGetterName(isUTC)]();
    var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
    var H = date[hoursGetterName(isUTC)]();
    var h2 = (H - 1) % 12 + 1;
    var m2 = date[minutesGetterName(isUTC)]();
    var s2 = date[secondsGetterName(isUTC)]();
    var S2 = date[millisecondsGetterName(isUTC)]();
    var a2 = H >= 12 ? "pm" : "am";
    var A2 = a2.toUpperCase();
    var localeModel = lang instanceof Model ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
    var timeModel = localeModel.getModel("time");
    var month = timeModel.get("month");
    var monthAbbr = timeModel.get("monthAbbr");
    var dayOfWeek = timeModel.get("dayOfWeek");
    var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
    return (template || "").replace(/{a}/g, a2 + "").replace(/{A}/g, A2 + "").replace(/{yyyy}/g, y2 + "").replace(/{yy}/g, pad(y2 % 100 + "", 2)).replace(/{Q}/g, q2 + "").replace(/{MMMM}/g, month[M2 - 1]).replace(/{MMM}/g, monthAbbr[M2 - 1]).replace(/{MM}/g, pad(M2, 2)).replace(/{M}/g, M2 + "").replace(/{dd}/g, pad(d2, 2)).replace(/{d}/g, d2 + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h2 + "", 2)).replace(/{h}/g, h2 + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s2, 2)).replace(/{s}/g, s2 + "").replace(/{SSS}/g, pad(S2, 3)).replace(/{S}/g, S2 + "");
  }
  function leveledFormat(tick, idx, formatter, lang, isUTC) {
    var template = null;
    if (isString$1(formatter)) {
      template = formatter;
    } else if (isFunction$1(formatter)) {
      template = formatter(tick.value, idx, {
        level: tick.level
      });
    } else {
      var defaults2 = extend$1({}, defaultLeveledFormatter);
      if (tick.level > 0) {
        for (var i2 = 0; i2 < primaryTimeUnits.length; ++i2) {
          defaults2[primaryTimeUnits[i2]] = "{primary|" + defaults2[primaryTimeUnits[i2]] + "}";
        }
      }
      var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults$1(formatter, defaults2) : defaults2;
      var unit = getUnitFromValue(tick.value, isUTC);
      if (mergedFormatter[unit]) {
        template = mergedFormatter[unit];
      } else if (mergedFormatter.inherit) {
        var targetId = timeUnits.indexOf(unit);
        for (var i2 = targetId - 1; i2 >= 0; --i2) {
          if (mergedFormatter[unit]) {
            template = mergedFormatter[unit];
            break;
          }
        }
        template = template || defaults2.none;
      }
      if (isArray$1(template)) {
        var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
        levelId = Math.min(levelId, template.length - 1);
        template = template[levelId];
      }
    }
    return format$1(new Date(tick.value), template, isUTC, lang);
  }
  function getUnitFromValue(value, isUTC) {
    var date = parseDate(value);
    var M2 = date[monthGetterName(isUTC)]() + 1;
    var d2 = date[dateGetterName(isUTC)]();
    var h2 = date[hoursGetterName(isUTC)]();
    var m2 = date[minutesGetterName(isUTC)]();
    var s2 = date[secondsGetterName(isUTC)]();
    var S2 = date[millisecondsGetterName(isUTC)]();
    var isSecond = S2 === 0;
    var isMinute = isSecond && s2 === 0;
    var isHour = isMinute && m2 === 0;
    var isDay = isHour && h2 === 0;
    var isMonth = isDay && d2 === 1;
    var isYear = isMonth && M2 === 1;
    if (isYear) {
      return "year";
    } else if (isMonth) {
      return "month";
    } else if (isDay) {
      return "day";
    } else if (isHour) {
      return "hour";
    } else if (isMinute) {
      return "minute";
    } else if (isSecond) {
      return "second";
    } else {
      return "millisecond";
    }
  }
  function getUnitValue(value, unit, isUTC) {
    var date = isNumber$1(value) ? parseDate(value) : value;
    unit = unit || getUnitFromValue(value, isUTC);
    switch (unit) {
      case "year":
        return date[fullYearGetterName(isUTC)]();
      case "half-year":
        return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
      case "month":
        return date[monthGetterName(isUTC)]();
      case "day":
        return date[dateGetterName(isUTC)]();
      case "half-day":
        return date[hoursGetterName(isUTC)]() / 24;
      case "hour":
        return date[hoursGetterName(isUTC)]();
      case "minute":
        return date[minutesGetterName(isUTC)]();
      case "second":
        return date[secondsGetterName(isUTC)]();
      case "millisecond":
        return date[millisecondsGetterName(isUTC)]();
    }
  }
  function fullYearGetterName(isUTC) {
    return isUTC ? "getUTCFullYear" : "getFullYear";
  }
  function monthGetterName(isUTC) {
    return isUTC ? "getUTCMonth" : "getMonth";
  }
  function dateGetterName(isUTC) {
    return isUTC ? "getUTCDate" : "getDate";
  }
  function hoursGetterName(isUTC) {
    return isUTC ? "getUTCHours" : "getHours";
  }
  function minutesGetterName(isUTC) {
    return isUTC ? "getUTCMinutes" : "getMinutes";
  }
  function secondsGetterName(isUTC) {
    return isUTC ? "getUTCSeconds" : "getSeconds";
  }
  function millisecondsGetterName(isUTC) {
    return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function fullYearSetterName(isUTC) {
    return isUTC ? "setUTCFullYear" : "setFullYear";
  }
  function monthSetterName(isUTC) {
    return isUTC ? "setUTCMonth" : "setMonth";
  }
  function dateSetterName(isUTC) {
    return isUTC ? "setUTCDate" : "setDate";
  }
  function hoursSetterName(isUTC) {
    return isUTC ? "setUTCHours" : "setHours";
  }
  function minutesSetterName(isUTC) {
    return isUTC ? "setUTCMinutes" : "setMinutes";
  }
  function secondsSetterName(isUTC) {
    return isUTC ? "setUTCSeconds" : "setSeconds";
  }
  function millisecondsSetterName(isUTC) {
    return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
    var textEl = new ZRText({
      style: {
        text,
        font,
        align,
        verticalAlign,
        padding,
        rich,
        overflow: truncate ? "truncate" : null,
        lineHeight
      }
    });
    return textEl.getBoundingRect();
  }
  function addCommas(x2) {
    if (!isNumeric(x2)) {
      return isString$1(x2) ? x2 : "-";
    }
    var parts2 = (x2 + "").split(".");
    return parts2[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts2.length > 1 ? "." + parts2[1] : "");
  }
  function toCamelCase$1(str, upperCaseFirst) {
    str = (str || "").toLowerCase().replace(/-(.)/g, function(match2, group1) {
      return group1.toUpperCase();
    });
    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
    }
    return str;
  }
  var normalizeCssArray = normalizeCssArray$1;
  function makeValueReadable(value, valueType, useUTC) {
    var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function stringToUserReadable(str) {
      return str && trim$1(str) ? str : "-";
    }
    function isNumberUserReadable(num) {
      return !!(num != null && !isNaN(num) && isFinite(num));
    }
    var isTypeTime = valueType === "time";
    var isValueDate = value instanceof Date;
    if (isTypeTime || isValueDate) {
      var date = isTypeTime ? parseDate(value) : value;
      if (!isNaN(+date)) {
        return format$1(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
      } else if (isValueDate) {
        return "-";
      }
    }
    if (valueType === "ordinal") {
      return isStringSafe(value) ? stringToUserReadable(value) : isNumber$1(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
    }
    var numericResult = numericToNumber(value);
    return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
  }
  var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
  var wrapVar = function(varName, seriesIdx) {
    return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
  };
  function formatTpl(tpl, paramsList, encode2) {
    if (!isArray$1(paramsList)) {
      paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
      return "";
    }
    var $vars = paramsList[0].$vars || [];
    for (var i2 = 0; i2 < $vars.length; i2++) {
      var alias = TPL_VAR_ALIAS[i2];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k2 = 0; k2 < $vars.length; k2++) {
        var val = paramsList[seriesIdx][$vars[k2]];
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k2], seriesIdx), encode2 ? encodeHTML(val) : val);
      }
    }
    return tpl;
  }
  function formatTplSimple(tpl, param, encode2) {
    each$4(param, function(value, key2) {
      tpl = tpl.replace("{" + key2 + "}", value);
    });
    return tpl;
  }
  function getTooltipMarker(inOpt, extraCssText) {
    var opt = isString$1(inOpt) ? {
      color: inOpt,
      extraCssText
    } : inOpt || {};
    var color2 = opt.color;
    var type = opt.type;
    extraCssText = opt.extraCssText;
    var renderMode = opt.renderMode || "html";
    if (!color2) {
      return "";
    }
    if (renderMode === "html") {
      return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>';
    } else {
      var markerId = opt.markerId || "markerX";
      return {
        renderMode,
        content: "{" + markerId + "|}  ",
        style: type === "subItem" ? {
          width: 4,
          height: 4,
          borderRadius: 2,
          backgroundColor: color2
        } : {
          width: 10,
          height: 10,
          borderRadius: 5,
          backgroundColor: color2
        }
      };
    }
  }
  function formatTime(tpl, value, isUTC) {
    if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
      tpl = "MM-dd\nyyyy";
    }
    var date = parseDate(value);
    var getUTC = isUTC ? "getUTC" : "get";
    var y2 = date[getUTC + "FullYear"]();
    var M2 = date[getUTC + "Month"]() + 1;
    var d2 = date[getUTC + "Date"]();
    var h2 = date[getUTC + "Hours"]();
    var m2 = date[getUTC + "Minutes"]();
    var s2 = date[getUTC + "Seconds"]();
    var S2 = date[getUTC + "Milliseconds"]();
    tpl = tpl.replace("MM", pad(M2, 2)).replace("M", M2).replace("yyyy", y2).replace("yy", pad(y2 % 100 + "", 2)).replace("dd", pad(d2, 2)).replace("d", d2).replace("hh", pad(h2, 2)).replace("h", h2).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s2, 2)).replace("s", s2).replace("SSS", pad(S2, 3));
    return tpl;
  }
  function capitalFirst(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
  }
  function convertToColorString(color2, defaultColor) {
    defaultColor = defaultColor || "transparent";
    return isString$1(color2) ? color2 : isObject$3(color2) ? color2.colorStops && (color2.colorStops[0] || {}).color || defaultColor : defaultColor;
  }
  function windowOpen(link, target) {
    if (target === "_blank" || target === "blank") {
      var blank = window.open();
      blank.opener = null;
      blank.location.href = link;
    } else {
      window.open(link, target);
    }
  }
  var each$3 = each$4;
  var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
  var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
  function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x2 = 0;
    var y2 = 0;
    if (maxWidth == null) {
      maxWidth = Infinity;
    }
    if (maxHeight == null) {
      maxHeight = Infinity;
    }
    var currentLineMaxSize = 0;
    group.eachChild(function(child, idx) {
      var rect = child.getBoundingRect();
      var nextChild = group.childAt(idx + 1);
      var nextChildRect = nextChild && nextChild.getBoundingRect();
      var nextX;
      var nextY;
      if (orient === "horizontal") {
        var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
        nextX = x2 + moveX;
        if (nextX > maxWidth || child.newline) {
          x2 = 0;
          nextX = moveX;
          y2 += currentLineMaxSize + gap;
          currentLineMaxSize = rect.height;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
        }
      } else {
        var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
        nextY = y2 + moveY;
        if (nextY > maxHeight || child.newline) {
          x2 += currentLineMaxSize + gap;
          y2 = 0;
          nextY = moveY;
          currentLineMaxSize = rect.width;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
        }
      }
      if (child.newline) {
        return;
      }
      child.x = x2;
      child.y = y2;
      child.markRedraw();
      orient === "horizontal" ? x2 = nextX + gap : y2 = nextY + gap;
    });
  }
  var box = boxLayout;
  curry$1(boxLayout, "vertical");
  curry$1(boxLayout, "horizontal");
  function getLayoutRect(positionInfo, containerRect, margin) {
    margin = normalizeCssArray(margin || 0);
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var left = parsePercent(positionInfo.left, containerWidth);
    var top = parsePercent(positionInfo.top, containerHeight);
    var right = parsePercent(positionInfo.right, containerWidth);
    var bottom = parsePercent(positionInfo.bottom, containerHeight);
    var width = parsePercent(positionInfo.width, containerWidth);
    var height = parsePercent(positionInfo.height, containerHeight);
    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect;
    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left;
    }
    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top;
    }
    if (aspect != null) {
      if (isNaN(width) && isNaN(height)) {
        if (aspect > containerWidth / containerHeight) {
          width = containerWidth * 0.8;
        } else {
          height = containerHeight * 0.8;
        }
      }
      if (isNaN(width)) {
        width = aspect * height;
      }
      if (isNaN(height)) {
        height = width / aspect;
      }
    }
    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin;
    }
    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin;
    }
    switch (positionInfo.left || positionInfo.right) {
      case "center":
        left = containerWidth / 2 - width / 2 - margin[3];
        break;
      case "right":
        left = containerWidth - width - horizontalMargin;
        break;
    }
    switch (positionInfo.top || positionInfo.bottom) {
      case "middle":
      case "center":
        top = containerHeight / 2 - height / 2 - margin[0];
        break;
      case "bottom":
        top = containerHeight - height - verticalMargin;
        break;
    }
    left = left || 0;
    top = top || 0;
    if (isNaN(width)) {
      width = containerWidth - horizontalMargin - left - (right || 0);
    }
    if (isNaN(height)) {
      height = containerHeight - verticalMargin - top - (bottom || 0);
    }
    var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
    rect.margin = margin;
    return rect;
  }
  function sizeCalculable(option, hvIdx) {
    return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
  }
  function fetchLayoutMode(ins) {
    var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
    return isObject$3(layoutMode) ? layoutMode : layoutMode ? {
      type: layoutMode
    } : null;
  }
  function mergeLayoutParam(targetOption, newOption, opt) {
    var ignoreSize = opt && opt.ignoreSize;
    !isArray$1(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
    var hResult = merge2(HV_NAMES[0], 0);
    var vResult = merge2(HV_NAMES[1], 1);
    copy2(HV_NAMES[0], targetOption, hResult);
    copy2(HV_NAMES[1], targetOption, vResult);
    function merge2(names2, hvIdx) {
      var newParams = {};
      var newValueCount = 0;
      var merged = {};
      var mergedValueCount = 0;
      var enoughParamNumber = 2;
      each$3(names2, function(name) {
        merged[name] = targetOption[name];
      });
      each$3(names2, function(name) {
        hasProp2(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
        hasValue(newParams, name) && newValueCount++;
        hasValue(merged, name) && mergedValueCount++;
      });
      if (ignoreSize[hvIdx]) {
        if (hasValue(newOption, names2[1])) {
          merged[names2[2]] = null;
        } else if (hasValue(newOption, names2[2])) {
          merged[names2[1]] = null;
        }
        return merged;
      }
      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged;
      } else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        for (var i2 = 0; i2 < names2.length; i2++) {
          var name_1 = names2[i2];
          if (!hasProp2(newParams, name_1) && hasProp2(targetOption, name_1)) {
            newParams[name_1] = targetOption[name_1];
            break;
          }
        }
        return newParams;
      }
    }
    function hasProp2(obj2, name) {
      return obj2.hasOwnProperty(name);
    }
    function hasValue(obj2, name) {
      return obj2[name] != null && obj2[name] !== "auto";
    }
    function copy2(names2, target, source) {
      each$3(names2, function(name) {
        target[name] = source[name];
      });
    }
  }
  function getLayoutParams(source) {
    return copyLayoutParams({}, source);
  }
  function copyLayoutParams(target, source) {
    source && target && each$3(LOCATION_PARAMS, function(name) {
      source.hasOwnProperty(name) && (target[name] = source[name]);
    });
    return target;
  }
  var inner$9 = makeInner();
  var ComponentModel = (
    /** @class */
    function(_super) {
      __extends(ComponentModel2, _super);
      function ComponentModel2(option, parentModel, ecModel) {
        var _this = _super.call(this, option, parentModel, ecModel) || this;
        _this.uid = getUID("ec_cpt_model");
        return _this;
      }
      ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
      };
      ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge$1(option, themeModel.get(this.mainType));
        merge$1(option, this.getDefaultOption());
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      ComponentModel2.prototype.mergeOption = function(option, ecModel) {
        merge$1(this.option, option, true);
        var layoutMode = fetchLayoutMode(this);
        if (layoutMode) {
          mergeLayoutParam(this.option, option, layoutMode);
        }
      };
      ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
      };
      ComponentModel2.prototype.getDefaultOption = function() {
        var ctor = this.constructor;
        if (!isExtendedClass(ctor)) {
          return ctor.defaultOption;
        }
        var fields = inner$9(this);
        if (!fields.defaultOption) {
          var optList = [];
          var clz = ctor;
          while (clz) {
            var opt = clz.prototype.defaultOption;
            opt && optList.push(opt);
            clz = clz.superClass;
          }
          var defaultOption2 = {};
          for (var i2 = optList.length - 1; i2 >= 0; i2--) {
            defaultOption2 = merge$1(defaultOption2, optList[i2], true);
          }
          fields.defaultOption = defaultOption2;
        }
        return fields.defaultOption;
      };
      ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
        var indexKey = mainType + "Index";
        var idKey = mainType + "Id";
        return queryReferringComponents(this.ecModel, mainType, {
          index: this.get(indexKey, true),
          id: this.get(idKey, true)
        }, opt);
      };
      ComponentModel2.prototype.getBoxLayoutParams = function() {
        var boxLayoutModel = this;
        return {
          left: boxLayoutModel.get("left"),
          top: boxLayoutModel.get("top"),
          right: boxLayoutModel.get("right"),
          bottom: boxLayoutModel.get("bottom"),
          width: boxLayoutModel.get("width"),
          height: boxLayoutModel.get("height")
        };
      };
      ComponentModel2.prototype.getZLevelKey = function() {
        return "";
      };
      ComponentModel2.prototype.setZLevel = function(zlevel) {
        this.option.zlevel = zlevel;
      };
      ComponentModel2.protoInitialize = function() {
        var proto2 = ComponentModel2.prototype;
        proto2.type = "component";
        proto2.id = "";
        proto2.name = "";
        proto2.mainType = "";
        proto2.subType = "";
        proto2.componentIndex = 0;
      }();
      return ComponentModel2;
    }(Model)
  );
  mountExtend(ComponentModel, Model);
  enableClassManagement(ComponentModel);
  enableSubTypeDefaulter(ComponentModel);
  enableTopologicalTravel(ComponentModel, getDependencies);
  function getDependencies(componentType) {
    var deps = [];
    each$4(ComponentModel.getClassesByMainType(componentType), function(clz) {
      deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
    });
    deps = map$1(deps, function(type) {
      return parseClassType(type).main;
    });
    if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
      deps.unshift("dataset");
    }
    return deps;
  }
  var platform$2 = "";
  if (typeof navigator !== "undefined") {
    platform$2 = navigator.platform || "";
  }
  var decalColor = "rgba(0, 0, 0, 0.2)";
  const globalDefault = {
    darkMode: "auto",
    // backgroundColor: 'rgba(0,0,0,0)',
    colorBy: "series",
    color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
    gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
    aria: {
      decal: {
        decals: [{
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [2, 5],
          symbolSize: 1,
          rotation: Math.PI / 6
        }, {
          color: decalColor,
          symbol: "circle",
          dashArrayX: [[8, 8], [0, 8, 8, 0]],
          dashArrayY: [6, 0],
          symbolSize: 0.8
        }, {
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [4, 3],
          rotation: -Math.PI / 4
        }, {
          color: decalColor,
          dashArrayX: [[6, 6], [0, 6, 6, 0]],
          dashArrayY: [6, 0]
        }, {
          color: decalColor,
          dashArrayX: [[1, 0], [1, 6]],
          dashArrayY: [1, 0, 6, 0],
          rotation: Math.PI / 4
        }, {
          color: decalColor,
          symbol: "triangle",
          dashArrayX: [[9, 9], [0, 9, 9, 0]],
          dashArrayY: [7, 2],
          symbolSize: 0.75
        }]
      }
    },
    // If xAxis and yAxis declared, grid is created by default.
    // grid: {},
    textStyle: {
      // color: '#000',
      // decoration: 'none',
      // PENDING
      fontFamily: platform$2.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      // fontFamily: 'Arial, Verdana, sans-serif',
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
    // Default is source-over
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    // Configuration for progressive/incremental rendering
    progressiveThreshold: 3e3,
    progressive: 400,
    // Threshold of if use single hover layer to optimize.
    // It is recommended that `hoverLayerThreshold` is equivalent to or less than
    // `progressiveThreshold`, otherwise hover will cause restart of progressive,
    // which is unexpected.
    // see example <echarts/test/heatmap-large.html>.
    hoverLayerThreshold: 3e3,
    // See: module:echarts/scale/Time
    useUTC: false
  };
  var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]);
  var SOURCE_FORMAT_ORIGINAL = "original";
  var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
  var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
  var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
  var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
  var SOURCE_FORMAT_UNKNOWN = "unknown";
  var SERIES_LAYOUT_BY_COLUMN = "column";
  var SERIES_LAYOUT_BY_ROW = "row";
  var BE_ORDINAL = {
    Must: 1,
    Might: 2,
    Not: 3
    // Other cases
  };
  var innerGlobalModel = makeInner();
  function resetSourceDefaulter(ecModel) {
    innerGlobalModel(ecModel).datasetMap = createHashMap();
  }
  function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
    var encode2 = {};
    var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
    if (!datasetModel || !coordDimensions) {
      return encode2;
    }
    var encodeItemName = [];
    var encodeSeriesName = [];
    var ecModel = seriesModel.ecModel;
    var datasetMap = innerGlobalModel(ecModel).datasetMap;
    var key2 = datasetModel.uid + "_" + source.seriesLayoutBy;
    var baseCategoryDimIndex;
    var categoryWayValueDimStart;
    coordDimensions = coordDimensions.slice();
    each$4(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
      var coordDimInfo = isObject$3(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
        name: coordDimInfoLoose
      };
      if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx;
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
      }
      encode2[coordDimInfo.name] = [];
    });
    var datasetRecord = datasetMap.get(key2) || datasetMap.set(key2, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    });
    each$4(coordDimensions, function(coordDimInfo, coordDimIdx) {
      var coordDimName = coordDimInfo.name;
      var count = getDataDimCountOnCoordDim(coordDimInfo);
      if (baseCategoryDimIndex == null) {
        var start2 = datasetRecord.valueWayDim;
        pushDim(encode2[coordDimName], start2, count);
        pushDim(encodeSeriesName, start2, count);
        datasetRecord.valueWayDim += count;
      } else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode2[coordDimName], 0, count);
        pushDim(encodeItemName, 0, count);
      } else {
        var start2 = datasetRecord.categoryWayDim;
        pushDim(encode2[coordDimName], start2, count);
        pushDim(encodeSeriesName, start2, count);
        datasetRecord.categoryWayDim += count;
      }
    });
    function pushDim(dimIdxArr, idxFrom, idxCount) {
      for (var i2 = 0; i2 < idxCount; i2++) {
        dimIdxArr.push(idxFrom + i2);
      }
    }
    function getDataDimCountOnCoordDim(coordDimInfo) {
      var dimsDef = coordDimInfo.dimsDef;
      return dimsDef ? dimsDef.length : 1;
    }
    encodeItemName.length && (encode2.itemName = encodeItemName);
    encodeSeriesName.length && (encode2.seriesName = encodeSeriesName);
    return encode2;
  }
  function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
    var encode2 = {};
    var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
    if (!datasetModel) {
      return encode2;
    }
    var sourceFormat = source.sourceFormat;
    var dimensionsDefine = source.dimensionsDefine;
    var potentialNameDimIndex;
    if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      each$4(dimensionsDefine, function(dim, idx) {
        if ((isObject$3(dim) ? dim.name : dim) === "name") {
          potentialNameDimIndex = idx;
        }
      });
    }
    var idxResult = function() {
      var idxRes0 = {};
      var idxRes1 = {};
      var guessRecords = [];
      for (var i2 = 0, len2 = Math.min(5, dimCount); i2 < len2; i2++) {
        var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i2);
        guessRecords.push(guessResult);
        var isPureNumber = guessResult === BE_ORDINAL.Not;
        if (isPureNumber && idxRes0.v == null && i2 !== potentialNameDimIndex) {
          idxRes0.v = i2;
        }
        if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
          idxRes0.n = i2;
        }
        if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
          return idxRes0;
        }
        if (!isPureNumber) {
          if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i2 !== potentialNameDimIndex) {
            idxRes1.v = i2;
          }
          if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
            idxRes1.n = i2;
          }
        }
      }
      function fulfilled(idxResult2) {
        return idxResult2.v != null && idxResult2.n != null;
      }
      return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
    }();
    if (idxResult) {
      encode2.value = [idxResult.v];
      var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
      encode2.itemName = [nameDimIndex];
      encode2.seriesName = [nameDimIndex];
    }
    return encode2;
  }
  function querySeriesUpstreamDatasetModel(seriesModel) {
    var thisData = seriesModel.get("data", true);
    if (!thisData) {
      return queryReferringComponents(seriesModel.ecModel, "dataset", {
        index: seriesModel.get("datasetIndex", true),
        id: seriesModel.get("datasetId", true)
      }, SINGLE_REFERRING).models[0];
    }
  }
  function queryDatasetUpstreamDatasetModels(datasetModel) {
    if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
      return [];
    }
    return queryReferringComponents(datasetModel.ecModel, "dataset", {
      index: datasetModel.get("fromDatasetIndex", true),
      id: datasetModel.get("fromDatasetId", true)
    }, SINGLE_REFERRING).models;
  }
  function guessOrdinal(source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
  }
  function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    var result;
    var maxLoop = 5;
    if (isTypedArray$1(data)) {
      return BE_ORDINAL.Not;
    }
    var dimName;
    var dimType;
    if (dimensionsDefine) {
      var dimDefItem = dimensionsDefine[dimIndex];
      if (isObject$3(dimDefItem)) {
        dimName = dimDefItem.name;
        dimType = dimDefItem.type;
      } else if (isString$1(dimDefItem)) {
        dimName = dimDefItem;
      }
    }
    if (dimType != null) {
      return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        var sample = dataArrayRows[dimIndex];
        for (var i2 = 0; i2 < (sample || []).length && i2 < maxLoop; i2++) {
          if ((result = detectValue(sample[startIndex + i2])) != null) {
            return result;
          }
        }
      } else {
        for (var i2 = 0; i2 < dataArrayRows.length && i2 < maxLoop; i2++) {
          var row = dataArrayRows[startIndex + i2];
          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result;
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var dataObjectRows = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      for (var i2 = 0; i2 < dataObjectRows.length && i2 < maxLoop; i2++) {
        var item = dataObjectRows[i2];
        if (item && (result = detectValue(item[dimName])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      var dataKeyedColumns = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      var sample = dataKeyedColumns[dimName];
      if (!sample || isTypedArray$1(sample)) {
        return BE_ORDINAL.Not;
      }
      for (var i2 = 0; i2 < sample.length && i2 < maxLoop; i2++) {
        if ((result = detectValue(sample[i2])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var dataOriginal = data;
      for (var i2 = 0; i2 < dataOriginal.length && i2 < maxLoop; i2++) {
        var item = dataOriginal[i2];
        var val = getDataItemValue(item);
        if (!isArray$1(val)) {
          return BE_ORDINAL.Not;
        }
        if ((result = detectValue(val[dimIndex])) != null) {
          return result;
        }
      }
    }
    function detectValue(val2) {
      var beStr = isString$1(val2);
      if (val2 != null && Number.isFinite(Number(val2)) && val2 !== "") {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
      } else if (beStr && val2 !== "-") {
        return BE_ORDINAL.Must;
      }
    }
    return BE_ORDINAL.Not;
  }
  var internalOptionCreatorMap = createHashMap();
  function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
    var internalOptionCreator = internalOptionCreatorMap.get(mainType);
    if (!internalOptionCreator) {
      return newCmptOptionList;
    }
    var internalOptions = internalOptionCreator(ecModel);
    if (!internalOptions) {
      return newCmptOptionList;
    }
    return newCmptOptionList.concat(internalOptions);
  }
  var innerColor = makeInner();
  makeInner();
  var PaletteMixin = (
    /** @class */
    function() {
      function PaletteMixin2() {
      }
      PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
        var defaultPalette = normalizeToArray(this.get("color", true));
        var layeredPalette = this.get("colorLayer", true);
        return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
      };
      PaletteMixin2.prototype.clearColorPalette = function() {
        clearPalette(this, innerColor);
      };
      return PaletteMixin2;
    }()
  );
  function getNearestPalette(palettes, requestColorNum) {
    var paletteNum = palettes.length;
    for (var i2 = 0; i2 < paletteNum; i2++) {
      if (palettes[i2].length > requestColorNum) {
        return palettes[i2];
      }
    }
    return palettes[paletteNum - 1];
  }
  function getFromPalette(that, inner2, defaultPalette, layeredPalette, name, scope, requestNum) {
    scope = scope || that;
    var scopeFields = inner2(scope);
    var paletteIdx = scopeFields.paletteIdx || 0;
    var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
    if (paletteNameMap.hasOwnProperty(name)) {
      return paletteNameMap[name];
    }
    var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
    palette = palette || defaultPalette;
    if (!palette || !palette.length) {
      return;
    }
    var pickedPaletteItem = palette[paletteIdx];
    if (name) {
      paletteNameMap[name] = pickedPaletteItem;
    }
    scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
    return pickedPaletteItem;
  }
  function clearPalette(that, inner2) {
    inner2(that).paletteIdx = 0;
    inner2(that).paletteNameMap = {};
  }
  var reCreateSeriesIndices;
  var assertSeriesInitialized;
  var initBase;
  var OPTION_INNER_KEY = "\0_ec_inner";
  var OPTION_INNER_VALUE = 1;
  var GlobalModel = (
    /** @class */
    function(_super) {
      __extends(GlobalModel2, _super);
      function GlobalModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale2, optionManager) {
        theme2 = theme2 || {};
        this.option = null;
        this._theme = new Model(theme2);
        this._locale = new Model(locale2);
        this._optionManager = optionManager;
      };
      GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
        var innerOpt = normalizeSetOptionInput(opts);
        this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
        this._resetOption(null, innerOpt);
      };
      GlobalModel2.prototype.resetOption = function(type, opt) {
        return this._resetOption(type, normalizeSetOptionInput(opt));
      };
      GlobalModel2.prototype._resetOption = function(type, opt) {
        var optionChanged = false;
        var optionManager = this._optionManager;
        if (!type || type === "recreate") {
          var baseOption = optionManager.mountOption(type === "recreate");
          if (!this.option || type === "recreate") {
            initBase(this, baseOption);
          } else {
            this.restoreData();
            this._mergeOption(baseOption, opt);
          }
          optionChanged = true;
        }
        if (type === "timeline" || type === "media") {
          this.restoreData();
        }
        if (!type || type === "recreate" || type === "timeline") {
          var timelineOption = optionManager.getTimelineOption(this);
          if (timelineOption) {
            optionChanged = true;
            this._mergeOption(timelineOption, opt);
          }
        }
        if (!type || type === "recreate" || type === "media") {
          var mediaOptions = optionManager.getMediaOption(this);
          if (mediaOptions.length) {
            each$4(mediaOptions, function(mediaOption) {
              optionChanged = true;
              this._mergeOption(mediaOption, opt);
            }, this);
          }
        }
        return optionChanged;
      };
      GlobalModel2.prototype.mergeOption = function(option) {
        this._mergeOption(option, null);
      };
      GlobalModel2.prototype._mergeOption = function(newOption, opt) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var componentsCount = this._componentsCount;
        var newCmptTypes = [];
        var newCmptTypeMap = createHashMap();
        var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
        resetSourceDefaulter(this);
        each$4(newOption, function(componentOption, mainType) {
          if (componentOption == null) {
            return;
          }
          if (!ComponentModel.hasClass(mainType)) {
            option[mainType] = option[mainType] == null ? clone$4(componentOption) : merge$1(option[mainType], componentOption, true);
          } else if (mainType) {
            newCmptTypes.push(mainType);
            newCmptTypeMap.set(mainType, true);
          }
        });
        if (replaceMergeMainTypeMap) {
          replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
            if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
              newCmptTypes.push(mainTypeInReplaceMerge);
              newCmptTypeMap.set(mainTypeInReplaceMerge, true);
            }
          });
        }
        ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
        function visitComponent(mainType) {
          var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
          var oldCmptList = componentsMap.get(mainType);
          var mergeMode = (
            // `!oldCmptList` means init. See the comment in `mappingToExists`
            !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge"
          );
          var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
          setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel);
          option[mainType] = null;
          componentsMap.set(mainType, null);
          componentsCount.set(mainType, 0);
          var optionsByMainType = [];
          var cmptsByMainType = [];
          var cmptsCountByMainType = 0;
          var tooltipExists;
          each$4(mappingResult, function(resultItem, index2) {
            var componentModel = resultItem.existing;
            var newCmptOption = resultItem.newOption;
            if (!newCmptOption) {
              if (componentModel) {
                componentModel.mergeOption({}, this);
                componentModel.optionUpdated({}, false);
              }
            } else {
              var isSeriesType = mainType === "series";
              var ComponentModelClass = ComponentModel.getClass(
                mainType,
                resultItem.keyInfo.subType,
                !isSeriesType
                // Give a more detailed warn later if series don't exists
              );
              if (!ComponentModelClass) {
                return;
              }
              if (mainType === "tooltip") {
                if (tooltipExists) {
                  return;
                }
                tooltipExists = true;
              }
              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name;
                componentModel.mergeOption(newCmptOption, this);
                componentModel.optionUpdated(newCmptOption, false);
              } else {
                var extraOpt = extend$1({
                  componentIndex: index2
                }, resultItem.keyInfo);
                componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
                extend$1(componentModel, extraOpt);
                if (resultItem.brandNew) {
                  componentModel.__requireNewView = true;
                }
                componentModel.init(newCmptOption, this, this);
                componentModel.optionUpdated(null, true);
              }
            }
            if (componentModel) {
              optionsByMainType.push(componentModel.option);
              cmptsByMainType.push(componentModel);
              cmptsCountByMainType++;
            } else {
              optionsByMainType.push(void 0);
              cmptsByMainType.push(void 0);
            }
          }, this);
          option[mainType] = optionsByMainType;
          componentsMap.set(mainType, cmptsByMainType);
          componentsCount.set(mainType, cmptsCountByMainType);
          if (mainType === "series") {
            reCreateSeriesIndices(this);
          }
        }
        if (!this._seriesIndices) {
          reCreateSeriesIndices(this);
        }
      };
      GlobalModel2.prototype.getOption = function() {
        var option = clone$4(this.option);
        each$4(option, function(optInMainType, mainType) {
          if (ComponentModel.hasClass(mainType)) {
            var opts = normalizeToArray(optInMainType);
            var realLen = opts.length;
            var metNonInner = false;
            for (var i2 = realLen - 1; i2 >= 0; i2--) {
              if (opts[i2] && !isComponentIdInternal(opts[i2])) {
                metNonInner = true;
              } else {
                opts[i2] = null;
                !metNonInner && realLen--;
              }
            }
            opts.length = realLen;
            option[mainType] = opts;
          }
        });
        delete option[OPTION_INNER_KEY];
        return option;
      };
      GlobalModel2.prototype.getTheme = function() {
        return this._theme;
      };
      GlobalModel2.prototype.getLocaleModel = function() {
        return this._locale;
      };
      GlobalModel2.prototype.setUpdatePayload = function(payload) {
        this._payload = payload;
      };
      GlobalModel2.prototype.getUpdatePayload = function() {
        return this._payload;
      };
      GlobalModel2.prototype.getComponent = function(mainType, idx) {
        var list2 = this._componentsMap.get(mainType);
        if (list2) {
          var cmpt = list2[idx || 0];
          if (cmpt) {
            return cmpt;
          } else if (idx == null) {
            for (var i2 = 0; i2 < list2.length; i2++) {
              if (list2[i2]) {
                return list2[i2];
              }
            }
          }
        }
      };
      GlobalModel2.prototype.queryComponents = function(condition) {
        var mainType = condition.mainType;
        if (!mainType) {
          return [];
        }
        var index2 = condition.index;
        var id = condition.id;
        var name = condition.name;
        var cmpts = this._componentsMap.get(mainType);
        if (!cmpts || !cmpts.length) {
          return [];
        }
        var result;
        if (index2 != null) {
          result = [];
          each$4(normalizeToArray(index2), function(idx) {
            cmpts[idx] && result.push(cmpts[idx]);
          });
        } else if (id != null) {
          result = queryByIdOrName("id", id, cmpts);
        } else if (name != null) {
          result = queryByIdOrName("name", name, cmpts);
        } else {
          result = filter(cmpts, function(cmpt) {
            return !!cmpt;
          });
        }
        return filterBySubType(result, condition);
      };
      GlobalModel2.prototype.findComponents = function(condition) {
        var query = condition.query;
        var mainType = condition.mainType;
        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
          return !!cmpt;
        });
        return doFilter(filterBySubType(result, condition));
        function getQueryCond(q2) {
          var indexAttr = mainType + "Index";
          var idAttr = mainType + "Id";
          var nameAttr = mainType + "Name";
          return q2 && (q2[indexAttr] != null || q2[idAttr] != null || q2[nameAttr] != null) ? {
            mainType,
            // subType will be filtered finally.
            index: q2[indexAttr],
            id: q2[idAttr],
            name: q2[nameAttr]
          } : null;
        }
        function doFilter(res) {
          return condition.filter ? filter(res, condition.filter) : res;
        }
      };
      GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
        var componentsMap = this._componentsMap;
        if (isFunction$1(mainType)) {
          var ctxForAll_1 = cb;
          var cbForAll_1 = mainType;
          componentsMap.each(function(cmpts2, componentType) {
            for (var i22 = 0; cmpts2 && i22 < cmpts2.length; i22++) {
              var cmpt2 = cmpts2[i22];
              cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
            }
          });
        } else {
          var cmpts = isString$1(mainType) ? componentsMap.get(mainType) : isObject$3(mainType) ? this.findComponents(mainType) : null;
          for (var i2 = 0; cmpts && i2 < cmpts.length; i2++) {
            var cmpt = cmpts[i2];
            cmpt && cb.call(context, cmpt, cmpt.componentIndex);
          }
        }
      };
      GlobalModel2.prototype.getSeriesByName = function(name) {
        var nameStr = convertOptionIdName(name, null);
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
        });
      };
      GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
        return this._componentsMap.get("series")[seriesIndex];
      };
      GlobalModel2.prototype.getSeriesByType = function(subType) {
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries && oneSeries.subType === subType;
        });
      };
      GlobalModel2.prototype.getSeries = function() {
        return filter(this._componentsMap.get("series"), function(oneSeries) {
          return !!oneSeries;
        });
      };
      GlobalModel2.prototype.getSeriesCount = function() {
        return this._componentsCount.get("series");
      };
      GlobalModel2.prototype.eachSeries = function(cb, context) {
        assertSeriesInitialized(this);
        each$4(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          cb.call(context, series, rawSeriesIndex);
        }, this);
      };
      GlobalModel2.prototype.eachRawSeries = function(cb, context) {
        each$4(this._componentsMap.get("series"), function(series) {
          series && cb.call(context, series, series.componentIndex);
        });
      };
      GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
        assertSeriesInitialized(this);
        each$4(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex);
          }
        }, this);
      };
      GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
        return each$4(this.getSeriesByType(subType), cb, context);
      };
      GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
        assertSeriesInitialized(this);
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
      };
      GlobalModel2.prototype.getCurrentSeriesIndices = function() {
        return (this._seriesIndices || []).slice();
      };
      GlobalModel2.prototype.filterSeries = function(cb, context) {
        assertSeriesInitialized(this);
        var newSeriesIndices = [];
        each$4(this._seriesIndices, function(seriesRawIdx) {
          var series = this._componentsMap.get("series")[seriesRawIdx];
          cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
        }, this);
        this._seriesIndices = newSeriesIndices;
        this._seriesIndicesMap = createHashMap(newSeriesIndices);
      };
      GlobalModel2.prototype.restoreData = function(payload) {
        reCreateSeriesIndices(this);
        var componentsMap = this._componentsMap;
        var componentTypes = [];
        componentsMap.each(function(components, componentType) {
          if (ComponentModel.hasClass(componentType)) {
            componentTypes.push(componentType);
          }
        });
        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType) {
          each$4(componentsMap.get(componentType), function(component) {
            if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
              component.restoreData();
            }
          });
        });
      };
      GlobalModel2.internalField = function() {
        reCreateSeriesIndices = function(ecModel) {
          var seriesIndices = ecModel._seriesIndices = [];
          each$4(ecModel._componentsMap.get("series"), function(series) {
            series && seriesIndices.push(series.componentIndex);
          });
          ecModel._seriesIndicesMap = createHashMap(seriesIndices);
        };
        assertSeriesInitialized = function(ecModel) {
        };
        initBase = function(ecModel, baseOption) {
          ecModel.option = {};
          ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
          ecModel._componentsMap = createHashMap({
            series: []
          });
          ecModel._componentsCount = createHashMap();
          var airaOption = baseOption.aria;
          if (isObject$3(airaOption) && airaOption.enabled == null) {
            airaOption.enabled = true;
          }
          mergeTheme(baseOption, ecModel._theme.option);
          merge$1(baseOption, globalDefault, false);
          ecModel._mergeOption(baseOption, null);
        };
      }();
      return GlobalModel2;
    }(Model)
  );
  function isNotTargetSeries(seriesModel, payload) {
    if (payload) {
      var index2 = payload.seriesIndex;
      var id = payload.seriesId;
      var name_1 = payload.seriesName;
      return index2 != null && seriesModel.componentIndex !== index2 || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
    }
  }
  function mergeTheme(option, theme2) {
    var notMergeColorLayer = option.color && !option.colorLayer;
    each$4(theme2, function(themeItem, name) {
      if (name === "colorLayer" && notMergeColorLayer) {
        return;
      }
      if (!ComponentModel.hasClass(name)) {
        if (typeof themeItem === "object") {
          option[name] = !option[name] ? clone$4(themeItem) : merge$1(option[name], themeItem, false);
        } else {
          if (option[name] == null) {
            option[name] = themeItem;
          }
        }
      }
    });
  }
  function queryByIdOrName(attr, idOrName, cmpts) {
    if (isArray$1(idOrName)) {
      var keyMap_1 = createHashMap();
      each$4(idOrName, function(idOrNameItem) {
        if (idOrNameItem != null) {
          var idName = convertOptionIdName(idOrNameItem, null);
          idName != null && keyMap_1.set(idOrNameItem, true);
        }
      });
      return filter(cmpts, function(cmpt) {
        return cmpt && keyMap_1.get(cmpt[attr]);
      });
    } else {
      var idName_1 = convertOptionIdName(idOrName, null);
      return filter(cmpts, function(cmpt) {
        return cmpt && idName_1 != null && cmpt[attr] === idName_1;
      });
    }
  }
  function filterBySubType(components, condition) {
    return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
      return cmpt && cmpt.subType === condition.subType;
    }) : components;
  }
  function normalizeSetOptionInput(opts) {
    var replaceMergeMainTypeMap = createHashMap();
    opts && each$4(normalizeToArray(opts.replaceMerge), function(mainType) {
      replaceMergeMainTypeMap.set(mainType, true);
    });
    return {
      replaceMergeMainTypeMap
    };
  }
  mixin(GlobalModel, PaletteMixin);
  var availableMethods = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    // 'getModel',
    "getOption",
    // 'getViewOfComponentModel',
    // 'getViewOfSeriesModel',
    "getId",
    "updateLabelLayout"
  ];
  var ExtensionAPI = (
    /** @class */
    /* @__PURE__ */ function() {
      function ExtensionAPI2(ecInstance) {
        each$4(availableMethods, function(methodName) {
          this[methodName] = bind$2(ecInstance[methodName], ecInstance);
        }, this);
      }
      return ExtensionAPI2;
    }()
  );
  var coordinateSystemCreators = {};
  var CoordinateSystemManager = (
    /** @class */
    function() {
      function CoordinateSystemManager2() {
        this._coordinateSystems = [];
      }
      CoordinateSystemManager2.prototype.create = function(ecModel, api2) {
        var coordinateSystems = [];
        each$4(coordinateSystemCreators, function(creator, type) {
          var list2 = creator.create(ecModel, api2);
          coordinateSystems = coordinateSystems.concat(list2 || []);
        });
        this._coordinateSystems = coordinateSystems;
      };
      CoordinateSystemManager2.prototype.update = function(ecModel, api2) {
        each$4(this._coordinateSystems, function(coordSys) {
          coordSys.update && coordSys.update(ecModel, api2);
        });
      };
      CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
        return this._coordinateSystems.slice();
      };
      CoordinateSystemManager2.register = function(type, creator) {
        coordinateSystemCreators[type] = creator;
      };
      CoordinateSystemManager2.get = function(type) {
        return coordinateSystemCreators[type];
      };
      return CoordinateSystemManager2;
    }()
  );
  var QUERY_REG = /^(min|max)?(.+)$/;
  var OptionManager = (
    /** @class */
    function() {
      function OptionManager2(api2) {
        this._timelineOptions = [];
        this._mediaList = [];
        this._currentMediaIndices = [];
        this._api = api2;
      }
      OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
        if (rawOption) {
          each$4(normalizeToArray(rawOption.series), function(series) {
            series && series.data && isTypedArray$1(series.data) && setAsPrimitive(series.data);
          });
          each$4(normalizeToArray(rawOption.dataset), function(dataset) {
            dataset && dataset.source && isTypedArray$1(dataset.source) && setAsPrimitive(dataset.source);
          });
        }
        rawOption = clone$4(rawOption);
        var optionBackup = this._optionBackup;
        var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
        this._newBaseOption = newParsedOption.baseOption;
        if (optionBackup) {
          if (newParsedOption.timelineOptions.length) {
            optionBackup.timelineOptions = newParsedOption.timelineOptions;
          }
          if (newParsedOption.mediaList.length) {
            optionBackup.mediaList = newParsedOption.mediaList;
          }
          if (newParsedOption.mediaDefault) {
            optionBackup.mediaDefault = newParsedOption.mediaDefault;
          }
        } else {
          this._optionBackup = newParsedOption;
        }
      };
      OptionManager2.prototype.mountOption = function(isRecreate) {
        var optionBackup = this._optionBackup;
        this._timelineOptions = optionBackup.timelineOptions;
        this._mediaList = optionBackup.mediaList;
        this._mediaDefault = optionBackup.mediaDefault;
        this._currentMediaIndices = [];
        return clone$4(isRecreate ? optionBackup.baseOption : this._newBaseOption);
      };
      OptionManager2.prototype.getTimelineOption = function(ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;
        if (timelineOptions.length) {
          var timelineModel = ecModel.getComponent("timeline");
          if (timelineModel) {
            option = clone$4(
              // FIXME:TS as TimelineModel or quivlant interface
              timelineOptions[timelineModel.getCurrentIndex()]
            );
          }
        }
        return option;
      };
      OptionManager2.prototype.getMediaOption = function(ecModel) {
        var ecWidth = this._api.getWidth();
        var ecHeight = this._api.getHeight();
        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = [];
        if (!mediaList.length && !mediaDefault) {
          return result;
        }
        for (var i2 = 0, len2 = mediaList.length; i2 < len2; i2++) {
          if (applyMediaQuery(mediaList[i2].query, ecWidth, ecHeight)) {
            indices.push(i2);
          }
        }
        if (!indices.length && mediaDefault) {
          indices = [-1];
        }
        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map$1(indices, function(index2) {
            return clone$4(index2 === -1 ? mediaDefault.option : mediaList[index2].option);
          });
        }
        this._currentMediaIndices = indices;
        return result;
      };
      return OptionManager2;
    }()
  );
  function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
    var mediaList = [];
    var mediaDefault;
    var baseOption;
    var declaredBaseOption = rawOption.baseOption;
    var timelineOnRoot = rawOption.timeline;
    var timelineOptionsOnRoot = rawOption.options;
    var mediaOnRoot = rawOption.media;
    var hasMedia = !!rawOption.media;
    var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
    if (declaredBaseOption) {
      baseOption = declaredBaseOption;
      if (!baseOption.timeline) {
        baseOption.timeline = timelineOnRoot;
      }
    } else {
      if (hasTimeline || hasMedia) {
        rawOption.options = rawOption.media = null;
      }
      baseOption = rawOption;
    }
    if (hasMedia) {
      if (isArray$1(mediaOnRoot)) {
        each$4(mediaOnRoot, function(singleMedia) {
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              mediaDefault = singleMedia;
            }
          }
        });
      }
    }
    doPreprocess(baseOption);
    each$4(timelineOptionsOnRoot, function(option) {
      return doPreprocess(option);
    });
    each$4(mediaList, function(media) {
      return doPreprocess(media.option);
    });
    function doPreprocess(option) {
      each$4(optionPreprocessorFuncs2, function(preProcess) {
        preProcess(option, isNew);
      });
    }
    return {
      baseOption,
      timelineOptions: timelineOptionsOnRoot || [],
      mediaDefault,
      mediaList
    };
  }
  function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight
      // lower case for convenience.
    };
    var applicable = true;
    each$4(query, function(value, attr) {
      var matched = attr.match(QUERY_REG);
      if (!matched || !matched[1] || !matched[2]) {
        return;
      }
      var operator = matched[1];
      var realAttr = matched[2].toLowerCase();
      if (!compare(realMap[realAttr], value, operator)) {
        applicable = false;
      }
    });
    return applicable;
  }
  function compare(real, expect, operator) {
    if (operator === "min") {
      return real >= expect;
    } else if (operator === "max") {
      return real <= expect;
    } else {
      return real === expect;
    }
  }
  function indicesEquals(indices1, indices2) {
    return indices1.join(",") === indices2.join(",");
  }
  var each$2 = each$4;
  var isObject$2 = isObject$3;
  var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
  function compatEC2ItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;
    if (!itemStyleOpt) {
      return;
    }
    for (var i2 = 0, len2 = POSSIBLE_STYLES.length; i2 < len2; i2++) {
      var styleName = POSSIBLE_STYLES[i2];
      var normalItemStyleOpt = itemStyleOpt.normal;
      var emphasisItemStyleOpt = itemStyleOpt.emphasis;
      if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].normal) {
          opt[styleName].normal = normalItemStyleOpt[styleName];
        } else {
          merge$1(opt[styleName].normal, normalItemStyleOpt[styleName]);
        }
        normalItemStyleOpt[styleName] = null;
      }
      if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].emphasis) {
          opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
        } else {
          merge$1(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
        }
        emphasisItemStyleOpt[styleName] = null;
      }
    }
  }
  function convertNormalEmphasis(opt, optType, useExtend) {
    if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
      var normalOpt = opt[optType].normal;
      var emphasisOpt = opt[optType].emphasis;
      if (normalOpt) {
        if (useExtend) {
          opt[optType].normal = opt[optType].emphasis = null;
          defaults$1(opt[optType], normalOpt);
        } else {
          opt[optType] = normalOpt;
        }
      }
      if (emphasisOpt) {
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[optType] = emphasisOpt;
        if (emphasisOpt.focus) {
          opt.emphasis.focus = emphasisOpt.focus;
        }
        if (emphasisOpt.blurScope) {
          opt.emphasis.blurScope = emphasisOpt.blurScope;
        }
      }
    }
  }
  function removeEC3NormalStatus(opt) {
    convertNormalEmphasis(opt, "itemStyle");
    convertNormalEmphasis(opt, "lineStyle");
    convertNormalEmphasis(opt, "areaStyle");
    convertNormalEmphasis(opt, "label");
    convertNormalEmphasis(opt, "labelLine");
    convertNormalEmphasis(opt, "upperLabel");
    convertNormalEmphasis(opt, "edgeLabel");
  }
  function compatTextStyle(opt, propName) {
    var labelOptSingle = isObject$2(opt) && opt[propName];
    var textStyle = isObject$2(labelOptSingle) && labelOptSingle.textStyle;
    if (textStyle) {
      for (var i2 = 0, len2 = TEXT_STYLE_OPTIONS.length; i2 < len2; i2++) {
        var textPropName = TEXT_STYLE_OPTIONS[i2];
        if (textStyle.hasOwnProperty(textPropName)) {
          labelOptSingle[textPropName] = textStyle[textPropName];
        }
      }
    }
  }
  function compatEC3CommonStyles(opt) {
    if (opt) {
      removeEC3NormalStatus(opt);
      compatTextStyle(opt, "label");
      opt.emphasis && compatTextStyle(opt.emphasis, "label");
    }
  }
  function processSeries(seriesOpt) {
    if (!isObject$2(seriesOpt)) {
      return;
    }
    compatEC2ItemStyle(seriesOpt);
    removeEC3NormalStatus(seriesOpt);
    compatTextStyle(seriesOpt, "label");
    compatTextStyle(seriesOpt, "upperLabel");
    compatTextStyle(seriesOpt, "edgeLabel");
    if (seriesOpt.emphasis) {
      compatTextStyle(seriesOpt.emphasis, "label");
      compatTextStyle(seriesOpt.emphasis, "upperLabel");
      compatTextStyle(seriesOpt.emphasis, "edgeLabel");
    }
    var markPoint = seriesOpt.markPoint;
    if (markPoint) {
      compatEC2ItemStyle(markPoint);
      compatEC3CommonStyles(markPoint);
    }
    var markLine = seriesOpt.markLine;
    if (markLine) {
      compatEC2ItemStyle(markLine);
      compatEC3CommonStyles(markLine);
    }
    var markArea = seriesOpt.markArea;
    if (markArea) {
      compatEC3CommonStyles(markArea);
    }
    var data = seriesOpt.data;
    if (seriesOpt.type === "graph") {
      data = data || seriesOpt.nodes;
      var edgeData = seriesOpt.links || seriesOpt.edges;
      if (edgeData && !isTypedArray$1(edgeData)) {
        for (var i2 = 0; i2 < edgeData.length; i2++) {
          compatEC3CommonStyles(edgeData[i2]);
        }
      }
      each$4(seriesOpt.categories, function(opt) {
        removeEC3NormalStatus(opt);
      });
    }
    if (data && !isTypedArray$1(data)) {
      for (var i2 = 0; i2 < data.length; i2++) {
        compatEC3CommonStyles(data[i2]);
      }
    }
    markPoint = seriesOpt.markPoint;
    if (markPoint && markPoint.data) {
      var mpData = markPoint.data;
      for (var i2 = 0; i2 < mpData.length; i2++) {
        compatEC3CommonStyles(mpData[i2]);
      }
    }
    markLine = seriesOpt.markLine;
    if (markLine && markLine.data) {
      var mlData = markLine.data;
      for (var i2 = 0; i2 < mlData.length; i2++) {
        if (isArray$1(mlData[i2])) {
          compatEC3CommonStyles(mlData[i2][0]);
          compatEC3CommonStyles(mlData[i2][1]);
        } else {
          compatEC3CommonStyles(mlData[i2]);
        }
      }
    }
    if (seriesOpt.type === "gauge") {
      compatTextStyle(seriesOpt, "axisLabel");
      compatTextStyle(seriesOpt, "title");
      compatTextStyle(seriesOpt, "detail");
    } else if (seriesOpt.type === "treemap") {
      convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
      each$4(seriesOpt.levels, function(opt) {
        removeEC3NormalStatus(opt);
      });
    } else if (seriesOpt.type === "tree") {
      removeEC3NormalStatus(seriesOpt.leaves);
    }
  }
  function toArr(o2) {
    return isArray$1(o2) ? o2 : o2 ? [o2] : [];
  }
  function toObj(o2) {
    return (isArray$1(o2) ? o2[0] : o2) || {};
  }
  function globalCompatStyle(option, isTheme) {
    each$2(toArr(option.series), function(seriesOpt) {
      isObject$2(seriesOpt) && processSeries(seriesOpt);
    });
    var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
    isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
    each$2(axes, function(axisName) {
      each$2(toArr(option[axisName]), function(axisOpt) {
        if (axisOpt) {
          compatTextStyle(axisOpt, "axisLabel");
          compatTextStyle(axisOpt.axisPointer, "label");
        }
      });
    });
    each$2(toArr(option.parallel), function(parallelOpt) {
      var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
      compatTextStyle(parallelAxisDefault, "axisLabel");
      compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
    });
    each$2(toArr(option.calendar), function(calendarOpt) {
      convertNormalEmphasis(calendarOpt, "itemStyle");
      compatTextStyle(calendarOpt, "dayLabel");
      compatTextStyle(calendarOpt, "monthLabel");
      compatTextStyle(calendarOpt, "yearLabel");
    });
    each$2(toArr(option.radar), function(radarOpt) {
      compatTextStyle(radarOpt, "name");
      if (radarOpt.name && radarOpt.axisName == null) {
        radarOpt.axisName = radarOpt.name;
        delete radarOpt.name;
      }
      if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
        radarOpt.axisNameGap = radarOpt.nameGap;
        delete radarOpt.nameGap;
      }
    });
    each$2(toArr(option.geo), function(geoOpt) {
      if (isObject$2(geoOpt)) {
        compatEC3CommonStyles(geoOpt);
        each$2(toArr(geoOpt.regions), function(regionObj) {
          compatEC3CommonStyles(regionObj);
        });
      }
    });
    each$2(toArr(option.timeline), function(timelineOpt) {
      compatEC3CommonStyles(timelineOpt);
      convertNormalEmphasis(timelineOpt, "label");
      convertNormalEmphasis(timelineOpt, "itemStyle");
      convertNormalEmphasis(timelineOpt, "controlStyle", true);
      var data = timelineOpt.data;
      isArray$1(data) && each$4(data, function(item) {
        if (isObject$3(item)) {
          convertNormalEmphasis(item, "label");
          convertNormalEmphasis(item, "itemStyle");
        }
      });
    });
    each$2(toArr(option.toolbox), function(toolboxOpt) {
      convertNormalEmphasis(toolboxOpt, "iconStyle");
      each$2(toolboxOpt.feature, function(featureOpt) {
        convertNormalEmphasis(featureOpt, "iconStyle");
      });
    });
    compatTextStyle(toObj(option.axisPointer), "label");
    compatTextStyle(toObj(option.tooltip).axisPointer, "label");
  }
  function get(opt, path) {
    var pathArr = path.split(",");
    var obj2 = opt;
    for (var i2 = 0; i2 < pathArr.length; i2++) {
      obj2 = obj2 && obj2[pathArr[i2]];
      if (obj2 == null) {
        break;
      }
    }
    return obj2;
  }
  function set(opt, path, val, overwrite) {
    var pathArr = path.split(",");
    var obj2 = opt;
    var key2;
    var i2 = 0;
    for (; i2 < pathArr.length - 1; i2++) {
      key2 = pathArr[i2];
      if (obj2[key2] == null) {
        obj2[key2] = {};
      }
      obj2 = obj2[key2];
    }
    if (obj2[pathArr[i2]] == null) {
      obj2[pathArr[i2]] = val;
    }
  }
  function compatLayoutProperties(option) {
    option && each$4(LAYOUT_PROPERTIES, function(prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]];
      }
    });
  }
  var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
  var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
  var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
  function compatBarItemStyle(option) {
    var itemStyle = option && option.itemStyle;
    if (itemStyle) {
      for (var i2 = 0; i2 < BAR_ITEM_STYLE_MAP.length; i2++) {
        var oldName = BAR_ITEM_STYLE_MAP[i2][1];
        var newName = BAR_ITEM_STYLE_MAP[i2][0];
        if (itemStyle[oldName] != null) {
          itemStyle[newName] = itemStyle[oldName];
        }
      }
    }
  }
  function compatPieLabel(option) {
    if (!option) {
      return;
    }
    if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
      option.edgeDistance = option.margin;
    }
  }
  function compatSunburstState(option) {
    if (!option) {
      return;
    }
    if (option.downplay && !option.blur) {
      option.blur = option.downplay;
    }
  }
  function compatGraphFocus(option) {
    if (!option) {
      return;
    }
    if (option.focusNodeAdjacency != null) {
      option.emphasis = option.emphasis || {};
      if (option.emphasis.focus == null) {
        option.emphasis.focus = "adjacency";
      }
    }
  }
  function traverseTree(data, cb) {
    if (data) {
      for (var i2 = 0; i2 < data.length; i2++) {
        cb(data[i2]);
        data[i2] && traverseTree(data[i2].children, cb);
      }
    }
  }
  function globalBackwardCompat(option, isTheme) {
    globalCompatStyle(option, isTheme);
    option.series = normalizeToArray(option.series);
    each$4(option.series, function(seriesOpt) {
      if (!isObject$3(seriesOpt)) {
        return;
      }
      var seriesType2 = seriesOpt.type;
      if (seriesType2 === "line") {
        if (seriesOpt.clipOverflow != null) {
          seriesOpt.clip = seriesOpt.clipOverflow;
        }
      } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise;
        }
        compatPieLabel(seriesOpt.label);
        var data = seriesOpt.data;
        if (data && !isTypedArray$1(data)) {
          for (var i2 = 0; i2 < data.length; i2++) {
            compatPieLabel(data[i2]);
          }
        }
        if (seriesOpt.hoverOffset != null) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (seriesOpt.emphasis.scaleSize = null) {
            seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
          }
        }
      } else if (seriesType2 === "gauge") {
        var pointerColor = get(seriesOpt, "pointer.color");
        pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
      } else if (seriesType2 === "bar") {
        compatBarItemStyle(seriesOpt);
        compatBarItemStyle(seriesOpt.backgroundStyle);
        compatBarItemStyle(seriesOpt.emphasis);
        var data = seriesOpt.data;
        if (data && !isTypedArray$1(data)) {
          for (var i2 = 0; i2 < data.length; i2++) {
            if (typeof data[i2] === "object") {
              compatBarItemStyle(data[i2]);
              compatBarItemStyle(data[i2] && data[i2].emphasis);
            }
          }
        }
      } else if (seriesType2 === "sunburst") {
        var highlightPolicy = seriesOpt.highlightPolicy;
        if (highlightPolicy) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (!seriesOpt.emphasis.focus) {
            seriesOpt.emphasis.focus = highlightPolicy;
          }
        }
        compatSunburstState(seriesOpt);
        traverseTree(seriesOpt.data, compatSunburstState);
      } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
        compatGraphFocus(seriesOpt);
      } else if (seriesType2 === "map") {
        if (seriesOpt.mapType && !seriesOpt.map) {
          seriesOpt.map = seriesOpt.mapType;
        }
        if (seriesOpt.mapLocation) {
          defaults$1(seriesOpt, seriesOpt.mapLocation);
        }
      }
      if (seriesOpt.hoverAnimation != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
          seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
        }
      }
      compatLayoutProperties(seriesOpt);
    });
    if (option.dataRange) {
      option.visualMap = option.dataRange;
    }
    each$4(COMPATITABLE_COMPONENTS, function(componentName) {
      var options2 = option[componentName];
      if (options2) {
        if (!isArray$1(options2)) {
          options2 = [options2];
        }
        each$4(options2, function(option2) {
          compatLayoutProperties(option2);
        });
      }
    });
  }
  function dataStack$1(ecModel) {
    var stackInfoMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var stack2 = seriesModel.get("stack");
      if (stack2) {
        var stackInfoList = stackInfoMap.get(stack2) || stackInfoMap.set(stack2, []);
        var data = seriesModel.getData();
        var stackInfo = {
          // Used for calculate axis extent automatically.
          // TODO: Type getCalculationInfo return more specific type?
          stackResultDimension: data.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
          stackedDimension: data.getCalculationInfo("stackedDimension"),
          stackedByDimension: data.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
          data,
          seriesModel
        };
        if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
          return;
        }
        stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
        stackInfoList.push(stackInfo);
      }
    });
    stackInfoMap.each(calculateStack);
  }
  function calculateStack(stackInfoList) {
    each$4(stackInfoList, function(targetStackInfo, idxInStack) {
      var resultVal = [];
      var resultNaN = [NaN, NaN];
      var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
      var targetData = targetStackInfo.data;
      var isStackedByIndex = targetStackInfo.isStackedByIndex;
      var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
      targetData.modify(dims, function(v0, v1, dataIndex) {
        var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
        if (isNaN(sum)) {
          return resultNaN;
        }
        var byValue;
        var stackedDataRawIndex;
        if (isStackedByIndex) {
          stackedDataRawIndex = targetData.getRawIndex(dataIndex);
        } else {
          byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
        }
        var stackedOver = NaN;
        for (var j2 = idxInStack - 1; j2 >= 0; j2--) {
          var stackInfo = stackInfoList[j2];
          if (!isStackedByIndex) {
            stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
          }
          if (stackedDataRawIndex >= 0) {
            var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
            if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum >= 0 && val > 0 || stackStrategy === "samesign" && sum <= 0 && val < 0) {
              sum = addSafe(sum, val);
              stackedOver = val;
              break;
            }
          }
        }
        resultVal[0] = sum;
        resultVal[1] = stackedOver;
        return resultVal;
      });
    });
  }
  var SourceImpl = (
    /** @class */
    /* @__PURE__ */ function() {
      function SourceImpl2(fields) {
        this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
        this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
        this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
        this.startIndex = fields.startIndex || 0;
        this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
        this.metaRawOption = fields.metaRawOption;
        var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
        if (dimensionsDefine) {
          for (var i2 = 0; i2 < dimensionsDefine.length; i2++) {
            var dim = dimensionsDefine[i2];
            if (dim.type == null) {
              if (guessOrdinal(this, i2) === BE_ORDINAL.Must) {
                dim.type = "ordinal";
              }
            }
          }
        }
      }
      return SourceImpl2;
    }()
  );
  function isSourceInstance(val) {
    return val instanceof SourceImpl;
  }
  function createSource(sourceData, thisMetaRawOption, sourceFormat) {
    sourceFormat = sourceFormat || detectSourceFormat(sourceData);
    var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
    var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
    var source = new SourceImpl({
      data: sourceData,
      sourceFormat,
      seriesLayoutBy,
      dimensionsDefine: determined.dimensionsDefine,
      startIndex: determined.startIndex,
      dimensionsDetectedCount: determined.dimensionsDetectedCount,
      metaRawOption: clone$4(thisMetaRawOption)
    });
    return source;
  }
  function createSourceFromSeriesDataOption(data) {
    return new SourceImpl({
      data,
      sourceFormat: isTypedArray$1(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
    });
  }
  function cloneSourceShallow(source) {
    return new SourceImpl({
      data: source.data,
      sourceFormat: source.sourceFormat,
      seriesLayoutBy: source.seriesLayoutBy,
      dimensionsDefine: clone$4(source.dimensionsDefine),
      startIndex: source.startIndex,
      dimensionsDetectedCount: source.dimensionsDetectedCount
    });
  }
  function detectSourceFormat(data) {
    var sourceFormat = SOURCE_FORMAT_UNKNOWN;
    if (isTypedArray$1(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
    } else if (isArray$1(data)) {
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
      }
      for (var i2 = 0, len2 = data.length; i2 < len2; i2++) {
        var item = data[i2];
        if (item == null) {
          continue;
        } else if (isArray$1(item) || isTypedArray$1(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
          break;
        } else if (isObject$3(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
          break;
        }
      }
    } else if (isObject$3(data)) {
      for (var key2 in data) {
        if (hasOwn(data, key2) && isArrayLike(data[key2])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
          break;
        }
      }
    }
    return sourceFormat;
  }
  function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
    var dimensionsDetectedCount;
    var startIndex;
    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
        startIndex,
        dimensionsDetectedCount
      };
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (sourceHeader === "auto" || sourceHeader == null) {
        arrayRowsTravelFirst(function(val) {
          if (val != null && val !== "-") {
            if (isString$1(val)) {
              startIndex == null && (startIndex = 1);
            } else {
              startIndex = 0;
            }
          }
        }, seriesLayoutBy, dataArrayRows, 10);
      } else {
        startIndex = isNumber$1(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
      }
      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = [];
        arrayRowsTravelFirst(function(val, index2) {
          dimensionsDefine[index2] = val != null ? val + "" : "";
        }, seriesLayoutBy, dataArrayRows, Infinity);
      }
      dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data);
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimensionsDefine) {
        dimensionsDefine = [];
        each$4(data, function(colArr, key2) {
          dimensionsDefine.push(key2);
        });
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var value0 = getDataItemValue(data[0]);
      dimensionsDetectedCount = isArray$1(value0) && value0.length || 1;
    } else ;
    return {
      startIndex,
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      dimensionsDetectedCount
    };
  }
  function objectRowsCollectDimensions(data) {
    var firstIndex = 0;
    var obj2;
    while (firstIndex < data.length && !(obj2 = data[firstIndex++])) {
    }
    if (obj2) {
      return keys(obj2);
    }
  }
  function normalizeDimensionsOption(dimensionsDefine) {
    if (!dimensionsDefine) {
      return;
    }
    var nameMap = createHashMap();
    return map$1(dimensionsDefine, function(rawItem, index2) {
      rawItem = isObject$3(rawItem) ? rawItem : {
        name: rawItem
      };
      var item = {
        name: rawItem.name,
        displayName: rawItem.displayName,
        type: rawItem.type
      };
      if (item.name == null) {
        return item;
      }
      item.name += "";
      if (item.displayName == null) {
        item.displayName = item.name;
      }
      var exist = nameMap.get(item.name);
      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        });
      } else {
        item.name += "-" + exist.count++;
      }
      return item;
    });
  }
  function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      for (var i2 = 0; i2 < data.length && i2 < maxLoop; i2++) {
        cb(data[i2] ? data[i2][0] : null, i2);
      }
    } else {
      var value0 = data[0] || [];
      for (var i2 = 0; i2 < value0.length && i2 < maxLoop; i2++) {
        cb(value0[i2], i2);
      }
    }
  }
  function shouldRetrieveDataByName(source) {
    var sourceFormat = source.sourceFormat;
    return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
  }
  var _a, _b, _c;
  var providerMethods;
  var mountMethods;
  var DefaultDataProvider = (
    /** @class */
    function() {
      function DefaultDataProvider2(sourceParam, dimSize) {
        var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
        this._source = source;
        var data = this._data = source.data;
        if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
          this._offset = 0;
          this._dimSize = dimSize;
          this._data = data;
        }
        mountMethods(this, data, source);
      }
      DefaultDataProvider2.prototype.getSource = function() {
        return this._source;
      };
      DefaultDataProvider2.prototype.count = function() {
        return 0;
      };
      DefaultDataProvider2.prototype.getItem = function(idx, out2) {
        return;
      };
      DefaultDataProvider2.prototype.appendData = function(newData) {
      };
      DefaultDataProvider2.prototype.clean = function() {
      };
      DefaultDataProvider2.protoInitialize = function() {
        var proto2 = DefaultDataProvider2.prototype;
        proto2.pure = false;
        proto2.persistent = true;
      }();
      DefaultDataProvider2.internalField = function() {
        var _a2;
        mountMethods = function(provider, data, source) {
          var sourceFormat = source.sourceFormat;
          var seriesLayoutBy = source.seriesLayoutBy;
          var startIndex = source.startIndex;
          var dimsDef = source.dimensionsDefine;
          var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
          extend$1(provider, methods);
          if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
            provider.getItem = getItemForTypedArray;
            provider.count = countForTypedArray;
            provider.fillStorage = fillStorageForTypedArray;
          } else {
            var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
            provider.getItem = bind$2(rawItemGetter, null, data, startIndex, dimsDef);
            var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
            provider.count = bind$2(rawCounter, null, data, startIndex, dimsDef);
          }
        };
        var getItemForTypedArray = function(idx, out2) {
          idx = idx - this._offset;
          out2 = out2 || [];
          var data = this._data;
          var dimSize = this._dimSize;
          var offset2 = dimSize * idx;
          for (var i2 = 0; i2 < dimSize; i2++) {
            out2[i2] = data[offset2 + i2];
          }
          return out2;
        };
        var fillStorageForTypedArray = function(start2, end2, storage, extent3) {
          var data = this._data;
          var dimSize = this._dimSize;
          for (var dim = 0; dim < dimSize; dim++) {
            var dimExtent = extent3[dim];
            var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
            var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
            var count = end2 - start2;
            var arr = storage[dim];
            for (var i2 = 0; i2 < count; i2++) {
              var val = data[i2 * dimSize + dim];
              arr[start2 + i2] = val;
              val < min3 && (min3 = val);
              val > max3 && (max3 = val);
            }
            dimExtent[0] = min3;
            dimExtent[1] = max3;
          }
        };
        var countForTypedArray = function() {
          return this._data ? this._data.length / this._dimSize : 0;
        };
        providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
          pure: true,
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
          pure: true,
          appendData: function() {
            throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
          }
        }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
          pure: true,
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
          pure: true,
          appendData: function(newData) {
            var data = this._data;
            each$4(newData, function(newCol, key2) {
              var oldCol = data[key2] || (data[key2] = []);
              for (var i2 = 0; i2 < (newCol || []).length; i2++) {
                oldCol.push(newCol[i2]);
              }
            });
          }
        }, _a2[SOURCE_FORMAT_ORIGINAL] = {
          appendData: appendDataSimply
        }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
          persistent: false,
          pure: true,
          appendData: function(newData) {
            this._data = newData;
          },
          // Clean self if data is already used.
          clean: function() {
            this._offset += this.count();
            this._data = null;
          }
        }, _a2);
        function appendDataSimply(newData) {
          for (var i2 = 0; i2 < newData.length; i2++) {
            this._data.push(newData[i2]);
          }
        }
      }();
      return DefaultDataProvider2;
    }()
  );
  var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx];
  };
  var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex];
  }, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
    idx += startIndex;
    var item = out2 || [];
    var data = rawData;
    for (var i2 = 0; i2 < data.length; i2++) {
      var row = data[i2];
      item[i2] = row ? row[idx] : null;
    }
    return item;
  }, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
    var item = out2 || [];
    for (var i2 = 0; i2 < dimsDef.length; i2++) {
      var dimName = dimsDef[i2].name;
      var col = rawData[dimName];
      item[i2] = col ? col[idx] : null;
    }
    return item;
  }, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
  function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    return method;
  }
  var countSimply = function(rawData, startIndex, dimsDef) {
    return rawData.length;
  };
  var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex);
  }, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
    var row = rawData[0];
    return row ? Math.max(0, row.length - startIndex) : 0;
  }, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
    var dimName = dimsDef[0].name;
    var col = rawData[dimName];
    return col ? col.length : 0;
  }, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
  function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    return method;
  }
  var getRawValueSimply = function(dataItem, dimIndex, property2) {
    return dataItem[dimIndex];
  };
  var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property2) {
    return dataItem[property2];
  }, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property2) {
    var value = getDataItemValue(dataItem);
    return !(value instanceof Array) ? value : value[dimIndex];
  }, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
  function getRawSourceValueGetter(sourceFormat) {
    var method = rawSourceValueGetterMap[sourceFormat];
    return method;
  }
  function getMethodMapKey(sourceFormat, seriesLayoutBy) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
  }
  function retrieveRawValue(data, dataIndex, dim) {
    if (!data) {
      return;
    }
    var dataItem = data.getRawDataItem(dataIndex);
    if (dataItem == null) {
      return;
    }
    var store = data.getStore();
    var sourceFormat = store.getSource().sourceFormat;
    if (dim != null) {
      var dimIndex = data.getDimensionIndex(dim);
      var property2 = store.getDimensionProperty(dimIndex);
      return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property2);
    } else {
      var result = dataItem;
      if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        result = getDataItemValue(dataItem);
      }
      return result;
    }
  }
  var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
  var DataFormatMixin = (
    /** @class */
    function() {
      function DataFormatMixin2() {
      }
      DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name = data.getName(dataIndex);
        var itemOpt = data.getRawDataItem(dataIndex);
        var style = data.getItemVisual(dataIndex, "style");
        var color2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
        var borderColor = style && style.stroke;
        var mainType = this.mainType;
        var isSeries2 = mainType === "series";
        var userOutput = data.userOutput && data.userOutput.get();
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries2 ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries2 ? this.id : null,
          seriesName: isSeries2 ? this.name : null,
          name,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType,
          value: rawValue,
          color: color2,
          borderColor,
          dimensionNames: userOutput ? userOutput.fullDimensions : null,
          encode: userOutput ? userOutput.encode : null,
          // Param name list for mapping `a`, `b`, `c`, `d`, `e`
          $vars: ["seriesName", "name", "value"]
        };
      };
      DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
        status = status || "normal";
        var data = this.getData(dataType);
        var params2 = this.getDataParams(dataIndex, dataType);
        if (extendParams) {
          params2.value = extendParams.interpolatedValue;
        }
        if (labelDimIndex != null && isArray$1(params2.value)) {
          params2.value = params2.value[labelDimIndex];
        }
        if (!formatter) {
          var itemModel = data.getItemModel(dataIndex);
          formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
        }
        if (isFunction$1(formatter)) {
          params2.status = status;
          params2.dimensionIndex = labelDimIndex;
          return formatter(params2);
        } else if (isString$1(formatter)) {
          var str = formatTpl(formatter, params2);
          return str.replace(DIMENSION_LABEL_REG, function(origin2, dimStr) {
            var len2 = dimStr.length;
            var dimLoose = dimStr;
            if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
              dimLoose = +dimLoose.slice(1, len2 - 1);
            }
            var val = retrieveRawValue(data, dataIndex, dimLoose);
            if (extendParams && isArray$1(extendParams.interpolatedValue)) {
              var dimIndex = data.getDimensionIndex(dimLoose);
              if (dimIndex >= 0) {
                val = extendParams.interpolatedValue[dimIndex];
              }
            }
            return val != null ? val + "" : "";
          });
        }
      };
      DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
        return retrieveRawValue(this.getData(dataType), idx);
      };
      DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
        return;
      };
      return DataFormatMixin2;
    }()
  );
  function normalizeTooltipFormatResult(result) {
    var markupText;
    var markupFragment;
    if (isObject$3(result)) {
      if (result.type) {
        markupFragment = result;
      }
    } else {
      markupText = result;
    }
    return {
      text: markupText,
      // markers: markers || markersExisting,
      frag: markupFragment
    };
  }
  function createTask(define2) {
    return new Task(define2);
  }
  var Task = (
    /** @class */
    function() {
      function Task2(define2) {
        define2 = define2 || {};
        this._reset = define2.reset;
        this._plan = define2.plan;
        this._count = define2.count;
        this._onDirty = define2.onDirty;
        this._dirty = true;
      }
      Task2.prototype.perform = function(performArgs) {
        var upTask = this._upstream;
        var skip = performArgs && performArgs.skip;
        if (this._dirty && upTask) {
          var context = this.context;
          context.data = context.outputData = upTask.context.outputData;
        }
        if (this.__pipeline) {
          this.__pipeline.currentTask = this;
        }
        var planResult;
        if (this._plan && !skip) {
          planResult = this._plan(this.context);
        }
        var lastModBy = normalizeModBy(this._modBy);
        var lastModDataCount = this._modDataCount || 0;
        var modBy = normalizeModBy(performArgs && performArgs.modBy);
        var modDataCount = performArgs && performArgs.modDataCount || 0;
        if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
          planResult = "reset";
        }
        function normalizeModBy(val) {
          !(val >= 1) && (val = 1);
          return val;
        }
        var forceFirstProgress;
        if (this._dirty || planResult === "reset") {
          this._dirty = false;
          forceFirstProgress = this._doReset(skip);
        }
        this._modBy = modBy;
        this._modDataCount = modDataCount;
        var step = performArgs && performArgs.step;
        if (upTask) {
          this._dueEnd = upTask._outputDueEnd;
        } else {
          this._dueEnd = this._count ? this._count(this.context) : Infinity;
        }
        if (this._progress) {
          var start2 = this._dueIndex;
          var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
          if (!skip && (forceFirstProgress || start2 < end2)) {
            var progress = this._progress;
            if (isArray$1(progress)) {
              for (var i2 = 0; i2 < progress.length; i2++) {
                this._doProgress(progress[i2], start2, end2, modBy, modDataCount);
              }
            } else {
              this._doProgress(progress, start2, end2, modBy, modDataCount);
            }
          }
          this._dueIndex = end2;
          var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
          this._outputDueEnd = outputDueEnd;
        } else {
          this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
        }
        return this.unfinished();
      };
      Task2.prototype.dirty = function() {
        this._dirty = true;
        this._onDirty && this._onDirty(this.context);
      };
      Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
        iterator.reset(start2, end2, modBy, modDataCount);
        this._callingProgress = progress;
        this._callingProgress({
          start: start2,
          end: end2,
          count: end2 - start2,
          next: iterator.next
        }, this.context);
      };
      Task2.prototype._doReset = function(skip) {
        this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
        this._settedOutputEnd = null;
        var progress;
        var forceFirstProgress;
        if (!skip && this._reset) {
          progress = this._reset(this.context);
          if (progress && progress.progress) {
            forceFirstProgress = progress.forceFirstProgress;
            progress = progress.progress;
          }
          if (isArray$1(progress) && !progress.length) {
            progress = null;
          }
        }
        this._progress = progress;
        this._modBy = this._modDataCount = null;
        var downstream = this._downstream;
        downstream && downstream.dirty();
        return forceFirstProgress;
      };
      Task2.prototype.unfinished = function() {
        return this._progress && this._dueIndex < this._dueEnd;
      };
      Task2.prototype.pipe = function(downTask) {
        if (this._downstream !== downTask || this._dirty) {
          this._downstream = downTask;
          downTask._upstream = this;
          downTask.dirty();
        }
      };
      Task2.prototype.dispose = function() {
        if (this._disposed) {
          return;
        }
        this._upstream && (this._upstream._downstream = null);
        this._downstream && (this._downstream._upstream = null);
        this._dirty = false;
        this._disposed = true;
      };
      Task2.prototype.getUpstream = function() {
        return this._upstream;
      };
      Task2.prototype.getDownstream = function() {
        return this._downstream;
      };
      Task2.prototype.setOutputEnd = function(end2) {
        this._outputDueEnd = this._settedOutputEnd = end2;
      };
      return Task2;
    }()
  );
  var iterator = /* @__PURE__ */ function() {
    var end2;
    var current;
    var modBy;
    var modDataCount;
    var winCount;
    var it = {
      reset: function(s2, e2, sStep, sCount) {
        current = s2;
        end2 = e2;
        modBy = sStep;
        modDataCount = sCount;
        winCount = Math.ceil(modDataCount / modBy);
        it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
      }
    };
    return it;
    function sequentialNext() {
      return current < end2 ? current++ : null;
    }
    function modNext() {
      var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
      var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
      current++;
      return result;
    }
  }();
  function parseDataValue(value, opt) {
    var dimType = opt && opt.type;
    if (dimType === "ordinal") {
      return value;
    }
    if (dimType === "time" && !isNumber$1(value) && value != null && value !== "-") {
      value = +parseDate(value);
    }
    return value == null || value === "" ? NaN : Number(value);
  }
  var valueParserMap = createHashMap({
    "number": function(val) {
      return parseFloat(val);
    },
    "time": function(val) {
      return +parseDate(val);
    },
    "trim": function(val) {
      return isString$1(val) ? trim$1(val) : val;
    }
  });
  function getRawValueParser(type) {
    return valueParserMap.get(type);
  }
  var ORDER_COMPARISON_OP_MAP = {
    lt: function(lval, rval) {
      return lval < rval;
    },
    lte: function(lval, rval) {
      return lval <= rval;
    },
    gt: function(lval, rval) {
      return lval > rval;
    },
    gte: function(lval, rval) {
      return lval >= rval;
    }
  };
  var FilterOrderComparator = (
    /** @class */
    function() {
      function FilterOrderComparator2(op, rval) {
        if (!isNumber$1(rval)) {
          var errMsg = "";
          throwError(errMsg);
        }
        this._opFn = ORDER_COMPARISON_OP_MAP[op];
        this._rvalFloat = numericToNumber(rval);
      }
      FilterOrderComparator2.prototype.evaluate = function(lval) {
        return isNumber$1(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
      };
      return FilterOrderComparator2;
    }()
  );
  var SortOrderComparator = (
    /** @class */
    function() {
      function SortOrderComparator2(order, incomparable) {
        var isDesc = order === "desc";
        this._resultLT = isDesc ? 1 : -1;
        if (incomparable == null) {
          incomparable = isDesc ? "min" : "max";
        }
        this._incomparable = incomparable === "min" ? -Infinity : Infinity;
      }
      SortOrderComparator2.prototype.evaluate = function(lval, rval) {
        var lvalFloat = isNumber$1(lval) ? lval : numericToNumber(lval);
        var rvalFloat = isNumber$1(rval) ? rval : numericToNumber(rval);
        var lvalNotNumeric = isNaN(lvalFloat);
        var rvalNotNumeric = isNaN(rvalFloat);
        if (lvalNotNumeric) {
          lvalFloat = this._incomparable;
        }
        if (rvalNotNumeric) {
          rvalFloat = this._incomparable;
        }
        if (lvalNotNumeric && rvalNotNumeric) {
          var lvalIsStr = isString$1(lval);
          var rvalIsStr = isString$1(rval);
          if (lvalIsStr) {
            lvalFloat = rvalIsStr ? lval : 0;
          }
          if (rvalIsStr) {
            rvalFloat = lvalIsStr ? rval : 0;
          }
        }
        return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
      };
      return SortOrderComparator2;
    }()
  );
  var FilterEqualityComparator = (
    /** @class */
    function() {
      function FilterEqualityComparator2(isEq, rval) {
        this._rval = rval;
        this._isEQ = isEq;
        this._rvalTypeof = typeof rval;
        this._rvalFloat = numericToNumber(rval);
      }
      FilterEqualityComparator2.prototype.evaluate = function(lval) {
        var eqResult = lval === this._rval;
        if (!eqResult) {
          var lvalTypeof = typeof lval;
          if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
            eqResult = numericToNumber(lval) === this._rvalFloat;
          }
        }
        return this._isEQ ? eqResult : !eqResult;
      };
      return FilterEqualityComparator2;
    }()
  );
  function createFilterComparator(op, rval) {
    return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
  }
  var ExternalSource = (
    /** @class */
    function() {
      function ExternalSource2() {
      }
      ExternalSource2.prototype.getRawData = function() {
        throw new Error("not supported");
      };
      ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
        throw new Error("not supported");
      };
      ExternalSource2.prototype.cloneRawData = function() {
        return;
      };
      ExternalSource2.prototype.getDimensionInfo = function(dim) {
        return;
      };
      ExternalSource2.prototype.cloneAllDimensionInfo = function() {
        return;
      };
      ExternalSource2.prototype.count = function() {
        return;
      };
      ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
        return;
      };
      ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
        return;
      };
      ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
        return parseDataValue(rawVal, dimInfo);
      };
      return ExternalSource2;
    }()
  );
  function createExternalSource(internalSource, externalTransform) {
    var extSource = new ExternalSource();
    var data = internalSource.data;
    var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
    var sourceHeaderCount = internalSource.startIndex;
    var errMsg = "";
    if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
      throwError(errMsg);
    }
    var dimensions = [];
    var dimsByName = {};
    var dimsDef = internalSource.dimensionsDefine;
    if (dimsDef) {
      each$4(dimsDef, function(dimDef, idx) {
        var name = dimDef.name;
        var dimDefExt = {
          index: idx,
          name,
          displayName: dimDef.displayName
        };
        dimensions.push(dimDefExt);
        if (name != null) {
          var errMsg_1 = "";
          if (hasOwn(dimsByName, name)) {
            throwError(errMsg_1);
          }
          dimsByName[name] = dimDefExt;
        }
      });
    } else {
      for (var i2 = 0; i2 < internalSource.dimensionsDetectedCount || 0; i2++) {
        dimensions.push({
          index: i2
        });
      }
    }
    var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    if (externalTransform.__isBuiltIn) {
      extSource.getRawDataItem = function(dataIndex) {
        return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      };
      extSource.getRawData = bind$2(getRawData, null, internalSource);
    }
    extSource.cloneRawData = bind$2(cloneRawData, null, internalSource);
    var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    extSource.count = bind$2(rawCounter, null, data, sourceHeaderCount, dimensions);
    var rawValueGetter = getRawSourceValueGetter(sourceFormat);
    extSource.retrieveValue = function(dataIndex, dimIndex) {
      var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      return retrieveValueFromItem(rawItem, dimIndex);
    };
    var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
      if (dataItem == null) {
        return;
      }
      var dimDef = dimensions[dimIndex];
      if (dimDef) {
        return rawValueGetter(dataItem, dimIndex, dimDef.name);
      }
    };
    extSource.getDimensionInfo = bind$2(getDimensionInfo, null, dimensions, dimsByName);
    extSource.cloneAllDimensionInfo = bind$2(cloneAllDimensionInfo, null, dimensions);
    return extSource;
  }
  function getRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      throwError(errMsg);
    }
    return upstream.data;
  }
  function cloneRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    var data = upstream.data;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      throwError(errMsg);
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var result = [];
      for (var i2 = 0, len2 = data.length; i2 < len2; i2++) {
        result.push(data[i2].slice());
      }
      return result;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var result = [];
      for (var i2 = 0, len2 = data.length; i2 < len2; i2++) {
        result.push(extend$1({}, data[i2]));
      }
      return result;
    }
  }
  function getDimensionInfo(dimensions, dimsByName, dim) {
    if (dim == null) {
      return;
    }
    if (isNumber$1(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
      return dimensions[dim];
    } else if (hasOwn(dimsByName, dim)) {
      return dimsByName[dim];
    }
  }
  function cloneAllDimensionInfo(dimensions) {
    return clone$4(dimensions);
  }
  var externalTransformMap = createHashMap();
  function registerExternalTransform(externalTransform) {
    externalTransform = clone$4(externalTransform);
    var type = externalTransform.type;
    var errMsg = "";
    if (!type) {
      throwError(errMsg);
    }
    var typeParsed = type.split(":");
    if (typeParsed.length !== 2) {
      throwError(errMsg);
    }
    var isBuiltIn = false;
    if (typeParsed[0] === "echarts") {
      type = typeParsed[1];
      isBuiltIn = true;
    }
    externalTransform.__isBuiltIn = isBuiltIn;
    externalTransformMap.set(type, externalTransform);
  }
  function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
    var pipedTransOption = normalizeToArray(rawTransOption);
    var pipeLen = pipedTransOption.length;
    var errMsg = "";
    if (!pipeLen) {
      throwError(errMsg);
    }
    for (var i2 = 0, len2 = pipeLen; i2 < len2; i2++) {
      var transOption = pipedTransOption[i2];
      sourceList = applySingleDataTransform(transOption, sourceList);
      if (i2 !== len2 - 1) {
        sourceList.length = Math.max(sourceList.length, 1);
      }
    }
    return sourceList;
  }
  function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
    var errMsg = "";
    if (!upSourceList.length) {
      throwError(errMsg);
    }
    if (!isObject$3(transOption)) {
      throwError(errMsg);
    }
    var transType = transOption.type;
    var externalTransform = externalTransformMap.get(transType);
    if (!externalTransform) {
      throwError(errMsg);
    }
    var extUpSourceList = map$1(upSourceList, function(upSource) {
      return createExternalSource(upSource, externalTransform);
    });
    var resultList = normalizeToArray(externalTransform.transform({
      upstream: extUpSourceList[0],
      upstreamList: extUpSourceList,
      config: clone$4(transOption.config)
    }));
    return map$1(resultList, function(result, resultIndex) {
      var errMsg2 = "";
      if (!isObject$3(result)) {
        throwError(errMsg2);
      }
      if (!result.data) {
        throwError(errMsg2);
      }
      var sourceFormat = detectSourceFormat(result.data);
      if (!isSupportedSourceFormat(sourceFormat)) {
        throwError(errMsg2);
      }
      var resultMetaRawOption;
      var firstUpSource = upSourceList[0];
      if (firstUpSource && resultIndex === 0 && !result.dimensions) {
        var startIndex = firstUpSource.startIndex;
        if (startIndex) {
          result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
        }
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: startIndex,
          dimensions: firstUpSource.metaRawOption.dimensions
        };
      } else {
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: 0,
          dimensions: result.dimensions
        };
      }
      return createSource(result.data, resultMetaRawOption, null);
    });
  }
  function isSupportedSourceFormat(sourceFormat) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
  }
  var UNDEFINED = "undefined";
  var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
  var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
  var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
  var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
  var dataCtors = {
    "float": CtorFloat64Array,
    "int": CtorInt32Array$1,
    // Ordinal data type can be string or int
    "ordinal": Array,
    "number": Array,
    "time": CtorFloat64Array
  };
  var defaultDimValueGetters;
  function getIndicesCtor(rawCount) {
    return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
  }
  function getInitialExtent() {
    return [Infinity, -Infinity];
  }
  function cloneChunk(originalChunk) {
    var Ctor = originalChunk.constructor;
    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
  }
  function prepareStore(store, dimIdx, dimType, end2, append2) {
    var DataCtor = dataCtors[dimType || "float"];
    if (append2) {
      var oldStore = store[dimIdx];
      var oldLen = oldStore && oldStore.length;
      if (!(oldLen === end2)) {
        var newStore = new DataCtor(end2);
        for (var j2 = 0; j2 < oldLen; j2++) {
          newStore[j2] = oldStore[j2];
        }
        store[dimIdx] = newStore;
      }
    } else {
      store[dimIdx] = new DataCtor(end2);
    }
  }
  var DataStore = (
    /** @class */
    function() {
      function DataStore2() {
        this._chunks = [];
        this._rawExtent = [];
        this._extent = [];
        this._count = 0;
        this._rawCount = 0;
        this._calcDimNameToIdx = createHashMap();
      }
      DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
        this._provider = provider;
        this._chunks = [];
        this._indices = null;
        this.getRawIndex = this._getRawIdxIdentity;
        var source = provider.getSource();
        var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
        this._dimValueGetter = dimValueGetter || defaultGetter;
        this._rawExtent = [];
        shouldRetrieveDataByName(source);
        this._dimensions = map$1(inputDimensions, function(dim) {
          return {
            // Only pick these two props. Not leak other properties like orderMeta.
            type: dim.type,
            property: dim.property
          };
        });
        this._initDataFromProvider(0, provider.count());
      };
      DataStore2.prototype.getProvider = function() {
        return this._provider;
      };
      DataStore2.prototype.getSource = function() {
        return this._provider.getSource();
      };
      DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
        var calcDimNameToIdx = this._calcDimNameToIdx;
        var dimensions = this._dimensions;
        var calcDimIdx = calcDimNameToIdx.get(dimName);
        if (calcDimIdx != null) {
          if (dimensions[calcDimIdx].type === type) {
            return calcDimIdx;
          }
        } else {
          calcDimIdx = dimensions.length;
        }
        dimensions[calcDimIdx] = {
          type
        };
        calcDimNameToIdx.set(dimName, calcDimIdx);
        this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
        this._rawExtent[calcDimIdx] = getInitialExtent();
        return calcDimIdx;
      };
      DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
        var chunk = this._chunks[dimIdx];
        var dim = this._dimensions[dimIdx];
        var rawExtents = this._rawExtent;
        var offset2 = dim.ordinalOffset || 0;
        var len2 = chunk.length;
        if (offset2 === 0) {
          rawExtents[dimIdx] = getInitialExtent();
        }
        var dimRawExtent = rawExtents[dimIdx];
        for (var i2 = offset2; i2 < len2; i2++) {
          var val = chunk[i2] = ordinalMeta.parseAndCollect(chunk[i2]);
          if (!isNaN(val)) {
            dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
            dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
          }
        }
        dim.ordinalMeta = ordinalMeta;
        dim.ordinalOffset = len2;
        dim.type = "ordinal";
      };
      DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
        var dimInfo = this._dimensions[dimIdx];
        var ordinalMeta = dimInfo.ordinalMeta;
        return ordinalMeta;
      };
      DataStore2.prototype.getDimensionProperty = function(dimIndex) {
        var item = this._dimensions[dimIndex];
        return item && item.property;
      };
      DataStore2.prototype.appendData = function(data) {
        var provider = this._provider;
        var start2 = this.count();
        provider.appendData(data);
        var end2 = provider.count();
        if (!provider.persistent) {
          end2 += start2;
        }
        if (start2 < end2) {
          this._initDataFromProvider(start2, end2, true);
        }
        return [start2, end2];
      };
      DataStore2.prototype.appendValues = function(values, minFillLen) {
        var chunks = this._chunks;
        var dimensions = this._dimensions;
        var dimLen = dimensions.length;
        var rawExtent = this._rawExtent;
        var start2 = this.count();
        var end2 = start2 + Math.max(values.length, minFillLen || 0);
        for (var i2 = 0; i2 < dimLen; i2++) {
          var dim = dimensions[i2];
          prepareStore(chunks, i2, dim.type, end2, true);
        }
        var emptyDataItem = [];
        for (var idx = start2; idx < end2; idx++) {
          var sourceIdx = idx - start2;
          for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
            var dim = dimensions[dimIdx];
            var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
            chunks[dimIdx][idx] = val;
            var dimRawExtent = rawExtent[dimIdx];
            val < dimRawExtent[0] && (dimRawExtent[0] = val);
            val > dimRawExtent[1] && (dimRawExtent[1] = val);
          }
        }
        this._rawCount = this._count = end2;
        return {
          start: start2,
          end: end2
        };
      };
      DataStore2.prototype._initDataFromProvider = function(start2, end2, append2) {
        var provider = this._provider;
        var chunks = this._chunks;
        var dimensions = this._dimensions;
        var dimLen = dimensions.length;
        var rawExtent = this._rawExtent;
        var dimNames = map$1(dimensions, function(dim2) {
          return dim2.property;
        });
        for (var i2 = 0; i2 < dimLen; i2++) {
          var dim = dimensions[i2];
          if (!rawExtent[i2]) {
            rawExtent[i2] = getInitialExtent();
          }
          prepareStore(chunks, i2, dim.type, end2, append2);
        }
        if (provider.fillStorage) {
          provider.fillStorage(start2, end2, chunks, rawExtent);
        } else {
          var dataItem = [];
          for (var idx = start2; idx < end2; idx++) {
            dataItem = provider.getItem(idx, dataItem);
            for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
              var dimStorage = chunks[dimIdx];
              var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
              dimStorage[idx] = val;
              var dimRawExtent = rawExtent[dimIdx];
              val < dimRawExtent[0] && (dimRawExtent[0] = val);
              val > dimRawExtent[1] && (dimRawExtent[1] = val);
            }
          }
        }
        if (!provider.persistent && provider.clean) {
          provider.clean();
        }
        this._rawCount = this._count = end2;
        this._extent = [];
      };
      DataStore2.prototype.count = function() {
        return this._count;
      };
      DataStore2.prototype.get = function(dim, idx) {
        if (!(idx >= 0 && idx < this._count)) {
          return NaN;
        }
        var dimStore = this._chunks[dim];
        return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
      };
      DataStore2.prototype.getValues = function(dimensions, idx) {
        var values = [];
        var dimArr = [];
        if (idx == null) {
          idx = dimensions;
          dimensions = [];
          for (var i2 = 0; i2 < this._dimensions.length; i2++) {
            dimArr.push(i2);
          }
        } else {
          dimArr = dimensions;
        }
        for (var i2 = 0, len2 = dimArr.length; i2 < len2; i2++) {
          values.push(this.get(dimArr[i2], idx));
        }
        return values;
      };
      DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
        if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
          return NaN;
        }
        var dimStore = this._chunks[dim];
        return dimStore ? dimStore[rawIdx] : NaN;
      };
      DataStore2.prototype.getSum = function(dim) {
        var dimData = this._chunks[dim];
        var sum = 0;
        if (dimData) {
          for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
            var value = this.get(dim, i2);
            if (!isNaN(value)) {
              sum += value;
            }
          }
        }
        return sum;
      };
      DataStore2.prototype.getMedian = function(dim) {
        var dimDataArray = [];
        this.each([dim], function(val) {
          if (!isNaN(val)) {
            dimDataArray.push(val);
          }
        });
        var sortedDimDataArray = dimDataArray.sort(function(a2, b2) {
          return a2 - b2;
        });
        var len2 = this.count();
        return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
      };
      DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
        if (rawIndex >= this._rawCount || rawIndex < 0) {
          return -1;
        }
        if (!this._indices) {
          return rawIndex;
        }
        var indices = this._indices;
        var rawDataIndex = indices[rawIndex];
        if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
          return rawIndex;
        }
        var left = 0;
        var right = this._count - 1;
        while (left <= right) {
          var mid = (left + right) / 2 | 0;
          if (indices[mid] < rawIndex) {
            left = mid + 1;
          } else if (indices[mid] > rawIndex) {
            right = mid - 1;
          } else {
            return mid;
          }
        }
        return -1;
      };
      DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
        var chunks = this._chunks;
        var dimData = chunks[dim];
        var nearestIndices = [];
        if (!dimData) {
          return nearestIndices;
        }
        if (maxDistance == null) {
          maxDistance = Infinity;
        }
        var minDist = Infinity;
        var minDiff = -1;
        var nearestIndicesLen = 0;
        for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
          var dataIndex = this.getRawIndex(i2);
          var diff = value - dimData[dataIndex];
          var dist2 = Math.abs(diff);
          if (dist2 <= maxDistance) {
            if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
              minDist = dist2;
              minDiff = diff;
              nearestIndicesLen = 0;
            }
            if (diff === minDiff) {
              nearestIndices[nearestIndicesLen++] = i2;
            }
          }
        }
        nearestIndices.length = nearestIndicesLen;
        return nearestIndices;
      };
      DataStore2.prototype.getIndices = function() {
        var newIndices;
        var indices = this._indices;
        if (indices) {
          var Ctor = indices.constructor;
          var thisCount = this._count;
          if (Ctor === Array) {
            newIndices = new Ctor(thisCount);
            for (var i2 = 0; i2 < thisCount; i2++) {
              newIndices[i2] = indices[i2];
            }
          } else {
            newIndices = new Ctor(indices.buffer, 0, thisCount);
          }
        } else {
          var Ctor = getIndicesCtor(this._rawCount);
          newIndices = new Ctor(this.count());
          for (var i2 = 0; i2 < newIndices.length; i2++) {
            newIndices[i2] = i2;
          }
        }
        return newIndices;
      };
      DataStore2.prototype.filter = function(dims, cb) {
        if (!this._count) {
          return this;
        }
        var newStore = this.clone();
        var count = newStore.count();
        var Ctor = getIndicesCtor(newStore._rawCount);
        var newIndices = new Ctor(count);
        var value = [];
        var dimSize = dims.length;
        var offset2 = 0;
        var dim0 = dims[0];
        var chunks = newStore._chunks;
        for (var i2 = 0; i2 < count; i2++) {
          var keep = void 0;
          var rawIdx = newStore.getRawIndex(i2);
          if (dimSize === 0) {
            keep = cb(i2);
          } else if (dimSize === 1) {
            var val = chunks[dim0][rawIdx];
            keep = cb(val, i2);
          } else {
            var k2 = 0;
            for (; k2 < dimSize; k2++) {
              value[k2] = chunks[dims[k2]][rawIdx];
            }
            value[k2] = i2;
            keep = cb.apply(null, value);
          }
          if (keep) {
            newIndices[offset2++] = rawIdx;
          }
        }
        if (offset2 < count) {
          newStore._indices = newIndices;
        }
        newStore._count = offset2;
        newStore._extent = [];
        newStore._updateGetRawIdx();
        return newStore;
      };
      DataStore2.prototype.selectRange = function(range2) {
        var newStore = this.clone();
        var len2 = newStore._count;
        if (!len2) {
          return this;
        }
        var dims = keys(range2);
        var dimSize = dims.length;
        if (!dimSize) {
          return this;
        }
        var originalCount = newStore.count();
        var Ctor = getIndicesCtor(newStore._rawCount);
        var newIndices = new Ctor(originalCount);
        var offset2 = 0;
        var dim0 = dims[0];
        var min3 = range2[dim0][0];
        var max3 = range2[dim0][1];
        var storeArr = newStore._chunks;
        var quickFinished = false;
        if (!newStore._indices) {
          var idx = 0;
          if (dimSize === 1) {
            var dimStorage = storeArr[dims[0]];
            for (var i2 = 0; i2 < len2; i2++) {
              var val = dimStorage[i2];
              if (val >= min3 && val <= max3 || isNaN(val)) {
                newIndices[offset2++] = idx;
              }
              idx++;
            }
            quickFinished = true;
          } else if (dimSize === 2) {
            var dimStorage = storeArr[dims[0]];
            var dimStorage2 = storeArr[dims[1]];
            var min22 = range2[dims[1]][0];
            var max22 = range2[dims[1]][1];
            for (var i2 = 0; i2 < len2; i2++) {
              var val = dimStorage[i2];
              var val2 = dimStorage2[i2];
              if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min22 && val2 <= max22 || isNaN(val2))) {
                newIndices[offset2++] = idx;
              }
              idx++;
            }
            quickFinished = true;
          }
        }
        if (!quickFinished) {
          if (dimSize === 1) {
            for (var i2 = 0; i2 < originalCount; i2++) {
              var rawIndex = newStore.getRawIndex(i2);
              var val = storeArr[dims[0]][rawIndex];
              if (val >= min3 && val <= max3 || isNaN(val)) {
                newIndices[offset2++] = rawIndex;
              }
            }
          } else {
            for (var i2 = 0; i2 < originalCount; i2++) {
              var keep = true;
              var rawIndex = newStore.getRawIndex(i2);
              for (var k2 = 0; k2 < dimSize; k2++) {
                var dimk = dims[k2];
                var val = storeArr[dimk][rawIndex];
                if (val < range2[dimk][0] || val > range2[dimk][1]) {
                  keep = false;
                }
              }
              if (keep) {
                newIndices[offset2++] = newStore.getRawIndex(i2);
              }
            }
          }
        }
        if (offset2 < originalCount) {
          newStore._indices = newIndices;
        }
        newStore._count = offset2;
        newStore._extent = [];
        newStore._updateGetRawIdx();
        return newStore;
      };
      DataStore2.prototype.map = function(dims, cb) {
        var target = this.clone(dims);
        this._updateDims(target, dims, cb);
        return target;
      };
      DataStore2.prototype.modify = function(dims, cb) {
        this._updateDims(this, dims, cb);
      };
      DataStore2.prototype._updateDims = function(target, dims, cb) {
        var targetChunks = target._chunks;
        var tmpRetValue = [];
        var dimSize = dims.length;
        var dataCount = target.count();
        var values = [];
        var rawExtent = target._rawExtent;
        for (var i2 = 0; i2 < dims.length; i2++) {
          rawExtent[dims[i2]] = getInitialExtent();
        }
        for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
          var rawIndex = target.getRawIndex(dataIndex);
          for (var k2 = 0; k2 < dimSize; k2++) {
            values[k2] = targetChunks[dims[k2]][rawIndex];
          }
          values[dimSize] = dataIndex;
          var retValue = cb && cb.apply(null, values);
          if (retValue != null) {
            if (typeof retValue !== "object") {
              tmpRetValue[0] = retValue;
              retValue = tmpRetValue;
            }
            for (var i2 = 0; i2 < retValue.length; i2++) {
              var dim = dims[i2];
              var val = retValue[i2];
              var rawExtentOnDim = rawExtent[dim];
              var dimStore = targetChunks[dim];
              if (dimStore) {
                dimStore[rawIndex] = val;
              }
              if (val < rawExtentOnDim[0]) {
                rawExtentOnDim[0] = val;
              }
              if (val > rawExtentOnDim[1]) {
                rawExtentOnDim[1] = val;
              }
            }
          }
        }
      };
      DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
        var target = this.clone([valueDimension], true);
        var targetStorage = target._chunks;
        var dimStore = targetStorage[valueDimension];
        var len2 = this.count();
        var sampledIndex = 0;
        var frameSize = Math.floor(1 / rate);
        var currentRawIndex = this.getRawIndex(0);
        var maxArea;
        var area;
        var nextRawIndex;
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
        newIndices[sampledIndex++] = currentRawIndex;
        for (var i2 = 1; i2 < len2 - 1; i2 += frameSize) {
          var nextFrameStart = Math.min(i2 + frameSize, len2 - 1);
          var nextFrameEnd = Math.min(i2 + frameSize * 2, len2);
          var avgX = (nextFrameEnd + nextFrameStart) / 2;
          var avgY = 0;
          for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx);
            var y2 = dimStore[rawIndex];
            if (isNaN(y2)) {
              continue;
            }
            avgY += y2;
          }
          avgY /= nextFrameEnd - nextFrameStart;
          var frameStart = i2;
          var frameEnd = Math.min(i2 + frameSize, len2);
          var pointAX = i2 - 1;
          var pointAY = dimStore[currentRawIndex];
          maxArea = -1;
          nextRawIndex = frameStart;
          var firstNaNIndex = -1;
          var countNaN = 0;
          for (var idx = frameStart; idx < frameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx);
            var y2 = dimStore[rawIndex];
            if (isNaN(y2)) {
              countNaN++;
              if (firstNaNIndex < 0) {
                firstNaNIndex = rawIndex;
              }
              continue;
            }
            area = Math.abs((pointAX - avgX) * (y2 - pointAY) - (pointAX - idx) * (avgY - pointAY));
            if (area > maxArea) {
              maxArea = area;
              nextRawIndex = rawIndex;
            }
          }
          if (countNaN > 0 && countNaN < frameEnd - frameStart) {
            newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
            nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
          }
          newIndices[sampledIndex++] = nextRawIndex;
          currentRawIndex = nextRawIndex;
        }
        newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
        target._count = sampledIndex;
        target._indices = newIndices;
        target.getRawIndex = this._getRawIdx;
        return target;
      };
      DataStore2.prototype.minmaxDownSample = function(valueDimension, rate) {
        var target = this.clone([valueDimension], true);
        var targetStorage = target._chunks;
        var frameSize = Math.floor(1 / rate);
        var dimStore = targetStorage[valueDimension];
        var len2 = this.count();
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize) * 2);
        var offset2 = 0;
        for (var i2 = 0; i2 < len2; i2 += frameSize) {
          var minIndex = i2;
          var minValue = dimStore[this.getRawIndex(minIndex)];
          var maxIndex = i2;
          var maxValue = dimStore[this.getRawIndex(maxIndex)];
          var thisFrameSize = frameSize;
          if (i2 + frameSize > len2) {
            thisFrameSize = len2 - i2;
          }
          for (var k2 = 0; k2 < thisFrameSize; k2++) {
            var rawIndex = this.getRawIndex(i2 + k2);
            var value = dimStore[rawIndex];
            if (value < minValue) {
              minValue = value;
              minIndex = i2 + k2;
            }
            if (value > maxValue) {
              maxValue = value;
              maxIndex = i2 + k2;
            }
          }
          var rawMinIndex = this.getRawIndex(minIndex);
          var rawMaxIndex = this.getRawIndex(maxIndex);
          if (minIndex < maxIndex) {
            newIndices[offset2++] = rawMinIndex;
            newIndices[offset2++] = rawMaxIndex;
          } else {
            newIndices[offset2++] = rawMaxIndex;
            newIndices[offset2++] = rawMinIndex;
          }
        }
        target._count = offset2;
        target._indices = newIndices;
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
        var target = this.clone([dimension], true);
        var targetStorage = target._chunks;
        var frameValues = [];
        var frameSize = Math.floor(1 / rate);
        var dimStore = targetStorage[dimension];
        var len2 = this.count();
        var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
        var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
        var offset2 = 0;
        for (var i2 = 0; i2 < len2; i2 += frameSize) {
          if (frameSize > len2 - i2) {
            frameSize = len2 - i2;
            frameValues.length = frameSize;
          }
          for (var k2 = 0; k2 < frameSize; k2++) {
            var dataIdx = this.getRawIndex(i2 + k2);
            frameValues[k2] = dimStore[dataIdx];
          }
          var value = sampleValue(frameValues);
          var sampleFrameIdx = this.getRawIndex(Math.min(i2 + sampleIndex(frameValues, value) || 0, len2 - 1));
          dimStore[sampleFrameIdx] = value;
          if (value < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = value;
          }
          if (value > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = value;
          }
          newIndices[offset2++] = sampleFrameIdx;
        }
        target._count = offset2;
        target._indices = newIndices;
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype.each = function(dims, cb) {
        if (!this._count) {
          return;
        }
        var dimSize = dims.length;
        var chunks = this._chunks;
        for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
          var rawIdx = this.getRawIndex(i2);
          switch (dimSize) {
            case 0:
              cb(i2);
              break;
            case 1:
              cb(chunks[dims[0]][rawIdx], i2);
              break;
            case 2:
              cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i2);
              break;
            default:
              var k2 = 0;
              var value = [];
              for (; k2 < dimSize; k2++) {
                value[k2] = chunks[dims[k2]][rawIdx];
              }
              value[k2] = i2;
              cb.apply(null, value);
          }
        }
      };
      DataStore2.prototype.getDataExtent = function(dim) {
        var dimData = this._chunks[dim];
        var initialExtent = getInitialExtent();
        if (!dimData) {
          return initialExtent;
        }
        var currEnd = this.count();
        var useRaw = !this._indices;
        var dimExtent;
        if (useRaw) {
          return this._rawExtent[dim].slice();
        }
        dimExtent = this._extent[dim];
        if (dimExtent) {
          return dimExtent.slice();
        }
        dimExtent = initialExtent;
        var min3 = dimExtent[0];
        var max3 = dimExtent[1];
        for (var i2 = 0; i2 < currEnd; i2++) {
          var rawIdx = this.getRawIndex(i2);
          var value = dimData[rawIdx];
          value < min3 && (min3 = value);
          value > max3 && (max3 = value);
        }
        dimExtent = [min3, max3];
        this._extent[dim] = dimExtent;
        return dimExtent;
      };
      DataStore2.prototype.getRawDataItem = function(idx) {
        var rawIdx = this.getRawIndex(idx);
        if (!this._provider.persistent) {
          var val = [];
          var chunks = this._chunks;
          for (var i2 = 0; i2 < chunks.length; i2++) {
            val.push(chunks[i2][rawIdx]);
          }
          return val;
        } else {
          return this._provider.getItem(rawIdx);
        }
      };
      DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
        var target = new DataStore2();
        var chunks = this._chunks;
        var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj2, dimIdx) {
          obj2[dimIdx] = true;
          return obj2;
        }, {});
        if (clonedDimsMap) {
          for (var i2 = 0; i2 < chunks.length; i2++) {
            target._chunks[i2] = !clonedDimsMap[i2] ? chunks[i2] : cloneChunk(chunks[i2]);
          }
        } else {
          target._chunks = chunks;
        }
        this._copyCommonProps(target);
        if (!ignoreIndices) {
          target._indices = this._cloneIndices();
        }
        target._updateGetRawIdx();
        return target;
      };
      DataStore2.prototype._copyCommonProps = function(target) {
        target._count = this._count;
        target._rawCount = this._rawCount;
        target._provider = this._provider;
        target._dimensions = this._dimensions;
        target._extent = clone$4(this._extent);
        target._rawExtent = clone$4(this._rawExtent);
      };
      DataStore2.prototype._cloneIndices = function() {
        if (this._indices) {
          var Ctor = this._indices.constructor;
          var indices = void 0;
          if (Ctor === Array) {
            var thisCount = this._indices.length;
            indices = new Ctor(thisCount);
            for (var i2 = 0; i2 < thisCount; i2++) {
              indices[i2] = this._indices[i2];
            }
          } else {
            indices = new Ctor(this._indices);
          }
          return indices;
        }
        return null;
      };
      DataStore2.prototype._getRawIdxIdentity = function(idx) {
        return idx;
      };
      DataStore2.prototype._getRawIdx = function(idx) {
        if (idx < this._count && idx >= 0) {
          return this._indices[idx];
        }
        return -1;
      };
      DataStore2.prototype._updateGetRawIdx = function() {
        this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
      };
      DataStore2.internalField = function() {
        function getDimValueSimply(dataItem, property2, dataIndex, dimIndex) {
          return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
        }
        defaultDimValueGetters = {
          arrayRows: getDimValueSimply,
          objectRows: function(dataItem, property2, dataIndex, dimIndex) {
            return parseDataValue(dataItem[property2], this._dimensions[dimIndex]);
          },
          keyedColumns: getDimValueSimply,
          original: function(dataItem, property2, dataIndex, dimIndex) {
            var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
            return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
          },
          typedArray: function(dataItem, property2, dataIndex, dimIndex) {
            return dataItem[dimIndex];
          }
        };
      }();
      return DataStore2;
    }()
  );
  var SourceManager = (
    /** @class */
    function() {
      function SourceManager2(sourceHost) {
        this._sourceList = [];
        this._storeList = [];
        this._upstreamSignList = [];
        this._versionSignBase = 0;
        this._dirty = true;
        this._sourceHost = sourceHost;
      }
      SourceManager2.prototype.dirty = function() {
        this._setLocalSource([], []);
        this._storeList = [];
        this._dirty = true;
      };
      SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
        this._sourceList = sourceList;
        this._upstreamSignList = upstreamSignList;
        this._versionSignBase++;
        if (this._versionSignBase > 9e10) {
          this._versionSignBase = 0;
        }
      };
      SourceManager2.prototype._getVersionSign = function() {
        return this._sourceHost.uid + "_" + this._versionSignBase;
      };
      SourceManager2.prototype.prepareSource = function() {
        if (this._isDirty()) {
          this._createSource();
          this._dirty = false;
        }
      };
      SourceManager2.prototype._createSource = function() {
        this._setLocalSource([], []);
        var sourceHost = this._sourceHost;
        var upSourceMgrList = this._getUpstreamSourceManagers();
        var hasUpstream = !!upSourceMgrList.length;
        var resultSourceList;
        var upstreamSignList;
        if (isSeries(sourceHost)) {
          var seriesModel = sourceHost;
          var data = void 0;
          var sourceFormat = void 0;
          var upSource = void 0;
          if (hasUpstream) {
            var upSourceMgr = upSourceMgrList[0];
            upSourceMgr.prepareSource();
            upSource = upSourceMgr.getSource();
            data = upSource.data;
            sourceFormat = upSource.sourceFormat;
            upstreamSignList = [upSourceMgr._getVersionSign()];
          } else {
            data = seriesModel.get("data", true);
            sourceFormat = isTypedArray$1(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
            upstreamSignList = [];
          }
          var newMetaRawOption = this._getSourceMetaRawOption() || {};
          var upMetaRawOption = upSource && upSource.metaRawOption || {};
          var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
          var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
          var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
          var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
          resultSourceList = needsCreateSource ? [createSource(data, {
            seriesLayoutBy,
            sourceHeader,
            dimensions
          }, sourceFormat)] : [];
        } else {
          var datasetModel = sourceHost;
          if (hasUpstream) {
            var result = this._applyTransform(upSourceMgrList);
            resultSourceList = result.sourceList;
            upstreamSignList = result.upstreamSignList;
          } else {
            var sourceData = datasetModel.get("source", true);
            resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
            upstreamSignList = [];
          }
        }
        this._setLocalSource(resultSourceList, upstreamSignList);
      };
      SourceManager2.prototype._applyTransform = function(upMgrList) {
        var datasetModel = this._sourceHost;
        var transformOption = datasetModel.get("transform", true);
        var fromTransformResult = datasetModel.get("fromTransformResult", true);
        if (fromTransformResult != null) {
          var errMsg = "";
          if (upMgrList.length !== 1) {
            doThrow(errMsg);
          }
        }
        var sourceList;
        var upSourceList = [];
        var upstreamSignList = [];
        each$4(upMgrList, function(upMgr) {
          upMgr.prepareSource();
          var upSource = upMgr.getSource(fromTransformResult || 0);
          var errMsg2 = "";
          if (fromTransformResult != null && !upSource) {
            doThrow(errMsg2);
          }
          upSourceList.push(upSource);
          upstreamSignList.push(upMgr._getVersionSign());
        });
        if (transformOption) {
          sourceList = applyDataTransform(transformOption, upSourceList, {
            datasetIndex: datasetModel.componentIndex
          });
        } else if (fromTransformResult != null) {
          sourceList = [cloneSourceShallow(upSourceList[0])];
        }
        return {
          sourceList,
          upstreamSignList
        };
      };
      SourceManager2.prototype._isDirty = function() {
        if (this._dirty) {
          return true;
        }
        var upSourceMgrList = this._getUpstreamSourceManagers();
        for (var i2 = 0; i2 < upSourceMgrList.length; i2++) {
          var upSrcMgr = upSourceMgrList[i2];
          if (
            // Consider the case that there is ancestor diry, call it recursively.
            // The performance is probably not an issue because usually the chain is not long.
            upSrcMgr._isDirty() || this._upstreamSignList[i2] !== upSrcMgr._getVersionSign()
          ) {
            return true;
          }
        }
      };
      SourceManager2.prototype.getSource = function(sourceIndex) {
        sourceIndex = sourceIndex || 0;
        var source = this._sourceList[sourceIndex];
        if (!source) {
          var upSourceMgrList = this._getUpstreamSourceManagers();
          return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
        }
        return source;
      };
      SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
        var schema = seriesDimRequest.makeStoreSchema();
        return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
      };
      SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
        var sourceIndex = 0;
        var storeList = this._storeList;
        var cachedStoreMap = storeList[sourceIndex];
        if (!cachedStoreMap) {
          cachedStoreMap = storeList[sourceIndex] = {};
        }
        var cachedStore = cachedStoreMap[sourceReadKey];
        if (!cachedStore) {
          var upSourceMgr = this._getUpstreamSourceManagers()[0];
          if (isSeries(this._sourceHost) && upSourceMgr) {
            cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
          } else {
            cachedStore = new DataStore();
            cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
          }
          cachedStoreMap[sourceReadKey] = cachedStore;
        }
        return cachedStore;
      };
      SourceManager2.prototype._getUpstreamSourceManagers = function() {
        var sourceHost = this._sourceHost;
        if (isSeries(sourceHost)) {
          var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
          return !datasetModel ? [] : [datasetModel.getSourceManager()];
        } else {
          return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
            return datasetModel2.getSourceManager();
          });
        }
      };
      SourceManager2.prototype._getSourceMetaRawOption = function() {
        var sourceHost = this._sourceHost;
        var seriesLayoutBy;
        var sourceHeader;
        var dimensions;
        if (isSeries(sourceHost)) {
          seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
          sourceHeader = sourceHost.get("sourceHeader", true);
          dimensions = sourceHost.get("dimensions", true);
        } else if (!this._getUpstreamSourceManagers().length) {
          var model = sourceHost;
          seriesLayoutBy = model.get("seriesLayoutBy", true);
          sourceHeader = model.get("sourceHeader", true);
          dimensions = model.get("dimensions", true);
        }
        return {
          seriesLayoutBy,
          sourceHeader,
          dimensions
        };
      };
      return SourceManager2;
    }()
  );
  function disableTransformOptionMerge(datasetModel) {
    var transformOption = datasetModel.option.transform;
    transformOption && setAsPrimitive(datasetModel.option.transform);
  }
  function isSeries(sourceHost) {
    return sourceHost.mainType === "series";
  }
  function doThrow(errMsg) {
    throw new Error(errMsg);
  }
  var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
  function getTooltipLineHeight(textStyle) {
    var lineHeight = textStyle.lineHeight;
    if (lineHeight == null) {
      return TOOLTIP_LINE_HEIGHT_CSS;
    } else {
      return "line-height:" + encodeHTML(lineHeight + "") + "px";
    }
  }
  function getTooltipTextStyle(textStyle, renderMode) {
    var nameFontColor = textStyle.color || "#6e7079";
    var nameFontSize = textStyle.fontSize || 12;
    var nameFontWeight = textStyle.fontWeight || "400";
    var valueFontColor = textStyle.color || "#464646";
    var valueFontSize = textStyle.fontSize || 14;
    var valueFontWeight = textStyle.fontWeight || "900";
    if (renderMode === "html") {
      return {
        // eslint-disable-next-line max-len
        nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
        // eslint-disable-next-line max-len
        valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
      };
    } else {
      return {
        nameStyle: {
          fontSize: nameFontSize,
          fill: nameFontColor,
          fontWeight: nameFontWeight
        },
        valueStyle: {
          fontSize: valueFontSize,
          fill: valueFontColor,
          fontWeight: valueFontWeight
        }
      };
    }
  }
  var HTML_GAPS = [0, 10, 20, 30];
  var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
  function createTooltipMarkup(type, option) {
    option.type = type;
    return option;
  }
  function isSectionFragment(frag) {
    return frag.type === "section";
  }
  function getBuilder(frag) {
    return isSectionFragment(frag) ? buildSection : buildNameValue;
  }
  function getBlockGapLevel(frag) {
    if (isSectionFragment(frag)) {
      var gapLevel_1 = 0;
      var subBlockLen = frag.blocks.length;
      var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
      each$4(frag.blocks, function(subBlock) {
        var subGapLevel = getBlockGapLevel(subBlock);
        if (subGapLevel >= gapLevel_1) {
          gapLevel_1 = subGapLevel + +(hasInnerGap_1 && // 0 always can not be readable gap level.
          (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
        }
      });
      return gapLevel_1;
    }
    return 0;
  }
  function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var noHeader = fragment.noHeader;
    var gaps = getGap(getBlockGapLevel(fragment));
    var subMarkupTextList = [];
    var subBlocks = fragment.blocks || [];
    assert(!subBlocks || isArray$1(subBlocks));
    subBlocks = subBlocks || [];
    var orderMode = ctx.orderMode;
    if (fragment.sortBlocks && orderMode) {
      subBlocks = subBlocks.slice();
      var orderMap = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (hasOwn(orderMap, orderMode)) {
        var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
        subBlocks.sort(function(a2, b2) {
          return comparator_1.evaluate(a2.sortParam, b2.sortParam);
        });
      } else if (orderMode === "seriesDesc") {
        subBlocks.reverse();
      }
    }
    each$4(subBlocks, function(subBlock, idx) {
      var valueFormatter = fragment.valueFormatter;
      var subMarkupText2 = getBuilder(subBlock)(
        // Inherit valueFormatter
        valueFormatter ? extend$1(extend$1({}, ctx), {
          valueFormatter
        }) : ctx,
        subBlock,
        idx > 0 ? gaps.html : 0,
        toolTipTextStyle
      );
      subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
    });
    var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
    if (noHeader) {
      return subMarkupText;
    }
    var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
    var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
    var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
    if (ctx.renderMode === "richText") {
      return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
    } else {
      return wrapBlockHTML(toolTipTextStyle, '<div style="' + nameStyle + ";" + tooltipLineHeight + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
    }
  }
  function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var renderMode = ctx.renderMode;
    var noName = fragment.noName;
    var noValue = fragment.noValue;
    var noMarker = !fragment.markerType;
    var name = fragment.name;
    var useUTC = ctx.useUTC;
    var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
      value = isArray$1(value) ? value : [value];
      return map$1(value, function(val, idx) {
        return makeValueReadable(val, isArray$1(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
      });
    };
    if (noName && noValue) {
      return;
    }
    var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
    var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
    var valueTypeOption = fragment.valueType;
    var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
    var valueAlignRight = !noMarker || !noName;
    var valueCloseToMarker = !noMarker && noName;
    var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
    return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
  }
  function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
    if (!fragment) {
      return;
    }
    var builder = getBuilder(fragment);
    var ctx = {
      useUTC,
      renderMode,
      orderMode,
      markupStyleCreator,
      valueFormatter: fragment.valueFormatter
    };
    return builder(ctx, fragment, 0, toolTipTextStyle);
  }
  function getGap(gapLevel) {
    return {
      html: HTML_GAPS[gapLevel],
      richText: RICH_TEXT_GAPS[gapLevel]
    };
  }
  function wrapBlockHTML(textStyle, encodedContent, topGap) {
    var clearfix = '<div style="clear:both"></div>';
    var marginCSS = "margin: " + topGap + "px 0 0";
    var tooltipLineHeight = getTooltipLineHeight(textStyle);
    return '<div style="' + marginCSS + ";" + tooltipLineHeight + ';">' + encodedContent + clearfix + "</div>";
  }
  function wrapInlineNameHTML(name, leftHasMarker, style) {
    var marginCss = leftHasMarker ? "margin-left:2px" : "";
    return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
  }
  function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
    var paddingStr = valueCloseToMarker ? "10px" : "20px";
    var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
    valueList = isArray$1(valueList) ? valueList : [valueList];
    return '<span style="' + alignCSS + ";" + style + '">' + map$1(valueList, function(value) {
      return encodeHTML(value);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function wrapInlineNameRichText(ctx, name, style) {
    return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
  }
  function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
    var styles = [style];
    var paddingLeft = valueCloseToMarker ? 10 : 20;
    alignRight && styles.push({
      padding: [0, 0, 0, paddingLeft],
      align: "right"
    });
    return ctx.markupStyleCreator.wrapRichTextStyle(isArray$1(values) ? values.join("  ") : values, styles);
  }
  function retrieveVisualColorForTooltipMarker(series, dataIndex) {
    var style = series.getData().getItemVisual(dataIndex, "style");
    var color2 = style[series.visualDrawType];
    return convertToColorString(color2);
  }
  function getPaddingFromTooltipModel(model, renderMode) {
    var padding = model.get("padding");
    return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
  }
  var TooltipMarkupStyleCreator = (
    /** @class */
    function() {
      function TooltipMarkupStyleCreator2() {
        this.richTextStyles = {};
        this._nextStyleNameId = getRandomIdBase();
      }
      TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
        return "__EC_aUTo_" + this._nextStyleNameId++;
      };
      TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
        var markerId = renderMode === "richText" ? this._generateStyleName() : null;
        var marker = getTooltipMarker({
          color: colorStr,
          type: markerType,
          renderMode,
          markerId
        });
        if (isString$1(marker)) {
          return marker;
        } else {
          this.richTextStyles[markerId] = marker.style;
          return marker.content;
        }
      };
      TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
        var finalStl = {};
        if (isArray$1(styles)) {
          each$4(styles, function(stl) {
            return extend$1(finalStl, stl);
          });
        } else {
          extend$1(finalStl, styles);
        }
        var styleName = this._generateStyleName();
        this.richTextStyles[styleName] = finalStl;
        return "{" + styleName + "|" + text + "}";
      };
      return TooltipMarkupStyleCreator2;
    }()
  );
  function defaultSeriesFormatTooltip(opt) {
    var series = opt.series;
    var dataIndex = opt.dataIndex;
    var multipleSeries = opt.multipleSeries;
    var data = series.getData();
    var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
    var tooltipDimLen = tooltipDims.length;
    var value = series.getRawValue(dataIndex);
    var isValueArr = isArray$1(value);
    var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
    var inlineValue;
    var inlineValueType;
    var subBlocks;
    var sortParam;
    if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
      var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
      inlineValue = formatArrResult.inlineValues;
      inlineValueType = formatArrResult.inlineValueTypes;
      subBlocks = formatArrResult.blocks;
      sortParam = formatArrResult.inlineValues[0];
    } else if (tooltipDimLen) {
      var dimInfo = data.getDimensionInfo(tooltipDims[0]);
      sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
      inlineValueType = dimInfo.type;
    } else {
      sortParam = inlineValue = isValueArr ? value[0] : value;
    }
    var seriesNameSpecified = isNameSpecified(series);
    var seriesName = seriesNameSpecified && series.name || "";
    var itemName = data.getName(dataIndex);
    var inlineName = multipleSeries ? seriesName : itemName;
    return createTooltipMarkup("section", {
      header: seriesName,
      // When series name is not specified, do not show a header line with only '-'.
      // This case always happens in tooltip.trigger: 'item'.
      noHeader: multipleSeries || !seriesNameSpecified,
      sortParam,
      blocks: [createTooltipMarkup("nameValue", {
        markerType: "item",
        markerColor,
        // Do not mix display seriesName and itemName in one tooltip,
        // which might confuses users.
        name: inlineName,
        // name dimension might be auto assigned, where the name might
        // be not readable. So we check trim here.
        noName: !trim$1(inlineName),
        value: inlineValue,
        valueType: inlineValueType,
        dataIndex
      })].concat(subBlocks || [])
    });
  }
  function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
    var data = series.getData();
    var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
      var dimItem = data.getDimensionInfo(idx);
      return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
    }, false);
    var inlineValues = [];
    var inlineValueTypes = [];
    var blocks = [];
    tooltipDims.length ? each$4(tooltipDims, function(dim) {
      setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
    }) : each$4(value, setEachItem);
    function setEachItem(val, dim) {
      var dimInfo = data.getDimensionInfo(dim);
      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return;
      }
      if (isValueMultipleLine) {
        blocks.push(createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor: colorStr,
          name: dimInfo.displayName,
          value: val,
          valueType: dimInfo.type
        }));
      } else {
        inlineValues.push(val);
        inlineValueTypes.push(dimInfo.type);
      }
    }
    return {
      inlineValues,
      inlineValueTypes,
      blocks
    };
  }
  var inner$8 = makeInner();
  function getSelectionKey(data, dataIndex) {
    return data.getName(dataIndex) || data.getId(dataIndex);
  }
  var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
  var SeriesModel = (
    /** @class */
    function(_super) {
      __extends(SeriesModel2, _super);
      function SeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._selectedDataIndicesMap = {};
        return _this;
      }
      SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
        this.seriesIndex = this.componentIndex;
        this.dataTask = createTask({
          count: dataTaskCount,
          reset: dataTaskReset
        });
        this.dataTask.context = {
          model: this
        };
        this.mergeDefaultAndTheme(option, ecModel);
        var sourceManager = inner$8(this).sourceManager = new SourceManager(this);
        sourceManager.prepareSource();
        var data = this.getInitialData(option, ecModel);
        wrapData(data, this);
        this.dataTask.context.data = data;
        inner$8(this).dataBeforeProcessed = data;
        autoSeriesName(this);
        this._initSelectedMapFromData(data);
      };
      SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeSubType = this.subType;
        if (ComponentModel.hasClass(themeSubType)) {
          themeSubType += "Series";
        }
        merge$1(option, ecModel.getTheme().get(this.subType));
        merge$1(option, this.getDefaultOption());
        defaultEmphasis(option, "label", ["show"]);
        this.fillDataTextStyle(option.data);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
        newSeriesOption = merge$1(this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);
        var layoutMode = fetchLayoutMode(this);
        if (layoutMode) {
          mergeLayoutParam(this.option, newSeriesOption, layoutMode);
        }
        var sourceManager = inner$8(this).sourceManager;
        sourceManager.dirty();
        sourceManager.prepareSource();
        var data = this.getInitialData(newSeriesOption, ecModel);
        wrapData(data, this);
        this.dataTask.dirty();
        this.dataTask.context.data = data;
        inner$8(this).dataBeforeProcessed = data;
        autoSeriesName(this);
        this._initSelectedMapFromData(data);
      };
      SeriesModel2.prototype.fillDataTextStyle = function(data) {
        if (data && !isTypedArray$1(data)) {
          var props2 = ["show"];
          for (var i2 = 0; i2 < data.length; i2++) {
            if (data[i2] && data[i2].label) {
              defaultEmphasis(data[i2], "label", props2);
            }
          }
        }
      };
      SeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return;
      };
      SeriesModel2.prototype.appendData = function(params2) {
        var data = this.getRawData();
        data.appendData(params2.data);
      };
      SeriesModel2.prototype.getData = function(dataType) {
        var task = getCurrentTask(this);
        if (task) {
          var data = task.context.data;
          return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
        } else {
          return inner$8(this).data;
        }
      };
      SeriesModel2.prototype.getAllData = function() {
        var mainData = this.getData();
        return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
          data: mainData
        }];
      };
      SeriesModel2.prototype.setData = function(data) {
        var task = getCurrentTask(this);
        if (task) {
          var context = task.context;
          context.outputData = data;
          if (task !== this.dataTask) {
            context.data = data;
          }
        }
        inner$8(this).data = data;
      };
      SeriesModel2.prototype.getEncode = function() {
        var encode2 = this.get("encode", true);
        if (encode2) {
          return createHashMap(encode2);
        }
      };
      SeriesModel2.prototype.getSourceManager = function() {
        return inner$8(this).sourceManager;
      };
      SeriesModel2.prototype.getSource = function() {
        return this.getSourceManager().getSource();
      };
      SeriesModel2.prototype.getRawData = function() {
        return inner$8(this).dataBeforeProcessed;
      };
      SeriesModel2.prototype.getColorBy = function() {
        var colorBy = this.get("colorBy");
        return colorBy || "series";
      };
      SeriesModel2.prototype.isColorBySeries = function() {
        return this.getColorBy() === "series";
      };
      SeriesModel2.prototype.getBaseAxis = function() {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
      };
      SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
        return defaultSeriesFormatTooltip({
          series: this,
          dataIndex,
          multipleSeries
        });
      };
      SeriesModel2.prototype.isAnimationEnabled = function() {
        var ecModel = this.ecModel;
        if (env.node && !(ecModel && ecModel.ssr)) {
          return false;
        }
        var animationEnabled = this.getShallow("animation");
        if (animationEnabled) {
          if (this.getData().count() > this.getShallow("animationThreshold")) {
            animationEnabled = false;
          }
        }
        return !!animationEnabled;
      };
      SeriesModel2.prototype.restoreData = function() {
        this.dataTask.dirty();
      };
      SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
        var ecModel = this.ecModel;
        var color2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
        if (!color2) {
          color2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
        }
        return color2;
      };
      SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
        return this.getRawData().mapDimensionsAll(coordDim);
      };
      SeriesModel2.prototype.getProgressive = function() {
        return this.get("progressive");
      };
      SeriesModel2.prototype.getProgressiveThreshold = function() {
        return this.get("progressiveThreshold");
      };
      SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
        this._innerSelect(this.getData(dataType), innerDataIndices);
      };
      SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
        var selectedMap = this.option.selectedMap;
        if (!selectedMap) {
          return;
        }
        var selectedMode = this.option.selectedMode;
        var data = this.getData(dataType);
        if (selectedMode === "series" || selectedMap === "all") {
          this.option.selectedMap = {};
          this._selectedDataIndicesMap = {};
          return;
        }
        for (var i2 = 0; i2 < innerDataIndices.length; i2++) {
          var dataIndex = innerDataIndices[i2];
          var nameOrId = getSelectionKey(data, dataIndex);
          selectedMap[nameOrId] = false;
          this._selectedDataIndicesMap[nameOrId] = -1;
        }
      };
      SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
        var tmpArr2 = [];
        for (var i2 = 0; i2 < innerDataIndices.length; i2++) {
          tmpArr2[0] = innerDataIndices[i2];
          this.isSelected(innerDataIndices[i2], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
        }
      };
      SeriesModel2.prototype.getSelectedDataIndices = function() {
        if (this.option.selectedMap === "all") {
          return [].slice.call(this.getData().getIndices());
        }
        var selectedDataIndicesMap = this._selectedDataIndicesMap;
        var nameOrIds = keys(selectedDataIndicesMap);
        var dataIndices = [];
        for (var i2 = 0; i2 < nameOrIds.length; i2++) {
          var dataIndex = selectedDataIndicesMap[nameOrIds[i2]];
          if (dataIndex >= 0) {
            dataIndices.push(dataIndex);
          }
        }
        return dataIndices;
      };
      SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
        var selectedMap = this.option.selectedMap;
        if (!selectedMap) {
          return false;
        }
        var data = this.getData(dataType);
        return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
      };
      SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
        if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          return true;
        }
        var universalTransitionOpt = this.option.universalTransition;
        if (!universalTransitionOpt) {
          return false;
        }
        if (universalTransitionOpt === true) {
          return true;
        }
        return universalTransitionOpt && universalTransitionOpt.enabled;
      };
      SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
        var _a2, _b2;
        var option = this.option;
        var selectedMode = option.selectedMode;
        var len2 = innerDataIndices.length;
        if (!selectedMode || !len2) {
          return;
        }
        if (selectedMode === "series") {
          option.selectedMap = "all";
        } else if (selectedMode === "multiple") {
          if (!isObject$3(option.selectedMap)) {
            option.selectedMap = {};
          }
          var selectedMap = option.selectedMap;
          for (var i2 = 0; i2 < len2; i2++) {
            var dataIndex = innerDataIndices[i2];
            var nameOrId = getSelectionKey(data, dataIndex);
            selectedMap[nameOrId] = true;
            this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
          }
        } else if (selectedMode === "single" || selectedMode === true) {
          var lastDataIndex = innerDataIndices[len2 - 1];
          var nameOrId = getSelectionKey(data, lastDataIndex);
          option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
          this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
        }
      };
      SeriesModel2.prototype._initSelectedMapFromData = function(data) {
        if (this.option.selectedMap) {
          return;
        }
        var dataIndices = [];
        if (data.hasItemOption) {
          data.each(function(idx) {
            var rawItem = data.getRawDataItem(idx);
            if (rawItem && rawItem.selected) {
              dataIndices.push(idx);
            }
          });
        }
        if (dataIndices.length > 0) {
          this._innerSelect(data, dataIndices);
        }
      };
      SeriesModel2.registerClass = function(clz) {
        return ComponentModel.registerClass(clz);
      };
      SeriesModel2.protoInitialize = function() {
        var proto2 = SeriesModel2.prototype;
        proto2.type = "series.__base__";
        proto2.seriesIndex = 0;
        proto2.ignoreStyleOnData = false;
        proto2.hasSymbolVisual = false;
        proto2.defaultSymbol = "circle";
        proto2.visualStyleAccessPath = "itemStyle";
        proto2.visualDrawType = "fill";
      }();
      return SeriesModel2;
    }(ComponentModel)
  );
  mixin(SeriesModel, DataFormatMixin);
  mixin(SeriesModel, PaletteMixin);
  mountExtend(SeriesModel, ComponentModel);
  function autoSeriesName(seriesModel) {
    var name = seriesModel.name;
    if (!isNameSpecified(seriesModel)) {
      seriesModel.name = getSeriesAutoName(seriesModel) || name;
    }
  }
  function getSeriesAutoName(seriesModel) {
    var data = seriesModel.getRawData();
    var dataDims = data.mapDimensionsAll("seriesName");
    var nameArr = [];
    each$4(dataDims, function(dataDim) {
      var dimInfo = data.getDimensionInfo(dataDim);
      dimInfo.displayName && nameArr.push(dimInfo.displayName);
    });
    return nameArr.join(" ");
  }
  function dataTaskCount(context) {
    return context.model.getRawData().count();
  }
  function dataTaskReset(context) {
    var seriesModel = context.model;
    seriesModel.setData(seriesModel.getRawData().cloneShallow());
    return dataTaskProgress;
  }
  function dataTaskProgress(param, context) {
    if (context.outputData && param.end > context.outputData.count()) {
      context.model.getRawData().cloneShallow(context.outputData);
    }
  }
  function wrapData(data, seriesModel) {
    each$4(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
      data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
    });
  }
  function onDataChange(seriesModel, newList) {
    var task = getCurrentTask(seriesModel);
    if (task) {
      task.setOutputEnd((newList || this).count());
    }
    return newList;
  }
  function getCurrentTask(seriesModel) {
    var scheduler = (seriesModel.ecModel || {}).scheduler;
    var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
    if (pipeline) {
      var task = pipeline.currentTask;
      if (task) {
        var agentStubMap = task.agentStubMap;
        if (agentStubMap) {
          task = agentStubMap.get(seriesModel.uid);
        }
      }
      return task;
    }
  }
  var ComponentView = (
    /** @class */
    function() {
      function ComponentView2() {
        this.group = new Group$2();
        this.uid = getUID("viewComponent");
      }
      ComponentView2.prototype.init = function(ecModel, api2) {
      };
      ComponentView2.prototype.render = function(model, ecModel, api2, payload) {
      };
      ComponentView2.prototype.dispose = function(ecModel, api2) {
      };
      ComponentView2.prototype.updateView = function(model, ecModel, api2, payload) {
      };
      ComponentView2.prototype.updateLayout = function(model, ecModel, api2, payload) {
      };
      ComponentView2.prototype.updateVisual = function(model, ecModel, api2, payload) {
      };
      ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
      };
      ComponentView2.prototype.eachRendered = function(cb) {
        var group = this.group;
        if (group) {
          group.traverse(cb);
        }
      };
      return ComponentView2;
    }()
  );
  enableClassExtend(ComponentView);
  enableClassManagement(ComponentView);
  function createRenderPlanner() {
    var inner2 = makeInner();
    return function(seriesModel) {
      var fields = inner2(seriesModel);
      var pipelineContext = seriesModel.pipelineContext;
      var originalLarge = !!fields.large;
      var originalProgressive = !!fields.progressiveRender;
      var large = fields.large = !!(pipelineContext && pipelineContext.large);
      var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
      return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
    };
  }
  var inner$7 = makeInner();
  var renderPlanner = createRenderPlanner();
  var ChartView = (
    /** @class */
    function() {
      function ChartView2() {
        this.group = new Group$2();
        this.uid = getUID("viewChart");
        this.renderTask = createTask({
          plan: renderTaskPlan,
          reset: renderTaskReset
        });
        this.renderTask.context = {
          view: this
        };
      }
      ChartView2.prototype.init = function(ecModel, api2) {
      };
      ChartView2.prototype.render = function(seriesModel, ecModel, api2, payload) {
      };
      ChartView2.prototype.highlight = function(seriesModel, ecModel, api2, payload) {
        var data = seriesModel.getData(payload && payload.dataType);
        if (!data) {
          return;
        }
        toggleHighlight(data, payload, "emphasis");
      };
      ChartView2.prototype.downplay = function(seriesModel, ecModel, api2, payload) {
        var data = seriesModel.getData(payload && payload.dataType);
        if (!data) {
          return;
        }
        toggleHighlight(data, payload, "normal");
      };
      ChartView2.prototype.remove = function(ecModel, api2) {
        this.group.removeAll();
      };
      ChartView2.prototype.dispose = function(ecModel, api2) {
      };
      ChartView2.prototype.updateView = function(seriesModel, ecModel, api2, payload) {
        this.render(seriesModel, ecModel, api2, payload);
      };
      ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api2, payload) {
        this.render(seriesModel, ecModel, api2, payload);
      };
      ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api2, payload) {
        this.render(seriesModel, ecModel, api2, payload);
      };
      ChartView2.prototype.eachRendered = function(cb) {
        traverseElements(this.group, cb);
      };
      ChartView2.markUpdateMethod = function(payload, methodName) {
        inner$7(payload).updateMethod = methodName;
      };
      ChartView2.protoInitialize = function() {
        var proto2 = ChartView2.prototype;
        proto2.type = "chart";
      }();
      return ChartView2;
    }()
  );
  function elSetState(el, state, highlightDigit) {
    if (el && isHighDownDispatcher(el)) {
      (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
    }
  }
  function toggleHighlight(data, payload, state) {
    var dataIndex = queryDataIndex(data, payload);
    var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
    if (dataIndex != null) {
      each$4(normalizeToArray(dataIndex), function(dataIdx) {
        elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
      });
    } else {
      data.eachItemGraphicEl(function(el) {
        elSetState(el, state, highlightDigit);
      });
    }
  }
  enableClassExtend(ChartView);
  enableClassManagement(ChartView);
  function renderTaskPlan(context) {
    return renderPlanner(context.model);
  }
  function renderTaskReset(context) {
    var seriesModel = context.model;
    var ecModel = context.ecModel;
    var api2 = context.api;
    var payload = context.payload;
    var progressiveRender = seriesModel.pipelineContext.progressiveRender;
    var view = context.view;
    var updateMethod = payload && inner$7(payload).updateMethod;
    var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
    if (methodName !== "render") {
      view[methodName](seriesModel, ecModel, api2, payload);
    }
    return progressMethodMap[methodName];
  }
  var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function(params2, context) {
        context.view.incrementalRender(params2, context.model, context.ecModel, context.api, context.payload);
      }
    },
    render: {
      // Put view.render in `progress` to support appendData. But in this case
      // view.render should not be called in reset, otherwise it will be called
      // twise. Use `forceFirstProgress` to make sure that view.render is called
      // in any cases.
      forceFirstProgress: true,
      progress: function(params2, context) {
        context.view.render(context.model, context.ecModel, context.api, context.payload);
      }
    }
  };
  var ORIGIN_METHOD = "\0__throttleOriginMethod";
  var RATE = "\0__throttleRate";
  var THROTTLE_TYPE = "\0__throttleType";
  function throttle$1(fn, delay, debounce2) {
    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    var debounceNextCall;
    delay = delay || 0;
    function exec() {
      lastExec = (/* @__PURE__ */ new Date()).getTime();
      timer = null;
      fn.apply(scope, args || []);
    }
    var cb = function() {
      var cbArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        cbArgs[_i] = arguments[_i];
      }
      currCall = (/* @__PURE__ */ new Date()).getTime();
      scope = this;
      args = cbArgs;
      var thisDelay = debounceNextCall || delay;
      var thisDebounce = debounceNextCall || debounce2;
      debounceNextCall = null;
      diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
      clearTimeout(timer);
      if (thisDebounce) {
        timer = setTimeout(exec, thisDelay);
      } else {
        if (diff >= 0) {
          exec();
        } else {
          timer = setTimeout(exec, -diff);
        }
      }
      lastCall = currCall;
    };
    cb.clear = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    cb.debounceNextCall = function(debounceDelay) {
      debounceNextCall = debounceDelay;
    };
    return cb;
  }
  function createOrUpdate(obj2, fnAttr, rate, throttleType) {
    var fn = obj2[fnAttr];
    if (!fn) {
      return;
    }
    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];
    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return obj2[fnAttr] = originFn;
      }
      fn = obj2[fnAttr] = throttle$1(originFn, rate, throttleType === "debounce");
      fn[ORIGIN_METHOD] = originFn;
      fn[THROTTLE_TYPE] = throttleType;
      fn[RATE] = rate;
    }
    return fn;
  }
  function clear(obj2, fnAttr) {
    var fn = obj2[fnAttr];
    if (fn && fn[ORIGIN_METHOD]) {
      fn.clear && fn.clear();
      obj2[fnAttr] = fn[ORIGIN_METHOD];
    }
  }
  var inner$6 = makeInner();
  var defaultStyleMappers = {
    itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
    lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
  };
  var defaultColorKey = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function getStyleMapper(seriesModel, stylePath) {
    var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
    if (!styleMapper) {
      console.warn("Unknown style type '" + stylePath + "'.");
      return defaultStyleMappers.itemStyle;
    }
    return styleMapper;
  }
  function getDefaultColorKey(seriesModel, stylePath) {
    var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
    if (!colorKey) {
      console.warn("Unknown style type '" + stylePath + "'.");
      return "fill";
    }
    return colorKey;
  }
  var seriesStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var styleModel = seriesModel.getModel(stylePath);
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var globalStyle = getStyle2(styleModel);
      var decalOption = styleModel.getShallow("decal");
      if (decalOption) {
        data.setVisual("decal", decalOption);
        decalOption.dirty = true;
      }
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      var color2 = globalStyle[colorKey];
      var colorCallback = isFunction$1(color2) ? color2 : null;
      var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
      if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
        var colorPalette2 = seriesModel.getColorFromPalette(
          // TODO series count changed.
          seriesModel.name,
          null,
          ecModel.getSeriesCount()
        );
        if (!globalStyle[colorKey]) {
          globalStyle[colorKey] = colorPalette2;
          data.setVisual("colorFromPalette", true);
        }
        globalStyle.fill = globalStyle.fill === "auto" || isFunction$1(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
        globalStyle.stroke = globalStyle.stroke === "auto" || isFunction$1(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
      }
      data.setVisual("style", globalStyle);
      data.setVisual("drawType", colorKey);
      if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
        data.setVisual("colorFromPalette", false);
        return {
          dataEach: function(data2, idx) {
            var dataParams = seriesModel.getDataParams(idx);
            var itemStyle = extend$1({}, globalStyle);
            itemStyle[colorKey] = colorCallback(dataParams);
            data2.setItemVisual(idx, "style", itemStyle);
          }
        };
      }
    }
  };
  var sharedModel = new Model();
  var dataStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var colorKey = data.getVisual("drawType");
      return {
        dataEach: data.hasItemOption ? function(data2, idx) {
          var rawItem = data2.getRawDataItem(idx);
          if (rawItem && rawItem[stylePath]) {
            sharedModel.option = rawItem[stylePath];
            var style = getStyle2(sharedModel);
            var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
            extend$1(existsStyle, style);
            if (sharedModel.option.decal) {
              data2.setItemVisual(idx, "decal", sharedModel.option.decal);
              sharedModel.option.decal.dirty = true;
            }
            if (colorKey in style) {
              data2.setItemVisual(idx, "colorFromPalette", false);
            }
          }
        } : null
      };
    }
  };
  var dataColorPaletteTask = {
    performRawSeries: true,
    overallReset: function(ecModel) {
      var paletteScopeGroupByType = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var colorBy = seriesModel.getColorBy();
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var key2 = seriesModel.type + "-" + colorBy;
        var colorScope = paletteScopeGroupByType.get(key2);
        if (!colorScope) {
          colorScope = {};
          paletteScopeGroupByType.set(key2, colorScope);
        }
        inner$6(seriesModel).scope = colorScope;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        var dataAll = seriesModel.getRawData();
        var idxMap = {};
        var data = seriesModel.getData();
        var colorScope = inner$6(seriesModel).scope;
        var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
        var colorKey = getDefaultColorKey(seriesModel, stylePath);
        data.each(function(idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function(rawIdx) {
          var idx = idxMap[rawIdx];
          var fromPalette = data.getItemVisual(idx, "colorFromPalette");
          if (fromPalette) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
            var dataCount = dataAll.count();
            itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
          }
        });
      });
    }
  };
  var PI$1 = Math.PI;
  function defaultLoading(api2, opts) {
    opts = opts || {};
    defaults$1(opts, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var group = new Group$2();
    var mask = new Rect({
      style: {
        fill: opts.maskColor
      },
      zlevel: opts.zlevel,
      z: 1e4
    });
    group.add(mask);
    var textContent = new ZRText({
      style: {
        text: opts.text,
        fill: opts.textColor,
        fontSize: opts.fontSize,
        fontWeight: opts.fontWeight,
        fontStyle: opts.fontStyle,
        fontFamily: opts.fontFamily
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    var labelRect = new Rect({
      style: {
        fill: "none"
      },
      textContent,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    group.add(labelRect);
    var arc;
    if (opts.showSpinner) {
      arc = new Arc({
        shape: {
          startAngle: -PI$1 / 2,
          endAngle: -PI$1 / 2 + 0.1,
          r: opts.spinnerRadius
        },
        style: {
          stroke: opts.color,
          lineCap: "round",
          lineWidth: opts.lineWidth
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      arc.animateShape(true).when(1e3, {
        endAngle: PI$1 * 3 / 2
      }).start("circularInOut");
      arc.animateShape(true).when(1e3, {
        startAngle: PI$1 * 3 / 2
      }).delay(300).start("circularInOut");
      group.add(arc);
    }
    group.resize = function() {
      var textWidth = textContent.getBoundingRect().width;
      var r2 = opts.showSpinner ? opts.spinnerRadius : 0;
      var cx = (api2.getWidth() - r2 * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r2);
      var cy = api2.getHeight() / 2;
      opts.showSpinner && arc.setShape({
        cx,
        cy
      });
      labelRect.setShape({
        x: cx - r2,
        y: cy - r2,
        width: r2 * 2,
        height: r2 * 2
      });
      mask.setShape({
        x: 0,
        y: 0,
        width: api2.getWidth(),
        height: api2.getHeight()
      });
    };
    group.resize();
    return group;
  }
  var Scheduler = (
    /** @class */
    function() {
      function Scheduler2(ecInstance, api2, dataProcessorHandlers, visualHandlers) {
        this._stageTaskMap = createHashMap();
        this.ecInstance = ecInstance;
        this.api = api2;
        dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
        visualHandlers = this._visualHandlers = visualHandlers.slice();
        this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
      }
      Scheduler2.prototype.restoreData = function(ecModel, payload) {
        ecModel.restoreData(payload);
        this._stageTaskMap.each(function(taskRecord) {
          var overallTask = taskRecord.overallTask;
          overallTask && overallTask.dirty();
        });
      };
      Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
        if (!task.__pipeline) {
          return;
        }
        var pipeline = this._pipelineMap.get(task.__pipeline.id);
        var pCtx = pipeline.context;
        var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
        var step = incremental ? pipeline.step : null;
        var modDataCount = pCtx && pCtx.modDataCount;
        var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
        return {
          step,
          modBy,
          modDataCount
        };
      };
      Scheduler2.prototype.getPipeline = function(pipelineId) {
        return this._pipelineMap.get(pipelineId);
      };
      Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
        var pipeline = this._pipelineMap.get(seriesModel.uid);
        var data = seriesModel.getData();
        var dataLen = data.count();
        var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
        var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
        var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
        seriesModel.pipelineContext = pipeline.context = {
          progressiveRender,
          modDataCount,
          large
        };
      };
      Scheduler2.prototype.restorePipelines = function(ecModel) {
        var scheduler = this;
        var pipelineMap = scheduler._pipelineMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var progressive = seriesModel.getProgressive();
          var pipelineId = seriesModel.uid;
          pipelineMap.set(pipelineId, {
            id: pipelineId,
            head: null,
            tail: null,
            threshold: seriesModel.getProgressiveThreshold(),
            progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
            blockIndex: -1,
            step: Math.round(progressive || 700),
            count: 0
          });
          scheduler._pipe(seriesModel, seriesModel.dataTask);
        });
      };
      Scheduler2.prototype.prepareStageTasks = function() {
        var stageTaskMap = this._stageTaskMap;
        var ecModel = this.api.getModel();
        var api2 = this.api;
        each$4(this._allHandlers, function(handler) {
          var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
          var errMsg = "";
          assert(!(handler.reset && handler.overallReset), errMsg);
          handler.reset && this._createSeriesStageTask(handler, record, ecModel, api2);
          handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api2);
        }, this);
      };
      Scheduler2.prototype.prepareView = function(view, model, ecModel, api2) {
        var renderTask = view.renderTask;
        var context = renderTask.context;
        context.model = model;
        context.ecModel = ecModel;
        context.api = api2;
        renderTask.__block = !view.incrementalPrepareRender;
        this._pipe(model, renderTask);
      };
      Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
        this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
          block: true
        });
      };
      Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
        this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
      };
      Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
        opt = opt || {};
        var unfinished = false;
        var scheduler = this;
        each$4(stageHandlers, function(stageHandler, idx) {
          if (opt.visualType && opt.visualType !== stageHandler.visualType) {
            return;
          }
          var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
          var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
          var overallTask = stageHandlerRecord.overallTask;
          if (overallTask) {
            var overallNeedDirty_1;
            var agentStubMap = overallTask.agentStubMap;
            agentStubMap.each(function(stub) {
              if (needSetDirty(opt, stub)) {
                stub.dirty();
                overallNeedDirty_1 = true;
              }
            });
            overallNeedDirty_1 && overallTask.dirty();
            scheduler.updatePayload(overallTask, payload);
            var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
            agentStubMap.each(function(stub) {
              stub.perform(performArgs_1);
            });
            if (overallTask.perform(performArgs_1)) {
              unfinished = true;
            }
          } else if (seriesTaskMap) {
            seriesTaskMap.each(function(task, pipelineId) {
              if (needSetDirty(opt, task)) {
                task.dirty();
              }
              var performArgs = scheduler.getPerformArgs(task, opt.block);
              performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
              scheduler.updatePayload(task, payload);
              if (task.perform(performArgs)) {
                unfinished = true;
              }
            });
          }
        });
        function needSetDirty(opt2, task) {
          return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
        }
        this.unfinished = unfinished || this.unfinished;
      };
      Scheduler2.prototype.performSeriesTasks = function(ecModel) {
        var unfinished;
        ecModel.eachSeries(function(seriesModel) {
          unfinished = seriesModel.dataTask.perform() || unfinished;
        });
        this.unfinished = unfinished || this.unfinished;
      };
      Scheduler2.prototype.plan = function() {
        this._pipelineMap.each(function(pipeline) {
          var task = pipeline.tail;
          do {
            if (task.__block) {
              pipeline.blockIndex = task.__idxInPipeline;
              break;
            }
            task = task.getUpstream();
          } while (task);
        });
      };
      Scheduler2.prototype.updatePayload = function(task, payload) {
        payload !== "remain" && (task.context.payload = payload);
      };
      Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api2) {
        var scheduler = this;
        var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
        var seriesType2 = stageHandler.seriesType;
        var getTargetSeries = stageHandler.getTargetSeries;
        if (stageHandler.createOnAllSeries) {
          ecModel.eachRawSeries(create2);
        } else if (seriesType2) {
          ecModel.eachRawSeriesByType(seriesType2, create2);
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api2).each(create2);
        }
        function create2(seriesModel) {
          var pipelineId = seriesModel.uid;
          var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
            plan: seriesTaskPlan,
            reset: seriesTaskReset,
            count: seriesTaskCount
          }));
          task.context = {
            model: seriesModel,
            ecModel,
            api: api2,
            // PENDING: `useClearVisual` not used?
            useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
            plan: stageHandler.plan,
            reset: stageHandler.reset,
            scheduler
          };
          scheduler._pipe(seriesModel, task);
        }
      };
      Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api2) {
        var scheduler = this;
        var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
          reset: overallTaskReset
        });
        overallTask.context = {
          ecModel,
          api: api2,
          overallReset: stageHandler.overallReset,
          scheduler
        };
        var oldAgentStubMap = overallTask.agentStubMap;
        var newAgentStubMap = overallTask.agentStubMap = createHashMap();
        var seriesType2 = stageHandler.seriesType;
        var getTargetSeries = stageHandler.getTargetSeries;
        var overallProgress = true;
        var shouldOverallTaskDirty = false;
        var errMsg = "";
        assert(!stageHandler.createOnAllSeries, errMsg);
        if (seriesType2) {
          ecModel.eachRawSeriesByType(seriesType2, createStub);
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api2).each(createStub);
        } else {
          overallProgress = false;
          each$4(ecModel.getSeries(), createStub);
        }
        function createStub(seriesModel) {
          var pipelineId = seriesModel.uid;
          var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || // When the result of `getTargetSeries` changed, the overallTask
          // should be set as dirty and re-performed.
          (shouldOverallTaskDirty = true, createTask({
            reset: stubReset,
            onDirty: stubOnDirty
          })));
          stub.context = {
            model: seriesModel,
            overallProgress
            // FIXME:TS never used, so comment it
            // modifyOutputEnd: modifyOutputEnd
          };
          stub.agent = overallTask;
          stub.__block = overallProgress;
          scheduler._pipe(seriesModel, stub);
        }
        if (shouldOverallTaskDirty) {
          overallTask.dirty();
        }
      };
      Scheduler2.prototype._pipe = function(seriesModel, task) {
        var pipelineId = seriesModel.uid;
        var pipeline = this._pipelineMap.get(pipelineId);
        !pipeline.head && (pipeline.head = task);
        pipeline.tail && pipeline.tail.pipe(task);
        pipeline.tail = task;
        task.__idxInPipeline = pipeline.count++;
        task.__pipeline = pipeline;
      };
      Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
        if (isFunction$1(stageHandler)) {
          stageHandler = {
            overallReset: stageHandler,
            seriesType: detectSeriseType(stageHandler)
          };
        }
        stageHandler.uid = getUID("stageHandler");
        visualType && (stageHandler.visualType = visualType);
        return stageHandler;
      };
      return Scheduler2;
    }()
  );
  function overallTaskReset(context) {
    context.overallReset(context.ecModel, context.api, context.payload);
  }
  function stubReset(context) {
    return context.overallProgress && stubProgress;
  }
  function stubProgress() {
    this.agent.dirty();
    this.getDownstream().dirty();
  }
  function stubOnDirty() {
    this.agent && this.agent.dirty();
  }
  function seriesTaskPlan(context) {
    return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
  }
  function seriesTaskReset(context) {
    if (context.useClearVisual) {
      context.data.clearAllVisual();
    }
    var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
    return resetDefines.length > 1 ? map$1(resetDefines, function(v2, idx) {
      return makeSeriesTaskProgress(idx);
    }) : singleSeriesTaskProgress;
  }
  var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
  function makeSeriesTaskProgress(resetDefineIdx) {
    return function(params2, context) {
      var data = context.data;
      var resetDefine = context.resetDefines[resetDefineIdx];
      if (resetDefine && resetDefine.dataEach) {
        for (var i2 = params2.start; i2 < params2.end; i2++) {
          resetDefine.dataEach(data, i2);
        }
      } else if (resetDefine && resetDefine.progress) {
        resetDefine.progress(params2, data);
      }
    };
  }
  function seriesTaskCount(context) {
    return context.data.count();
  }
  function detectSeriseType(legacyFunc) {
    seriesType = null;
    try {
      legacyFunc(ecModelMock, apiMock);
    } catch (e2) {
    }
    return seriesType;
  }
  var ecModelMock = {};
  var apiMock = {};
  var seriesType;
  mockMethods(ecModelMock, GlobalModel);
  mockMethods(apiMock, ExtensionAPI);
  ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
    seriesType = type;
  };
  ecModelMock.eachComponent = function(cond) {
    if (cond.mainType === "series" && cond.subType) {
      seriesType = cond.subType;
    }
  };
  function mockMethods(target, Clz) {
    for (var name_1 in Clz.prototype) {
      target[name_1] = noop$1;
    }
  }
  var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
  const lightTheme = {
    color: colorAll,
    colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
  };
  var contrastColor = "#B9B8CE";
  var backgroundColor = "#100C2A";
  var axisCommon = function() {
    return {
      axisLine: {
        lineStyle: {
          color: contrastColor
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  };
  var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
  var theme = {
    darkMode: true,
    color: colorPalette,
    backgroundColor,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        // TODO Contrast of label backgorundColor
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: contrastColor
      },
      pageTextStyle: {
        color: contrastColor
      }
    },
    textStyle: {
      color: contrastColor
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: contrastColor
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: contrastColor
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: contrastColor
      }
    },
    timeline: {
      lineStyle: {
        color: contrastColor
      },
      label: {
        color: contrastColor
      },
      controlStyle: {
        color: contrastColor,
        borderColor: contrastColor
      }
    },
    calendar: {
      itemStyle: {
        color: backgroundColor
      },
      dayLabel: {
        color: contrastColor
      },
      monthLabel: {
        color: contrastColor
      },
      yearLabel: {
        color: contrastColor
      }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: colorPalette
    },
    gauge: {
      title: {
        color: contrastColor
      },
      axisLine: {
        lineStyle: {
          color: [[1, "rgba(207,212,219,0.2)"]]
        }
      },
      axisLabel: {
        color: contrastColor
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
        // borderColor: '#ca2824',
        // borderColor0: '#09a443'
      }
    }
  };
  theme.categoryAxis.splitLine.show = false;
  var ECEventProcessor = (
    /** @class */
    function() {
      function ECEventProcessor2() {
      }
      ECEventProcessor2.prototype.normalizeQuery = function(query) {
        var cptQuery = {};
        var dataQuery = {};
        var otherQuery = {};
        if (isString$1(query)) {
          var condCptType = parseClassType(query);
          cptQuery.mainType = condCptType.main || null;
          cptQuery.subType = condCptType.sub || null;
        } else {
          var suffixes_1 = ["Index", "Name", "Id"];
          var dataKeys_1 = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          };
          each$4(query, function(val, key2) {
            var reserved = false;
            for (var i2 = 0; i2 < suffixes_1.length; i2++) {
              var propSuffix = suffixes_1[i2];
              var suffixPos = key2.lastIndexOf(propSuffix);
              if (suffixPos > 0 && suffixPos === key2.length - propSuffix.length) {
                var mainType = key2.slice(0, suffixPos);
                if (mainType !== "data") {
                  cptQuery.mainType = mainType;
                  cptQuery[propSuffix.toLowerCase()] = val;
                  reserved = true;
                }
              }
            }
            if (dataKeys_1.hasOwnProperty(key2)) {
              dataQuery[key2] = val;
              reserved = true;
            }
            if (!reserved) {
              otherQuery[key2] = val;
            }
          });
        }
        return {
          cptQuery,
          dataQuery,
          otherQuery
        };
      };
      ECEventProcessor2.prototype.filter = function(eventType2, query) {
        var eventInfo = this.eventInfo;
        if (!eventInfo) {
          return true;
        }
        var targetEl = eventInfo.targetEl;
        var packedEvent = eventInfo.packedEvent;
        var model = eventInfo.model;
        var view = eventInfo.view;
        if (!model || !view) {
          return true;
        }
        var cptQuery = query.cptQuery;
        var dataQuery = query.dataQuery;
        return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType2, query.otherQuery, targetEl, packedEvent));
        function check(query2, host, prop, propOnHost) {
          return query2[prop] == null || host[propOnHost || prop] === query2[prop];
        }
      };
      ECEventProcessor2.prototype.afterTrigger = function() {
        this.eventInfo = null;
      };
      return ECEventProcessor2;
    }()
  );
  var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
  var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
  var seriesSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      if (seriesModel.legendIcon) {
        data.setVisual("legendIcon", seriesModel.legendIcon);
      }
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      var symbolOptions = {};
      var symbolOptionsCb = {};
      var hasCallback = false;
      for (var i2 = 0; i2 < SYMBOL_PROPS_WITH_CB.length; i2++) {
        var symbolPropName = SYMBOL_PROPS_WITH_CB[i2];
        var val = seriesModel.get(symbolPropName);
        if (isFunction$1(val)) {
          hasCallback = true;
          symbolOptionsCb[symbolPropName] = val;
        } else {
          symbolOptions[symbolPropName] = val;
        }
      }
      symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
      data.setVisual(extend$1({
        legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
        symbolKeepAspect: seriesModel.get("symbolKeepAspect")
      }, symbolOptions));
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var symbolPropsCb = keys(symbolOptionsCb);
      function dataEach(data2, idx) {
        var rawValue = seriesModel.getRawValue(idx);
        var params2 = seriesModel.getDataParams(idx);
        for (var i3 = 0; i3 < symbolPropsCb.length; i3++) {
          var symbolPropName2 = symbolPropsCb[i3];
          data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params2));
        }
      }
      return {
        dataEach: hasCallback ? dataEach : null
      };
    }
  };
  var dataSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      function dataEach(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        for (var i2 = 0; i2 < SYMBOL_PROPS.length; i2++) {
          var symbolPropName = SYMBOL_PROPS[i2];
          var val = itemModel.getShallow(symbolPropName, true);
          if (val != null) {
            data2.setItemVisual(idx, symbolPropName, val);
          }
        }
      }
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  };
  function getItemVisualFromData(data, dataIndex, key2) {
    switch (key2) {
      case "color":
        var style = data.getItemVisual(dataIndex, "style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getItemVisual(dataIndex, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getItemVisual(dataIndex, key2);
    }
  }
  function getVisualFromData(data, key2) {
    switch (key2) {
      case "color":
        var style = data.getVisual("style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getVisual(key2);
    }
  }
  function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
    function getSeriesIndices(ecModel, payload) {
      var seriesIndices = [];
      ecModel.eachComponent({
        mainType: "series",
        subType: seriesType2,
        query: payload
      }, function(seriesModel) {
        seriesIndices.push(seriesModel.seriesIndex);
      });
      return seriesIndices;
    }
    each$4([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
      ecRegisterAction(eventsMap[0], function(payload, ecModel, api2) {
        payload = extend$1({}, payload);
        api2.dispatchAction(extend$1(payload, {
          type: eventsMap[1],
          seriesIndex: getSeriesIndices(ecModel, payload)
        }));
      });
    });
  }
  function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
    var legacyEventName = type + eventPostfix;
    if (!ecIns.isSilent(legacyEventName)) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "pie"
      }, function(seriesModel) {
        var seriesIndex = seriesModel.seriesIndex;
        var selectedMap = seriesModel.option.selectedMap;
        var selected = payload.selected;
        for (var i2 = 0; i2 < selected.length; i2++) {
          if (selected[i2].seriesIndex === seriesIndex) {
            var data = seriesModel.getData();
            var dataIndex = queryDataIndex(data, payload.fromActionPayload);
            ecIns.trigger(legacyEventName, {
              type: legacyEventName,
              seriesId: seriesModel.id,
              name: isArray$1(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
              selected: isString$1(selectedMap) ? selectedMap : extend$1({}, selectedMap)
            });
          }
        }
      });
    }
  }
  function handleLegacySelectEvents(messageCenter, ecIns, api2) {
    messageCenter.on("selectchanged", function(params2) {
      var ecModel = api2.getModel();
      if (params2.isFromClick) {
        handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params2);
        handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params2);
      } else if (params2.fromAction === "select") {
        handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params2);
        handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params2);
      } else if (params2.fromAction === "unselect") {
        handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params2);
        handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params2);
      }
    });
  }
  function findEventDispatcher(target, det, returnFirstMatch) {
    var found;
    while (target) {
      if (det(target)) {
        found = target;
        if (returnFirstMatch) {
          break;
        }
      }
      target = target.__hostTarget || target.parent;
    }
    return found;
  }
  var wmUniqueIndex = Math.round(Math.random() * 9);
  var supportDefineProperty = typeof Object.defineProperty === "function";
  var WeakMap$1 = function() {
    function WeakMap2() {
      this._id = "__ec_inner_" + wmUniqueIndex++;
    }
    WeakMap2.prototype.get = function(key2) {
      return this._guard(key2)[this._id];
    };
    WeakMap2.prototype.set = function(key2, value) {
      var target = this._guard(key2);
      if (supportDefineProperty) {
        Object.defineProperty(target, this._id, {
          value,
          enumerable: false,
          configurable: true
        });
      } else {
        target[this._id] = value;
      }
      return this;
    };
    WeakMap2.prototype["delete"] = function(key2) {
      if (this.has(key2)) {
        delete this._guard(key2)[this._id];
        return true;
      }
      return false;
    };
    WeakMap2.prototype.has = function(key2) {
      return !!this._guard(key2)[this._id];
    };
    WeakMap2.prototype._guard = function(key2) {
      if (key2 !== Object(key2)) {
        throw TypeError("Value of WeakMap is not a non-null object.");
      }
      return key2;
    };
    return WeakMap2;
  }();
  var Triangle = Path.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy + height);
      path.lineTo(cx - width, cy + height);
      path.closePath();
    }
  });
  var Diamond = Path.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy);
      path.lineTo(cx, cy + height);
      path.lineTo(cx - width, cy);
      path.closePath();
    }
  });
  var Pin = Path.extend({
    type: "pin",
    shape: {
      // x, y on the cusp
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var x2 = shape.x;
      var y2 = shape.y;
      var w2 = shape.width / 5 * 3;
      var h2 = Math.max(w2, shape.height);
      var r2 = w2 / 2;
      var dy = r2 * r2 / (h2 - r2);
      var cy = y2 - h2 + r2 + dy;
      var angle = Math.asin(dy / r2);
      var dx = Math.cos(angle) * r2;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      var cpLen = r2 * 0.6;
      var cpLen2 = r2 * 0.7;
      path.moveTo(x2 - dx, cy + dy);
      path.arc(x2, cy, r2, Math.PI - angle, Math.PI * 2 + angle);
      path.bezierCurveTo(x2 + dx - tanX * cpLen, cy + dy + tanY * cpLen, x2, y2 - cpLen2, x2, y2);
      path.bezierCurveTo(x2, y2 - cpLen2, x2 - dx + tanX * cpLen, cy + dy + tanY * cpLen, x2 - dx, cy + dy);
      path.closePath();
    }
  });
  var Arrow = Path.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x2 = shape.x;
      var y2 = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + dx, y2 + height);
      ctx.lineTo(x2, y2 + height / 4 * 3);
      ctx.lineTo(x2 - dx, y2 + height);
      ctx.lineTo(x2, y2);
      ctx.closePath();
    }
  });
  var symbolCtors = {
    line: Line,
    rect: Rect,
    roundRect: Rect,
    square: Rect,
    circle: Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function(x2, y2, w2, h2, shape) {
      shape.x1 = x2;
      shape.y1 = y2 + h2 / 2;
      shape.x2 = x2 + w2;
      shape.y2 = y2 + h2 / 2;
    },
    rect: function(x2, y2, w2, h2, shape) {
      shape.x = x2;
      shape.y = y2;
      shape.width = w2;
      shape.height = h2;
    },
    roundRect: function(x2, y2, w2, h2, shape) {
      shape.x = x2;
      shape.y = y2;
      shape.width = w2;
      shape.height = h2;
      shape.r = Math.min(w2, h2) / 4;
    },
    square: function(x2, y2, w2, h2, shape) {
      var size = Math.min(w2, h2);
      shape.x = x2;
      shape.y = y2;
      shape.width = size;
      shape.height = size;
    },
    circle: function(x2, y2, w2, h2, shape) {
      shape.cx = x2 + w2 / 2;
      shape.cy = y2 + h2 / 2;
      shape.r = Math.min(w2, h2) / 2;
    },
    diamond: function(x2, y2, w2, h2, shape) {
      shape.cx = x2 + w2 / 2;
      shape.cy = y2 + h2 / 2;
      shape.width = w2;
      shape.height = h2;
    },
    pin: function(x2, y2, w2, h2, shape) {
      shape.x = x2 + w2 / 2;
      shape.y = y2 + h2 / 2;
      shape.width = w2;
      shape.height = h2;
    },
    arrow: function(x2, y2, w2, h2, shape) {
      shape.x = x2 + w2 / 2;
      shape.y = y2 + h2 / 2;
      shape.width = w2;
      shape.height = h2;
    },
    triangle: function(x2, y2, w2, h2, shape) {
      shape.cx = x2 + w2 / 2;
      shape.cy = y2 + h2 / 2;
      shape.width = w2;
      shape.height = h2;
    }
  };
  var symbolBuildProxies = {};
  each$4(symbolCtors, function(Ctor, name) {
    symbolBuildProxies[name] = new Ctor();
  });
  var SymbolClz = Path.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(out2, config, rect) {
      var res = calculateTextPosition(out2, config, rect);
      var shape = this.shape;
      if (shape && shape.symbolType === "pin" && config.position === "inside") {
        res.y = rect.y + rect.height * 0.4;
      }
      return res;
    },
    buildPath: function(ctx, shape, inBundle) {
      var symbolType = shape.symbolType;
      if (symbolType !== "none") {
        var proxySymbol = symbolBuildProxies[symbolType];
        if (!proxySymbol) {
          symbolType = "rect";
          proxySymbol = symbolBuildProxies[symbolType];
        }
        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  });
  function symbolPathSetColor(color2, innerColor2) {
    if (this.type !== "image") {
      var symbolStyle = this.style;
      if (this.__isEmptyBrush) {
        symbolStyle.stroke = color2;
        symbolStyle.fill = innerColor2 || "#fff";
        symbolStyle.lineWidth = 2;
      } else if (this.shape.symbolType === "line") {
        symbolStyle.stroke = color2;
      } else {
        symbolStyle.fill = color2;
      }
      this.markRedraw();
    }
  }
  function createSymbol(symbolType, x2, y2, w2, h2, color2, keepAspect) {
    var isEmpty2 = symbolType.indexOf("empty") === 0;
    if (isEmpty2) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }
    var symbolPath;
    if (symbolType.indexOf("image://") === 0) {
      symbolPath = makeImage(symbolType.slice(8), new BoundingRect(x2, y2, w2, h2), keepAspect ? "center" : "cover");
    } else if (symbolType.indexOf("path://") === 0) {
      symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect(x2, y2, w2, h2), keepAspect ? "center" : "cover");
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType,
          x: x2,
          y: y2,
          width: w2,
          height: h2
        }
      });
    }
    symbolPath.__isEmptyBrush = isEmpty2;
    symbolPath.setColor = symbolPathSetColor;
    if (color2) {
      symbolPath.setColor(color2);
    }
    return symbolPath;
  }
  function normalizeSymbolSize(symbolSize) {
    if (!isArray$1(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return [symbolSize[0] || 0, symbolSize[1] || 0];
  }
  function normalizeSymbolOffset(symbolOffset, symbolSize) {
    if (symbolOffset == null) {
      return;
    }
    if (!isArray$1(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
  }
  function isSafeNum(num) {
    return isFinite(num);
  }
  function createLinearGradient(ctx, obj2, rect) {
    var x2 = obj2.x == null ? 0 : obj2.x;
    var x22 = obj2.x2 == null ? 1 : obj2.x2;
    var y2 = obj2.y == null ? 0 : obj2.y;
    var y22 = obj2.y2 == null ? 0 : obj2.y2;
    if (!obj2.global) {
      x2 = x2 * rect.width + rect.x;
      x22 = x22 * rect.width + rect.x;
      y2 = y2 * rect.height + rect.y;
      y22 = y22 * rect.height + rect.y;
    }
    x2 = isSafeNum(x2) ? x2 : 0;
    x22 = isSafeNum(x22) ? x22 : 1;
    y2 = isSafeNum(y2) ? y2 : 0;
    y22 = isSafeNum(y22) ? y22 : 0;
    var canvasGradient = ctx.createLinearGradient(x2, y2, x22, y22);
    return canvasGradient;
  }
  function createRadialGradient(ctx, obj2, rect) {
    var width = rect.width;
    var height = rect.height;
    var min3 = Math.min(width, height);
    var x2 = obj2.x == null ? 0.5 : obj2.x;
    var y2 = obj2.y == null ? 0.5 : obj2.y;
    var r2 = obj2.r == null ? 0.5 : obj2.r;
    if (!obj2.global) {
      x2 = x2 * width + rect.x;
      y2 = y2 * height + rect.y;
      r2 = r2 * min3;
    }
    x2 = isSafeNum(x2) ? x2 : 0.5;
    y2 = isSafeNum(y2) ? y2 : 0.5;
    r2 = r2 >= 0 && isSafeNum(r2) ? r2 : 0.5;
    var canvasGradient = ctx.createRadialGradient(x2, y2, 0, x2, y2, r2);
    return canvasGradient;
  }
  function getCanvasGradient(ctx, obj2, rect) {
    var canvasGradient = obj2.type === "radial" ? createRadialGradient(ctx, obj2, rect) : createLinearGradient(ctx, obj2, rect);
    var colorStops = obj2.colorStops;
    for (var i2 = 0; i2 < colorStops.length; i2++) {
      canvasGradient.addColorStop(colorStops[i2].offset, colorStops[i2].color);
    }
    return canvasGradient;
  }
  function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
      return false;
    }
    if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
      return true;
    }
    for (var i2 = 0; i2 < clipPaths.length; i2++) {
      if (clipPaths[i2] !== prevClipPaths[i2]) {
        return true;
      }
    }
    return false;
  }
  function parseInt10(val) {
    return parseInt(val, 10);
  }
  function getSize(root2, whIdx, opts) {
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var stl = document.defaultView.getComputedStyle(root2);
    return (root2[cwh] || parseInt10(stl[wh]) || parseInt10(root2.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  }
  function normalizeLineDash(lineType, lineWidth) {
    if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
      return null;
    }
    return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber$1(lineType) ? [lineType] : isArray$1(lineType) ? lineType : null;
  }
  function getLineDash(el) {
    var style = el.style;
    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
    var lineDashOffset = style.lineDashOffset;
    if (lineDash) {
      var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
      if (lineScale_1 && lineScale_1 !== 1) {
        lineDash = map$1(lineDash, function(rawVal) {
          return rawVal / lineScale_1;
        });
        lineDashOffset /= lineScale_1;
      }
    }
    return [lineDash, lineDashOffset];
  }
  var pathProxyForDraw = new PathProxy(true);
  function styleHasStroke(style) {
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  }
  function isValidStrokeFillStyle(strokeOrFill) {
    return typeof strokeOrFill === "string" && strokeOrFill !== "none";
  }
  function styleHasFill(style) {
    var fill = style.fill;
    return fill != null && fill !== "none";
  }
  function doFillPath(ctx, style) {
    if (style.fillOpacity != null && style.fillOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.fillOpacity * style.opacity;
      ctx.fill();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.fill();
    }
  }
  function doStrokePath(ctx, style) {
    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.strokeOpacity * style.opacity;
      ctx.stroke();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.stroke();
    }
  }
  function createCanvasPattern(ctx, pattern, el) {
    var image = createOrUpdateImage(pattern.image, pattern.__image, el);
    if (isImageReady(image)) {
      var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
      if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
        var matrix2 = new DOMMatrix();
        matrix2.translateSelf(pattern.x || 0, pattern.y || 0);
        matrix2.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
        matrix2.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
        canvasPattern.setTransform(matrix2);
      }
      return canvasPattern;
    }
  }
  function brushPath(ctx, el, style, inBatch) {
    var _a2;
    var hasStroke = styleHasStroke(style);
    var hasFill = styleHasFill(style);
    var strokePercent = style.strokePercent;
    var strokePart = strokePercent < 1;
    var firstDraw = !el.path;
    if ((!el.silent || strokePart) && firstDraw) {
      el.createPathProxy();
    }
    var path = el.path || pathProxyForDraw;
    var dirtyFlag = el.__dirty;
    if (!inBatch) {
      var fill = style.fill;
      var stroke = style.stroke;
      var hasFillGradient = hasFill && !!fill.colorStops;
      var hasStrokeGradient = hasStroke && !!stroke.colorStops;
      var hasFillPattern = hasFill && !!fill.image;
      var hasStrokePattern = hasStroke && !!stroke.image;
      var fillGradient = void 0;
      var strokeGradient = void 0;
      var fillPattern = void 0;
      var strokePattern = void 0;
      var rect = void 0;
      if (hasFillGradient || hasStrokeGradient) {
        rect = el.getBoundingRect();
      }
      if (hasFillGradient) {
        fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
        el.__canvasFillGradient = fillGradient;
      }
      if (hasStrokeGradient) {
        strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
        el.__canvasStrokeGradient = strokeGradient;
      }
      if (hasFillPattern) {
        fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
        el.__canvasFillPattern = fillPattern;
      }
      if (hasStrokePattern) {
        strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
        el.__canvasStrokePattern = fillPattern;
      }
      if (hasFillGradient) {
        ctx.fillStyle = fillGradient;
      } else if (hasFillPattern) {
        if (fillPattern) {
          ctx.fillStyle = fillPattern;
        } else {
          hasFill = false;
        }
      }
      if (hasStrokeGradient) {
        ctx.strokeStyle = strokeGradient;
      } else if (hasStrokePattern) {
        if (strokePattern) {
          ctx.strokeStyle = strokePattern;
        } else {
          hasStroke = false;
        }
      }
    }
    var scale2 = el.getGlobalScale();
    path.setScale(scale2[0], scale2[1], el.segmentIgnoreThreshold);
    var lineDash;
    var lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    var needsRebuild = true;
    if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
      path.setDPR(ctx.dpr);
      if (strokePart) {
        path.setContext(null);
      } else {
        path.setContext(ctx);
        needsRebuild = false;
      }
      path.reset();
      el.buildPath(path, el.shape, inBatch);
      path.toStatic();
      el.pathUpdated();
    }
    if (needsRebuild) {
      path.rebuildPath(ctx, strokePart ? strokePercent : 1);
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (!inBatch) {
      if (style.strokeFirst) {
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
        if (hasFill) {
          doFillPath(ctx, style);
        }
      } else {
        if (hasFill) {
          doFillPath(ctx, style);
        }
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
  function brushImage(ctx, el, style) {
    var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
    if (!image || !isImageReady(image)) {
      return;
    }
    var x2 = style.x || 0;
    var y2 = style.y || 0;
    var width = el.getWidth();
    var height = el.getHeight();
    var aspect = image.width / image.height;
    if (width == null && height != null) {
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    }
    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x2, y2, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x2, y2, width, height);
    } else {
      ctx.drawImage(image, x2, y2, width, height);
    }
  }
  function brushText(ctx, el, style) {
    var _a2;
    var text = style.text;
    text != null && (text += "");
    if (text) {
      ctx.font = style.font || DEFAULT_FONT;
      ctx.textAlign = style.textAlign;
      ctx.textBaseline = style.textBaseline;
      var lineDash = void 0;
      var lineDashOffset = void 0;
      if (ctx.setLineDash && style.lineDash) {
        _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      }
      if (lineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
      }
      if (style.strokeFirst) {
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
      } else {
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
      }
      if (lineDash) {
        ctx.setLineDash([]);
      }
    }
  }
  var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  var STROKE_PROPS = [
    ["lineCap", "butt"],
    ["lineJoin", "miter"],
    ["miterLimit", 10]
  ];
  function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
    var styleChanged = false;
    if (!forceSetAll) {
      prevStyle = prevStyle || {};
      if (style === prevStyle) {
        return false;
      }
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
      var opacity = Math.max(Math.min(style.opacity, 1), 0);
      ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
    }
    if (forceSetAll || style.blend !== prevStyle.blend) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
    }
    for (var i2 = 0; i2 < SHADOW_NUMBER_PROPS.length; i2++) {
      var propName = SHADOW_NUMBER_PROPS[i2];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = ctx.dpr * (style[propName] || 0);
      }
    }
    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
    }
    return styleChanged;
  }
  function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
    var style = getStyle(el, scope.inHover);
    var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
    if (style === prevStyle) {
      return false;
    }
    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
    if (forceSetAll || style.fill !== prevStyle.fill) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
    }
    if (forceSetAll || style.stroke !== prevStyle.stroke) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }
    if (el.hasStroke()) {
      var lineWidth = style.lineWidth;
      var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
      if (ctx.lineWidth !== newLineWidth) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx.lineWidth = newLineWidth;
      }
    }
    for (var i2 = 0; i2 < STROKE_PROPS.length; i2++) {
      var prop = STROKE_PROPS[i2];
      var propName = prop[0];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = style[propName] || prop[1];
      }
    }
    return styleChanged;
  }
  function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
  }
  function setContextTransform(ctx, el) {
    var m2 = el.transform;
    var dpr2 = ctx.dpr || 1;
    if (m2) {
      ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
    } else {
      ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
    }
  }
  function updateClipStatus(clipPaths, ctx, scope) {
    var allClipped = false;
    for (var i2 = 0; i2 < clipPaths.length; i2++) {
      var clipPath = clipPaths[i2];
      allClipped = allClipped || clipPath.isZeroArea();
      setContextTransform(ctx, clipPath);
      ctx.beginPath();
      clipPath.buildPath(ctx, clipPath.shape);
      ctx.clip();
    }
    scope.allClipped = allClipped;
  }
  function isTransformChanged(m0, m1) {
    if (m0 && m1) {
      return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
    } else if (!m0 && !m1) {
      return false;
    }
    return true;
  }
  var DRAW_TYPE_PATH = 1;
  var DRAW_TYPE_IMAGE = 2;
  var DRAW_TYPE_TEXT = 3;
  var DRAW_TYPE_INCREMENTAL = 4;
  function canPathBatch(style) {
    var hasFill = styleHasFill(style);
    var hasStroke = styleHasStroke(style);
    return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
  }
  function flushPathDrawn(ctx, scope) {
    scope.batchFill && ctx.fill();
    scope.batchStroke && ctx.stroke();
    scope.batchFill = "";
    scope.batchStroke = "";
  }
  function getStyle(el, inHover) {
    return inHover ? el.__hoverStyle || el.style : el.style;
  }
  function brushSingle(ctx, el) {
    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
  }
  function brush(ctx, el, scope, isLast) {
    var m2 = el.transform;
    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
      el.__dirty &= ~REDRAW_BIT;
      el.__isRendered = false;
      return;
    }
    var clipPaths = el.__clipPaths;
    var prevElClipPaths = scope.prevElClipPaths;
    var forceSetTransform = false;
    var forceSetStyle = false;
    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
      if (prevElClipPaths && prevElClipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.restore();
        forceSetStyle = forceSetTransform = true;
        scope.prevElClipPaths = null;
        scope.allClipped = false;
        scope.prevEl = null;
      }
      if (clipPaths && clipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.save();
        updateClipStatus(clipPaths, ctx, scope);
        forceSetTransform = true;
      }
      scope.prevElClipPaths = clipPaths;
    }
    if (scope.allClipped) {
      el.__isRendered = false;
      return;
    }
    el.beforeBrush && el.beforeBrush();
    el.innerBeforeBrush();
    var prevEl = scope.prevEl;
    if (!prevEl) {
      forceSetStyle = forceSetTransform = true;
    }
    var canBatchPath = el instanceof Path && el.autoBatch && canPathBatch(el.style);
    if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
      flushPathDrawn(ctx, scope);
      setContextTransform(ctx, el);
    } else if (!canBatchPath) {
      flushPathDrawn(ctx, scope);
    }
    var style = getStyle(el, scope.inHover);
    if (el instanceof Path) {
      if (scope.lastDrawType !== DRAW_TYPE_PATH) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_PATH;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
        ctx.beginPath();
      }
      brushPath(ctx, el, style, canBatchPath);
      if (canBatchPath) {
        scope.batchFill = style.fill || "";
        scope.batchStroke = style.stroke || "";
      }
    } else {
      if (el instanceof TSpan) {
        if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_TEXT;
        }
        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushText(ctx, el, style);
      } else if (el instanceof ZRImage) {
        if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_IMAGE;
        }
        bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushImage(ctx, el, style);
      } else if (el.getTemporalDisplayables) {
        if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
        }
        brushIncremental(ctx, el, scope);
      }
    }
    if (canBatchPath && isLast) {
      flushPathDrawn(ctx, scope);
    }
    el.innerAfterBrush();
    el.afterBrush && el.afterBrush();
    scope.prevEl = el;
    el.__dirty = 0;
    el.__isRendered = true;
  }
  function brushIncremental(ctx, el, scope) {
    var displayables = el.getDisplayables();
    var temporalDisplayables = el.getTemporalDisplayables();
    ctx.save();
    var innerScope = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: scope.viewWidth,
      viewHeight: scope.viewHeight,
      inHover: scope.inHover
    };
    var i2;
    var len2;
    for (i2 = el.getCursor(), len2 = displayables.length; i2 < len2; i2++) {
      var displayable = displayables[i2];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i2 === len2 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
      var displayable = temporalDisplayables[i_1];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    el.clearTemporalDisplayables();
    el.notClear = true;
    ctx.restore();
  }
  var decalMap = new WeakMap$1();
  var decalCache = new LRU(100);
  var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
  function createOrUpdatePatternFromDecal(decalObject, api2) {
    if (decalObject === "none") {
      return null;
    }
    var dpr2 = api2.getDevicePixelRatio();
    var zr = api2.getZr();
    var isSVG = zr.painter.type === "svg";
    if (decalObject.dirty) {
      decalMap["delete"](decalObject);
    }
    var oldPattern = decalMap.get(decalObject);
    if (oldPattern) {
      return oldPattern;
    }
    var decalOpt = defaults$1(decalObject, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    if (decalOpt.backgroundColor === "none") {
      decalOpt.backgroundColor = null;
    }
    var pattern = {
      repeat: "repeat"
    };
    setPatternnSource(pattern);
    pattern.rotation = decalOpt.rotation;
    pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
    decalMap.set(decalObject, pattern);
    decalObject.dirty = false;
    return pattern;
    function setPatternnSource(pattern22) {
      var keys2 = [dpr2];
      var isValidKey = true;
      for (var i2 = 0; i2 < decalKeys.length; ++i2) {
        var value = decalOpt[decalKeys[i2]];
        if (value != null && !isArray$1(value) && !isString$1(value) && !isNumber$1(value) && typeof value !== "boolean") {
          isValidKey = false;
          break;
        }
        keys2.push(value);
      }
      var cacheKey;
      if (isValidKey) {
        cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
        var cache2 = decalCache.get(cacheKey);
        if (cache2) {
          isSVG ? pattern22.svgElement = cache2 : pattern22.image = cache2;
        }
      }
      var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
      var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
      var symbolArray = normalizeSymbolArray(decalOpt.symbol);
      var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
      var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
      var canvas = !isSVG && platformApi.createCanvas();
      var svgRoot = isSVG && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      };
      var pSize = getPatternSize();
      var ctx;
      if (canvas) {
        canvas.width = pSize.width * dpr2;
        canvas.height = pSize.height * dpr2;
        ctx = canvas.getContext("2d");
      }
      brushDecal();
      if (isValidKey) {
        decalCache.put(cacheKey, canvas || svgRoot);
      }
      pattern22.image = canvas;
      pattern22.svgElement = svgRoot;
      pattern22.svgWidth = pSize.width;
      pattern22.svgHeight = pSize.height;
      function getPatternSize() {
        var width = 1;
        for (var i22 = 0, xlen = lineBlockLengthsX.length; i22 < xlen; ++i22) {
          width = getLeastCommonMultiple(width, lineBlockLengthsX[i22]);
        }
        var symbolRepeats = 1;
        for (var i22 = 0, xlen = symbolArray.length; i22 < xlen; ++i22) {
          symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i22].length);
        }
        width *= symbolRepeats;
        var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
        return {
          width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
          height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
        };
      }
      function brushDecal() {
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (decalOpt.backgroundColor) {
            ctx.fillStyle = decalOpt.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        var ySum = 0;
        for (var i22 = 0; i22 < dashArrayY.length; ++i22) {
          ySum += dashArrayY[i22];
        }
        if (ySum <= 0) {
          return;
        }
        var y2 = -lineBlockLengthY;
        var yId = 0;
        var yIdTotal = 0;
        var xId0 = 0;
        while (y2 < pSize.height) {
          if (yId % 2 === 0) {
            var symbolYId = yIdTotal / 2 % symbolArray.length;
            var x2 = 0;
            var xId1 = 0;
            var xId1Total = 0;
            while (x2 < pSize.width * 2) {
              var xSum = 0;
              for (var i22 = 0; i22 < dashArrayX[xId0].length; ++i22) {
                xSum += dashArrayX[xId0][i22];
              }
              if (xSum <= 0) {
                break;
              }
              if (xId1 % 2 === 0) {
                var size = (1 - decalOpt.symbolSize) * 0.5;
                var left = x2 + dashArrayX[xId0][xId1] * size;
                var top_1 = y2 + dashArrayY[yId] * size;
                var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
                var height = dashArrayY[yId] * decalOpt.symbolSize;
                var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
                brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
              }
              x2 += dashArrayX[xId0][xId1];
              ++xId1Total;
              ++xId1;
              if (xId1 === dashArrayX[xId0].length) {
                xId1 = 0;
              }
            }
            ++xId0;
            if (xId0 === dashArrayX.length) {
              xId0 = 0;
            }
          }
          y2 += dashArrayY[yId];
          ++yIdTotal;
          ++yId;
          if (yId === dashArrayY.length) {
            yId = 0;
          }
        }
        function brushSymbol(x22, y22, width2, height2, symbolType) {
          var scale2 = isSVG ? 1 : dpr2;
          var symbol = createSymbol(symbolType, x22 * scale2, y22 * scale2, width2 * scale2, height2 * scale2, decalOpt.color, decalOpt.symbolKeepAspect);
          if (isSVG) {
            var symbolVNode = zr.painter.renderOneToVNode(symbol);
            if (symbolVNode) {
              svgRoot.children.push(symbolVNode);
            }
          } else {
            brushSingle(ctx, symbol);
          }
        }
      }
    }
  }
  function normalizeSymbolArray(symbol) {
    if (!symbol || symbol.length === 0) {
      return [["rect"]];
    }
    if (isString$1(symbol)) {
      return [[symbol]];
    }
    var isAllString = true;
    for (var i2 = 0; i2 < symbol.length; ++i2) {
      if (!isString$1(symbol[i2])) {
        isAllString = false;
        break;
      }
    }
    if (isAllString) {
      return normalizeSymbolArray([symbol]);
    }
    var result = [];
    for (var i2 = 0; i2 < symbol.length; ++i2) {
      if (isString$1(symbol[i2])) {
        result.push([symbol[i2]]);
      } else {
        result.push(symbol[i2]);
      }
    }
    return result;
  }
  function normalizeDashArrayX(dash) {
    if (!dash || dash.length === 0) {
      return [[0, 0]];
    }
    if (isNumber$1(dash)) {
      var dashValue = Math.ceil(dash);
      return [[dashValue, dashValue]];
    }
    var isAllNumber = true;
    for (var i2 = 0; i2 < dash.length; ++i2) {
      if (!isNumber$1(dash[i2])) {
        isAllNumber = false;
        break;
      }
    }
    if (isAllNumber) {
      return normalizeDashArrayX([dash]);
    }
    var result = [];
    for (var i2 = 0; i2 < dash.length; ++i2) {
      if (isNumber$1(dash[i2])) {
        var dashValue = Math.ceil(dash[i2]);
        result.push([dashValue, dashValue]);
      } else {
        var dashValue = map$1(dash[i2], function(n2) {
          return Math.ceil(n2);
        });
        if (dashValue.length % 2 === 1) {
          result.push(dashValue.concat(dashValue));
        } else {
          result.push(dashValue);
        }
      }
    }
    return result;
  }
  function normalizeDashArrayY(dash) {
    if (!dash || typeof dash === "object" && dash.length === 0) {
      return [0, 0];
    }
    if (isNumber$1(dash)) {
      var dashValue_1 = Math.ceil(dash);
      return [dashValue_1, dashValue_1];
    }
    var dashValue = map$1(dash, function(n2) {
      return Math.ceil(n2);
    });
    return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
  }
  function getLineBlockLengthX(dash) {
    return map$1(dash, function(line2) {
      return getLineBlockLengthY(line2);
    });
  }
  function getLineBlockLengthY(dash) {
    var blockLength = 0;
    for (var i2 = 0; i2 < dash.length; ++i2) {
      blockLength += dash[i2];
    }
    if (dash.length % 2 === 1) {
      return blockLength * 2;
    }
    return blockLength;
  }
  function decalVisual(ecModel, api2) {
    ecModel.eachRawSeries(function(seriesModel) {
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      if (data.hasItemVisual()) {
        data.each(function(idx) {
          var decal2 = data.getItemVisual(idx, "decal");
          if (decal2) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api2);
          }
        });
      }
      var decal = data.getVisual("decal");
      if (decal) {
        var style = data.getVisual("style");
        style.decal = createOrUpdatePatternFromDecal(decal, api2);
      }
    });
  }
  var lifecycle = new Eventful();
  var implsStore = {};
  function registerImpl(name, impl) {
    implsStore[name] = impl;
  }
  function getImpl(name) {
    return implsStore[name];
  }
  var version = "5.6.0";
  var dependencies = {
    zrender: "5.6.1"
  };
  var TEST_FRAME_REMAIN_TIME = 1;
  var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
  var PRIORITY_PROCESSOR_DATASTACK = 900;
  var PRIORITY_PROCESSOR_FILTER = 1e3;
  var PRIORITY_PROCESSOR_DEFAULT = 2e3;
  var PRIORITY_PROCESSOR_STATISTIC = 5e3;
  var PRIORITY_VISUAL_LAYOUT = 1e3;
  var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
  var PRIORITY_VISUAL_GLOBAL = 2e3;
  var PRIORITY_VISUAL_CHART = 3e3;
  var PRIORITY_VISUAL_COMPONENT = 4e3;
  var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
  var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
  var PRIORITY_VISUAL_BRUSH = 5e3;
  var PRIORITY_VISUAL_ARIA = 6e3;
  var PRIORITY_VISUAL_DECAL = 7e3;
  var PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH,
      CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
      ARIA: PRIORITY_VISUAL_ARIA,
      DECAL: PRIORITY_VISUAL_DECAL
    }
  };
  var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
  var PENDING_UPDATE = "__pendingUpdate";
  var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
  var ACTION_REG = /^[a-zA-Z0-9_]+$/;
  var CONNECT_STATUS_KEY = "__connectUpdateStatus";
  var CONNECT_STATUS_PENDING = 0;
  var CONNECT_STATUS_UPDATING = 1;
  var CONNECT_STATUS_UPDATED = 2;
  function createRegisterEventWithLowercaseECharts(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.isDisposed()) {
        disposedWarning(this.id);
        return;
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function createRegisterEventWithLowercaseMessageCenter(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function toLowercaseNameAndCallEventful(host, method, args) {
    args[0] = args[0] && args[0].toLowerCase();
    return Eventful.prototype[method].apply(host, args);
  }
  var MessageCenter = (
    /** @class */
    function(_super) {
      __extends(MessageCenter2, _super);
      function MessageCenter2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return MessageCenter2;
    }(Eventful)
  );
  var messageCenterProto = MessageCenter.prototype;
  messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
  messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
  var prepare;
  var prepareView;
  var updateDirectly;
  var updateMethods;
  var doConvertPixel;
  var updateStreamModes;
  var doDispatchAction;
  var flushPendingActions;
  var triggerUpdatedEvent;
  var bindRenderedEvent;
  var bindMouseEvent;
  var render;
  var renderComponents;
  var renderSeries;
  var createExtensionAPI;
  var enableConnect;
  var markStatusToUpdate;
  var applyChangedStates;
  var ECharts = (
    /** @class */
    function(_super) {
      __extends(ECharts2, _super);
      function ECharts2(dom, theme2, opts) {
        var _this = _super.call(this, new ECEventProcessor()) || this;
        _this._chartsViews = [];
        _this._chartsMap = {};
        _this._componentsViews = [];
        _this._componentsMap = {};
        _this._pendingActions = [];
        opts = opts || {};
        if (isString$1(theme2)) {
          theme2 = themeStorage[theme2];
        }
        _this._dom = dom;
        var defaultRenderer = "canvas";
        var defaultCoarsePointer = "auto";
        var defaultUseDirtyRect = false;
        if (opts.ssr) {
          registerSSRDataGetter(function(el) {
            var ecData = getECData(el);
            var dataIndex = ecData.dataIndex;
            if (dataIndex == null) {
              return;
            }
            var hashMap = createHashMap();
            hashMap.set("series_index", ecData.seriesIndex);
            hashMap.set("data_index", dataIndex);
            ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
            return hashMap;
          });
        }
        var zr = _this._zr = init$1(dom, {
          renderer: opts.renderer || defaultRenderer,
          devicePixelRatio: opts.devicePixelRatio,
          width: opts.width,
          height: opts.height,
          ssr: opts.ssr,
          useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
          useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
          pointerSize: opts.pointerSize
        });
        _this._ssr = opts.ssr;
        _this._throttledZrFlush = throttle$1(bind$2(zr.flush, zr), 17);
        theme2 = clone$4(theme2);
        theme2 && globalBackwardCompat(theme2, true);
        _this._theme = theme2;
        _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
        _this._coordSysMgr = new CoordinateSystemManager();
        var api2 = _this._api = createExtensionAPI(_this);
        function prioritySortFunc(a2, b2) {
          return a2.__prio - b2.__prio;
        }
        sort(visualFuncs, prioritySortFunc);
        sort(dataProcessorFuncs, prioritySortFunc);
        _this._scheduler = new Scheduler(_this, api2, dataProcessorFuncs, visualFuncs);
        _this._messageCenter = new MessageCenter();
        _this._initEvents();
        _this.resize = bind$2(_this.resize, _this);
        zr.animation.on("frame", _this._onframe, _this);
        bindRenderedEvent(zr, _this);
        bindMouseEvent(zr, _this);
        setAsPrimitive(_this);
        return _this;
      }
      ECharts2.prototype._onframe = function() {
        if (this._disposed) {
          return;
        }
        applyChangedStates(this);
        var scheduler = this._scheduler;
        if (this[PENDING_UPDATE]) {
          var silent = this[PENDING_UPDATE].silent;
          this[IN_MAIN_PROCESS_KEY] = true;
          try {
            prepare(this);
            updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
          } catch (e2) {
            this[IN_MAIN_PROCESS_KEY] = false;
            this[PENDING_UPDATE] = null;
            throw e2;
          }
          this._zr.flush();
          this[IN_MAIN_PROCESS_KEY] = false;
          this[PENDING_UPDATE] = null;
          flushPendingActions.call(this, silent);
          triggerUpdatedEvent.call(this, silent);
        } else if (scheduler.unfinished) {
          var remainTime = TEST_FRAME_REMAIN_TIME;
          var ecModel = this._model;
          var api2 = this._api;
          scheduler.unfinished = false;
          do {
            var startTime = +/* @__PURE__ */ new Date();
            scheduler.performSeriesTasks(ecModel);
            scheduler.performDataProcessorTasks(ecModel);
            updateStreamModes(this, ecModel);
            scheduler.performVisualTasks(ecModel);
            renderSeries(this, this._model, api2, "remain", {});
            remainTime -= +/* @__PURE__ */ new Date() - startTime;
          } while (remainTime > 0 && scheduler.unfinished);
          if (!scheduler.unfinished) {
            this._zr.flush();
          }
        }
      };
      ECharts2.prototype.getDom = function() {
        return this._dom;
      };
      ECharts2.prototype.getId = function() {
        return this.id;
      };
      ECharts2.prototype.getZr = function() {
        return this._zr;
      };
      ECharts2.prototype.isSSR = function() {
        return this._ssr;
      };
      ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          return;
        }
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var silent;
        var replaceMerge;
        var transitionOpt;
        if (isObject$3(notMerge)) {
          lazyUpdate = notMerge.lazyUpdate;
          silent = notMerge.silent;
          replaceMerge = notMerge.replaceMerge;
          transitionOpt = notMerge.transition;
          notMerge = notMerge.notMerge;
        }
        this[IN_MAIN_PROCESS_KEY] = true;
        if (!this._model || notMerge) {
          var optionManager = new OptionManager(this._api);
          var theme2 = this._theme;
          var ecModel = this._model = new GlobalModel();
          ecModel.scheduler = this._scheduler;
          ecModel.ssr = this._ssr;
          ecModel.init(null, null, null, theme2, this._locale, optionManager);
        }
        this._model.setOption(option, {
          replaceMerge
        }, optionPreprocessorFuncs);
        var updateParams = {
          seriesTransition: transitionOpt,
          optionChanged: true
        };
        if (lazyUpdate) {
          this[PENDING_UPDATE] = {
            silent,
            updateParams
          };
          this[IN_MAIN_PROCESS_KEY] = false;
          this.getZr().wakeUp();
        } else {
          try {
            prepare(this);
            updateMethods.update.call(this, null, updateParams);
          } catch (e2) {
            this[PENDING_UPDATE] = null;
            this[IN_MAIN_PROCESS_KEY] = false;
            throw e2;
          }
          if (!this._ssr) {
            this._zr.flush();
          }
          this[PENDING_UPDATE] = null;
          this[IN_MAIN_PROCESS_KEY] = false;
          flushPendingActions.call(this, silent);
          triggerUpdatedEvent.call(this, silent);
        }
      };
      ECharts2.prototype.setTheme = function() {
      };
      ECharts2.prototype.getModel = function() {
        return this._model;
      };
      ECharts2.prototype.getOption = function() {
        return this._model && this._model.getOption();
      };
      ECharts2.prototype.getWidth = function() {
        return this._zr.getWidth();
      };
      ECharts2.prototype.getHeight = function() {
        return this._zr.getHeight();
      };
      ECharts2.prototype.getDevicePixelRatio = function() {
        return this._zr.painter.dpr || env.hasGlobalWindow && window.devicePixelRatio || 1;
      };
      ECharts2.prototype.getRenderedCanvas = function(opts) {
        return this.renderToCanvas(opts);
      };
      ECharts2.prototype.renderToCanvas = function(opts) {
        opts = opts || {};
        var painter = this._zr.painter;
        return painter.getRenderedCanvas({
          backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
          pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
        });
      };
      ECharts2.prototype.renderToSVGString = function(opts) {
        opts = opts || {};
        var painter = this._zr.painter;
        return painter.renderToString({
          useViewBox: opts.useViewBox
        });
      };
      ECharts2.prototype.getSvgDataURL = function() {
        if (!env.svgSupported) {
          return;
        }
        var zr = this._zr;
        var list2 = zr.storage.getDisplayList();
        each$4(list2, function(el) {
          el.stopAnimation(null, true);
        });
        return zr.painter.toDataURL();
      };
      ECharts2.prototype.getDataURL = function(opts) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        opts = opts || {};
        var excludeComponents = opts.excludeComponents;
        var ecModel = this._model;
        var excludesComponentViews = [];
        var self2 = this;
        each$4(excludeComponents, function(componentType) {
          ecModel.eachComponent({
            mainType: componentType
          }, function(component) {
            var view = self2._componentsMap[component.__viewId];
            if (!view.group.ignore) {
              excludesComponentViews.push(view);
              view.group.ignore = true;
            }
          });
        });
        var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
        each$4(excludesComponentViews, function(view) {
          view.group.ignore = false;
        });
        return url;
      };
      ECharts2.prototype.getConnectedDataURL = function(opts) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var isSvg = opts.type === "svg";
        var groupId = this.group;
        var mathMin2 = Math.min;
        var mathMax2 = Math.max;
        var MAX_NUMBER = Infinity;
        if (connectedGroups[groupId]) {
          var left_1 = MAX_NUMBER;
          var top_1 = MAX_NUMBER;
          var right_1 = -MAX_NUMBER;
          var bottom_1 = -MAX_NUMBER;
          var canvasList_1 = [];
          var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
          each$4(instances, function(chart, id) {
            if (chart.group === groupId) {
              var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$4(opts));
              var boundingRect = chart.getDom().getBoundingClientRect();
              left_1 = mathMin2(boundingRect.left, left_1);
              top_1 = mathMin2(boundingRect.top, top_1);
              right_1 = mathMax2(boundingRect.right, right_1);
              bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
              canvasList_1.push({
                dom: canvas,
                left: boundingRect.left,
                top: boundingRect.top
              });
            }
          });
          left_1 *= dpr_1;
          top_1 *= dpr_1;
          right_1 *= dpr_1;
          bottom_1 *= dpr_1;
          var width = right_1 - left_1;
          var height = bottom_1 - top_1;
          var targetCanvas = platformApi.createCanvas();
          var zr_1 = init$1(targetCanvas, {
            renderer: isSvg ? "svg" : "canvas"
          });
          zr_1.resize({
            width,
            height
          });
          if (isSvg) {
            var content_1 = "";
            each$4(canvasList_1, function(item) {
              var x2 = item.left - left_1;
              var y2 = item.top - top_1;
              content_1 += '<g transform="translate(' + x2 + "," + y2 + ')">' + item.dom + "</g>";
            });
            zr_1.painter.getSvgRoot().innerHTML = content_1;
            if (opts.connectedBackgroundColor) {
              zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
            }
            zr_1.refreshImmediately();
            return zr_1.painter.toDataURL();
          } else {
            if (opts.connectedBackgroundColor) {
              zr_1.add(new Rect({
                shape: {
                  x: 0,
                  y: 0,
                  width,
                  height
                },
                style: {
                  fill: opts.connectedBackgroundColor
                }
              }));
            }
            each$4(canvasList_1, function(item) {
              var img = new ZRImage({
                style: {
                  x: item.left * dpr_1 - left_1,
                  y: item.top * dpr_1 - top_1,
                  image: item.dom
                }
              });
              zr_1.add(img);
            });
            zr_1.refreshImmediately();
            return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
          }
        } else {
          return this.getDataURL(opts);
        }
      };
      ECharts2.prototype.convertToPixel = function(finder, value) {
        return doConvertPixel(this, "convertToPixel", finder, value);
      };
      ECharts2.prototype.convertFromPixel = function(finder, value) {
        return doConvertPixel(this, "convertFromPixel", finder, value);
      };
      ECharts2.prototype.containPixel = function(finder, value) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var ecModel = this._model;
        var result;
        var findResult = parseFinder(ecModel, finder);
        each$4(findResult, function(models, key2) {
          key2.indexOf("Models") >= 0 && each$4(models, function(model) {
            var coordSys = model.coordinateSystem;
            if (coordSys && coordSys.containPoint) {
              result = result || !!coordSys.containPoint(value);
            } else if (key2 === "seriesModels") {
              var view = this._chartsMap[model.__viewId];
              if (view && view.containPoint) {
                result = result || view.containPoint(value, model);
              }
            } else ;
          }, this);
        }, this);
        return !!result;
      };
      ECharts2.prototype.getVisual = function(finder, visualType) {
        var ecModel = this._model;
        var parsedFinder = parseFinder(ecModel, finder, {
          defaultMainType: "series"
        });
        var seriesModel = parsedFinder.seriesModel;
        var data = seriesModel.getData();
        var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
        return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
      };
      ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
        return this._componentsMap[componentModel.__viewId];
      };
      ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
        return this._chartsMap[seriesModel.__viewId];
      };
      ECharts2.prototype._initEvents = function() {
        var _this = this;
        each$4(MOUSE_EVENT_NAMES, function(eveName) {
          var handler = function(e2) {
            var ecModel = _this.getModel();
            var el = e2.target;
            var params2;
            var isGlobalOut = eveName === "globalout";
            if (isGlobalOut) {
              params2 = {};
            } else {
              el && findEventDispatcher(el, function(parent2) {
                var ecData = getECData(parent2);
                if (ecData && ecData.dataIndex != null) {
                  var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
                  params2 = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
                  return true;
                } else if (ecData.eventData) {
                  params2 = extend$1({}, ecData.eventData);
                  return true;
                }
              }, true);
            }
            if (params2) {
              var componentType = params2.componentType;
              var componentIndex = params2.componentIndex;
              if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
                componentType = "series";
                componentIndex = params2.seriesIndex;
              }
              var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
              var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
              params2.event = e2;
              params2.type = eveName;
              _this._$eventProcessor.eventInfo = {
                targetEl: el,
                packedEvent: params2,
                model,
                view
              };
              _this.trigger(eveName, params2);
            }
          };
          handler.zrEventfulCallAtLast = true;
          _this._zr.on(eveName, handler, _this);
        });
        each$4(eventActionMap, function(actionType, eventType2) {
          _this._messageCenter.on(eventType2, function(event) {
            this.trigger(eventType2, event);
          }, _this);
        });
        each$4(["selectchanged"], function(eventType2) {
          _this._messageCenter.on(eventType2, function(event) {
            this.trigger(eventType2, event);
          }, _this);
        });
        handleLegacySelectEvents(this._messageCenter, this, this._api);
      };
      ECharts2.prototype.isDisposed = function() {
        return this._disposed;
      };
      ECharts2.prototype.clear = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this.setOption({
          series: []
        }, true);
      };
      ECharts2.prototype.dispose = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._disposed = true;
        var dom = this.getDom();
        if (dom) {
          setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
        }
        var chart = this;
        var api2 = chart._api;
        var ecModel = chart._model;
        each$4(chart._componentsViews, function(component) {
          component.dispose(ecModel, api2);
        });
        each$4(chart._chartsViews, function(chart2) {
          chart2.dispose(ecModel, api2);
        });
        chart._zr.dispose();
        chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
        delete instances[chart.id];
      };
      ECharts2.prototype.resize = function(opts) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          return;
        }
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._zr.resize(opts);
        var ecModel = this._model;
        this._loadingFX && this._loadingFX.resize();
        if (!ecModel) {
          return;
        }
        var needPrepare = ecModel.resetOption("media");
        var silent = opts && opts.silent;
        if (this[PENDING_UPDATE]) {
          if (silent == null) {
            silent = this[PENDING_UPDATE].silent;
          }
          needPrepare = true;
          this[PENDING_UPDATE] = null;
        }
        this[IN_MAIN_PROCESS_KEY] = true;
        try {
          needPrepare && prepare(this);
          updateMethods.update.call(this, {
            type: "resize",
            animation: extend$1({
              // Disable animation
              duration: 0
            }, opts && opts.animation)
          });
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
        this[IN_MAIN_PROCESS_KEY] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      };
      ECharts2.prototype.showLoading = function(name, cfg) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        if (isObject$3(name)) {
          cfg = name;
          name = "";
        }
        name = name || "default";
        this.hideLoading();
        if (!loadingEffects[name]) {
          return;
        }
        var el = loadingEffects[name](this._api, cfg);
        var zr = this._zr;
        this._loadingFX = el;
        zr.add(el);
      };
      ECharts2.prototype.hideLoading = function() {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        this._loadingFX && this._zr.remove(this._loadingFX);
        this._loadingFX = null;
      };
      ECharts2.prototype.makeActionFromEvent = function(eventObj) {
        var payload = extend$1({}, eventObj);
        payload.type = eventActionMap[eventObj.type];
        return payload;
      };
      ECharts2.prototype.dispatchAction = function(payload, opt) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        if (!isObject$3(opt)) {
          opt = {
            silent: !!opt
          };
        }
        if (!actions[payload.type]) {
          return;
        }
        if (!this._model) {
          return;
        }
        if (this[IN_MAIN_PROCESS_KEY]) {
          this._pendingActions.push(payload);
          return;
        }
        var silent = opt.silent;
        doDispatchAction.call(this, payload, silent);
        var flush = opt.flush;
        if (flush) {
          this._zr.flush();
        } else if (flush !== false && env.browser.weChat) {
          this._throttledZrFlush();
        }
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      };
      ECharts2.prototype.updateLabelLayout = function() {
        lifecycle.trigger("series:layoutlabels", this._model, this._api, {
          // Not adding series labels.
          // TODO
          updatedSeries: []
        });
      };
      ECharts2.prototype.appendData = function(params2) {
        if (this._disposed) {
          disposedWarning(this.id);
          return;
        }
        var seriesIndex = params2.seriesIndex;
        var ecModel = this.getModel();
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        seriesModel.appendData(params2);
        this._scheduler.unfinished = true;
        this.getZr().wakeUp();
      };
      ECharts2.internalField = function() {
        prepare = function(ecIns) {
          var scheduler = ecIns._scheduler;
          scheduler.restorePipelines(ecIns._model);
          scheduler.prepareStageTasks();
          prepareView(ecIns, true);
          prepareView(ecIns, false);
          scheduler.plan();
        };
        prepareView = function(ecIns, isComponent) {
          var ecModel = ecIns._model;
          var scheduler = ecIns._scheduler;
          var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
          var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
          var zr = ecIns._zr;
          var api2 = ecIns._api;
          for (var i2 = 0; i2 < viewList.length; i2++) {
            viewList[i2].__alive = false;
          }
          isComponent ? ecModel.eachComponent(function(componentType, model) {
            componentType !== "series" && doPrepare(model);
          }) : ecModel.eachSeries(doPrepare);
          function doPrepare(model) {
            var requireNewView = model.__requireNewView;
            model.__requireNewView = false;
            var viewId = "_ec_" + model.id + "_" + model.type;
            var view2 = !requireNewView && viewMap[viewId];
            if (!view2) {
              var classType = parseClassType(model.type);
              var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : (
                // FIXME:TS
                // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
                // For backward compat, still support a chart type declared as only subType
                // like "liquidfill", but recommend "series.liquidfill"
                // But need a base class to make a type series.
                ChartView.getClass(classType.sub)
              );
              view2 = new Clazz();
              view2.init(ecModel, api2);
              viewMap[viewId] = view2;
              viewList.push(view2);
              zr.add(view2.group);
            }
            model.__viewId = view2.__id = viewId;
            view2.__alive = true;
            view2.__model = model;
            view2.group.__ecComponentInfo = {
              mainType: model.mainType,
              index: model.componentIndex
            };
            !isComponent && scheduler.prepareView(view2, model, ecModel, api2);
          }
          for (var i2 = 0; i2 < viewList.length; ) {
            var view = viewList[i2];
            if (!view.__alive) {
              !isComponent && view.renderTask.dispose();
              zr.remove(view.group);
              view.dispose(ecModel, api2);
              viewList.splice(i2, 1);
              if (viewMap[view.__id] === view) {
                delete viewMap[view.__id];
              }
              view.__id = view.group.__ecComponentInfo = null;
            } else {
              i2++;
            }
          }
        };
        updateDirectly = function(ecIns, method, payload, mainType, subType) {
          var ecModel = ecIns._model;
          ecModel.setUpdatePayload(payload);
          if (!mainType) {
            each$4([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
            return;
          }
          var query = {};
          query[mainType + "Id"] = payload[mainType + "Id"];
          query[mainType + "Index"] = payload[mainType + "Index"];
          query[mainType + "Name"] = payload[mainType + "Name"];
          var condition = {
            mainType,
            query
          };
          subType && (condition.subType = subType);
          var excludeSeriesId = payload.excludeSeriesId;
          var excludeSeriesIdMap;
          if (excludeSeriesId != null) {
            excludeSeriesIdMap = createHashMap();
            each$4(normalizeToArray(excludeSeriesId), function(id) {
              var modelId = convertOptionIdName(id, null);
              if (modelId != null) {
                excludeSeriesIdMap.set(modelId, true);
              }
            });
          }
          ecModel && ecModel.eachComponent(condition, function(model) {
            var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
            if (isExcluded) {
              return;
            }
            if (isHighDownPayload(payload)) {
              if (model instanceof SeriesModel) {
                if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
                  blurSeriesFromHighlightPayload(model, payload, ecIns._api);
                }
              } else {
                var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
                if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
                  blurComponent(model.mainType, model.componentIndex, ecIns._api);
                }
                if (dispatchers) {
                  each$4(dispatchers, function(dispatcher) {
                    payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
                  });
                }
              }
            } else if (isSelectChangePayload(payload)) {
              if (model instanceof SeriesModel) {
                toggleSelectionFromPayload(model, payload, ecIns._api);
                updateSeriesElementSelection(model);
                markStatusToUpdate(ecIns);
              }
            }
          }, ecIns);
          ecModel && ecModel.eachComponent(condition, function(model) {
            var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
            if (isExcluded) {
              return;
            }
            callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
          }, ecIns);
          function callView(view) {
            view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
          }
        };
        updateMethods = {
          prepareAndUpdate: function(payload) {
            prepare(this);
            updateMethods.update.call(this, payload, {
              // Needs to mark option changed if newOption is given.
              // It's from MagicType.
              // TODO If use a separate flag optionChanged in payload?
              optionChanged: payload.newOption != null
            });
          },
          update: function(payload, updateParams) {
            var ecModel = this._model;
            var api2 = this._api;
            var zr = this._zr;
            var coordSysMgr = this._coordSysMgr;
            var scheduler = this._scheduler;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            scheduler.restoreData(ecModel, payload);
            scheduler.performSeriesTasks(ecModel);
            coordSysMgr.create(ecModel, api2);
            scheduler.performDataProcessorTasks(ecModel, payload);
            updateStreamModes(this, ecModel);
            coordSysMgr.update(ecModel, api2);
            clearColorPalette(ecModel);
            scheduler.performVisualTasks(ecModel, payload);
            render(this, ecModel, api2, payload, updateParams);
            var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
            var darkMode = ecModel.get("darkMode");
            zr.setBackgroundColor(backgroundColor2);
            if (darkMode != null && darkMode !== "auto") {
              zr.setDarkMode(darkMode);
            }
            lifecycle.trigger("afterupdate", ecModel, api2);
          },
          updateTransform: function(payload) {
            var _this = this;
            var ecModel = this._model;
            var api2 = this._api;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            var componentDirtyList = [];
            ecModel.eachComponent(function(componentType, componentModel) {
              if (componentType === "series") {
                return;
              }
              var componentView = _this.getViewOfComponentModel(componentModel);
              if (componentView && componentView.__alive) {
                if (componentView.updateTransform) {
                  var result = componentView.updateTransform(componentModel, ecModel, api2, payload);
                  result && result.update && componentDirtyList.push(componentView);
                } else {
                  componentDirtyList.push(componentView);
                }
              }
            });
            var seriesDirtyMap = createHashMap();
            ecModel.eachSeries(function(seriesModel) {
              var chartView = _this._chartsMap[seriesModel.__viewId];
              if (chartView.updateTransform) {
                var result = chartView.updateTransform(seriesModel, ecModel, api2, payload);
                result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
              } else {
                seriesDirtyMap.set(seriesModel.uid, 1);
              }
            });
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true,
              dirtyMap: seriesDirtyMap
            });
            renderSeries(this, ecModel, api2, payload, {}, seriesDirtyMap);
            lifecycle.trigger("afterupdate", ecModel, api2);
          },
          updateView: function(payload) {
            var ecModel = this._model;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            ChartView.markUpdateMethod(payload, "updateView");
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true
            });
            render(this, ecModel, this._api, payload, {});
            lifecycle.trigger("afterupdate", ecModel, this._api);
          },
          updateVisual: function(payload) {
            var _this = this;
            var ecModel = this._model;
            if (!ecModel) {
              return;
            }
            ecModel.setUpdatePayload(payload);
            ecModel.eachSeries(function(seriesModel) {
              seriesModel.getData().clearAllVisual();
            });
            ChartView.markUpdateMethod(payload, "updateVisual");
            clearColorPalette(ecModel);
            this._scheduler.performVisualTasks(ecModel, payload, {
              visualType: "visual",
              setDirty: true
            });
            ecModel.eachComponent(function(componentType, componentModel) {
              if (componentType !== "series") {
                var componentView = _this.getViewOfComponentModel(componentModel);
                componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
              }
            });
            ecModel.eachSeries(function(seriesModel) {
              var chartView = _this._chartsMap[seriesModel.__viewId];
              chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
            });
            lifecycle.trigger("afterupdate", ecModel, this._api);
          },
          updateLayout: function(payload) {
            updateMethods.update.call(this, payload);
          }
        };
        doConvertPixel = function(ecIns, methodName, finder, value) {
          if (ecIns._disposed) {
            disposedWarning(ecIns.id);
            return;
          }
          var ecModel = ecIns._model;
          var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
          var result;
          var parsedFinder = parseFinder(ecModel, finder);
          for (var i2 = 0; i2 < coordSysList.length; i2++) {
            var coordSys = coordSysList[i2];
            if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
              return result;
            }
          }
        };
        updateStreamModes = function(ecIns, ecModel) {
          var chartsMap = ecIns._chartsMap;
          var scheduler = ecIns._scheduler;
          ecModel.eachSeries(function(seriesModel) {
            scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
          });
        };
        doDispatchAction = function(payload, silent) {
          var _this = this;
          var ecModel = this.getModel();
          var payloadType = payload.type;
          var escapeConnect = payload.escapeConnect;
          var actionWrap = actions[payloadType];
          var actionInfo = actionWrap.actionInfo;
          var cptTypeTmp = (actionInfo.update || "update").split(":");
          var updateMethod = cptTypeTmp.pop();
          var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
          this[IN_MAIN_PROCESS_KEY] = true;
          var payloads = [payload];
          var batched = false;
          if (payload.batch) {
            batched = true;
            payloads = map$1(payload.batch, function(item) {
              item = defaults$1(extend$1({}, item), payload);
              item.batch = null;
              return item;
            });
          }
          var eventObjBatch = [];
          var eventObj;
          var isSelectChange = isSelectChangePayload(payload);
          var isHighDown = isHighDownPayload(payload);
          if (isHighDown) {
            allLeaveBlur(this._api);
          }
          each$4(payloads, function(batchItem) {
            eventObj = actionWrap.action(batchItem, _this._model, _this._api);
            eventObj = eventObj || extend$1({}, batchItem);
            eventObj.type = actionInfo.event || eventObj.type;
            eventObjBatch.push(eventObj);
            if (isHighDown) {
              var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
              var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
              updateDirectly(_this, updateMethod, batchItem, componentMainType);
              markStatusToUpdate(_this);
            } else if (isSelectChange) {
              updateDirectly(_this, updateMethod, batchItem, "series");
              markStatusToUpdate(_this);
            } else if (cptType) {
              updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
            }
          });
          if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
            try {
              if (this[PENDING_UPDATE]) {
                prepare(this);
                updateMethods.update.call(this, payload);
                this[PENDING_UPDATE] = null;
              } else {
                updateMethods[updateMethod].call(this, payload);
              }
            } catch (e2) {
              this[IN_MAIN_PROCESS_KEY] = false;
              throw e2;
            }
          }
          if (batched) {
            eventObj = {
              type: actionInfo.event || payloadType,
              escapeConnect,
              batch: eventObjBatch
            };
          } else {
            eventObj = eventObjBatch[0];
          }
          this[IN_MAIN_PROCESS_KEY] = false;
          if (!silent) {
            var messageCenter = this._messageCenter;
            messageCenter.trigger(eventObj.type, eventObj);
            if (isSelectChange) {
              var newObj = {
                type: "selectchanged",
                escapeConnect,
                selected: getAllSelectedIndices(ecModel),
                isFromClick: payload.isFromClick || false,
                fromAction: payload.type,
                fromActionPayload: payload
              };
              messageCenter.trigger(newObj.type, newObj);
            }
          }
        };
        flushPendingActions = function(silent) {
          var pendingActions = this._pendingActions;
          while (pendingActions.length) {
            var payload = pendingActions.shift();
            doDispatchAction.call(this, payload, silent);
          }
        };
        triggerUpdatedEvent = function(silent) {
          !silent && this.trigger("updated");
        };
        bindRenderedEvent = function(zr, ecIns) {
          zr.on("rendered", function(params2) {
            ecIns.trigger("rendered", params2);
            if (
              // Although zr is dirty if initial animation is not finished
              // and this checking is called on frame, we also check
              // animation finished for robustness.
              zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length
            ) {
              ecIns.trigger("finished");
            }
          });
        };
        bindMouseEvent = function(zr, ecIns) {
          zr.on("mouseover", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
            if (dispatcher) {
              handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
              markStatusToUpdate(ecIns);
            }
          }).on("mouseout", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
            if (dispatcher) {
              handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
              markStatusToUpdate(ecIns);
            }
          }).on("click", function(e2) {
            var el = e2.target;
            var dispatcher = findEventDispatcher(el, function(target) {
              return getECData(target).dataIndex != null;
            }, true);
            if (dispatcher) {
              var actionType = dispatcher.selected ? "unselect" : "select";
              var ecData = getECData(dispatcher);
              ecIns._api.dispatchAction({
                type: actionType,
                dataType: ecData.dataType,
                dataIndexInside: ecData.dataIndex,
                seriesIndex: ecData.seriesIndex,
                isFromClick: true
              });
            }
          });
        };
        function clearColorPalette(ecModel) {
          ecModel.clearColorPalette();
          ecModel.eachSeries(function(seriesModel) {
            seriesModel.clearColorPalette();
          });
        }
        function allocateZlevels(ecModel) {
          var componentZLevels = [];
          var seriesZLevels = [];
          var hasSeparateZLevel = false;
          ecModel.eachComponent(function(componentType, componentModel) {
            var zlevel = componentModel.get("zlevel") || 0;
            var z2 = componentModel.get("z") || 0;
            var zlevelKey = componentModel.getZLevelKey();
            hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
            (componentType === "series" ? seriesZLevels : componentZLevels).push({
              zlevel,
              z: z2,
              idx: componentModel.componentIndex,
              type: componentType,
              key: zlevelKey
            });
          });
          if (hasSeparateZLevel) {
            var zLevels = componentZLevels.concat(seriesZLevels);
            var lastSeriesZLevel_1;
            var lastSeriesKey_1;
            sort(zLevels, function(a2, b2) {
              if (a2.zlevel === b2.zlevel) {
                return a2.z - b2.z;
              }
              return a2.zlevel - b2.zlevel;
            });
            each$4(zLevels, function(item) {
              var componentModel = ecModel.getComponent(item.type, item.idx);
              var zlevel = item.zlevel;
              var key2 = item.key;
              if (lastSeriesZLevel_1 != null) {
                zlevel = Math.max(lastSeriesZLevel_1, zlevel);
              }
              if (key2) {
                if (zlevel === lastSeriesZLevel_1 && key2 !== lastSeriesKey_1) {
                  zlevel++;
                }
                lastSeriesKey_1 = key2;
              } else if (lastSeriesKey_1) {
                if (zlevel === lastSeriesZLevel_1) {
                  zlevel++;
                }
                lastSeriesKey_1 = "";
              }
              lastSeriesZLevel_1 = zlevel;
              componentModel.setZLevel(zlevel);
            });
          }
        }
        render = function(ecIns, ecModel, api2, payload, updateParams) {
          allocateZlevels(ecModel);
          renderComponents(ecIns, ecModel, api2, payload, updateParams);
          each$4(ecIns._chartsViews, function(chart) {
            chart.__alive = false;
          });
          renderSeries(ecIns, ecModel, api2, payload, updateParams);
          each$4(ecIns._chartsViews, function(chart) {
            if (!chart.__alive) {
              chart.remove(ecModel, api2);
            }
          });
        };
        renderComponents = function(ecIns, ecModel, api2, payload, updateParams, dirtyList) {
          each$4(dirtyList || ecIns._componentsViews, function(componentView) {
            var componentModel = componentView.__model;
            clearStates(componentModel, componentView);
            componentView.render(componentModel, ecModel, api2, payload);
            updateZ2(componentModel, componentView);
            updateStates(componentModel, componentView);
          });
        };
        renderSeries = function(ecIns, ecModel, api2, payload, updateParams, dirtyMap) {
          var scheduler = ecIns._scheduler;
          updateParams = extend$1(updateParams || {}, {
            updatedSeries: ecModel.getSeries()
          });
          lifecycle.trigger("series:beforeupdate", ecModel, api2, updateParams);
          var unfinished = false;
          ecModel.eachSeries(function(seriesModel) {
            var chartView = ecIns._chartsMap[seriesModel.__viewId];
            chartView.__alive = true;
            var renderTask = chartView.renderTask;
            scheduler.updatePayload(renderTask, payload);
            clearStates(seriesModel, chartView);
            if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
              renderTask.dirty();
            }
            if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
              unfinished = true;
            }
            chartView.group.silent = !!seriesModel.get("silent");
            updateBlend(seriesModel, chartView);
            updateSeriesElementSelection(seriesModel);
          });
          scheduler.unfinished = unfinished || scheduler.unfinished;
          lifecycle.trigger("series:layoutlabels", ecModel, api2, updateParams);
          lifecycle.trigger("series:transition", ecModel, api2, updateParams);
          ecModel.eachSeries(function(seriesModel) {
            var chartView = ecIns._chartsMap[seriesModel.__viewId];
            updateZ2(seriesModel, chartView);
            updateStates(seriesModel, chartView);
          });
          updateHoverLayerStatus(ecIns, ecModel);
          lifecycle.trigger("series:afterupdate", ecModel, api2, updateParams);
        };
        markStatusToUpdate = function(ecIns) {
          ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
          ecIns.getZr().wakeUp();
        };
        applyChangedStates = function(ecIns) {
          if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
            return;
          }
          ecIns.getZr().storage.traverse(function(el) {
            if (isElementRemoved(el)) {
              return;
            }
            applyElementStates(el);
          });
          ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
        };
        function applyElementStates(el) {
          var newStates = [];
          var oldStates = el.currentStates;
          for (var i2 = 0; i2 < oldStates.length; i2++) {
            var stateName = oldStates[i2];
            if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
              newStates.push(stateName);
            }
          }
          if (el.selected && el.states.select) {
            newStates.push("select");
          }
          if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
            newStates.push("emphasis");
          } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
            newStates.push("blur");
          }
          el.useStates(newStates);
        }
        function updateHoverLayerStatus(ecIns, ecModel) {
          var zr = ecIns._zr;
          var storage = zr.storage;
          var elCount = 0;
          storage.traverse(function(el) {
            if (!el.isGroup) {
              elCount++;
            }
          });
          if (elCount > ecModel.get("hoverLayerThreshold") && !env.node && !env.worker) {
            ecModel.eachSeries(function(seriesModel) {
              if (seriesModel.preventUsingHoverLayer) {
                return;
              }
              var chartView = ecIns._chartsMap[seriesModel.__viewId];
              if (chartView.__alive) {
                chartView.eachRendered(function(el) {
                  if (el.states.emphasis) {
                    el.states.emphasis.hoverLayer = true;
                  }
                });
              }
            });
          }
        }
        function updateBlend(seriesModel, chartView) {
          var blendMode = seriesModel.get("blendMode") || null;
          chartView.eachRendered(function(el) {
            if (!el.isGroup) {
              el.style.blend = blendMode;
            }
          });
        }
        function updateZ2(model, view) {
          if (model.preventAutoZ) {
            return;
          }
          var z2 = model.get("z") || 0;
          var zlevel = model.get("zlevel") || 0;
          view.eachRendered(function(el) {
            doUpdateZ(el, z2, zlevel, -Infinity);
            return true;
          });
        }
        function doUpdateZ(el, z2, zlevel, maxZ2) {
          var label = el.getTextContent();
          var labelLine = el.getTextGuideLine();
          var isGroup = el.isGroup;
          if (isGroup) {
            var children = el.childrenRef();
            for (var i2 = 0; i2 < children.length; i2++) {
              maxZ2 = Math.max(doUpdateZ(children[i2], z2, zlevel, maxZ2), maxZ2);
            }
          } else {
            el.z = z2;
            el.zlevel = zlevel;
            maxZ2 = Math.max(el.z2, maxZ2);
          }
          if (label) {
            label.z = z2;
            label.zlevel = zlevel;
            isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
          }
          if (labelLine) {
            var textGuideLineConfig = el.textGuideLineConfig;
            labelLine.z = z2;
            labelLine.zlevel = zlevel;
            isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
          }
          return maxZ2;
        }
        function clearStates(model, view) {
          view.eachRendered(function(el) {
            if (isElementRemoved(el)) {
              return;
            }
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (el.stateTransition) {
              el.stateTransition = null;
            }
            if (textContent && textContent.stateTransition) {
              textContent.stateTransition = null;
            }
            if (textGuide && textGuide.stateTransition) {
              textGuide.stateTransition = null;
            }
            if (el.hasState()) {
              el.prevStates = el.currentStates;
              el.clearStates();
            } else if (el.prevStates) {
              el.prevStates = null;
            }
          });
        }
        function updateStates(model, view) {
          var stateAnimationModel = model.getModel("stateAnimation");
          var enableAnimation = model.isAnimationEnabled();
          var duration = stateAnimationModel.get("duration");
          var stateTransition = duration > 0 ? {
            duration,
            delay: stateAnimationModel.get("delay"),
            easing: stateAnimationModel.get("easing")
            // additive: stateAnimationModel.get('additive')
          } : null;
          view.eachRendered(function(el) {
            if (el.states && el.states.emphasis) {
              if (isElementRemoved(el)) {
                return;
              }
              if (el instanceof Path) {
                savePathStates(el);
              }
              if (el.__dirty) {
                var prevStates = el.prevStates;
                if (prevStates) {
                  el.useStates(prevStates);
                }
              }
              if (enableAnimation) {
                el.stateTransition = stateTransition;
                var textContent = el.getTextContent();
                var textGuide = el.getTextGuideLine();
                if (textContent) {
                  textContent.stateTransition = stateTransition;
                }
                if (textGuide) {
                  textGuide.stateTransition = stateTransition;
                }
              }
              if (el.__dirty) {
                applyElementStates(el);
              }
            }
          });
        }
        createExtensionAPI = function(ecIns) {
          return new /** @class */
          (function(_super2) {
            __extends(class_1, _super2);
            function class_1() {
              return _super2 !== null && _super2.apply(this, arguments) || this;
            }
            class_1.prototype.getCoordinateSystems = function() {
              return ecIns._coordSysMgr.getCoordinateSystems();
            };
            class_1.prototype.getComponentByElement = function(el) {
              while (el) {
                var modelInfo = el.__ecComponentInfo;
                if (modelInfo != null) {
                  return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
                }
                el = el.parent;
              }
            };
            class_1.prototype.enterEmphasis = function(el, highlightDigit) {
              enterEmphasis(el, highlightDigit);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
              leaveEmphasis(el, highlightDigit);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.enterBlur = function(el) {
              enterBlur(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveBlur = function(el) {
              leaveBlur(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.enterSelect = function(el) {
              enterSelect(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.leaveSelect = function(el) {
              leaveSelect(el);
              markStatusToUpdate(ecIns);
            };
            class_1.prototype.getModel = function() {
              return ecIns.getModel();
            };
            class_1.prototype.getViewOfComponentModel = function(componentModel) {
              return ecIns.getViewOfComponentModel(componentModel);
            };
            class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
              return ecIns.getViewOfSeriesModel(seriesModel);
            };
            return class_1;
          }(ExtensionAPI))(ecIns);
        };
        enableConnect = function(chart) {
          function updateConnectedChartsStatus(charts, status) {
            for (var i2 = 0; i2 < charts.length; i2++) {
              var otherChart = charts[i2];
              otherChart[CONNECT_STATUS_KEY] = status;
            }
          }
          each$4(eventActionMap, function(actionType, eventType2) {
            chart._messageCenter.on(eventType2, function(event) {
              if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
                if (event && event.escapeConnect) {
                  return;
                }
                var action_1 = chart.makeActionFromEvent(event);
                var otherCharts_1 = [];
                each$4(instances, function(otherChart) {
                  if (otherChart !== chart && otherChart.group === chart.group) {
                    otherCharts_1.push(otherChart);
                  }
                });
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
                each$4(otherCharts_1, function(otherChart) {
                  if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                    otherChart.dispatchAction(action_1);
                  }
                });
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
              }
            });
          });
        };
      }();
      return ECharts2;
    }(Eventful)
  );
  var echartsProto = ECharts.prototype;
  echartsProto.on = createRegisterEventWithLowercaseECharts("on");
  echartsProto.off = createRegisterEventWithLowercaseECharts("off");
  echartsProto.one = function(eventName, cb, ctx) {
    var self2 = this;
    function wrapped() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      cb && cb.apply && cb.apply(this, args2);
      self2.off(eventName, wrapped);
    }
    this.on.call(this, eventName, wrapped, ctx);
  };
  var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
  function disposedWarning(id) {
  }
  var actions = {};
  var eventActionMap = {};
  var dataProcessorFuncs = [];
  var optionPreprocessorFuncs = [];
  var visualFuncs = [];
  var themeStorage = {};
  var loadingEffects = {};
  var instances = {};
  var connectedGroups = {};
  var idBase = +/* @__PURE__ */ new Date() - 0;
  var groupIdBase = +/* @__PURE__ */ new Date() - 0;
  var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
  function init(dom, theme2, opts) {
    var isClient = !(opts && opts.ssr);
    if (isClient) {
      var existInstance = getInstanceByDom(dom);
      if (existInstance) {
        return existInstance;
      }
    }
    var chart = new ECharts(dom, theme2, opts);
    chart.id = "ec_" + idBase++;
    instances[chart.id] = chart;
    isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    lifecycle.trigger("afterinit", chart);
    return chart;
  }
  function connect(groupId) {
    if (isArray$1(groupId)) {
      var charts = groupId;
      groupId = null;
      each$4(charts, function(chart) {
        if (chart.group != null) {
          groupId = chart.group;
        }
      });
      groupId = groupId || "g_" + groupIdBase++;
      each$4(charts, function(chart) {
        chart.group = groupId;
      });
    }
    connectedGroups[groupId] = true;
    return groupId;
  }
  function disconnect(groupId) {
    connectedGroups[groupId] = false;
  }
  var disConnect = disconnect;
  function dispose(chart) {
    if (isString$1(chart)) {
      chart = instances[chart];
    } else if (!(chart instanceof ECharts)) {
      chart = getInstanceByDom(chart);
    }
    if (chart instanceof ECharts && !chart.isDisposed()) {
      chart.dispose();
    }
  }
  function getInstanceByDom(dom) {
    return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
  }
  function getInstanceById(key2) {
    return instances[key2];
  }
  function registerTheme(name, theme2) {
    themeStorage[name] = theme2;
  }
  function registerPreprocessor(preprocessorFunc) {
    if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
  }
  function registerProcessor(priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
  }
  function registerPostInit(postInitFunc) {
    registerUpdateLifecycle("afterinit", postInitFunc);
  }
  function registerPostUpdate(postUpdateFunc) {
    registerUpdateLifecycle("afterupdate", postUpdateFunc);
  }
  function registerUpdateLifecycle(name, cb) {
    lifecycle.on(name, cb);
  }
  function registerAction(actionInfo, eventName, action) {
    if (isFunction$1(eventName)) {
      action = eventName;
      eventName = "";
    }
    var actionType = isObject$3(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
      event: eventName
    }][0];
    actionInfo.event = (actionInfo.event || actionType).toLowerCase();
    eventName = actionInfo.event;
    if (eventActionMap[eventName]) {
      return;
    }
    assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
    if (!actions[actionType]) {
      actions[actionType] = {
        action,
        actionInfo
      };
    }
    eventActionMap[eventName] = actionType;
  }
  function registerCoordinateSystem(type, coordSysCreator) {
    CoordinateSystemManager.register(type, coordSysCreator);
  }
  function getCoordinateSystemDimensions(type) {
    var coordSysCreator = CoordinateSystemManager.get(type);
    if (coordSysCreator) {
      return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
    }
  }
  function registerLayout(priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
  }
  function registerVisual(priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
  }
  var registeredTasks = [];
  function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction$1(priority) || isObject$3(priority)) {
      fn = priority;
      priority = defaultPriority;
    }
    if (indexOf(registeredTasks, fn) >= 0) {
      return;
    }
    registeredTasks.push(fn);
    var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
    stageHandler.__prio = priority;
    stageHandler.__raw = fn;
    targetList.push(stageHandler);
  }
  function registerLoading(name, loadingFx) {
    loadingEffects[name] = loadingFx;
  }
  function setCanvasCreator(creator) {
    setPlatformAPI({
      createCanvas: creator
    });
  }
  function registerMap(mapName, geoJson, specialAreas) {
    var registerMap2 = getImpl("registerMap");
    registerMap2 && registerMap2(mapName, geoJson, specialAreas);
  }
  function getMap(mapName) {
    var getMap2 = getImpl("getMap");
    return getMap2 && getMap2(mapName);
  }
  var registerTransform = registerExternalTransform;
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
  registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
  registerPreprocessor(globalBackwardCompat);
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
  registerLoading("default", defaultLoading);
  registerAction({
    type: HIGHLIGHT_ACTION_TYPE,
    event: HIGHLIGHT_ACTION_TYPE,
    update: HIGHLIGHT_ACTION_TYPE
  }, noop$1);
  registerAction({
    type: DOWNPLAY_ACTION_TYPE,
    event: DOWNPLAY_ACTION_TYPE,
    update: DOWNPLAY_ACTION_TYPE
  }, noop$1);
  registerAction({
    type: SELECT_ACTION_TYPE,
    event: SELECT_ACTION_TYPE,
    update: SELECT_ACTION_TYPE
  }, noop$1);
  registerAction({
    type: UNSELECT_ACTION_TYPE,
    event: UNSELECT_ACTION_TYPE,
    update: UNSELECT_ACTION_TYPE
  }, noop$1);
  registerAction({
    type: TOGGLE_SELECT_ACTION_TYPE,
    event: TOGGLE_SELECT_ACTION_TYPE,
    update: TOGGLE_SELECT_ACTION_TYPE
  }, noop$1);
  registerTheme("light", lightTheme);
  registerTheme("dark", theme);
  var dataTool = {};
  function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
    return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
  }
  function defaultKeyGetter(item) {
    return item;
  }
  var DataDiffer = (
    /** @class */
    function() {
      function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
        this._old = oldArr;
        this._new = newArr;
        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
        this._newKeyGetter = newKeyGetter || defaultKeyGetter;
        this.context = context;
        this._diffModeMultiple = diffMode === "multiple";
      }
      DataDiffer2.prototype.add = function(func) {
        this._add = func;
        return this;
      };
      DataDiffer2.prototype.update = function(func) {
        this._update = func;
        return this;
      };
      DataDiffer2.prototype.updateManyToOne = function(func) {
        this._updateManyToOne = func;
        return this;
      };
      DataDiffer2.prototype.updateOneToMany = function(func) {
        this._updateOneToMany = func;
        return this;
      };
      DataDiffer2.prototype.updateManyToMany = function(func) {
        this._updateManyToMany = func;
        return this;
      };
      DataDiffer2.prototype.remove = function(func) {
        this._remove = func;
        return this;
      };
      DataDiffer2.prototype.execute = function() {
        this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
      };
      DataDiffer2.prototype._executeOneToOne = function() {
        var oldArr = this._old;
        var newArr = this._new;
        var newDataIndexMap = {};
        var oldDataKeyArr = new Array(oldArr.length);
        var newDataKeyArr = new Array(newArr.length);
        this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
        for (var i2 = 0; i2 < oldArr.length; i2++) {
          var oldKey = oldDataKeyArr[i2];
          var newIdxMapVal = newDataIndexMap[oldKey];
          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (newIdxMapValLen > 1) {
            var newIdx = newIdxMapVal.shift();
            if (newIdxMapVal.length === 1) {
              newDataIndexMap[oldKey] = newIdxMapVal[0];
            }
            this._update && this._update(newIdx, i2);
          } else if (newIdxMapValLen === 1) {
            newDataIndexMap[oldKey] = null;
            this._update && this._update(newIdxMapVal, i2);
          } else {
            this._remove && this._remove(i2);
          }
        }
        this._performRestAdd(newDataKeyArr, newDataIndexMap);
      };
      DataDiffer2.prototype._executeMultiple = function() {
        var oldArr = this._old;
        var newArr = this._new;
        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
        for (var i2 = 0; i2 < oldDataKeyArr.length; i2++) {
          var oldKey = oldDataKeyArr[i2];
          var oldIdxMapVal = oldDataIndexMap[oldKey];
          var newIdxMapVal = newDataIndexMap[oldKey];
          var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
            this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
            this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
            this._update && this._update(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
            this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
            newDataIndexMap[oldKey] = null;
          } else if (oldIdxMapValLen > 1) {
            for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
              this._remove && this._remove(oldIdxMapVal[i_1]);
            }
          } else {
            this._remove && this._remove(oldIdxMapVal);
          }
        }
        this._performRestAdd(newDataKeyArr, newDataIndexMap);
      };
      DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
        for (var i2 = 0; i2 < newDataKeyArr.length; i2++) {
          var newKey = newDataKeyArr[i2];
          var newIdxMapVal = newDataIndexMap[newKey];
          var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
          if (idxMapValLen > 1) {
            for (var j2 = 0; j2 < idxMapValLen; j2++) {
              this._add && this._add(newIdxMapVal[j2]);
            }
          } else if (idxMapValLen === 1) {
            this._add && this._add(newIdxMapVal);
          }
          newDataIndexMap[newKey] = null;
        }
      };
      DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
        var cbModeMultiple = this._diffModeMultiple;
        for (var i2 = 0; i2 < arr.length; i2++) {
          var key2 = "_ec_" + this[keyGetterName](arr[i2], i2);
          if (!cbModeMultiple) {
            keyArr[i2] = key2;
          }
          if (!map2) {
            continue;
          }
          var idxMapVal = map2[key2];
          var idxMapValLen = dataIndexMapValueLength(idxMapVal);
          if (idxMapValLen === 0) {
            map2[key2] = i2;
            if (cbModeMultiple) {
              keyArr.push(key2);
            }
          } else if (idxMapValLen === 1) {
            map2[key2] = [idxMapVal, i2];
          } else {
            idxMapVal.push(i2);
          }
        }
      };
      return DataDiffer2;
    }()
  );
  var DimensionUserOuput = (
    /** @class */
    function() {
      function DimensionUserOuput2(encode2, dimRequest) {
        this._encode = encode2;
        this._schema = dimRequest;
      }
      DimensionUserOuput2.prototype.get = function() {
        return {
          // Do not generate full dimension name until fist used.
          fullDimensions: this._getFullDimensionNames(),
          encode: this._encode
        };
      };
      DimensionUserOuput2.prototype._getFullDimensionNames = function() {
        if (!this._cachedDimNames) {
          this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
        }
        return this._cachedDimNames;
      };
      return DimensionUserOuput2;
    }()
  );
  function summarizeDimensions(data, schema) {
    var summary = {};
    var encode2 = summary.encode = {};
    var notExtraCoordDimMap = createHashMap();
    var defaultedLabel = [];
    var defaultedTooltip = [];
    var userOutputEncode = {};
    each$4(data.dimensions, function(dimName) {
      var dimItem = data.getDimensionInfo(dimName);
      var coordDim = dimItem.coordDim;
      if (coordDim) {
        var coordDimIndex = dimItem.coordDimIndex;
        getOrCreateEncodeArr(encode2, coordDim)[coordDimIndex] = dimName;
        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1);
          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName;
          }
          getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
        }
        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName);
        }
      }
      VISUAL_DIMENSIONS.each(function(v2, otherDim) {
        var encodeArr = getOrCreateEncodeArr(encode2, otherDim);
        var dimIndex = dimItem.otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name;
        }
      });
    });
    var dataDimsOnCoord = [];
    var encodeFirstDimNotExtra = {};
    notExtraCoordDimMap.each(function(v2, coordDim) {
      var dimArr = encode2[coordDim];
      encodeFirstDimNotExtra[coordDim] = dimArr[0];
      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
    });
    summary.dataDimsOnCoord = dataDimsOnCoord;
    summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
      return data.getDimensionInfo(dimName).storeDimIndex;
    });
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
    var encodeLabel = encode2.label;
    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice();
    }
    var encodeTooltip = encode2.tooltip;
    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice();
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice();
    }
    encode2.defaultedLabel = defaultedLabel;
    encode2.defaultedTooltip = defaultedTooltip;
    summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
    return summary;
  }
  function getOrCreateEncodeArr(encode2, dim) {
    if (!encode2.hasOwnProperty(dim)) {
      encode2[dim] = [];
    }
    return encode2[dim];
  }
  function getDimensionTypeByAxis(axisType) {
    return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
  }
  function mayLabelDimType(dimType) {
    return !(dimType === "ordinal" || dimType === "time");
  }
  var SeriesDimensionDefine = (
    /** @class */
    /* @__PURE__ */ function() {
      function SeriesDimensionDefine2(opt) {
        this.otherDims = {};
        if (opt != null) {
          extend$1(this, opt);
        }
      }
      return SeriesDimensionDefine2;
    }()
  );
  var inner$5 = makeInner();
  var dimTypeShort = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  };
  var SeriesDataSchema = (
    /** @class */
    function() {
      function SeriesDataSchema2(opt) {
        this.dimensions = opt.dimensions;
        this._dimOmitted = opt.dimensionOmitted;
        this.source = opt.source;
        this._fullDimCount = opt.fullDimensionCount;
        this._updateDimOmitted(opt.dimensionOmitted);
      }
      SeriesDataSchema2.prototype.isDimensionOmitted = function() {
        return this._dimOmitted;
      };
      SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
        this._dimOmitted = dimensionOmitted;
        if (!dimensionOmitted) {
          return;
        }
        if (!this._dimNameMap) {
          this._dimNameMap = ensureSourceDimNameMap(this.source);
        }
      };
      SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
        return retrieve2(this._dimNameMap.get(dimName), -1);
      };
      SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
        var dimensionsDefine = this.source.dimensionsDefine;
        if (dimensionsDefine) {
          return dimensionsDefine[dimIndex];
        }
      };
      SeriesDataSchema2.prototype.makeStoreSchema = function() {
        var dimCount = this._fullDimCount;
        var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
        var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
        var dimHash = "";
        var dims = [];
        for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
          var property2 = void 0;
          var type = void 0;
          var ordinalMeta = void 0;
          var seriesDimDef = this.dimensions[seriesDimIdx];
          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            property2 = willRetrieveDataByName ? seriesDimDef.name : null;
            type = seriesDimDef.type;
            ordinalMeta = seriesDimDef.ordinalMeta;
            seriesDimIdx++;
          } else {
            var sourceDimDef = this.getSourceDimension(fullDimIdx);
            if (sourceDimDef) {
              property2 = willRetrieveDataByName ? sourceDimDef.name : null;
              type = sourceDimDef.type;
            }
          }
          dims.push({
            property: property2,
            type,
            ordinalMeta
          });
          if (willRetrieveDataByName && property2 != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
            dimHash += makeHashStrict ? property2.replace(/\`/g, "`1").replace(/\$/g, "`2") : property2;
          }
          dimHash += "$";
          dimHash += dimTypeShort[type] || "f";
          if (ordinalMeta) {
            dimHash += ordinalMeta.uid;
          }
          dimHash += "$";
        }
        var source = this.source;
        var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
        return {
          dimensions: dims,
          hash
        };
      };
      SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
        var result = [];
        for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
          var name_1 = void 0;
          var seriesDimDef = this.dimensions[seriesDimIdx];
          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            if (!seriesDimDef.isCalculationCoord) {
              name_1 = seriesDimDef.name;
            }
            seriesDimIdx++;
          } else {
            var sourceDimDef = this.getSourceDimension(fullDimIdx);
            if (sourceDimDef) {
              name_1 = sourceDimDef.name;
            }
          }
          result.push(name_1);
        }
        return result;
      };
      SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
        this.dimensions.push(dimDef);
        dimDef.isCalculationCoord = true;
        this._fullDimCount++;
        this._updateDimOmitted(true);
      };
      return SeriesDataSchema2;
    }()
  );
  function isSeriesDataSchema(schema) {
    return schema instanceof SeriesDataSchema;
  }
  function createDimNameMap(dimsDef) {
    var dataDimNameMap = createHashMap();
    for (var i2 = 0; i2 < (dimsDef || []).length; i2++) {
      var dimDefItemRaw = dimsDef[i2];
      var userDimName = isObject$3(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        dataDimNameMap.set(userDimName, i2);
      }
    }
    return dataDimNameMap;
  }
  function ensureSourceDimNameMap(source) {
    var innerSource = inner$5(source);
    return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
  }
  function shouldOmitUnusedDimensions(dimCount) {
    return dimCount > 30;
  }
  var isObject$1 = isObject$3;
  var map = map$1;
  var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
  var ID_PREFIX = "e\0\0";
  var INDEX_NOT_FOUND = -1;
  var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
  var CLONE_PROPERTIES = ["_approximateExtent"];
  var prepareInvertedIndex;
  var getId;
  var getIdNameFromStore;
  var normalizeDimensions;
  var transferProperties;
  var cloneListForMapAndSample;
  var makeIdFromName;
  var SeriesData = (
    /** @class */
    function() {
      function SeriesData2(dimensionsInput, hostModel) {
        this.type = "list";
        this._dimOmitted = false;
        this._nameList = [];
        this._idList = [];
        this._visual = {};
        this._layout = {};
        this._itemVisuals = [];
        this._itemLayouts = [];
        this._graphicEls = [];
        this._approximateExtent = {};
        this._calculationInfo = {};
        this.hasItemOption = false;
        this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"];
        this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
        this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
        var dimensions;
        var assignStoreDimIdx = false;
        if (isSeriesDataSchema(dimensionsInput)) {
          dimensions = dimensionsInput.dimensions;
          this._dimOmitted = dimensionsInput.isDimensionOmitted();
          this._schema = dimensionsInput;
        } else {
          assignStoreDimIdx = true;
          dimensions = dimensionsInput;
        }
        dimensions = dimensions || ["x", "y"];
        var dimensionInfos = {};
        var dimensionNames = [];
        var invertedIndicesMap = {};
        var needsHasOwn = false;
        var emptyObj = {};
        for (var i2 = 0; i2 < dimensions.length; i2++) {
          var dimInfoInput = dimensions[i2];
          var dimensionInfo = isString$1(dimInfoInput) ? new SeriesDimensionDefine({
            name: dimInfoInput
          }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;
          var dimensionName = dimensionInfo.name;
          dimensionInfo.type = dimensionInfo.type || "float";
          if (!dimensionInfo.coordDim) {
            dimensionInfo.coordDim = dimensionName;
            dimensionInfo.coordDimIndex = 0;
          }
          var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
          dimensionNames.push(dimensionName);
          dimensionInfos[dimensionName] = dimensionInfo;
          if (emptyObj[dimensionName] != null) {
            needsHasOwn = true;
          }
          if (dimensionInfo.createInvertedIndices) {
            invertedIndicesMap[dimensionName] = [];
          }
          if (otherDims.itemName === 0) {
            this._nameDimIdx = i2;
          }
          if (otherDims.itemId === 0) {
            this._idDimIdx = i2;
          }
          if (assignStoreDimIdx) {
            dimensionInfo.storeDimIndex = i2;
          }
        }
        this.dimensions = dimensionNames;
        this._dimInfos = dimensionInfos;
        this._initGetDimensionInfo(needsHasOwn);
        this.hostModel = hostModel;
        this._invertedIndicesMap = invertedIndicesMap;
        if (this._dimOmitted) {
          var dimIdxToName_1 = this._dimIdxToName = createHashMap();
          each$4(dimensionNames, function(dimName) {
            dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
          });
        }
      }
      SeriesData2.prototype.getDimension = function(dim) {
        var dimIdx = this._recognizeDimIndex(dim);
        if (dimIdx == null) {
          return dim;
        }
        dimIdx = dim;
        if (!this._dimOmitted) {
          return this.dimensions[dimIdx];
        }
        var dimName = this._dimIdxToName.get(dimIdx);
        if (dimName != null) {
          return dimName;
        }
        var sourceDimDef = this._schema.getSourceDimension(dimIdx);
        if (sourceDimDef) {
          return sourceDimDef.name;
        }
      };
      SeriesData2.prototype.getDimensionIndex = function(dim) {
        var dimIdx = this._recognizeDimIndex(dim);
        if (dimIdx != null) {
          return dimIdx;
        }
        if (dim == null) {
          return -1;
        }
        var dimInfo = this._getDimInfo(dim);
        return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
      };
      SeriesData2.prototype._recognizeDimIndex = function(dim) {
        if (isNumber$1(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
          return +dim;
        }
      };
      SeriesData2.prototype._getStoreDimIndex = function(dim) {
        var dimIdx = this.getDimensionIndex(dim);
        return dimIdx;
      };
      SeriesData2.prototype.getDimensionInfo = function(dim) {
        return this._getDimInfo(this.getDimension(dim));
      };
      SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
        var dimensionInfos = this._dimInfos;
        this._getDimInfo = needsHasOwn ? function(dimName) {
          return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
        } : function(dimName) {
          return dimensionInfos[dimName];
        };
      };
      SeriesData2.prototype.getDimensionsOnCoord = function() {
        return this._dimSummary.dataDimsOnCoord.slice();
      };
      SeriesData2.prototype.mapDimension = function(coordDim, idx) {
        var dimensionsSummary = this._dimSummary;
        if (idx == null) {
          return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
        }
        var dims = dimensionsSummary.encode[coordDim];
        return dims ? dims[idx] : null;
      };
      SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
        var dimensionsSummary = this._dimSummary;
        var dims = dimensionsSummary.encode[coordDim];
        return (dims || []).slice();
      };
      SeriesData2.prototype.getStore = function() {
        return this._store;
      };
      SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
        var _this = this;
        var store;
        if (data instanceof DataStore) {
          store = data;
        }
        if (!store) {
          var dimensions = this.dimensions;
          var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
          store = new DataStore();
          var dimensionInfos = map(dimensions, function(dimName) {
            return {
              type: _this._dimInfos[dimName].type,
              property: dimName
            };
          });
          store.initData(provider, dimensionInfos, dimValueGetter);
        }
        this._store = store;
        this._nameList = (nameList || []).slice();
        this._idList = [];
        this._nameRepeatCount = {};
        this._doInit(0, store.count());
        this._dimSummary = summarizeDimensions(this, this._schema);
        this.userOutput = this._dimSummary.userOutput;
      };
      SeriesData2.prototype.appendData = function(data) {
        var range2 = this._store.appendData(data);
        this._doInit(range2[0], range2[1]);
      };
      SeriesData2.prototype.appendValues = function(values, names2) {
        var _a2 = this._store.appendValues(values, names2 && names2.length), start2 = _a2.start, end2 = _a2.end;
        var shouldMakeIdFromName = this._shouldMakeIdFromName();
        this._updateOrdinalMeta();
        if (names2) {
          for (var idx = start2; idx < end2; idx++) {
            var sourceIdx = idx - start2;
            this._nameList[idx] = names2[sourceIdx];
            if (shouldMakeIdFromName) {
              makeIdFromName(this, idx);
            }
          }
        }
      };
      SeriesData2.prototype._updateOrdinalMeta = function() {
        var store = this._store;
        var dimensions = this.dimensions;
        for (var i2 = 0; i2 < dimensions.length; i2++) {
          var dimInfo = this._dimInfos[dimensions[i2]];
          if (dimInfo.ordinalMeta) {
            store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
          }
        }
      };
      SeriesData2.prototype._shouldMakeIdFromName = function() {
        var provider = this._store.getProvider();
        return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
      };
      SeriesData2.prototype._doInit = function(start2, end2) {
        if (start2 >= end2) {
          return;
        }
        var store = this._store;
        var provider = store.getProvider();
        this._updateOrdinalMeta();
        var nameList = this._nameList;
        var idList = this._idList;
        var sourceFormat = provider.getSource().sourceFormat;
        var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
        if (isFormatOriginal && !provider.pure) {
          var sharedDataItem = [];
          for (var idx = start2; idx < end2; idx++) {
            var dataItem = provider.getItem(idx, sharedDataItem);
            if (!this.hasItemOption && isDataItemOption(dataItem)) {
              this.hasItemOption = true;
            }
            if (dataItem) {
              var itemName = dataItem.name;
              if (nameList[idx] == null && itemName != null) {
                nameList[idx] = convertOptionIdName(itemName, null);
              }
              var itemId = dataItem.id;
              if (idList[idx] == null && itemId != null) {
                idList[idx] = convertOptionIdName(itemId, null);
              }
            }
          }
        }
        if (this._shouldMakeIdFromName()) {
          for (var idx = start2; idx < end2; idx++) {
            makeIdFromName(this, idx);
          }
        }
        prepareInvertedIndex(this);
      };
      SeriesData2.prototype.getApproximateExtent = function(dim) {
        return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
        dim = this.getDimension(dim);
        this._approximateExtent[dim] = extent3.slice();
      };
      SeriesData2.prototype.getCalculationInfo = function(key2) {
        return this._calculationInfo[key2];
      };
      SeriesData2.prototype.setCalculationInfo = function(key2, value) {
        isObject$1(key2) ? extend$1(this._calculationInfo, key2) : this._calculationInfo[key2] = value;
      };
      SeriesData2.prototype.getName = function(idx) {
        var rawIndex = this.getRawIndex(idx);
        var name = this._nameList[rawIndex];
        if (name == null && this._nameDimIdx != null) {
          name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
        }
        if (name == null) {
          name = "";
        }
        return name;
      };
      SeriesData2.prototype._getCategory = function(dimIdx, idx) {
        var ordinal = this._store.get(dimIdx, idx);
        var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
        if (ordinalMeta) {
          return ordinalMeta.categories[ordinal];
        }
        return ordinal;
      };
      SeriesData2.prototype.getId = function(idx) {
        return getId(this, this.getRawIndex(idx));
      };
      SeriesData2.prototype.count = function() {
        return this._store.count();
      };
      SeriesData2.prototype.get = function(dim, idx) {
        var store = this._store;
        var dimInfo = this._dimInfos[dim];
        if (dimInfo) {
          return store.get(dimInfo.storeDimIndex, idx);
        }
      };
      SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
        var store = this._store;
        var dimInfo = this._dimInfos[dim];
        if (dimInfo) {
          return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
        }
      };
      SeriesData2.prototype.getIndices = function() {
        return this._store.getIndices();
      };
      SeriesData2.prototype.getDataExtent = function(dim) {
        return this._store.getDataExtent(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getSum = function(dim) {
        return this._store.getSum(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getMedian = function(dim) {
        return this._store.getMedian(this._getStoreDimIndex(dim));
      };
      SeriesData2.prototype.getValues = function(dimensions, idx) {
        var _this = this;
        var store = this._store;
        return isArray$1(dimensions) ? store.getValues(map(dimensions, function(dim) {
          return _this._getStoreDimIndex(dim);
        }), idx) : store.getValues(dimensions);
      };
      SeriesData2.prototype.hasValue = function(idx) {
        var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
        for (var i2 = 0, len2 = dataDimIndicesOnCoord.length; i2 < len2; i2++) {
          if (isNaN(this._store.get(dataDimIndicesOnCoord[i2], idx))) {
            return false;
          }
        }
        return true;
      };
      SeriesData2.prototype.indexOfName = function(name) {
        for (var i2 = 0, len2 = this._store.count(); i2 < len2; i2++) {
          if (this.getName(i2) === name) {
            return i2;
          }
        }
        return -1;
      };
      SeriesData2.prototype.getRawIndex = function(idx) {
        return this._store.getRawIndex(idx);
      };
      SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
        return this._store.indexOfRawIndex(rawIndex);
      };
      SeriesData2.prototype.rawIndexOf = function(dim, value) {
        var invertedIndices = dim && this._invertedIndicesMap[dim];
        var rawIndex = invertedIndices && invertedIndices[value];
        if (rawIndex == null || isNaN(rawIndex)) {
          return INDEX_NOT_FOUND;
        }
        return rawIndex;
      };
      SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
        return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
      };
      SeriesData2.prototype.each = function(dims, cb, ctx) {
        if (isFunction$1(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        var fCtx = ctx || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store.each(dimIndices, fCtx ? bind$2(cb, fCtx) : cb);
      };
      SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
        if (isFunction$1(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        var fCtx = ctx || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store = this._store.filter(dimIndices, fCtx ? bind$2(cb, fCtx) : cb);
        return this;
      };
      SeriesData2.prototype.selectRange = function(range2) {
        var _this = this;
        var innerRange = {};
        var dims = keys(range2);
        each$4(dims, function(dim) {
          var dimIdx = _this._getStoreDimIndex(dim);
          innerRange[dimIdx] = range2[dim];
        });
        this._store = this._store.selectRange(innerRange);
        return this;
      };
      SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
        if (isFunction$1(dims)) {
          ctx = cb;
          cb = dims;
          dims = [];
        }
        ctx = ctx || this;
        var result = [];
        this.each(dims, function() {
          result.push(cb && cb.apply(this, arguments));
        }, ctx);
        return result;
      };
      SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
        var fCtx = ctx || ctxCompat || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        var list2 = cloneListForMapAndSample(this);
        list2._store = this._store.map(dimIndices, fCtx ? bind$2(cb, fCtx) : cb);
        return list2;
      };
      SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
        var fCtx = ctx || ctxCompat || this;
        var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
        this._store.modify(dimIndices, fCtx ? bind$2(cb, fCtx) : cb);
      };
      SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
        var list2 = cloneListForMapAndSample(this);
        list2._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
        return list2;
      };
      SeriesData2.prototype.minmaxDownSample = function(valueDimension, rate) {
        var list2 = cloneListForMapAndSample(this);
        list2._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
        return list2;
      };
      SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
        var list2 = cloneListForMapAndSample(this);
        list2._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
        return list2;
      };
      SeriesData2.prototype.getRawDataItem = function(idx) {
        return this._store.getRawDataItem(idx);
      };
      SeriesData2.prototype.getItemModel = function(idx) {
        var hostModel = this.hostModel;
        var dataItem = this.getRawDataItem(idx);
        return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);
      };
      SeriesData2.prototype.diff = function(otherList) {
        var thisList = this;
        return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
          return getId(otherList, idx);
        }, function(idx) {
          return getId(thisList, idx);
        });
      };
      SeriesData2.prototype.getVisual = function(key2) {
        var visual = this._visual;
        return visual && visual[key2];
      };
      SeriesData2.prototype.setVisual = function(kvObj, val) {
        this._visual = this._visual || {};
        if (isObject$1(kvObj)) {
          extend$1(this._visual, kvObj);
        } else {
          this._visual[kvObj] = val;
        }
      };
      SeriesData2.prototype.getItemVisual = function(idx, key2) {
        var itemVisual = this._itemVisuals[idx];
        var val = itemVisual && itemVisual[key2];
        if (val == null) {
          return this.getVisual(key2);
        }
        return val;
      };
      SeriesData2.prototype.hasItemVisual = function() {
        return this._itemVisuals.length > 0;
      };
      SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key2) {
        var itemVisuals = this._itemVisuals;
        var itemVisual = itemVisuals[idx];
        if (!itemVisual) {
          itemVisual = itemVisuals[idx] = {};
        }
        var val = itemVisual[key2];
        if (val == null) {
          val = this.getVisual(key2);
          if (isArray$1(val)) {
            val = val.slice();
          } else if (isObject$1(val)) {
            val = extend$1({}, val);
          }
          itemVisual[key2] = val;
        }
        return val;
      };
      SeriesData2.prototype.setItemVisual = function(idx, key2, value) {
        var itemVisual = this._itemVisuals[idx] || {};
        this._itemVisuals[idx] = itemVisual;
        if (isObject$1(key2)) {
          extend$1(itemVisual, key2);
        } else {
          itemVisual[key2] = value;
        }
      };
      SeriesData2.prototype.clearAllVisual = function() {
        this._visual = {};
        this._itemVisuals = [];
      };
      SeriesData2.prototype.setLayout = function(key2, val) {
        isObject$1(key2) ? extend$1(this._layout, key2) : this._layout[key2] = val;
      };
      SeriesData2.prototype.getLayout = function(key2) {
        return this._layout[key2];
      };
      SeriesData2.prototype.getItemLayout = function(idx) {
        return this._itemLayouts[idx];
      };
      SeriesData2.prototype.setItemLayout = function(idx, layout2, merge2) {
        this._itemLayouts[idx] = merge2 ? extend$1(this._itemLayouts[idx] || {}, layout2) : layout2;
      };
      SeriesData2.prototype.clearItemLayouts = function() {
        this._itemLayouts.length = 0;
      };
      SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
        var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
        setCommonECData(seriesIndex, this.dataType, idx, el);
        this._graphicEls[idx] = el;
      };
      SeriesData2.prototype.getItemGraphicEl = function(idx) {
        return this._graphicEls[idx];
      };
      SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
        each$4(this._graphicEls, function(el, idx) {
          if (el) {
            cb && cb.call(context, el, idx);
          }
        });
      };
      SeriesData2.prototype.cloneShallow = function(list2) {
        if (!list2) {
          list2 = new SeriesData2(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
        }
        transferProperties(list2, this);
        list2._store = this._store;
        return list2;
      };
      SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
        var originalMethod = this[methodName];
        if (!isFunction$1(originalMethod)) {
          return;
        }
        this.__wrappedMethods = this.__wrappedMethods || [];
        this.__wrappedMethods.push(methodName);
        this[methodName] = function() {
          var res = originalMethod.apply(this, arguments);
          return injectFunction.apply(this, [res].concat(slice(arguments)));
        };
      };
      SeriesData2.internalField = function() {
        prepareInvertedIndex = function(data) {
          var invertedIndicesMap = data._invertedIndicesMap;
          each$4(invertedIndicesMap, function(invertedIndices, dim) {
            var dimInfo = data._dimInfos[dim];
            var ordinalMeta = dimInfo.ordinalMeta;
            var store = data._store;
            if (ordinalMeta) {
              invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
              for (var i2 = 0; i2 < invertedIndices.length; i2++) {
                invertedIndices[i2] = INDEX_NOT_FOUND;
              }
              for (var i2 = 0; i2 < store.count(); i2++) {
                invertedIndices[store.get(dimInfo.storeDimIndex, i2)] = i2;
              }
            }
          });
        };
        getIdNameFromStore = function(data, dimIdx, idx) {
          return convertOptionIdName(data._getCategory(dimIdx, idx), null);
        };
        getId = function(data, rawIndex) {
          var id = data._idList[rawIndex];
          if (id == null && data._idDimIdx != null) {
            id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
          }
          if (id == null) {
            id = ID_PREFIX + rawIndex;
          }
          return id;
        };
        normalizeDimensions = function(dimensions) {
          if (!isArray$1(dimensions)) {
            dimensions = dimensions != null ? [dimensions] : [];
          }
          return dimensions;
        };
        cloneListForMapAndSample = function(original) {
          var list2 = new SeriesData2(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);
          transferProperties(list2, original);
          return list2;
        };
        transferProperties = function(target, source) {
          each$4(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
            if (source.hasOwnProperty(propName)) {
              target[propName] = source[propName];
            }
          });
          target.__wrappedMethods = source.__wrappedMethods;
          each$4(CLONE_PROPERTIES, function(propName) {
            target[propName] = clone$4(source[propName]);
          });
          target._calculationInfo = extend$1({}, source._calculationInfo);
        };
        makeIdFromName = function(data, idx) {
          var nameList = data._nameList;
          var idList = data._idList;
          var nameDimIdx = data._nameDimIdx;
          var idDimIdx = data._idDimIdx;
          var name = nameList[idx];
          var id = idList[idx];
          if (name == null && nameDimIdx != null) {
            nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
          }
          if (id == null && idDimIdx != null) {
            idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
          }
          if (id == null && name != null) {
            var nameRepeatCount = data._nameRepeatCount;
            var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
            id = name;
            if (nmCnt > 1) {
              id += "__ec__" + nmCnt;
            }
            idList[idx] = id;
          }
        };
      }();
      return SeriesData2;
    }()
  );
  function createDimensions(source, opt) {
    return prepareSeriesDataSchema(source, opt).dimensions;
  }
  function prepareSeriesDataSchema(source, opt) {
    if (!isSourceInstance(source)) {
      source = createSourceFromSeriesDataOption(source);
    }
    opt = opt || {};
    var sysDims = opt.coordDimensions || [];
    var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
    var coordDimNameMap = createHashMap();
    var resultList = [];
    var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
    var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
    var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
    var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
    var encodeDef = opt.encodeDefine;
    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount);
    }
    var encodeDefMap = createHashMap(encodeDef);
    var indicesMap = new CtorInt32Array$1(dimCount);
    for (var i2 = 0; i2 < indicesMap.length; i2++) {
      indicesMap[i2] = -1;
    }
    function getResultItem(dimIdx) {
      var idx = indicesMap[dimIdx];
      if (idx < 0) {
        var dimDefItemRaw = dimsDef[dimIdx];
        var dimDefItem = isObject$3(dimDefItemRaw) ? dimDefItemRaw : {
          name: dimDefItemRaw
        };
        var resultItem2 = new SeriesDimensionDefine();
        var userDimName = dimDefItem.name;
        if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
          resultItem2.name = resultItem2.displayName = userDimName;
        }
        dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
        var newIdx = resultList.length;
        indicesMap[dimIdx] = newIdx;
        resultItem2.storeDimIndex = dimIdx;
        resultList.push(resultItem2);
        return resultItem2;
      }
      return resultList[idx];
    }
    if (!omitUnusedDimensions) {
      for (var i2 = 0; i2 < dimCount; i2++) {
        getResultItem(i2);
      }
    }
    encodeDefMap.each(function(dataDimsRaw, coordDim2) {
      var dataDims = normalizeToArray(dataDimsRaw).slice();
      if (dataDims.length === 1 && !isString$1(dataDims[0]) && dataDims[0] < 0) {
        encodeDefMap.set(coordDim2, false);
        return;
      }
      var validDataDims = encodeDefMap.set(coordDim2, []);
      each$4(dataDims, function(resultDimIdxOrName, idx) {
        var resultDimIdx2 = isString$1(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
        if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
          validDataDims[idx] = resultDimIdx2;
          applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
        }
      });
    });
    var availDimIdx = 0;
    each$4(sysDims, function(sysDimItemRaw) {
      var coordDim2;
      var sysDimItemDimsDef;
      var sysDimItemOtherDims;
      var sysDimItem;
      if (isString$1(sysDimItemRaw)) {
        coordDim2 = sysDimItemRaw;
        sysDimItem = {};
      } else {
        sysDimItem = sysDimItemRaw;
        coordDim2 = sysDimItem.name;
        var ordinalMeta = sysDimItem.ordinalMeta;
        sysDimItem.ordinalMeta = null;
        sysDimItem = extend$1({}, sysDimItem);
        sysDimItem.ordinalMeta = ordinalMeta;
        sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemOtherDims = sysDimItem.otherDims;
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
      }
      var dataDims = encodeDefMap.get(coordDim2);
      if (dataDims === false) {
        return;
      }
      dataDims = normalizeToArray(dataDims);
      if (!dataDims.length) {
        for (var i3 = 0; i3 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i3++) {
          while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
            availDimIdx++;
          }
          availDimIdx < dimCount && dataDims.push(availDimIdx++);
        }
      }
      each$4(dataDims, function(resultDimIdx2, coordDimIndex) {
        var resultItem2 = getResultItem(resultDimIdx2);
        if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
          resultItem2.type = sysDimItem.type;
        }
        applyDim(defaults$1(resultItem2, sysDimItem), coordDim2, coordDimIndex);
        if (resultItem2.name == null && sysDimItemDimsDef) {
          var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
          !isObject$3(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          });
          resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
          resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
        }
        sysDimItemOtherDims && defaults$1(resultItem2.otherDims, sysDimItemOtherDims);
      });
    });
    function applyDim(resultItem2, coordDim2, coordDimIndex) {
      if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
        resultItem2.otherDims[coordDim2] = coordDimIndex;
      } else {
        resultItem2.coordDim = coordDim2;
        resultItem2.coordDimIndex = coordDimIndex;
        coordDimNameMap.set(coordDim2, true);
      }
    }
    var generateCoord = opt.generateCoord;
    var generateCoordCount = opt.generateCoordCount;
    var fromZero = generateCoordCount != null;
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
    var extra = generateCoord || "value";
    function ifNoNameFillWithCoordName(resultItem2) {
      if (resultItem2.name == null) {
        resultItem2.name = resultItem2.coordDim;
      }
    }
    if (!omitUnusedDimensions) {
      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = getResultItem(resultDimIdx);
        var coordDim = resultItem.coordDim;
        if (coordDim == null) {
          resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;
          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }
          generateCoordCount--;
        }
        ifNoNameFillWithCoordName(resultItem);
        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = "ordinal";
        }
      }
    } else {
      each$4(resultList, function(resultItem2) {
        ifNoNameFillWithCoordName(resultItem2);
      });
      resultList.sort(function(item0, item1) {
        return item0.storeDimIndex - item1.storeDimIndex;
      });
    }
    removeDuplication(resultList);
    return new SeriesDataSchema({
      source,
      dimensions: resultList,
      fullDimensionCount: dimCount,
      dimensionOmitted: omitUnusedDimensions
    });
  }
  function removeDuplication(result) {
    var duplicationMap = createHashMap();
    for (var i2 = 0; i2 < result.length; i2++) {
      var dim = result[i2];
      var dimOriginalName = dim.name;
      var count = duplicationMap.get(dimOriginalName) || 0;
      if (count > 0) {
        dim.name = dimOriginalName + (count - 1);
      }
      count++;
      duplicationMap.set(dimOriginalName, count);
    }
  }
  function getDimCount(source, sysDims, dimsDef, optDimCount) {
    var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
    each$4(sysDims, function(sysDimItem) {
      var sysDimItemDimsDef;
      if (isObject$3(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
        dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
      }
    });
    return dimCount;
  }
  function genCoordDimName(name, map2, fromZero) {
    if (fromZero || map2.hasKey(name)) {
      var i2 = 0;
      while (map2.hasKey(name + i2)) {
        i2++;
      }
      name += i2;
    }
    map2.set(name, true);
    return name;
  }
  var CoordSysInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function CoordSysInfo2(coordSysName) {
        this.coordSysDims = [];
        this.axisMap = createHashMap();
        this.categoryAxisMap = createHashMap();
        this.coordSysName = coordSysName;
      }
      return CoordSysInfo2;
    }()
  );
  function getCoordSysInfoBySeries(seriesModel) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var result = new CoordSysInfo(coordSysName);
    var fetch2 = fetchers[coordSysName];
    if (fetch2) {
      fetch2(seriesModel, result, result.axisMap, result.categoryAxisMap);
      return result;
    }
  }
  var fetchers = {
    cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
      var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
      var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
      result.coordSysDims = ["x", "y"];
      axisMap.set("x", xAxisModel);
      axisMap.set("y", yAxisModel);
      if (isCategory(xAxisModel)) {
        categoryAxisMap.set("x", xAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(yAxisModel)) {
        categoryAxisMap.set("y", yAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      result.coordSysDims = ["single"];
      axisMap.set("single", singleAxisModel);
      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set("single", singleAxisModel);
        result.firstCategoryDimIndex = 0;
      }
    },
    polar: function(seriesModel, result, axisMap, categoryAxisMap) {
      var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      result.coordSysDims = ["radius", "angle"];
      axisMap.set("radius", radiusAxisModel);
      axisMap.set("angle", angleAxisModel);
      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set("radius", radiusAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set("angle", angleAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    geo: function(seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ["lng", "lat"];
    },
    parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
      var ecModel = seriesModel.ecModel;
      var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
      each$4(parallelModel.parallelAxisIndex, function(axisIndex, index2) {
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axisDim = coordSysDims[index2];
        axisMap.set(axisDim, axisModel);
        if (isCategory(axisModel)) {
          categoryAxisMap.set(axisDim, axisModel);
          if (result.firstCategoryDimIndex == null) {
            result.firstCategoryDimIndex = index2;
          }
        }
      });
    }
  };
  function isCategory(axisModel) {
    return axisModel.get("type") === "category";
  }
  function enableDataStack(seriesModel, dimensionsInput, opt) {
    opt = opt || {};
    var byIndex = opt.byIndex;
    var stackedCoordDimension = opt.stackedCoordDimension;
    var dimensionDefineList;
    var schema;
    var store;
    if (isLegacyDimensionsInput(dimensionsInput)) {
      dimensionDefineList = dimensionsInput;
    } else {
      schema = dimensionsInput.schema;
      dimensionDefineList = schema.dimensions;
      store = dimensionsInput.store;
    }
    var mayStack = !!(seriesModel && seriesModel.get("stack"));
    var stackedByDimInfo;
    var stackedDimInfo;
    var stackResultDimension;
    var stackedOverDimension;
    each$4(dimensionDefineList, function(dimensionInfo, index2) {
      if (isString$1(dimensionInfo)) {
        dimensionDefineList[index2] = dimensionInfo = {
          name: dimensionInfo
        };
      }
      if (mayStack && !dimensionInfo.isExtraCoord) {
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo;
        }
        if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo;
        }
      }
    });
    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      byIndex = true;
    }
    if (stackedDimInfo) {
      stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
      stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true;
      }
      var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
      var stackedDimType = stackedDimInfo.type;
      var stackedDimCoordIndex_1 = 0;
      each$4(dimensionDefineList, function(dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
          stackedDimCoordIndex_1++;
        }
      });
      var stackedOverDimensionDefine = {
        name: stackResultDimension,
        coordDim: stackedDimCoordDim_1,
        coordDimIndex: stackedDimCoordIndex_1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length
      };
      var stackResultDimensionDefine = {
        name: stackedOverDimension,
        // This dimension contains stack base (generally, 0), so do not set it as
        // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex_1 + 1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length + 1
      };
      if (schema) {
        if (store) {
          stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
          stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
        }
        schema.appendCalculationDimension(stackedOverDimensionDefine);
        schema.appendCalculationDimension(stackResultDimensionDefine);
      } else {
        dimensionDefineList.push(stackedOverDimensionDefine);
        dimensionDefineList.push(stackResultDimensionDefine);
      }
    }
    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension,
      stackResultDimension
    };
  }
  function isLegacyDimensionsInput(dimensionsInput) {
    return !isSeriesDataSchema(dimensionsInput.schema);
  }
  function isDimensionStacked(data, stackedDim) {
    return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
  }
  function getStackedDimension(data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
  }
  function getCoordSysDimDefs(seriesModel, coordSysInfo) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var registeredCoordSys = CoordinateSystemManager.get(coordSysName);
    var coordSysDimDefs;
    if (coordSysInfo && coordSysInfo.coordSysDims) {
      coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function(dim) {
        var dimInfo = {
          name: dim
        };
        var axisModel = coordSysInfo.axisMap.get(dim);
        if (axisModel) {
          var axisType = axisModel.get("type");
          dimInfo.type = getDimensionTypeByAxis(axisType);
        }
        return dimInfo;
      });
    }
    if (!coordSysDimDefs) {
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
    }
    return coordSysDimDefs;
  }
  function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
    var firstCategoryDimIndex;
    var hasNameEncode;
    coordSysInfo && each$4(dimInfoList, function(dimInfo, dimIndex) {
      var coordDim = dimInfo.coordDim;
      var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex;
        }
        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        if (createInvertedIndices) {
          dimInfo.createInvertedIndices = true;
        }
      }
      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true;
      }
    });
    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
    }
    return firstCategoryDimIndex;
  }
  function createSeriesData(sourceRaw, seriesModel, opt) {
    opt = opt || {};
    var sourceManager = seriesModel.getSourceManager();
    var source;
    var isOriginalSource = false;
    {
      source = sourceManager.getSource();
      isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
    }
    var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
    var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
    var useEncodeDefaulter = opt.useEncodeDefaulter;
    var encodeDefaulter = isFunction$1(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
    var createDimensionOptions = {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefine: seriesModel.getEncode(),
      encodeDefaulter,
      canOmitUnusedDimensions: !isOriginalSource
    };
    var schema = prepareSeriesDataSchema(source, createDimensionOptions);
    var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
    var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
    var stackCalculationInfo = enableDataStack(seriesModel, {
      schema,
      store
    });
    var data = new SeriesData(schema, seriesModel);
    data.setCalculationInfo(stackCalculationInfo);
    var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
    } : null;
    data.hasItemOption = false;
    data.initData(
      // Try to reuse the data store in sourceManager if using dataset.
      isOriginalSource ? source : store,
      null,
      dimValueGetter
    );
    return data;
  }
  function isNeedCompleteOrdinalData(source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var sampleItem = firstDataNotNull(source.data || []);
      return !isArray$1(getDataItemValue(sampleItem));
    }
  }
  function firstDataNotNull(arr) {
    var i2 = 0;
    while (i2 < arr.length && arr[i2] == null) {
      i2++;
    }
    return arr[i2];
  }
  var Scale = (
    /** @class */
    function() {
      function Scale2(setting) {
        this._setting = setting || {};
        this._extent = [Infinity, -Infinity];
      }
      Scale2.prototype.getSetting = function(name) {
        return this._setting[name];
      };
      Scale2.prototype.unionExtent = function(other) {
        var extent3 = this._extent;
        other[0] < extent3[0] && (extent3[0] = other[0]);
        other[1] > extent3[1] && (extent3[1] = other[1]);
      };
      Scale2.prototype.unionExtentFromData = function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      };
      Scale2.prototype.getExtent = function() {
        return this._extent.slice();
      };
      Scale2.prototype.setExtent = function(start2, end2) {
        var thisExtent = this._extent;
        if (!isNaN(start2)) {
          thisExtent[0] = start2;
        }
        if (!isNaN(end2)) {
          thisExtent[1] = end2;
        }
      };
      Scale2.prototype.isInExtentRange = function(value) {
        return this._extent[0] <= value && this._extent[1] >= value;
      };
      Scale2.prototype.isBlank = function() {
        return this._isBlank;
      };
      Scale2.prototype.setBlank = function(isBlank) {
        this._isBlank = isBlank;
      };
      return Scale2;
    }()
  );
  enableClassManagement(Scale);
  var uidBase = 0;
  var OrdinalMeta = (
    /** @class */
    function() {
      function OrdinalMeta2(opt) {
        this.categories = opt.categories || [];
        this._needCollect = opt.needCollect;
        this._deduplication = opt.deduplication;
        this.uid = ++uidBase;
      }
      OrdinalMeta2.createByAxisModel = function(axisModel) {
        var option = axisModel.option;
        var data = option.data;
        var categories = data && map$1(data, getName);
        return new OrdinalMeta2({
          categories,
          needCollect: !categories,
          // deduplication is default in axis.
          deduplication: option.dedplication !== false
        });
      };
      OrdinalMeta2.prototype.getOrdinal = function(category) {
        return this._getOrCreateMap().get(category);
      };
      OrdinalMeta2.prototype.parseAndCollect = function(category) {
        var index2;
        var needCollect = this._needCollect;
        if (!isString$1(category) && !needCollect) {
          return category;
        }
        if (needCollect && !this._deduplication) {
          index2 = this.categories.length;
          this.categories[index2] = category;
          return index2;
        }
        var map2 = this._getOrCreateMap();
        index2 = map2.get(category);
        if (index2 == null) {
          if (needCollect) {
            index2 = this.categories.length;
            this.categories[index2] = category;
            map2.set(category, index2);
          } else {
            index2 = NaN;
          }
        }
        return index2;
      };
      OrdinalMeta2.prototype._getOrCreateMap = function() {
        return this._map || (this._map = createHashMap(this.categories));
      };
      return OrdinalMeta2;
    }()
  );
  function getName(obj2) {
    if (isObject$3(obj2) && obj2.value != null) {
      return obj2.value;
    } else {
      return obj2 + "";
    }
  }
  function isIntervalOrLogScale(scale2) {
    return scale2.type === "interval" || scale2.type === "log";
  }
  function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
    var result = {};
    var span = extent3[1] - extent3[0];
    var interval = result.interval = nice(span / splitNumber, true);
    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval;
    }
    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval;
    }
    var precision = result.intervalPrecision = getIntervalPrecision(interval);
    var niceTickExtent = result.niceTickExtent = [round$1(Math.ceil(extent3[0] / interval) * interval, precision), round$1(Math.floor(extent3[1] / interval) * interval, precision)];
    fixExtent(niceTickExtent, extent3);
    return result;
  }
  function increaseInterval(interval) {
    var exp10 = Math.pow(10, quantityExponent(interval));
    var f2 = interval / exp10;
    if (!f2) {
      f2 = 1;
    } else if (f2 === 2) {
      f2 = 3;
    } else if (f2 === 3) {
      f2 = 5;
    } else {
      f2 *= 2;
    }
    return round$1(f2 * exp10);
  }
  function getIntervalPrecision(interval) {
    return getPrecision(interval) + 2;
  }
  function clamp(niceTickExtent, idx, extent3) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
  }
  function fixExtent(niceTickExtent, extent3) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
    clamp(niceTickExtent, 0, extent3);
    clamp(niceTickExtent, 1, extent3);
    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1];
    }
  }
  function contain$1(val, extent3) {
    return val >= extent3[0] && val <= extent3[1];
  }
  function normalize(val, extent3) {
    if (extent3[1] === extent3[0]) {
      return 0.5;
    }
    return (val - extent3[0]) / (extent3[1] - extent3[0]);
  }
  function scale(val, extent3) {
    return val * (extent3[1] - extent3[0]) + extent3[0];
  }
  var OrdinalScale = (
    /** @class */
    function(_super) {
      __extends(OrdinalScale2, _super);
      function OrdinalScale2(setting) {
        var _this = _super.call(this, setting) || this;
        _this.type = "ordinal";
        var ordinalMeta = _this.getSetting("ordinalMeta");
        if (!ordinalMeta) {
          ordinalMeta = new OrdinalMeta({});
        }
        if (isArray$1(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta({
            categories: map$1(ordinalMeta, function(item) {
              return isObject$3(item) ? item.value : item;
            })
          });
        }
        _this._ordinalMeta = ordinalMeta;
        _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
        return _this;
      }
      OrdinalScale2.prototype.parse = function(val) {
        if (val == null) {
          return NaN;
        }
        return isString$1(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
      };
      OrdinalScale2.prototype.contain = function(rank) {
        rank = this.parse(rank);
        return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
      };
      OrdinalScale2.prototype.normalize = function(val) {
        val = this._getTickNumber(this.parse(val));
        return normalize(val, this._extent);
      };
      OrdinalScale2.prototype.scale = function(val) {
        val = Math.round(scale(val, this._extent));
        return this.getRawOrdinalNumber(val);
      };
      OrdinalScale2.prototype.getTicks = function() {
        var ticks = [];
        var extent3 = this._extent;
        var rank = extent3[0];
        while (rank <= extent3[1]) {
          ticks.push({
            value: rank
          });
          rank++;
        }
        return ticks;
      };
      OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
        return;
      };
      OrdinalScale2.prototype.setSortInfo = function(info) {
        if (info == null) {
          this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
          return;
        }
        var infoOrdinalNumbers = info.ordinalNumbers;
        var ordinalsByTick = this._ordinalNumbersByTick = [];
        var ticksByOrdinal = this._ticksByOrdinalNumber = [];
        var tickNum = 0;
        var allCategoryLen = this._ordinalMeta.categories.length;
        for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
          var ordinalNumber = infoOrdinalNumbers[tickNum];
          ordinalsByTick[tickNum] = ordinalNumber;
          ticksByOrdinal[ordinalNumber] = tickNum;
        }
        var unusedOrdinal = 0;
        for (; tickNum < allCategoryLen; ++tickNum) {
          while (ticksByOrdinal[unusedOrdinal] != null) {
            unusedOrdinal++;
          }
          ordinalsByTick.push(unusedOrdinal);
          ticksByOrdinal[unusedOrdinal] = tickNum;
        }
      };
      OrdinalScale2.prototype._getTickNumber = function(ordinal) {
        var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
        return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
      };
      OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
        var ordinalNumbersByTick = this._ordinalNumbersByTick;
        return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
      };
      OrdinalScale2.prototype.getLabel = function(tick) {
        if (!this.isBlank()) {
          var ordinalNumber = this.getRawOrdinalNumber(tick.value);
          var cateogry = this._ordinalMeta.categories[ordinalNumber];
          return cateogry == null ? "" : cateogry + "";
        }
      };
      OrdinalScale2.prototype.count = function() {
        return this._extent[1] - this._extent[0] + 1;
      };
      OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      };
      OrdinalScale2.prototype.isInExtentRange = function(value) {
        value = this._getTickNumber(value);
        return this._extent[0] <= value && this._extent[1] >= value;
      };
      OrdinalScale2.prototype.getOrdinalMeta = function() {
        return this._ordinalMeta;
      };
      OrdinalScale2.prototype.calcNiceTicks = function() {
      };
      OrdinalScale2.prototype.calcNiceExtent = function() {
      };
      OrdinalScale2.type = "ordinal";
      return OrdinalScale2;
    }(Scale)
  );
  Scale.registerClass(OrdinalScale);
  var roundNumber = round$1;
  var IntervalScale = (
    /** @class */
    function(_super) {
      __extends(IntervalScale2, _super);
      function IntervalScale2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "interval";
        _this._interval = 0;
        _this._intervalPrecision = 2;
        return _this;
      }
      IntervalScale2.prototype.parse = function(val) {
        return val;
      };
      IntervalScale2.prototype.contain = function(val) {
        return contain$1(val, this._extent);
      };
      IntervalScale2.prototype.normalize = function(val) {
        return normalize(val, this._extent);
      };
      IntervalScale2.prototype.scale = function(val) {
        return scale(val, this._extent);
      };
      IntervalScale2.prototype.setExtent = function(start2, end2) {
        var thisExtent = this._extent;
        if (!isNaN(start2)) {
          thisExtent[0] = parseFloat(start2);
        }
        if (!isNaN(end2)) {
          thisExtent[1] = parseFloat(end2);
        }
      };
      IntervalScale2.prototype.unionExtent = function(other) {
        var extent3 = this._extent;
        other[0] < extent3[0] && (extent3[0] = other[0]);
        other[1] > extent3[1] && (extent3[1] = other[1]);
        this.setExtent(extent3[0], extent3[1]);
      };
      IntervalScale2.prototype.getInterval = function() {
        return this._interval;
      };
      IntervalScale2.prototype.setInterval = function(interval) {
        this._interval = interval;
        this._niceExtent = this._extent.slice();
        this._intervalPrecision = getIntervalPrecision(interval);
      };
      IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
        var interval = this._interval;
        var extent3 = this._extent;
        var niceTickExtent = this._niceExtent;
        var intervalPrecision = this._intervalPrecision;
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        var safeLimit = 1e4;
        if (extent3[0] < niceTickExtent[0]) {
          if (expandToNicedExtent) {
            ticks.push({
              value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
            });
          } else {
            ticks.push({
              value: extent3[0]
            });
          }
        }
        var tick = niceTickExtent[0];
        while (tick <= niceTickExtent[1]) {
          ticks.push({
            value: tick
          });
          tick = roundNumber(tick + interval, intervalPrecision);
          if (tick === ticks[ticks.length - 1].value) {
            break;
          }
          if (ticks.length > safeLimit) {
            return [];
          }
        }
        var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
        if (extent3[1] > lastNiceTick) {
          if (expandToNicedExtent) {
            ticks.push({
              value: roundNumber(lastNiceTick + interval, intervalPrecision)
            });
          } else {
            ticks.push({
              value: extent3[1]
            });
          }
        }
        return ticks;
      };
      IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
        var ticks = this.getTicks(true);
        var minorTicks = [];
        var extent3 = this.getExtent();
        for (var i2 = 1; i2 < ticks.length; i2++) {
          var nextTick2 = ticks[i2];
          var prevTick = ticks[i2 - 1];
          var count = 0;
          var minorTicksGroup = [];
          var interval = nextTick2.value - prevTick.value;
          var minorInterval = interval / splitNumber;
          while (count < splitNumber - 1) {
            var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);
            if (minorTick > extent3[0] && minorTick < extent3[1]) {
              minorTicksGroup.push(minorTick);
            }
            count++;
          }
          minorTicks.push(minorTicksGroup);
        }
        return minorTicks;
      };
      IntervalScale2.prototype.getLabel = function(data, opt) {
        if (data == null) {
          return "";
        }
        var precision = opt && opt.precision;
        if (precision == null) {
          precision = getPrecision(data.value) || 0;
        } else if (precision === "auto") {
          precision = this._intervalPrecision;
        }
        var dataNum = roundNumber(data.value, precision, true);
        return addCommas(dataNum);
      };
      IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent3 = this._extent;
        var span = extent3[1] - extent3[0];
        if (!isFinite(span)) {
          return;
        }
        if (span < 0) {
          span = -span;
          extent3.reverse();
        }
        var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
      };
      IntervalScale2.prototype.calcNiceExtent = function(opt) {
        var extent3 = this._extent;
        if (extent3[0] === extent3[1]) {
          if (extent3[0] !== 0) {
            var expandSize = Math.abs(extent3[0]);
            if (!opt.fixMax) {
              extent3[1] += expandSize / 2;
              extent3[0] -= expandSize / 2;
            } else {
              extent3[0] -= expandSize / 2;
            }
          } else {
            extent3[1] = 1;
          }
        }
        var span = extent3[1] - extent3[0];
        if (!isFinite(span)) {
          extent3[0] = 0;
          extent3[1] = 1;
        }
        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        if (!opt.fixMin) {
          extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
        }
        if (!opt.fixMax) {
          extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
        }
      };
      IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
        this._niceExtent = [min3, max3];
      };
      IntervalScale2.type = "interval";
      return IntervalScale2;
    }(Scale)
  );
  Scale.registerClass(IntervalScale);
  var supportFloat32Array = typeof Float32Array !== "undefined";
  var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
  function createFloat32Array(arg) {
    if (isArray$1(arg)) {
      return supportFloat32Array ? new Float32Array(arg) : arg;
    }
    return new Float32ArrayCtor(arg);
  }
  var STACK_PREFIX = "__ec_stack_";
  function getSeriesStackId(seriesModel) {
    return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
  }
  function getAxisKey(axis) {
    return axis.dim + axis.index;
  }
  function getLayoutOnAxis(opt) {
    var params2 = [];
    var baseAxis = opt.axis;
    var axisKey = "axis0";
    if (baseAxis.type !== "category") {
      return;
    }
    var bandWidth = baseAxis.getBandWidth();
    for (var i2 = 0; i2 < opt.count || 0; i2++) {
      params2.push(defaults$1({
        bandWidth,
        axisKey,
        stackId: STACK_PREFIX + i2
      }, opt));
    }
    var widthAndOffsets = doCalBarWidthAndOffset(params2);
    var result = [];
    for (var i2 = 0; i2 < opt.count; i2++) {
      var item = widthAndOffsets[axisKey][STACK_PREFIX + i2];
      item.offsetCenter = item.offset + item.width / 2;
      result.push(item);
    }
    return result;
  }
  function prepareLayoutBarSeries(seriesType2, ecModel) {
    var seriesModels = [];
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (isOnCartesian(seriesModel)) {
        seriesModels.push(seriesModel);
      }
    });
    return seriesModels;
  }
  function getValueAxesMinGaps(barSeries) {
    var axisValues = {};
    each$4(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      if (baseAxis.type !== "time" && baseAxis.type !== "value") {
        return;
      }
      var data = seriesModel.getData();
      var key3 = baseAxis.dim + "_" + baseAxis.index;
      var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var store = data.getStore();
      for (var i2 = 0, cnt = store.count(); i2 < cnt; ++i2) {
        var value = store.get(dimIdx, i2);
        if (!axisValues[key3]) {
          axisValues[key3] = [value];
        } else {
          axisValues[key3].push(value);
        }
      }
    });
    var axisMinGaps = {};
    for (var key2 in axisValues) {
      if (axisValues.hasOwnProperty(key2)) {
        var valuesInAxis = axisValues[key2];
        if (valuesInAxis) {
          valuesInAxis.sort(function(a2, b2) {
            return a2 - b2;
          });
          var min3 = null;
          for (var j2 = 1; j2 < valuesInAxis.length; ++j2) {
            var delta = valuesInAxis[j2] - valuesInAxis[j2 - 1];
            if (delta > 0) {
              min3 = min3 === null ? delta : Math.min(min3, delta);
            }
          }
          axisMinGaps[key2] = min3;
        }
      }
    }
    return axisMinGaps;
  }
  function makeColumnLayout(barSeries) {
    var axisMinGaps = getValueAxesMinGaps(barSeries);
    var seriesInfoList = [];
    each$4(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else if (baseAxis.type === "value" || baseAxis.type === "time") {
        var key2 = baseAxis.dim + "_" + baseAxis.index;
        var minGap = axisMinGaps[key2];
        var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
        var scale2 = baseAxis.scale.getExtent();
        var scaleSpan = Math.abs(scale2[1] - scale2[0]);
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
      } else {
        var data = seriesModel.getData();
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      }
      var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
      var barMinWidth = parsePercent(
        // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
        // the auto-calculated bar width might be less than 0.5 / 1.
        seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1),
        bandWidth
      );
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      seriesInfoList.push({
        bandWidth,
        barWidth,
        barMaxWidth,
        barMinWidth,
        barGap,
        barCategoryGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      });
    });
    return doCalBarWidthAndOffset(seriesInfoList);
  }
  function doCalBarWidthAndOffset(seriesInfoList) {
    var columnsMap = {};
    each$4(seriesInfoList, function(seriesInfo, idx) {
      var axisKey = seriesInfo.axisKey;
      var bandWidth = seriesInfo.bandWidth;
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = seriesInfo.stackId;
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = seriesInfo.barWidth;
      if (barWidth && !stacks[stackId].width) {
        stacks[stackId].width = barWidth;
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        columnsOnAxis.remainedWidth -= barWidth;
      }
      var barMaxWidth = seriesInfo.barMaxWidth;
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      var barMinWidth = seriesInfo.barMinWidth;
      barMinWidth && (stacks[stackId].minWidth = barMinWidth);
      var barGap = seriesInfo.barGap;
      barGap != null && (columnsOnAxis.gap = barGap);
      var barCategoryGap = seriesInfo.barCategoryGap;
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    each$4(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGapPercent = columnsOnAxis.categoryGap;
      if (categoryGapPercent == null) {
        var columnCount = keys(stacks).length;
        categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
      }
      var categoryGap = parsePercent(categoryGapPercent, bandWidth);
      var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      each$4(stacks, function(column2) {
        var maxWidth = column2.maxWidth;
        var minWidth = column2.minWidth;
        if (!column2.width) {
          var finalWidth = autoWidth;
          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth);
          }
          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth;
          }
          if (finalWidth !== autoWidth) {
            column2.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        } else {
          var finalWidth = column2.width;
          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth);
          }
          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth);
          }
          column2.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      each$4(stacks, function(column2, idx) {
        if (!column2.width) {
          column2.width = autoWidth;
        }
        lastColumn = column2;
        widthSum += column2.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset2 = -widthSum / 2;
      each$4(stacks, function(column2, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth,
          offset: offset2,
          width: column2.width
        };
        offset2 += column2.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
    if (barWidthAndOffset && axis) {
      var result = barWidthAndOffset[getAxisKey(axis)];
      return result;
    }
  }
  function layout$1(seriesType2, ecModel) {
    var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
    var barWidthAndOffset = makeColumnLayout(seriesModels);
    each$4(seriesModels, function(seriesModel) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      data.setLayout({
        bandWidth: columnLayoutInfo.bandWidth,
        offset: columnOffset,
        size: columnWidth
      });
    });
  }
  function createProgressiveLayout(seriesType2) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        if (!isOnCartesian(seriesModel)) {
          return;
        }
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var valueAxis2 = cartesian.getOtherAxis(baseAxis);
        var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
        var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
        var drawBackground = seriesModel.get("showBackground", true);
        var valueDim = data.mapDimension(valueAxis2.dim);
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
        var isValueAxisH = valueAxis2.isHorizontal();
        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
        var isLarge = isInLargeMode(seriesModel);
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
        var columnWidth = data.getLayout("size");
        var columnOffset = data.getLayout("offset");
        return {
          progress: function(params2, data2) {
            var count = params2.count;
            var largePoints = isLarge && createFloat32Array(count * 3);
            var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);
            var largeDataIndices = isLarge && createFloat32Array(count);
            var coordLayout = cartesian.master.getRect();
            var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
            var dataIndex;
            var store = data2.getStore();
            var idxOffset = 0;
            while ((dataIndex = params2.next()) != null) {
              var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
              var baseValue = store.get(baseDimIdx, dataIndex);
              var baseCoord = valueAxisStart;
              var stackStartValue = void 0;
              if (stacked) {
                stackStartValue = +value - store.get(valueDimIdx, dataIndex);
              }
              var x2 = void 0;
              var y2 = void 0;
              var width = void 0;
              var height = void 0;
              if (isValueAxisH) {
                var coord = cartesian.dataToPoint([value, baseValue]);
                if (stacked) {
                  var startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);
                  baseCoord = startCoord[0];
                }
                x2 = baseCoord;
                y2 = coord[1] + columnOffset;
                width = coord[0] - baseCoord;
                height = columnWidth;
                if (Math.abs(width) < barMinHeight) {
                  width = (width < 0 ? -1 : 1) * barMinHeight;
                }
              } else {
                var coord = cartesian.dataToPoint([baseValue, value]);
                if (stacked) {
                  var startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);
                  baseCoord = startCoord[1];
                }
                x2 = coord[0] + columnOffset;
                y2 = baseCoord;
                width = columnWidth;
                height = coord[1] - baseCoord;
                if (Math.abs(height) < barMinHeight) {
                  height = (height <= 0 ? -1 : 1) * barMinHeight;
                }
              }
              if (!isLarge) {
                data2.setItemLayout(dataIndex, {
                  x: x2,
                  y: y2,
                  width,
                  height
                });
              } else {
                largePoints[idxOffset] = x2;
                largePoints[idxOffset + 1] = y2;
                largePoints[idxOffset + 2] = isValueAxisH ? width : height;
                if (largeBackgroundPoints) {
                  largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x2;
                  largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y2 : coordLayout.y;
                  largeBackgroundPoints[idxOffset + 2] = bgSize;
                }
                largeDataIndices[dataIndex] = dataIndex;
              }
              idxOffset += 3;
            }
            if (isLarge) {
              data2.setLayout({
                largePoints,
                largeDataIndices,
                largeBackgroundPoints,
                valueAxisHorizontal: isValueAxisH
              });
            }
          }
        };
      }
    };
  }
  function isOnCartesian(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
  }
  function isInLargeMode(seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
  }
  function getValueAxisStart(baseAxis, valueAxis2) {
    var startValue = valueAxis2.model.get("startValue");
    if (!startValue) {
      startValue = 0;
    }
    return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? startValue > 0 ? startValue : 1 : startValue));
  }
  var bisect = function(a2, x2, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a2[mid][1] < x2) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return lo;
  };
  var TimeScale = (
    /** @class */
    function(_super) {
      __extends(TimeScale2, _super);
      function TimeScale2(settings) {
        var _this = _super.call(this, settings) || this;
        _this.type = "time";
        return _this;
      }
      TimeScale2.prototype.getLabel = function(tick) {
        var useUTC = this.getSetting("useUTC");
        return format$1(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
      };
      TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
        var isUTC = this.getSetting("useUTC");
        var lang = this.getSetting("locale");
        return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
      };
      TimeScale2.prototype.getTicks = function() {
        var interval = this._interval;
        var extent3 = this._extent;
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        ticks.push({
          value: extent3[0],
          level: 0
        });
        var useUTC = this.getSetting("useUTC");
        var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
        ticks = ticks.concat(innerTicks);
        ticks.push({
          value: extent3[1],
          level: 0
        });
        return ticks;
      };
      TimeScale2.prototype.calcNiceExtent = function(opt) {
        var extent3 = this._extent;
        if (extent3[0] === extent3[1]) {
          extent3[0] -= ONE_DAY;
          extent3[1] += ONE_DAY;
        }
        if (extent3[1] === -Infinity && extent3[0] === Infinity) {
          var d2 = /* @__PURE__ */ new Date();
          extent3[1] = +new Date(d2.getFullYear(), d2.getMonth(), d2.getDate());
          extent3[0] = extent3[1] - ONE_DAY;
        }
        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
      };
      TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;
        var extent3 = this._extent;
        var span = extent3[1] - extent3[0];
        this._approxInterval = span / approxTickNum;
        if (minInterval != null && this._approxInterval < minInterval) {
          this._approxInterval = minInterval;
        }
        if (maxInterval != null && this._approxInterval > maxInterval) {
          this._approxInterval = maxInterval;
        }
        var scaleIntervalsLen = scaleIntervals.length;
        var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
        this._interval = scaleIntervals[idx][1];
        this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
      };
      TimeScale2.prototype.parse = function(val) {
        return isNumber$1(val) ? val : +parseDate(val);
      };
      TimeScale2.prototype.contain = function(val) {
        return contain$1(this.parse(val), this._extent);
      };
      TimeScale2.prototype.normalize = function(val) {
        return normalize(this.parse(val), this._extent);
      };
      TimeScale2.prototype.scale = function(val) {
        return scale(val, this._extent);
      };
      TimeScale2.type = "time";
      return TimeScale2;
    }(IntervalScale)
  );
  var scaleIntervals = [
    // Format                           interval
    ["second", ONE_SECOND],
    ["minute", ONE_MINUTE],
    ["hour", ONE_HOUR],
    ["quarter-day", ONE_HOUR * 6],
    ["half-day", ONE_HOUR * 12],
    ["day", ONE_DAY * 1.2],
    ["half-week", ONE_DAY * 3.5],
    ["week", ONE_DAY * 7],
    ["month", ONE_DAY * 31],
    ["quarter", ONE_DAY * 95],
    ["half-year", ONE_YEAR / 2],
    ["year", ONE_YEAR]
    // 1Y
  ];
  function isUnitValueSame(unit, valueA, valueB, isUTC) {
    var dateA = parseDate(valueA);
    var dateB = parseDate(valueB);
    var isSame = function(unit2) {
      return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
    };
    var isSameYear = function() {
      return isSame("year");
    };
    var isSameMonth = function() {
      return isSameYear() && isSame("month");
    };
    var isSameDay = function() {
      return isSameMonth() && isSame("day");
    };
    var isSameHour = function() {
      return isSameDay() && isSame("hour");
    };
    var isSameMinute = function() {
      return isSameHour() && isSame("minute");
    };
    var isSameSecond = function() {
      return isSameMinute() && isSame("second");
    };
    var isSameMilliSecond = function() {
      return isSameSecond() && isSame("millisecond");
    };
    switch (unit) {
      case "year":
        return isSameYear();
      case "month":
        return isSameMonth();
      case "day":
        return isSameDay();
      case "hour":
        return isSameHour();
      case "minute":
        return isSameMinute();
      case "second":
        return isSameSecond();
      case "millisecond":
        return isSameMilliSecond();
    }
  }
  function getDateInterval(approxInterval, daysInMonth) {
    approxInterval /= ONE_DAY;
    return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
  }
  function getMonthInterval(approxInterval) {
    var APPROX_ONE_MONTH = 30 * ONE_DAY;
    approxInterval /= APPROX_ONE_MONTH;
    return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
  }
  function getHourInterval(approxInterval) {
    approxInterval /= ONE_HOUR;
    return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
  }
  function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
    approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
    return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
  }
  function getMillisecondsInterval(approxInterval) {
    return nice(approxInterval, true);
  }
  function getFirstTimestampOfUnit(date, unitName, isUTC) {
    var outDate = new Date(date);
    switch (getPrimaryTimeUnit(unitName)) {
      case "year":
      case "month":
        outDate[monthSetterName(isUTC)](0);
      case "day":
        outDate[dateSetterName(isUTC)](1);
      case "hour":
        outDate[hoursSetterName(isUTC)](0);
      case "minute":
        outDate[minutesSetterName(isUTC)](0);
      case "second":
        outDate[secondsSetterName(isUTC)](0);
        outDate[millisecondsSetterName(isUTC)](0);
    }
    return outDate.getTime();
  }
  function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
    var safeLimit = 1e4;
    var unitNames = timeUnits;
    var iter = 0;
    function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate2, out2) {
      var date = new Date(minTimestamp);
      var dateTime = minTimestamp;
      var d2 = date[getMethodName]();
      while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
        out2.push({
          value: dateTime
        });
        d2 += interval;
        date[setMethodName](d2);
        dateTime = date.getTime();
      }
      out2.push({
        value: dateTime,
        notAdd: true
      });
    }
    function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
      var newAddedTicks = [];
      var isFirstLevel = !lastLevelTicks.length;
      if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
        return;
      }
      if (isFirstLevel) {
        lastLevelTicks = [{
          // TODO Optimize. Not include so may ticks.
          value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
        }, {
          value: extent3[1]
        }];
      }
      for (var i22 = 0; i22 < lastLevelTicks.length - 1; i22++) {
        var startTick = lastLevelTicks[i22].value;
        var endTick = lastLevelTicks[i22 + 1].value;
        if (startTick === endTick) {
          continue;
        }
        var interval = void 0;
        var getterName = void 0;
        var setterName = void 0;
        var isDate2 = false;
        switch (unitName) {
          case "year":
            interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
            getterName = fullYearGetterName(isUTC);
            setterName = fullYearSetterName(isUTC);
            break;
          case "half-year":
          case "quarter":
          case "month":
            interval = getMonthInterval(approxInterval);
            getterName = monthGetterName(isUTC);
            setterName = monthSetterName(isUTC);
            break;
          case "week":
          // PENDING If week is added. Ignore day.
          case "half-week":
          case "day":
            interval = getDateInterval(approxInterval);
            getterName = dateGetterName(isUTC);
            setterName = dateSetterName(isUTC);
            isDate2 = true;
            break;
          case "half-day":
          case "quarter-day":
          case "hour":
            interval = getHourInterval(approxInterval);
            getterName = hoursGetterName(isUTC);
            setterName = hoursSetterName(isUTC);
            break;
          case "minute":
            interval = getMinutesAndSecondsInterval(approxInterval, true);
            getterName = minutesGetterName(isUTC);
            setterName = minutesSetterName(isUTC);
            break;
          case "second":
            interval = getMinutesAndSecondsInterval(approxInterval, false);
            getterName = secondsGetterName(isUTC);
            setterName = secondsSetterName(isUTC);
            break;
          case "millisecond":
            interval = getMillisecondsInterval(approxInterval);
            getterName = millisecondsGetterName(isUTC);
            setterName = millisecondsSetterName(isUTC);
            break;
        }
        addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate2, newAddedTicks);
        if (unitName === "year" && levelTicks2.length > 1 && i22 === 0) {
          levelTicks2.unshift({
            value: levelTicks2[0].value - interval
          });
        }
      }
      for (var i22 = 0; i22 < newAddedTicks.length; i22++) {
        levelTicks2.push(newAddedTicks[i22]);
      }
      return newAddedTicks;
    }
    var levelsTicks = [];
    var currentLevelTicks = [];
    var tickCount = 0;
    var lastLevelTickCount = 0;
    for (var i2 = 0; i2 < unitNames.length && iter++ < safeLimit; ++i2) {
      var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i2]);
      if (!isPrimaryTimeUnit(unitNames[i2])) {
        continue;
      }
      addLevelTicks(unitNames[i2], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
      var nextPrimaryTimeUnit = unitNames[i2 + 1] ? getPrimaryTimeUnit(unitNames[i2 + 1]) : null;
      if (primaryTimeUnit !== nextPrimaryTimeUnit) {
        if (currentLevelTicks.length) {
          lastLevelTickCount = tickCount;
          currentLevelTicks.sort(function(a2, b2) {
            return a2.value - b2.value;
          });
          var levelTicksRemoveDuplicated = [];
          for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
            var tickValue = currentLevelTicks[i_1].value;
            if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
              levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
              if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
                tickCount++;
              }
            }
          }
          var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
          if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
            break;
          }
          levelsTicks.push(levelTicksRemoveDuplicated);
          if (tickCount > targetTickNum || bottomUnitName === unitNames[i2]) {
            break;
          }
        }
        currentLevelTicks = [];
      }
    }
    var levelsTicksInExtent = filter(map$1(levelsTicks, function(levelTicks2) {
      return filter(levelTicks2, function(tick) {
        return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
      });
    }), function(levelTicks2) {
      return levelTicks2.length > 0;
    });
    var ticks = [];
    var maxLevel = levelsTicksInExtent.length - 1;
    for (var i2 = 0; i2 < levelsTicksInExtent.length; ++i2) {
      var levelTicks = levelsTicksInExtent[i2];
      for (var k2 = 0; k2 < levelTicks.length; ++k2) {
        ticks.push({
          value: levelTicks[k2].value,
          level: maxLevel - i2
        });
      }
    }
    ticks.sort(function(a2, b2) {
      return a2.value - b2.value;
    });
    var result = [];
    for (var i2 = 0; i2 < ticks.length; ++i2) {
      if (i2 === 0 || ticks[i2].value !== ticks[i2 - 1].value) {
        result.push(ticks[i2]);
      }
    }
    return result;
  }
  Scale.registerClass(TimeScale);
  var scaleProto = Scale.prototype;
  var intervalScaleProto = IntervalScale.prototype;
  var roundingErrorFix = round$1;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var mathPow = Math.pow;
  var mathLog$1 = Math.log;
  var LogScale = (
    /** @class */
    function(_super) {
      __extends(LogScale2, _super);
      function LogScale2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "log";
        _this.base = 10;
        _this._originalScale = new IntervalScale();
        _this._interval = 0;
        return _this;
      }
      LogScale2.prototype.getTicks = function(expandToNicedExtent) {
        var originalScale = this._originalScale;
        var extent3 = this._extent;
        var originalExtent = originalScale.getExtent();
        var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
        return map$1(ticks, function(tick) {
          var val = tick.value;
          var powVal = round$1(mathPow(this.base, val));
          powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
          powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
          return {
            value: powVal
          };
        }, this);
      };
      LogScale2.prototype.setExtent = function(start2, end2) {
        var base2 = mathLog$1(this.base);
        start2 = mathLog$1(Math.max(0, start2)) / base2;
        end2 = mathLog$1(Math.max(0, end2)) / base2;
        intervalScaleProto.setExtent.call(this, start2, end2);
      };
      LogScale2.prototype.getExtent = function() {
        var base2 = this.base;
        var extent3 = scaleProto.getExtent.call(this);
        extent3[0] = mathPow(base2, extent3[0]);
        extent3[1] = mathPow(base2, extent3[1]);
        var originalScale = this._originalScale;
        var originalExtent = originalScale.getExtent();
        this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
        this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
        return extent3;
      };
      LogScale2.prototype.unionExtent = function(extent3) {
        this._originalScale.unionExtent(extent3);
        var base2 = this.base;
        extent3[0] = mathLog$1(extent3[0]) / mathLog$1(base2);
        extent3[1] = mathLog$1(extent3[1]) / mathLog$1(base2);
        scaleProto.unionExtent.call(this, extent3);
      };
      LogScale2.prototype.unionExtentFromData = function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      };
      LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent3 = this._extent;
        var span = extent3[1] - extent3[0];
        if (span === Infinity || span <= 0) {
          return;
        }
        var interval = quantity(span);
        var err = approxTickNum / span * interval;
        if (err <= 0.5) {
          interval *= 10;
        }
        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10;
        }
        var niceExtent = [round$1(mathCeil(extent3[0] / interval) * interval), round$1(mathFloor(extent3[1] / interval) * interval)];
        this._interval = interval;
        this._niceExtent = niceExtent;
      };
      LogScale2.prototype.calcNiceExtent = function(opt) {
        intervalScaleProto.calcNiceExtent.call(this, opt);
        this._fixMin = opt.fixMin;
        this._fixMax = opt.fixMax;
      };
      LogScale2.prototype.parse = function(val) {
        return val;
      };
      LogScale2.prototype.contain = function(val) {
        val = mathLog$1(val) / mathLog$1(this.base);
        return contain$1(val, this._extent);
      };
      LogScale2.prototype.normalize = function(val) {
        val = mathLog$1(val) / mathLog$1(this.base);
        return normalize(val, this._extent);
      };
      LogScale2.prototype.scale = function(val) {
        val = scale(val, this._extent);
        return mathPow(this.base, val);
      };
      LogScale2.type = "log";
      return LogScale2;
    }(Scale)
  );
  var proto = LogScale.prototype;
  proto.getMinorTicks = intervalScaleProto.getMinorTicks;
  proto.getLabel = intervalScaleProto.getLabel;
  function fixRoundingError(val, originalVal) {
    return roundingErrorFix(val, getPrecision(originalVal));
  }
  Scale.registerClass(LogScale);
  var ScaleRawExtentInfo = (
    /** @class */
    function() {
      function ScaleRawExtentInfo2(scale2, model, originalExtent) {
        this._prepareParams(scale2, model, originalExtent);
      }
      ScaleRawExtentInfo2.prototype._prepareParams = function(scale2, model, dataExtent) {
        if (dataExtent[1] < dataExtent[0]) {
          dataExtent = [NaN, NaN];
        }
        this._dataMin = dataExtent[0];
        this._dataMax = dataExtent[1];
        var isOrdinal = this._isOrdinal = scale2.type === "ordinal";
        this._needCrossZero = scale2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
        var axisMinValue = model.get("min", true);
        if (axisMinValue == null) {
          axisMinValue = model.get("startValue", true);
        }
        var modelMinRaw = this._modelMinRaw = axisMinValue;
        if (isFunction$1(modelMinRaw)) {
          this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }));
        } else if (modelMinRaw !== "dataMin") {
          this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw);
        }
        var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
        if (isFunction$1(modelMaxRaw)) {
          this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }));
        } else if (modelMaxRaw !== "dataMax") {
          this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw);
        }
        if (isOrdinal) {
          this._axisDataLen = model.getCategories().length;
        } else {
          var boundaryGap = model.get("boundaryGap");
          var boundaryGapArr = isArray$1(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
          if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
            this._boundaryGapInner = [0, 0];
          } else {
            this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
          }
        }
      };
      ScaleRawExtentInfo2.prototype.calculate = function() {
        var isOrdinal = this._isOrdinal;
        var dataMin = this._dataMin;
        var dataMax = this._dataMax;
        var axisDataLen = this._axisDataLen;
        var boundaryGapInner = this._boundaryGapInner;
        var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
        var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
        var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
        var minFixed = min3 != null;
        var maxFixed = max3 != null;
        if (min3 == null) {
          min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
        }
        if (max3 == null) {
          max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
        }
        (min3 == null || !isFinite(min3)) && (min3 = NaN);
        (max3 == null || !isFinite(max3)) && (max3 = NaN);
        var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
        if (this._needCrossZero) {
          if (min3 > 0 && max3 > 0 && !minFixed) {
            min3 = 0;
          }
          if (min3 < 0 && max3 < 0 && !maxFixed) {
            max3 = 0;
          }
        }
        var determinedMin = this._determinedMin;
        var determinedMax = this._determinedMax;
        if (determinedMin != null) {
          min3 = determinedMin;
          minFixed = true;
        }
        if (determinedMax != null) {
          max3 = determinedMax;
          maxFixed = true;
        }
        return {
          min: min3,
          max: max3,
          minFixed,
          maxFixed,
          isBlank
        };
      };
      ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
        this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
      };
      ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
        var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
        this[attr] = val;
      };
      ScaleRawExtentInfo2.prototype.freeze = function() {
        this.frozen = true;
      };
      return ScaleRawExtentInfo2;
    }()
  );
  var DETERMINED_MIN_MAX_ATTR = {
    min: "_determinedMin",
    max: "_determinedMax"
  };
  var DATA_MIN_MAX_ATTR = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function ensureScaleRawExtentInfo(scale2, model, originalExtent) {
    var rawExtentInfo = scale2.rawExtentInfo;
    if (rawExtentInfo) {
      return rawExtentInfo;
    }
    rawExtentInfo = new ScaleRawExtentInfo(scale2, model, originalExtent);
    scale2.rawExtentInfo = rawExtentInfo;
    return rawExtentInfo;
  }
  function parseAxisModelMinMax(scale2, minMax) {
    return minMax == null ? null : eqNaN(minMax) ? NaN : scale2.parse(minMax);
  }
  function getScaleExtent(scale2, model) {
    var scaleType = scale2.type;
    var rawExtentResult = ensureScaleRawExtentInfo(scale2, model, scale2.getExtent()).calculate();
    scale2.setBlank(rawExtentResult.isBlank);
    var min3 = rawExtentResult.min;
    var max3 = rawExtentResult.max;
    var ecModel = model.ecModel;
    if (ecModel && scaleType === "time") {
      var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
      var isBaseAxisAndHasBarSeries_1 = false;
      each$4(barSeriesModels, function(seriesModel) {
        isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
      });
      if (isBaseAxisAndHasBarSeries_1) {
        var barWidthAndOffset = makeColumnLayout(barSeriesModels);
        var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
        min3 = adjustedScale.min;
        max3 = adjustedScale.max;
      }
    }
    return {
      extent: [min3, max3],
      // "fix" means "fixed", the value should not be
      // changed in the subsequent steps.
      fixMin: rawExtentResult.minFixed,
      fixMax: rawExtentResult.maxFixed
    };
  }
  function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
    var axisExtent = model.axis.getExtent();
    var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
    var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
    if (barsOnCurrentAxis === void 0) {
      return {
        min: min3,
        max: max3
      };
    }
    var minOverflow = Infinity;
    each$4(barsOnCurrentAxis, function(item) {
      minOverflow = Math.min(item.offset, minOverflow);
    });
    var maxOverflow = -Infinity;
    each$4(barsOnCurrentAxis, function(item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow);
    });
    minOverflow = Math.abs(minOverflow);
    maxOverflow = Math.abs(maxOverflow);
    var totalOverFlow = minOverflow + maxOverflow;
    var oldRange = max3 - min3;
    var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
    var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
    max3 += overflowBuffer * (maxOverflow / totalOverFlow);
    min3 -= overflowBuffer * (minOverflow / totalOverFlow);
    return {
      min: min3,
      max: max3
    };
  }
  function niceScaleExtent(scale2, inModel) {
    var model = inModel;
    var extentInfo = getScaleExtent(scale2, model);
    var extent3 = extentInfo.extent;
    var splitNumber = model.get("splitNumber");
    if (scale2 instanceof LogScale) {
      scale2.base = model.get("logBase");
    }
    var scaleType = scale2.type;
    var interval = model.get("interval");
    var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
    scale2.setExtent(extent3[0], extent3[1]);
    scale2.calcNiceExtent({
      splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: isIntervalOrTime ? model.get("minInterval") : null,
      maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
    });
    if (interval != null) {
      scale2.setInterval && scale2.setInterval(interval);
    }
  }
  function createScaleByModel(model, axisType) {
    axisType = axisType || model.get("type");
    if (axisType) {
      switch (axisType) {
        // Buildin scale
        case "category":
          return new OrdinalScale({
            ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
            extent: [Infinity, -Infinity]
          });
        case "time":
          return new TimeScale({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get("useUTC")
          });
        default:
          return new (Scale.getClass(axisType) || IntervalScale)();
      }
    }
  }
  function ifAxisCrossZero(axis) {
    var dataExtent = axis.scale.getExtent();
    var min3 = dataExtent[0];
    var max3 = dataExtent[1];
    return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
  }
  function makeLabelFormatter(axis) {
    var labelFormatter = axis.getLabelModel().get("formatter");
    var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
    if (axis.scale.type === "time") {
      return /* @__PURE__ */ function(tpl) {
        return function(tick, idx) {
          return axis.scale.getFormattedLabel(tick, idx, tpl);
        };
      }(labelFormatter);
    } else if (isString$1(labelFormatter)) {
      return /* @__PURE__ */ function(tpl) {
        return function(tick) {
          var label = axis.scale.getLabel(tick);
          var text = tpl.replace("{value}", label != null ? label : "");
          return text;
        };
      }(labelFormatter);
    } else if (isFunction$1(labelFormatter)) {
      return /* @__PURE__ */ function(cb) {
        return function(tick, idx) {
          if (categoryTickStart != null) {
            idx = tick.value - categoryTickStart;
          }
          return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
            level: tick.level
          } : null);
        };
      }(labelFormatter);
    } else {
      return function(tick) {
        return axis.scale.getLabel(tick);
      };
    }
  }
  function getAxisRawValue(axis, tick) {
    return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
  }
  function estimateLabelUnionRect(axis) {
    var axisModel = axis.model;
    var scale2 = axis.scale;
    if (!axisModel.get(["axisLabel", "show"]) || scale2.isBlank()) {
      return;
    }
    var realNumberScaleTicks;
    var tickCount;
    var categoryScaleExtent = scale2.getExtent();
    if (scale2 instanceof OrdinalScale) {
      tickCount = scale2.count();
    } else {
      realNumberScaleTicks = scale2.getTicks();
      tickCount = realNumberScaleTicks.length;
    }
    var axisLabelModel = axis.getLabelModel();
    var labelFormatter = makeLabelFormatter(axis);
    var rect;
    var step = 1;
    if (tickCount > 40) {
      step = Math.ceil(tickCount / 40);
    }
    for (var i2 = 0; i2 < tickCount; i2 += step) {
      var tick = realNumberScaleTicks ? realNumberScaleTicks[i2] : {
        value: categoryScaleExtent[0] + i2
      };
      var label = labelFormatter(tick, i2);
      var unrotatedSingleRect = axisLabelModel.getTextRect(label);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }
    return rect;
  }
  function rotateTextRect(textRect, rotate2) {
    var rotateRadians = rotate2 * Math.PI / 180;
    var beforeWidth = textRect.width;
    var beforeHeight = textRect.height;
    var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
    var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
    var rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight);
    return rotatedRect;
  }
  function getOptionCategoryInterval(model) {
    var interval = model.get("interval");
    return interval == null ? "auto" : interval;
  }
  function shouldShowAllLabels(axis) {
    return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
  }
  function getDataDimensionsOnAxis(data, axisDim) {
    var dataDimMap = {};
    each$4(data.mapDimensionsAll(axisDim), function(dataDim) {
      dataDimMap[getStackedDimension(data, dataDim)] = true;
    });
    return keys(dataDimMap);
  }
  var AxisModelCommonMixin = (
    /** @class */
    function() {
      function AxisModelCommonMixin2() {
      }
      AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
        var option = this.option;
        return !option.scale;
      };
      AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
        return;
      };
      return AxisModelCommonMixin2;
    }()
  );
  function createList(seriesModel) {
    return createSeriesData(null, seriesModel);
  }
  var dataStack = {
    isDimensionStacked,
    enableDataStack,
    getStackedDimension
  };
  function createScale(dataExtent, option) {
    var axisModel = option;
    if (!(option instanceof Model)) {
      axisModel = new Model(option);
    }
    var scale2 = createScaleByModel(axisModel);
    scale2.setExtent(dataExtent[0], dataExtent[1]);
    niceScaleExtent(scale2, axisModel);
    return scale2;
  }
  function mixinAxisModelCommonMethods(Model2) {
    mixin(Model2, AxisModelCommonMixin);
  }
  function createTextStyle(textStyleModel, opts) {
    opts = opts || {};
    return createTextStyle$1(textStyleModel, null, null, opts.state !== "normal");
  }
  const helper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    createDimensions,
    createList,
    createScale,
    createSymbol,
    createTextStyle,
    dataStack,
    enableHoverEmphasis,
    getECData,
    getLayoutRect,
    mixinAxisModelCommonMethods
  }, Symbol.toStringTag, { value: "Module" }));
  var extensions = [];
  var extensionRegisters = {
    registerPreprocessor,
    registerProcessor,
    registerPostInit,
    registerPostUpdate,
    registerUpdateLifecycle,
    registerAction,
    registerCoordinateSystem,
    registerLayout,
    registerVisual,
    registerTransform,
    registerLoading,
    registerMap,
    registerImpl,
    PRIORITY,
    ComponentModel,
    ComponentView,
    SeriesModel,
    ChartView,
    // TODO Use ComponentModel and SeriesModel instead of Constructor
    registerComponentModel: function(ComponentModelClass) {
      ComponentModel.registerClass(ComponentModelClass);
    },
    registerComponentView: function(ComponentViewClass) {
      ComponentView.registerClass(ComponentViewClass);
    },
    registerSeriesModel: function(SeriesModelClass) {
      SeriesModel.registerClass(SeriesModelClass);
    },
    registerChartView: function(ChartViewClass) {
      ChartView.registerClass(ChartViewClass);
    },
    registerSubTypeDefaulter: function(componentType, defaulter) {
      ComponentModel.registerSubTypeDefaulter(componentType, defaulter);
    },
    registerPainter: function(painterType, PainterCtor) {
      registerPainter(painterType, PainterCtor);
    }
  };
  function use(ext) {
    if (isArray$1(ext)) {
      each$4(ext, function(singleExt) {
        use(singleExt);
      });
      return;
    }
    if (indexOf(extensions, ext) >= 0) {
      return;
    }
    extensions.push(ext);
    if (isFunction$1(ext)) {
      ext = {
        install: ext
      };
    }
    ext.install(extensionRegisters);
  }
  var EPSILON = 1e-8;
  function isAroundEqual(a2, b2) {
    return Math.abs(a2 - b2) < EPSILON;
  }
  function contain(points2, x2, y2) {
    var w2 = 0;
    var p2 = points2[0];
    if (!p2) {
      return false;
    }
    for (var i2 = 1; i2 < points2.length; i2++) {
      var p22 = points2[i2];
      w2 += windingLine(p2[0], p2[1], p22[0], p22[1], x2, y2);
      p2 = p22;
    }
    var p0 = points2[0];
    if (!isAroundEqual(p2[0], p0[0]) || !isAroundEqual(p2[1], p0[1])) {
      w2 += windingLine(p2[0], p2[1], p0[0], p0[1], x2, y2);
    }
    return w2 !== 0;
  }
  var TMP_TRANSFORM = [];
  function transformPoints(points2, transform2) {
    for (var p2 = 0; p2 < points2.length; p2++) {
      applyTransform$1(points2[p2], points2[p2], transform2);
    }
  }
  function updateBBoxFromPoints(points2, min3, max3, projection) {
    for (var i2 = 0; i2 < points2.length; i2++) {
      var p2 = points2[i2];
      if (projection) {
        p2 = projection.project(p2);
      }
      if (p2 && isFinite(p2[0]) && isFinite(p2[1])) {
        min$1(min3, min3, p2);
        max$1(max3, max3, p2);
      }
    }
  }
  function centroid$1(points2) {
    var signedArea = 0;
    var cx = 0;
    var cy = 0;
    var len2 = points2.length;
    var x0 = points2[len2 - 1][0];
    var y0 = points2[len2 - 1][1];
    for (var i2 = 0; i2 < len2; i2++) {
      var x1 = points2[i2][0];
      var y1 = points2[i2][1];
      var a2 = x0 * y1 - x1 * y0;
      signedArea += a2;
      cx += (x0 + x1) * a2;
      cy += (y0 + y1) * a2;
      x0 = x1;
      y0 = y1;
    }
    return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points2[0][0] || 0, points2[0][1] || 0];
  }
  var Region = (
    /** @class */
    function() {
      function Region2(name) {
        this.name = name;
      }
      Region2.prototype.setCenter = function(center2) {
        this._center = center2;
      };
      Region2.prototype.getCenter = function() {
        var center2 = this._center;
        if (!center2) {
          center2 = this._center = this.calcCenter();
        }
        return center2;
      };
      return Region2;
    }()
  );
  var GeoJSONPolygonGeometry = (
    /** @class */
    /* @__PURE__ */ function() {
      function GeoJSONPolygonGeometry2(exterior, interiors) {
        this.type = "polygon";
        this.exterior = exterior;
        this.interiors = interiors;
      }
      return GeoJSONPolygonGeometry2;
    }()
  );
  var GeoJSONLineStringGeometry = (
    /** @class */
    /* @__PURE__ */ function() {
      function GeoJSONLineStringGeometry2(points2) {
        this.type = "linestring";
        this.points = points2;
      }
      return GeoJSONLineStringGeometry2;
    }()
  );
  var GeoJSONRegion = (
    /** @class */
    function(_super) {
      __extends(GeoJSONRegion2, _super);
      function GeoJSONRegion2(name, geometries, cp) {
        var _this = _super.call(this, name) || this;
        _this.type = "geoJSON";
        _this.geometries = geometries;
        _this._center = cp && [cp[0], cp[1]];
        return _this;
      }
      GeoJSONRegion2.prototype.calcCenter = function() {
        var geometries = this.geometries;
        var largestGeo;
        var largestGeoSize = 0;
        for (var i2 = 0; i2 < geometries.length; i2++) {
          var geo = geometries[i2];
          var exterior = geo.exterior;
          var size = exterior && exterior.length;
          if (size > largestGeoSize) {
            largestGeo = geo;
            largestGeoSize = size;
          }
        }
        if (largestGeo) {
          return centroid$1(largestGeo.exterior);
        }
        var rect = this.getBoundingRect();
        return [rect.x + rect.width / 2, rect.y + rect.height / 2];
      };
      GeoJSONRegion2.prototype.getBoundingRect = function(projection) {
        var rect = this._rect;
        if (rect && !projection) {
          return rect;
        }
        var min3 = [Infinity, Infinity];
        var max3 = [-Infinity, -Infinity];
        var geometries = this.geometries;
        each$4(geometries, function(geo) {
          if (geo.type === "polygon") {
            updateBBoxFromPoints(geo.exterior, min3, max3, projection);
          } else {
            each$4(geo.points, function(points2) {
              updateBBoxFromPoints(points2, min3, max3, projection);
            });
          }
        });
        if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
          min3[0] = min3[1] = max3[0] = max3[1] = 0;
        }
        rect = new BoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
        if (!projection) {
          this._rect = rect;
        }
        return rect;
      };
      GeoJSONRegion2.prototype.contain = function(coord) {
        var rect = this.getBoundingRect();
        var geometries = this.geometries;
        if (!rect.contain(coord[0], coord[1])) {
          return false;
        }
        loopGeo: for (var i2 = 0, len2 = geometries.length; i2 < len2; i2++) {
          var geo = geometries[i2];
          if (geo.type !== "polygon") {
            continue;
          }
          var exterior = geo.exterior;
          var interiors = geo.interiors;
          if (contain(exterior, coord[0], coord[1])) {
            for (var k2 = 0; k2 < (interiors ? interiors.length : 0); k2++) {
              if (contain(interiors[k2], coord[0], coord[1])) {
                continue loopGeo;
              }
            }
            return true;
          }
        }
        return false;
      };
      GeoJSONRegion2.prototype.transformTo = function(x2, y2, width, height) {
        var rect = this.getBoundingRect();
        var aspect = rect.width / rect.height;
        if (!width) {
          width = aspect * height;
        } else if (!height) {
          height = width / aspect;
        }
        var target = new BoundingRect(x2, y2, width, height);
        var transform2 = rect.calculateTransform(target);
        var geometries = this.geometries;
        for (var i2 = 0; i2 < geometries.length; i2++) {
          var geo = geometries[i2];
          if (geo.type === "polygon") {
            transformPoints(geo.exterior, transform2);
            each$4(geo.interiors, function(interior) {
              transformPoints(interior, transform2);
            });
          } else {
            each$4(geo.points, function(points2) {
              transformPoints(points2, transform2);
            });
          }
        }
        rect = this._rect;
        rect.copy(target);
        this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      };
      GeoJSONRegion2.prototype.cloneShallow = function(name) {
        name == null && (name = this.name);
        var newRegion = new GeoJSONRegion2(name, this.geometries, this._center);
        newRegion._rect = this._rect;
        newRegion.transformTo = null;
        return newRegion;
      };
      return GeoJSONRegion2;
    }(Region)
  );
  (function(_super) {
    __extends(GeoSVGRegion, _super);
    function GeoSVGRegion(name, elOnlyForCalculate) {
      var _this = _super.call(this, name) || this;
      _this.type = "geoSVG";
      _this._elOnlyForCalculate = elOnlyForCalculate;
      return _this;
    }
    GeoSVGRegion.prototype.calcCenter = function() {
      var el = this._elOnlyForCalculate;
      var rect = el.getBoundingRect();
      var center2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      var mat = identity(TMP_TRANSFORM);
      var target = el;
      while (target && !target.isGeoSVGGraphicRoot) {
        mul(mat, target.getLocalTransform(), mat);
        target = target.parent;
      }
      invert(mat, mat);
      applyTransform$1(center2, center2, mat);
      return center2;
    };
    return GeoSVGRegion;
  })(Region);
  function decode(json) {
    if (!json.UTF8Encoding) {
      return json;
    }
    var jsonCompressed = json;
    var encodeScale = jsonCompressed.UTF8Scale;
    if (encodeScale == null) {
      encodeScale = 1024;
    }
    var features = jsonCompressed.features;
    each$4(features, function(feature) {
      var geometry = feature.geometry;
      var encodeOffsets = geometry.encodeOffsets;
      var coordinates = geometry.coordinates;
      if (!encodeOffsets) {
        return;
      }
      switch (geometry.type) {
        case "LineString":
          geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
          break;
        case "Polygon":
          decodeRings(coordinates, encodeOffsets, encodeScale);
          break;
        case "MultiLineString":
          decodeRings(coordinates, encodeOffsets, encodeScale);
          break;
        case "MultiPolygon":
          each$4(coordinates, function(rings, idx) {
            return decodeRings(rings, encodeOffsets[idx], encodeScale);
          });
      }
    });
    jsonCompressed.UTF8Encoding = false;
    return jsonCompressed;
  }
  function decodeRings(rings, encodeOffsets, encodeScale) {
    for (var c2 = 0; c2 < rings.length; c2++) {
      rings[c2] = decodeRing(rings[c2], encodeOffsets[c2], encodeScale);
    }
  }
  function decodeRing(coordinate, encodeOffsets, encodeScale) {
    var result = [];
    var prevX = encodeOffsets[0];
    var prevY = encodeOffsets[1];
    for (var i2 = 0; i2 < coordinate.length; i2 += 2) {
      var x2 = coordinate.charCodeAt(i2) - 64;
      var y2 = coordinate.charCodeAt(i2 + 1) - 64;
      x2 = x2 >> 1 ^ -(x2 & 1);
      y2 = y2 >> 1 ^ -(y2 & 1);
      x2 += prevX;
      y2 += prevY;
      prevX = x2;
      prevY = y2;
      result.push([x2 / encodeScale, y2 / encodeScale]);
    }
    return result;
  }
  function parseGeoJSON(geoJson, nameProperty) {
    geoJson = decode(geoJson);
    return map$1(filter(geoJson.features, function(featureObj) {
      return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
    }), function(featureObj) {
      var properties = featureObj.properties;
      var geo = featureObj.geometry;
      var geometries = [];
      switch (geo.type) {
        case "Polygon":
          var coordinates = geo.coordinates;
          geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
          break;
        case "MultiPolygon":
          each$4(geo.coordinates, function(item) {
            if (item[0]) {
              geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
            }
          });
          break;
        case "LineString":
          geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
          break;
        case "MultiLineString":
          geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
      }
      var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
      region.properties = properties;
      return region;
    });
  }
  const number = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    MAX_SAFE_INTEGER,
    asc,
    getPercentWithPrecision,
    getPixelPrecision,
    getPrecision,
    getPrecisionSafe,
    isNumeric,
    isRadianAroundZero,
    linearMap,
    nice,
    numericToNumber,
    parseDate,
    quantile,
    quantity,
    quantityExponent,
    reformIntervals,
    remRadian,
    round: round$1
  }, Symbol.toStringTag, { value: "Module" }));
  const time = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    format: format$1,
    parse: parseDate
  }, Symbol.toStringTag, { value: "Module" }));
  const graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Arc,
    BezierCurve,
    BoundingRect,
    Circle,
    CompoundPath,
    Ellipse,
    Group: Group$2,
    Image: ZRImage,
    IncrementalDisplayable,
    Line,
    LinearGradient,
    Polygon,
    Polyline,
    RadialGradient,
    Rect,
    Ring,
    Sector,
    Text: ZRText,
    clipPointsByRect,
    clipRectByRect,
    createIcon,
    extendPath,
    extendShape,
    getShapeClass,
    getTransform,
    initProps,
    makeImage,
    makePath,
    mergePath,
    registerShape,
    resizePath,
    updateProps: updateProps$1
  }, Symbol.toStringTag, { value: "Module" }));
  const format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addCommas,
    capitalFirst,
    encodeHTML,
    formatTime,
    formatTpl,
    getTextRect,
    getTooltipMarker,
    normalizeCssArray,
    toCamelCase: toCamelCase$1,
    truncateText
  }, Symbol.toStringTag, { value: "Module" }));
  const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bind: bind$2,
    clone: clone$4,
    curry: curry$1,
    defaults: defaults$1,
    each: each$4,
    extend: extend$1,
    filter,
    indexOf,
    inherits: inherits$1,
    isArray: isArray$1,
    isFunction: isFunction$1,
    isObject: isObject$3,
    isString: isString$1,
    map: map$1,
    merge: merge$1,
    reduce
  }, Symbol.toStringTag, { value: "Module" }));
  var inner$4 = makeInner();
  function tickValuesToNumbers(axis, values) {
    var nums = map$1(values, function(val) {
      return axis.scale.parse(val);
    });
    if (axis.type === "time" && nums.length > 0) {
      nums.sort();
      nums.unshift(nums[0]);
      nums.push(nums[nums.length - 1]);
    }
    return nums;
  }
  function createAxisLabels(axis) {
    var custom = axis.getLabelModel().get("customValues");
    if (custom) {
      var labelFormatter_1 = makeLabelFormatter(axis);
      var extent_1 = axis.scale.getExtent();
      var tickNumbers = tickValuesToNumbers(axis, custom);
      var ticks = filter(tickNumbers, function(val) {
        return val >= extent_1[0] && val <= extent_1[1];
      });
      return {
        labels: map$1(ticks, function(numval) {
          var tick = {
            value: numval
          };
          return {
            formattedLabel: labelFormatter_1(tick),
            rawLabel: axis.scale.getLabel(tick),
            tickValue: numval
          };
        })
      };
    }
    return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
  }
  function createAxisTicks(axis, tickModel) {
    var custom = axis.getTickModel().get("customValues");
    if (custom) {
      var extent_2 = axis.scale.getExtent();
      var tickNumbers = tickValuesToNumbers(axis, custom);
      return {
        ticks: filter(tickNumbers, function(val) {
          return val >= extent_2[0] && val <= extent_2[1];
        })
      };
    }
    return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
      ticks: map$1(axis.scale.getTicks(), function(tick) {
        return tick.value;
      })
    };
  }
  function makeCategoryLabels(axis) {
    var labelModel = axis.getLabelModel();
    var result = makeCategoryLabelsActually(axis, labelModel);
    return !labelModel.get("show") || axis.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: result.labelCategoryInterval
    } : result;
  }
  function makeCategoryLabelsActually(axis, labelModel) {
    var labelsCache = getListCache(axis, "labels");
    var optionLabelInterval = getOptionCategoryInterval(labelModel);
    var result = listCacheGet(labelsCache, optionLabelInterval);
    if (result) {
      return result;
    }
    var labels;
    var numericLabelInterval;
    if (isFunction$1(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
    } else {
      numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
      labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
    }
    return listCacheSet(labelsCache, optionLabelInterval, {
      labels,
      labelCategoryInterval: numericLabelInterval
    });
  }
  function makeCategoryTicks(axis, tickModel) {
    var ticksCache = getListCache(axis, "ticks");
    var optionTickInterval = getOptionCategoryInterval(tickModel);
    var result = listCacheGet(ticksCache, optionTickInterval);
    if (result) {
      return result;
    }
    var ticks;
    var tickCategoryInterval;
    if (!tickModel.get("show") || axis.scale.isBlank()) {
      ticks = [];
    }
    if (isFunction$1(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
    } else if (optionTickInterval === "auto") {
      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = map$1(labelsResult.labels, function(labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
    }
    return listCacheSet(ticksCache, optionTickInterval, {
      ticks,
      tickCategoryInterval
    });
  }
  function makeRealNumberLabels(axis) {
    var ticks = axis.scale.getTicks();
    var labelFormatter = makeLabelFormatter(axis);
    return {
      labels: map$1(ticks, function(tick, idx) {
        return {
          level: tick.level,
          formattedLabel: labelFormatter(tick, idx),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: tick.value
        };
      })
    };
  }
  function getListCache(axis, prop) {
    return inner$4(axis)[prop] || (inner$4(axis)[prop] = []);
  }
  function listCacheGet(cache2, key2) {
    for (var i2 = 0; i2 < cache2.length; i2++) {
      if (cache2[i2].key === key2) {
        return cache2[i2].value;
      }
    }
  }
  function listCacheSet(cache2, key2, value) {
    cache2.push({
      key: key2,
      value
    });
    return value;
  }
  function makeAutoCategoryInterval(axis) {
    var result = inner$4(axis).autoInterval;
    return result != null ? result : inner$4(axis).autoInterval = axis.calculateCategoryInterval();
  }
  function calculateCategoryInterval(axis) {
    var params2 = fetchAutoCategoryIntervalCalculationParams(axis);
    var labelFormatter = makeLabelFormatter(axis);
    var rotation = (params2.axisRotate - params2.labelRotate) / 180 * Math.PI;
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var step = 1;
    if (tickCount > 40) {
      step = Math.max(1, Math.floor(tickCount / 40));
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitW = Math.abs(unitSpan * Math.cos(rotation));
    var unitH = Math.abs(unitSpan * Math.sin(rotation));
    var maxW = 0;
    var maxH = 0;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      var width = 0;
      var height = 0;
      var rect = getBoundingRect(labelFormatter({
        value: tickValue
      }), params2.font, "center", "top");
      width = rect.width * 1.3;
      height = rect.height * 1.3;
      maxW = Math.max(maxW, width, 7);
      maxH = Math.max(maxH, height, 7);
    }
    var dw = maxW / unitW;
    var dh = maxH / unitH;
    isNaN(dw) && (dw = Infinity);
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
    var cache2 = inner$4(axis.model);
    var axisExtent = axis.getExtent();
    var lastAutoInterval = cache2.lastAutoInterval;
    var lastTickCount = cache2.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache2.axisExtent0 === axisExtent[0] && cache2.axisExtent1 === axisExtent[1]) {
      interval = lastAutoInterval;
    } else {
      cache2.lastTickCount = tickCount;
      cache2.lastAutoInterval = interval;
      cache2.axisExtent0 = axisExtent[0];
      cache2.axisExtent1 = axisExtent[1];
    }
    return interval;
  }
  function fetchAutoCategoryIntervalCalculationParams(axis) {
    var labelModel = axis.getLabelModel();
    return {
      axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get("rotate") || 0,
      font: labelModel.getFont()
    };
  }
  function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
    var labelFormatter = makeLabelFormatter(axis);
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var labelModel = axis.getLabelModel();
    var result = [];
    var step = Math.max((categoryInterval || 0) + 1, 1);
    var startTick = ordinalExtent[0];
    var tickCount = ordinalScale.count();
    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step);
    }
    var showAllLabel = shouldShowAllLabels(axis);
    var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
    var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0]);
    }
    var tickValue = startTick;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue);
    }
    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1]);
    }
    function addItem(tickValue2) {
      var tickObj = {
        value: tickValue2
      };
      result.push(onlyTick ? tickValue2 : {
        formattedLabel: labelFormatter(tickObj),
        rawLabel: ordinalScale.getLabel(tickObj),
        tickValue: tickValue2
      });
    }
    return result;
  }
  function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
    var ordinalScale = axis.scale;
    var labelFormatter = makeLabelFormatter(axis);
    var result = [];
    each$4(ordinalScale.getTicks(), function(tick) {
      var rawLabel = ordinalScale.getLabel(tick);
      var tickValue = tick.value;
      if (categoryInterval(tick.value, rawLabel)) {
        result.push(onlyTick ? tickValue : {
          formattedLabel: labelFormatter(tick),
          rawLabel,
          tickValue
        });
      }
    });
    return result;
  }
  var NORMALIZED_EXTENT = [0, 1];
  var Axis = (
    /** @class */
    function() {
      function Axis2(dim, scale2, extent3) {
        this.onBand = false;
        this.inverse = false;
        this.dim = dim;
        this.scale = scale2;
        this._extent = extent3 || [0, 0];
      }
      Axis2.prototype.contain = function(coord) {
        var extent3 = this._extent;
        var min3 = Math.min(extent3[0], extent3[1]);
        var max3 = Math.max(extent3[0], extent3[1]);
        return coord >= min3 && coord <= max3;
      };
      Axis2.prototype.containData = function(data) {
        return this.scale.contain(data);
      };
      Axis2.prototype.getExtent = function() {
        return this._extent.slice();
      };
      Axis2.prototype.getPixelPrecision = function(dataExtent) {
        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
      };
      Axis2.prototype.setExtent = function(start2, end2) {
        var extent3 = this._extent;
        extent3[0] = start2;
        extent3[1] = end2;
      };
      Axis2.prototype.dataToCoord = function(data, clamp2) {
        var extent3 = this._extent;
        var scale2 = this.scale;
        data = scale2.normalize(data);
        if (this.onBand && scale2.type === "ordinal") {
          extent3 = extent3.slice();
          fixExtentWithBands(extent3, scale2.count());
        }
        return linearMap(data, NORMALIZED_EXTENT, extent3, clamp2);
      };
      Axis2.prototype.coordToData = function(coord, clamp2) {
        var extent3 = this._extent;
        var scale2 = this.scale;
        if (this.onBand && scale2.type === "ordinal") {
          extent3 = extent3.slice();
          fixExtentWithBands(extent3, scale2.count());
        }
        var t2 = linearMap(coord, extent3, NORMALIZED_EXTENT, clamp2);
        return this.scale.scale(t2);
      };
      Axis2.prototype.pointToData = function(point, clamp2) {
        return;
      };
      Axis2.prototype.getTicksCoords = function(opt) {
        opt = opt || {};
        var tickModel = opt.tickModel || this.getTickModel();
        var result = createAxisTicks(this, tickModel);
        var ticks = result.ticks;
        var ticksCoords = map$1(ticks, function(tickVal) {
          return {
            coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
            tickValue: tickVal
          };
        }, this);
        var alignWithLabel = tickModel.get("alignWithLabel");
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
        return ticksCoords;
      };
      Axis2.prototype.getMinorTicksCoords = function() {
        if (this.scale.type === "ordinal") {
          return [];
        }
        var minorTickModel = this.model.getModel("minorTick");
        var splitNumber = minorTickModel.get("splitNumber");
        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5;
        }
        var minorTicks = this.scale.getMinorTicks(splitNumber);
        var minorTicksCoords = map$1(minorTicks, function(minorTicksGroup) {
          return map$1(minorTicksGroup, function(minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            };
          }, this);
        }, this);
        return minorTicksCoords;
      };
      Axis2.prototype.getViewLabels = function() {
        return createAxisLabels(this).labels;
      };
      Axis2.prototype.getLabelModel = function() {
        return this.model.getModel("axisLabel");
      };
      Axis2.prototype.getTickModel = function() {
        return this.model.getModel("axisTick");
      };
      Axis2.prototype.getBandWidth = function() {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();
        var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
        len2 === 0 && (len2 = 1);
        var size = Math.abs(axisExtent[1] - axisExtent[0]);
        return Math.abs(size) / len2;
      };
      Axis2.prototype.calculateCategoryInterval = function() {
        return calculateCategoryInterval(this);
      };
      return Axis2;
    }()
  );
  function fixExtentWithBands(extent3, nTick) {
    var size = extent3[1] - extent3[0];
    var len2 = nTick;
    var margin = size / len2 / 2;
    extent3[0] += margin;
    extent3[1] -= margin;
  }
  function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
    var ticksLen = ticksCoords.length;
    if (!axis.onBand || alignWithLabel || !ticksLen) {
      return;
    }
    var axisExtent = axis.getExtent();
    var last2;
    var diffSize;
    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0];
      last2 = ticksCoords[1] = {
        coord: axisExtent[1],
        tickValue: ticksCoords[0].tickValue
      };
    } else {
      var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
      var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
      each$4(ticksCoords, function(ticksItem) {
        ticksItem.coord -= shift_1 / 2;
      });
      var dataExtent = axis.scale.getExtent();
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
      last2 = {
        coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,
        tickValue: dataExtent[1] + 1
      };
      ticksCoords.push(last2);
    }
    var inverse = axisExtent[0] > axisExtent[1];
    if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
      clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
    }
    if (clamp2 && littleThan(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0]
      });
    }
    if (littleThan(axisExtent[1], last2.coord)) {
      clamp2 ? last2.coord = axisExtent[1] : ticksCoords.pop();
    }
    if (clamp2 && littleThan(last2.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1]
      });
    }
    function littleThan(a2, b2) {
      a2 = round$1(a2);
      b2 = round$1(b2);
      return inverse ? a2 > b2 : a2 < b2;
    }
  }
  function extendComponentModel(proto2) {
    var Model2 = ComponentModel.extend(proto2);
    ComponentModel.registerClass(Model2);
    return Model2;
  }
  function extendComponentView(proto2) {
    var View = ComponentView.extend(proto2);
    ComponentView.registerClass(View);
    return View;
  }
  function extendSeriesModel(proto2) {
    var Model2 = SeriesModel.extend(proto2);
    SeriesModel.registerClass(Model2);
    return Model2;
  }
  function extendChartView(proto2) {
    var View = ChartView.extend(proto2);
    ChartView.registerClass(View);
    return View;
  }
  var PI2$1 = Math.PI * 2;
  var CMD$1 = PathProxy.CMD;
  var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
  function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
    var width = rect.width;
    var height = rect.height;
    switch (pos) {
      case "top":
        outPt.set(rect.x + width / 2, rect.y - distance2);
        outDir.set(0, -1);
        break;
      case "bottom":
        outPt.set(rect.x + width / 2, rect.y + height + distance2);
        outDir.set(0, 1);
        break;
      case "left":
        outPt.set(rect.x - distance2, rect.y + height / 2);
        outDir.set(-1, 0);
        break;
      case "right":
        outPt.set(rect.x + width + distance2, rect.y + height / 2);
        outDir.set(1, 0);
        break;
    }
  }
  function projectPointToArc(cx, cy, r2, startAngle, endAngle, anticlockwise, x2, y2, out2) {
    x2 -= cx;
    y2 -= cy;
    var d2 = Math.sqrt(x2 * x2 + y2 * y2);
    x2 /= d2;
    y2 /= d2;
    var ox = x2 * r2 + cx;
    var oy = y2 * r2 + cy;
    if (Math.abs(startAngle - endAngle) % PI2$1 < 1e-4) {
      out2[0] = ox;
      out2[1] = oy;
      return d2 - r2;
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI2$1;
    }
    var angle = Math.atan2(y2, x2);
    if (angle < 0) {
      angle += PI2$1;
    }
    if (angle >= startAngle && angle <= endAngle || angle + PI2$1 >= startAngle && angle + PI2$1 <= endAngle) {
      out2[0] = ox;
      out2[1] = oy;
      return d2 - r2;
    }
    var x1 = r2 * Math.cos(startAngle) + cx;
    var y1 = r2 * Math.sin(startAngle) + cy;
    var x22 = r2 * Math.cos(endAngle) + cx;
    var y22 = r2 * Math.sin(endAngle) + cy;
    var d1 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    var d22 = (x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2);
    if (d1 < d22) {
      out2[0] = x1;
      out2[1] = y1;
      return Math.sqrt(d1);
    } else {
      out2[0] = x22;
      out2[1] = y22;
      return Math.sqrt(d22);
    }
  }
  function projectPointToLine(x1, y1, x2, y2, x3, y3, out2, limitToEnds) {
    var dx = x3 - x1;
    var dy = y3 - y1;
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    dx1 /= lineLen;
    dy1 /= lineLen;
    var projectedLen = dx * dx1 + dy * dy1;
    var t2 = projectedLen / lineLen;
    if (limitToEnds) {
      t2 = Math.min(Math.max(t2, 0), 1);
    }
    t2 *= lineLen;
    var ox = out2[0] = x1 + t2 * dx1;
    var oy = out2[1] = y1 + t2 * dy1;
    return Math.sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3));
  }
  function projectPointToRect(x1, y1, width, height, x2, y2, out2) {
    if (width < 0) {
      x1 = x1 + width;
      width = -width;
    }
    if (height < 0) {
      y1 = y1 + height;
      height = -height;
    }
    var x22 = x1 + width;
    var y22 = y1 + height;
    var ox = out2[0] = Math.min(Math.max(x2, x1), x22);
    var oy = out2[1] = Math.min(Math.max(y2, y1), y22);
    return Math.sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2));
  }
  var tmpPt = [];
  function nearestPointOnRect(pt, rect, out2) {
    var dist2 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
    out2.set(tmpPt[0], tmpPt[1]);
    return dist2;
  }
  function nearestPointOnPath(pt, path, out2) {
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    var minDist = Infinity;
    var data = path.data;
    var x2 = pt.x;
    var y2 = pt.y;
    for (var i2 = 0; i2 < data.length; ) {
      var cmd = data[i2++];
      if (i2 === 1) {
        xi = data[i2];
        yi = data[i2 + 1];
        x0 = xi;
        y0 = yi;
      }
      var d2 = minDist;
      switch (cmd) {
        case CMD$1.M:
          x0 = data[i2++];
          y0 = data[i2++];
          xi = x0;
          yi = y0;
          break;
        case CMD$1.L:
          d2 = projectPointToLine(xi, yi, data[i2], data[i2 + 1], x2, y2, tmpPt, true);
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$1.C:
          d2 = cubicProjectPoint(xi, yi, data[i2++], data[i2++], data[i2++], data[i2++], data[i2], data[i2 + 1], x2, y2, tmpPt);
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$1.Q:
          d2 = quadraticProjectPoint(xi, yi, data[i2++], data[i2++], data[i2], data[i2 + 1], x2, y2, tmpPt);
          xi = data[i2++];
          yi = data[i2++];
          break;
        case CMD$1.A:
          var cx = data[i2++];
          var cy = data[i2++];
          var rx = data[i2++];
          var ry = data[i2++];
          var theta = data[i2++];
          var dTheta = data[i2++];
          i2 += 1;
          var anticlockwise = !!(1 - data[i2++]);
          x1 = Math.cos(theta) * rx + cx;
          y1 = Math.sin(theta) * ry + cy;
          if (i2 <= 1) {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x2 - cx) * ry / rx + cx;
          d2 = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2, tmpPt);
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD$1.R:
          x0 = xi = data[i2++];
          y0 = yi = data[i2++];
          var width = data[i2++];
          var height = data[i2++];
          d2 = projectPointToRect(x0, y0, width, height, x2, y2, tmpPt);
          break;
        case CMD$1.Z:
          d2 = projectPointToLine(xi, yi, x0, y0, x2, y2, tmpPt, true);
          xi = x0;
          yi = y0;
          break;
      }
      if (d2 < minDist) {
        minDist = d2;
        out2.set(tmpPt[0], tmpPt[1]);
      }
    }
    return minDist;
  }
  var pt0 = new Point();
  var pt1 = new Point();
  var pt2 = new Point();
  var dir = new Point();
  var dir2 = new Point();
  function updateLabelLinePoints(target, labelLineModel) {
    if (!target) {
      return;
    }
    var labelLine = target.getTextGuideLine();
    var label = target.getTextContent();
    if (!(label && labelLine)) {
      return;
    }
    var labelGuideConfig = target.textGuideLineConfig || {};
    var points2 = [[0, 0], [0, 0], [0, 0]];
    var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
    var labelRect = label.getBoundingRect().clone();
    labelRect.applyTransform(label.getComputedTransform());
    var minDist = Infinity;
    var anchorPoint = labelGuideConfig.anchor;
    var targetTransform = target.getComputedTransform();
    var targetInversedTransform = targetTransform && invert([], targetTransform);
    var len2 = labelLineModel.get("length2") || 0;
    if (anchorPoint) {
      pt2.copy(anchorPoint);
    }
    for (var i2 = 0; i2 < searchSpace.length; i2++) {
      var candidate = searchSpace[i2];
      getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
      Point.scaleAndAdd(pt1, pt0, dir, len2);
      pt1.transform(targetInversedTransform);
      var boundingRect = target.getBoundingRect();
      var dist2 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
      if (dist2 < minDist) {
        minDist = dist2;
        pt1.transform(targetTransform);
        pt2.transform(targetTransform);
        pt2.toArray(points2[0]);
        pt1.toArray(points2[1]);
        pt0.toArray(points2[2]);
      }
    }
    limitTurnAngle(points2, labelLineModel.get("minTurnAngle"));
    labelLine.setShape({
      points: points2
    });
  }
  var tmpArr = [];
  var tmpProjPoint = new Point();
  function limitTurnAngle(linePoints, minTurnAngle) {
    if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
      return;
    }
    minTurnAngle = minTurnAngle / 180 * Math.PI;
    pt0.fromArray(linePoints[0]);
    pt1.fromArray(linePoints[1]);
    pt2.fromArray(linePoints[2]);
    Point.sub(dir, pt0, pt1);
    Point.sub(dir2, pt2, pt1);
    var len1 = dir.len();
    var len2 = dir2.len();
    if (len1 < 1e-3 || len2 < 1e-3) {
      return;
    }
    dir.scale(1 / len1);
    dir2.scale(1 / len2);
    var angleCos = dir.dot(dir2);
    var minTurnAngleCos = Math.cos(minTurnAngle);
    if (minTurnAngleCos < angleCos) {
      var d2 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
      tmpProjPoint.fromArray(tmpArr);
      tmpProjPoint.scaleAndAdd(dir2, d2 / Math.tan(Math.PI - minTurnAngle));
      var t2 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t2)) {
        return;
      }
      if (t2 < 0) {
        Point.copy(tmpProjPoint, pt1);
      } else if (t2 > 1) {
        Point.copy(tmpProjPoint, pt2);
      }
      tmpProjPoint.toArray(linePoints[1]);
    }
  }
  function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
    if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
      return;
    }
    maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
    pt0.fromArray(linePoints[0]);
    pt1.fromArray(linePoints[1]);
    pt2.fromArray(linePoints[2]);
    Point.sub(dir, pt1, pt0);
    Point.sub(dir2, pt2, pt1);
    var len1 = dir.len();
    var len2 = dir2.len();
    if (len1 < 1e-3 || len2 < 1e-3) {
      return;
    }
    dir.scale(1 / len1);
    dir2.scale(1 / len2);
    var angleCos = dir.dot(surfaceNormal);
    var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
    if (angleCos < maxSurfaceAngleCos) {
      var d2 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
      tmpProjPoint.fromArray(tmpArr);
      var HALF_PI = Math.PI / 2;
      var angle2 = Math.acos(dir2.dot(surfaceNormal));
      var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
      if (newAngle >= HALF_PI) {
        Point.copy(tmpProjPoint, pt2);
      } else {
        tmpProjPoint.scaleAndAdd(dir2, d2 / Math.tan(Math.PI / 2 - newAngle));
        var t2 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
        if (isNaN(t2)) {
          return;
        }
        if (t2 < 0) {
          Point.copy(tmpProjPoint, pt1);
        } else if (t2 > 1) {
          Point.copy(tmpProjPoint, pt2);
        }
      }
      tmpProjPoint.toArray(linePoints[1]);
    }
  }
  function setLabelLineState(labelLine, ignore, stateName, stateModel) {
    var isNormal = stateName === "normal";
    var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
    stateObj.ignore = ignore;
    var smooth = stateModel.get("smooth");
    if (smooth && smooth === true) {
      smooth = 0.3;
    }
    stateObj.shape = stateObj.shape || {};
    if (smooth > 0) {
      stateObj.shape.smooth = smooth;
    }
    var styleObj = stateModel.getModel("lineStyle").getLineStyle();
    isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
  }
  function buildLabelLinePath(path, shape) {
    var smooth = shape.smooth;
    var points2 = shape.points;
    if (!points2) {
      return;
    }
    path.moveTo(points2[0][0], points2[0][1]);
    if (smooth > 0 && points2.length >= 3) {
      var len1 = dist$1(points2[0], points2[1]);
      var len2 = dist$1(points2[1], points2[2]);
      if (!len1 || !len2) {
        path.lineTo(points2[1][0], points2[1][1]);
        path.lineTo(points2[2][0], points2[2][1]);
        return;
      }
      var moveLen = Math.min(len1, len2) * smooth;
      var midPoint0 = lerp$1([], points2[1], points2[0], moveLen / len1);
      var midPoint2 = lerp$1([], points2[1], points2[2], moveLen / len2);
      var midPoint1 = lerp$1([], midPoint0, midPoint2, 0.5);
      path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
      path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points2[2][0], points2[2][1]);
    } else {
      for (var i2 = 1; i2 < points2.length; i2++) {
        path.lineTo(points2[i2][0], points2[i2][1]);
      }
    }
  }
  function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
    var labelLine = targetEl.getTextGuideLine();
    var label = targetEl.getTextContent();
    if (!label) {
      if (labelLine) {
        targetEl.removeTextGuideLine();
      }
      return;
    }
    var normalModel = statesModels.normal;
    var showNormal = normalModel.get("show");
    var labelIgnoreNormal = label.ignore;
    for (var i2 = 0; i2 < DISPLAY_STATES.length; i2++) {
      var stateName = DISPLAY_STATES[i2];
      var stateModel = statesModels[stateName];
      var isNormal = stateName === "normal";
      if (stateModel) {
        var stateShow = stateModel.get("show");
        var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
        if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
          if (stateObj) {
            stateObj.ignore = true;
          }
          if (!!labelLine) {
            setLabelLineState(labelLine, true, stateName, stateModel);
          }
          continue;
        }
        if (!labelLine) {
          labelLine = new Polyline();
          targetEl.setTextGuideLine(labelLine);
          if (!isNormal && (labelIgnoreNormal || !showNormal)) {
            setLabelLineState(labelLine, true, "normal", statesModels.normal);
          }
          if (targetEl.stateProxy) {
            labelLine.stateProxy = targetEl.stateProxy;
          }
        }
        setLabelLineState(labelLine, false, stateName, stateModel);
      }
    }
    if (labelLine) {
      defaults$1(labelLine.style, defaultStyle);
      labelLine.style.fill = null;
      var showAbove = normalModel.get("showAbove");
      var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
      labelLineConfig.showAbove = showAbove || false;
      labelLine.buildPath = buildLabelLinePath;
    }
  }
  function getLabelLineStatesModels(itemModel, labelLineName) {
    labelLineName = labelLineName || "labelLine";
    var statesModels = {
      normal: itemModel.getModel(labelLineName)
    };
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      var stateName = SPECIAL_STATES[i2];
      statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
    }
    return statesModels;
  }
  function prepareLayoutList(input) {
    var list2 = [];
    for (var i2 = 0; i2 < input.length; i2++) {
      var rawItem = input[i2];
      if (rawItem.defaultAttr.ignore) {
        continue;
      }
      var label = rawItem.label;
      var transform2 = label.getComputedTransform();
      var localRect = label.getBoundingRect();
      var isAxisAligned = !transform2 || transform2[1] < 1e-5 && transform2[2] < 1e-5;
      var minMargin = label.style.margin || 0;
      var globalRect = localRect.clone();
      globalRect.applyTransform(transform2);
      globalRect.x -= minMargin / 2;
      globalRect.y -= minMargin / 2;
      globalRect.width += minMargin;
      globalRect.height += minMargin;
      var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform2) : null;
      list2.push({
        label,
        labelLine: rawItem.labelLine,
        rect: globalRect,
        localRect,
        obb,
        priority: rawItem.priority,
        defaultAttr: rawItem.defaultAttr,
        layoutOption: rawItem.computedLayoutOption,
        axisAligned: isAxisAligned,
        transform: transform2
      });
    }
    return list2;
  }
  function shiftLayout(list2, xyDim, sizeDim, minBound, maxBound, balanceShift) {
    var len2 = list2.length;
    if (len2 < 2) {
      return;
    }
    list2.sort(function(a2, b2) {
      return a2.rect[xyDim] - b2.rect[xyDim];
    });
    var lastPos = 0;
    var delta;
    var adjusted = false;
    for (var i2 = 0; i2 < len2; i2++) {
      var item = list2[i2];
      var rect = item.rect;
      delta = rect[xyDim] - lastPos;
      if (delta < 0) {
        rect[xyDim] -= delta;
        item.label[xyDim] -= delta;
        adjusted = true;
      }
      lastPos = rect[xyDim] + rect[sizeDim];
    }
    var first = list2[0];
    var last2 = list2[len2 - 1];
    var minGap;
    var maxGap;
    updateMinMaxGap();
    minGap < 0 && squeezeGaps(-minGap, 0.8);
    maxGap < 0 && squeezeGaps(maxGap, 0.8);
    updateMinMaxGap();
    takeBoundsGap(minGap, maxGap, 1);
    takeBoundsGap(maxGap, minGap, -1);
    updateMinMaxGap();
    if (minGap < 0) {
      squeezeWhenBailout(-minGap);
    }
    if (maxGap < 0) {
      squeezeWhenBailout(maxGap);
    }
    function updateMinMaxGap() {
      minGap = first.rect[xyDim] - minBound;
      maxGap = maxBound - last2.rect[xyDim] - last2.rect[sizeDim];
    }
    function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
      if (gapThisBound < 0) {
        var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
        if (moveFromMaxGap > 0) {
          shiftList(moveFromMaxGap * moveDir, 0, len2);
          var remained = moveFromMaxGap + gapThisBound;
          if (remained < 0) {
            squeezeGaps(-remained * moveDir, 1);
          }
        } else {
          squeezeGaps(-gapThisBound * moveDir, 1);
        }
      }
    }
    function shiftList(delta2, start2, end2) {
      if (delta2 !== 0) {
        adjusted = true;
      }
      for (var i3 = start2; i3 < end2; i3++) {
        var item2 = list2[i3];
        var rect2 = item2.rect;
        rect2[xyDim] += delta2;
        item2.label[xyDim] += delta2;
      }
    }
    function squeezeGaps(delta2, maxSqeezePercent) {
      var gaps = [];
      var totalGaps = 0;
      for (var i3 = 1; i3 < len2; i3++) {
        var prevItemRect = list2[i3 - 1].rect;
        var gap = Math.max(list2[i3].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
        gaps.push(gap);
        totalGaps += gap;
      }
      if (!totalGaps) {
        return;
      }
      var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
      if (delta2 > 0) {
        for (var i3 = 0; i3 < len2 - 1; i3++) {
          var movement = gaps[i3] * squeezePercent;
          shiftList(movement, 0, i3 + 1);
        }
      } else {
        for (var i3 = len2 - 1; i3 > 0; i3--) {
          var movement = gaps[i3 - 1] * squeezePercent;
          shiftList(-movement, i3, len2);
        }
      }
    }
    function squeezeWhenBailout(delta2) {
      var dir3 = delta2 < 0 ? -1 : 1;
      delta2 = Math.abs(delta2);
      var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
      for (var i3 = 0; i3 < len2 - 1; i3++) {
        if (dir3 > 0) {
          shiftList(moveForEachLabel, 0, i3 + 1);
        } else {
          shiftList(-moveForEachLabel, len2 - i3 - 1, len2);
        }
        delta2 -= moveForEachLabel;
        if (delta2 <= 0) {
          return;
        }
      }
    }
    return adjusted;
  }
  function shiftLayoutOnX(list2, leftBound, rightBound, balanceShift) {
    return shiftLayout(list2, "x", "width", leftBound, rightBound);
  }
  function shiftLayoutOnY(list2, topBound, bottomBound, balanceShift) {
    return shiftLayout(list2, "y", "height", topBound, bottomBound);
  }
  function hideOverlap(labelList) {
    var displayedLabels = [];
    labelList.sort(function(a2, b2) {
      return b2.priority - a2.priority;
    });
    var globalRect = new BoundingRect(0, 0, 0, 0);
    function hideEl(el) {
      if (!el.ignore) {
        var emphasisState = el.ensureState("emphasis");
        if (emphasisState.ignore == null) {
          emphasisState.ignore = false;
        }
      }
      el.ignore = true;
    }
    for (var i2 = 0; i2 < labelList.length; i2++) {
      var labelItem = labelList[i2];
      var isAxisAligned = labelItem.axisAligned;
      var localRect = labelItem.localRect;
      var transform2 = labelItem.transform;
      var label = labelItem.label;
      var labelLine = labelItem.labelLine;
      globalRect.copy(labelItem.rect);
      globalRect.width -= 0.1;
      globalRect.height -= 0.1;
      globalRect.x += 0.05;
      globalRect.y += 0.05;
      var obb = labelItem.obb;
      var overlapped = false;
      for (var j2 = 0; j2 < displayedLabels.length; j2++) {
        var existsTextCfg = displayedLabels[j2];
        if (!globalRect.intersect(existsTextCfg.rect)) {
          continue;
        }
        if (isAxisAligned && existsTextCfg.axisAligned) {
          overlapped = true;
          break;
        }
        if (!existsTextCfg.obb) {
          existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);
        }
        if (!obb) {
          obb = new OrientedBoundingRect(localRect, transform2);
        }
        if (obb.intersect(existsTextCfg.obb)) {
          overlapped = true;
          break;
        }
      }
      if (overlapped) {
        hideEl(label);
        labelLine && hideEl(labelLine);
      } else {
        label.attr("ignore", labelItem.defaultAttr.ignore);
        labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
        displayedLabels.push(labelItem);
      }
    }
  }
  function cloneArr(points2) {
    if (points2) {
      var newPoints = [];
      for (var i2 = 0; i2 < points2.length; i2++) {
        newPoints.push(points2[i2].slice());
      }
      return newPoints;
    }
  }
  function prepareLayoutCallbackParams(labelItem, hostEl) {
    var label = labelItem.label;
    var labelLine = hostEl && hostEl.getTextGuideLine();
    return {
      dataIndex: labelItem.dataIndex,
      dataType: labelItem.dataType,
      seriesIndex: labelItem.seriesModel.seriesIndex,
      text: labelItem.label.style.text,
      rect: labelItem.hostRect,
      labelRect: labelItem.rect,
      // x: labelAttr.x,
      // y: labelAttr.y,
      align: label.style.align,
      verticalAlign: label.style.verticalAlign,
      labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
    };
  }
  var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
  var dummyTransformable = new Transformable();
  var labelLayoutInnerStore = makeInner();
  var labelLineAnimationStore = makeInner();
  function extendWithKeys(target, source, keys2) {
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key2 = keys2[i2];
      if (source[key2] != null) {
        target[key2] = source[key2];
      }
    }
  }
  var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
  var LabelManager = (
    /** @class */
    function() {
      function LabelManager2() {
        this._labelList = [];
        this._chartViewList = [];
      }
      LabelManager2.prototype.clearLabels = function() {
        this._labelList = [];
        this._chartViewList = [];
      };
      LabelManager2.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOption) {
        var labelStyle = label.style;
        var hostEl = label.__hostTarget;
        var textConfig = hostEl.textConfig || {};
        var labelTransform = label.getComputedTransform();
        var labelRect = label.getBoundingRect().plain();
        BoundingRect.applyTransform(labelRect, labelRect, labelTransform);
        if (labelTransform) {
          dummyTransformable.setLocalTransform(labelTransform);
        } else {
          dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
          dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
        }
        dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
        var host = label.__hostTarget;
        var hostRect;
        if (host) {
          hostRect = host.getBoundingRect().plain();
          var transform2 = host.getComputedTransform();
          BoundingRect.applyTransform(hostRect, hostRect, transform2);
        }
        var labelGuide = hostRect && host.getTextGuideLine();
        this._labelList.push({
          label,
          labelLine: labelGuide,
          seriesModel,
          dataIndex,
          dataType,
          layoutOption,
          computedLayoutOption: null,
          rect: labelRect,
          hostRect,
          // Label with lower priority will be hidden when overlapped
          // Use rect size as default priority
          priority: hostRect ? hostRect.width * hostRect.height : 0,
          // Save default label attributes.
          // For restore if developers want get back to default value in callback.
          defaultAttr: {
            ignore: label.ignore,
            labelGuideIgnore: labelGuide && labelGuide.ignore,
            x: dummyTransformable.x,
            y: dummyTransformable.y,
            scaleX: dummyTransformable.scaleX,
            scaleY: dummyTransformable.scaleY,
            rotation: dummyTransformable.rotation,
            style: {
              x: labelStyle.x,
              y: labelStyle.y,
              align: labelStyle.align,
              verticalAlign: labelStyle.verticalAlign,
              width: labelStyle.width,
              height: labelStyle.height,
              fontSize: labelStyle.fontSize
            },
            cursor: label.cursor,
            attachedPos: textConfig.position,
            attachedRot: textConfig.rotation
          }
        });
      };
      LabelManager2.prototype.addLabelsOfSeries = function(chartView) {
        var _this = this;
        this._chartViewList.push(chartView);
        var seriesModel = chartView.__model;
        var layoutOption = seriesModel.get("labelLayout");
        if (!(isFunction$1(layoutOption) || keys(layoutOption).length)) {
          return;
        }
        chartView.group.traverse(function(child) {
          if (child.ignore) {
            return true;
          }
          var textEl = child.getTextContent();
          var ecData = getECData(child);
          if (textEl && !textEl.disableLabelLayout) {
            _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
          }
        });
      };
      LabelManager2.prototype.updateLayoutConfig = function(api2) {
        var width = api2.getWidth();
        var height = api2.getHeight();
        function createDragHandler(el, labelLineModel) {
          return function() {
            updateLabelLinePoints(el, labelLineModel);
          };
        }
        for (var i2 = 0; i2 < this._labelList.length; i2++) {
          var labelItem = this._labelList[i2];
          var label = labelItem.label;
          var hostEl = label.__hostTarget;
          var defaultLabelAttr = labelItem.defaultAttr;
          var layoutOption = void 0;
          if (isFunction$1(labelItem.layoutOption)) {
            layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
          } else {
            layoutOption = labelItem.layoutOption;
          }
          layoutOption = layoutOption || {};
          labelItem.computedLayoutOption = layoutOption;
          var degreeToRadian = Math.PI / 180;
          if (hostEl) {
            hostEl.setTextConfig({
              // Force to set local false.
              local: false,
              // Ignore position and rotation config on the host el if x or y is changed.
              position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
              // Ignore rotation config on the host el if rotation is changed.
              rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
              offset: [layoutOption.dx || 0, layoutOption.dy || 0]
            });
          }
          var needsUpdateLabelLine = false;
          if (layoutOption.x != null) {
            label.x = parsePercent(layoutOption.x, width);
            label.setStyle("x", 0);
            needsUpdateLabelLine = true;
          } else {
            label.x = defaultLabelAttr.x;
            label.setStyle("x", defaultLabelAttr.style.x);
          }
          if (layoutOption.y != null) {
            label.y = parsePercent(layoutOption.y, height);
            label.setStyle("y", 0);
            needsUpdateLabelLine = true;
          } else {
            label.y = defaultLabelAttr.y;
            label.setStyle("y", defaultLabelAttr.style.y);
          }
          if (layoutOption.labelLinePoints) {
            var guideLine = hostEl.getTextGuideLine();
            if (guideLine) {
              guideLine.setShape({
                points: layoutOption.labelLinePoints
              });
              needsUpdateLabelLine = false;
            }
          }
          var labelLayoutStore = labelLayoutInnerStore(label);
          labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
          label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
          label.scaleX = defaultLabelAttr.scaleX;
          label.scaleY = defaultLabelAttr.scaleY;
          for (var k2 = 0; k2 < LABEL_OPTION_TO_STYLE_KEYS.length; k2++) {
            var key2 = LABEL_OPTION_TO_STYLE_KEYS[k2];
            label.setStyle(key2, layoutOption[key2] != null ? layoutOption[key2] : defaultLabelAttr.style[key2]);
          }
          if (layoutOption.draggable) {
            label.draggable = true;
            label.cursor = "move";
            if (hostEl) {
              var hostModel = labelItem.seriesModel;
              if (labelItem.dataIndex != null) {
                var data = labelItem.seriesModel.getData(labelItem.dataType);
                hostModel = data.getItemModel(labelItem.dataIndex);
              }
              label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
            }
          } else {
            label.off("drag");
            label.cursor = defaultLabelAttr.cursor;
          }
        }
      };
      LabelManager2.prototype.layout = function(api2) {
        var width = api2.getWidth();
        var height = api2.getHeight();
        var labelList = prepareLayoutList(this._labelList);
        var labelsNeedsAdjustOnX = filter(labelList, function(item) {
          return item.layoutOption.moveOverlap === "shiftX";
        });
        var labelsNeedsAdjustOnY = filter(labelList, function(item) {
          return item.layoutOption.moveOverlap === "shiftY";
        });
        shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
        shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
        var labelsNeedsHideOverlap = filter(labelList, function(item) {
          return item.layoutOption.hideOverlap;
        });
        hideOverlap(labelsNeedsHideOverlap);
      };
      LabelManager2.prototype.processLabelsOverall = function() {
        var _this = this;
        each$4(this._chartViewList, function(chartView) {
          var seriesModel = chartView.__model;
          var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
          var animationEnabled = seriesModel.isAnimationEnabled();
          chartView.group.traverse(function(child) {
            if (child.ignore && !child.forceLabelAnimation) {
              return true;
            }
            var needsUpdateLabelLine = !ignoreLabelLineUpdate;
            var label = child.getTextContent();
            if (!needsUpdateLabelLine && label) {
              needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
            }
            if (needsUpdateLabelLine) {
              _this._updateLabelLine(child, seriesModel);
            }
            if (animationEnabled) {
              _this._animateLabels(child, seriesModel);
            }
          });
        });
      };
      LabelManager2.prototype._updateLabelLine = function(el, seriesModel) {
        var textEl = el.getTextContent();
        var ecData = getECData(el);
        var dataIndex = ecData.dataIndex;
        if (textEl && dataIndex != null) {
          var data = seriesModel.getData(ecData.dataType);
          var itemModel = data.getItemModel(dataIndex);
          var defaultStyle = {};
          var visualStyle = data.getItemVisual(dataIndex, "style");
          if (visualStyle) {
            var visualType = data.getVisual("drawType");
            defaultStyle.stroke = visualStyle[visualType];
          }
          var labelLineModel = itemModel.getModel("labelLine");
          setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
          updateLabelLinePoints(el, labelLineModel);
        }
      };
      LabelManager2.prototype._animateLabels = function(el, seriesModel) {
        var textEl = el.getTextContent();
        var guideLine = el.getTextGuideLine();
        if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
          var layoutStore = labelLayoutInnerStore(textEl);
          var oldLayout = layoutStore.oldLayout;
          var ecData = getECData(el);
          var dataIndex = ecData.dataIndex;
          var newProps = {
            x: textEl.x,
            y: textEl.y,
            rotation: textEl.rotation
          };
          var data = seriesModel.getData(ecData.dataType);
          if (!oldLayout) {
            textEl.attr(newProps);
            if (!labelInner(textEl).valueAnimation) {
              var oldOpacity = retrieve2(textEl.style.opacity, 1);
              textEl.style.opacity = 0;
              initProps(textEl, {
                style: {
                  opacity: oldOpacity
                }
              }, seriesModel, dataIndex);
            }
          } else {
            textEl.attr(oldLayout);
            var prevStates = el.prevStates;
            if (prevStates) {
              if (indexOf(prevStates, "select") >= 0) {
                textEl.attr(layoutStore.oldLayoutSelect);
              }
              if (indexOf(prevStates, "emphasis") >= 0) {
                textEl.attr(layoutStore.oldLayoutEmphasis);
              }
            }
            updateProps$1(textEl, newProps, seriesModel, dataIndex);
          }
          layoutStore.oldLayout = newProps;
          if (textEl.states.select) {
            var layoutSelect = layoutStore.oldLayoutSelect = {};
            extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
            extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
          }
          if (textEl.states.emphasis) {
            var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
            extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
            extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
          }
          animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
        }
        if (guideLine && !guideLine.ignore && !guideLine.invisible) {
          var layoutStore = labelLineAnimationStore(guideLine);
          var oldLayout = layoutStore.oldLayout;
          var newLayout = {
            points: guideLine.shape.points
          };
          if (!oldLayout) {
            guideLine.setShape(newLayout);
            guideLine.style.strokePercent = 0;
            initProps(guideLine, {
              style: {
                strokePercent: 1
              }
            }, seriesModel);
          } else {
            guideLine.attr({
              shape: oldLayout
            });
            updateProps$1(guideLine, {
              shape: newLayout
            }, seriesModel);
          }
          layoutStore.oldLayout = newLayout;
        }
      };
      return LabelManager2;
    }()
  );
  var getLabelManager = makeInner();
  function installLabelLayout(registers) {
    registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api2, params2) {
      var labelManager = getLabelManager(api2).labelManager;
      if (!labelManager) {
        labelManager = getLabelManager(api2).labelManager = new LabelManager();
      }
      labelManager.clearLabels();
    });
    registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api2, params2) {
      var labelManager = getLabelManager(api2).labelManager;
      params2.updatedSeries.forEach(function(series) {
        labelManager.addLabelsOfSeries(api2.getViewOfSeriesModel(series));
      });
      labelManager.updateLayoutConfig(api2);
      labelManager.layout(api2);
      labelManager.processLabelsOverall();
    });
  }
  const echarts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Axis,
    ChartView,
    ComponentModel,
    ComponentView,
    List: SeriesData,
    Model,
    PRIORITY,
    SeriesModel,
    color,
    connect,
    dataTool,
    dependencies,
    disConnect,
    disconnect,
    dispose,
    env,
    extendChartView,
    extendComponentModel,
    extendComponentView,
    extendSeriesModel,
    format,
    getCoordinateSystemDimensions,
    getInstanceByDom,
    getInstanceById,
    getMap,
    graphic,
    helper,
    init,
    innerDrawElementOnCanvas: brushSingle,
    matrix,
    number,
    parseGeoJSON,
    parseGeoJson: parseGeoJSON,
    registerAction,
    registerCoordinateSystem,
    registerLayout,
    registerLoading,
    registerLocale,
    registerMap,
    registerPostInit,
    registerPostUpdate,
    registerPreprocessor,
    registerProcessor,
    registerTheme,
    registerTransform,
    registerUpdateLifecycle,
    registerVisual,
    setCanvasCreator,
    setPlatformAPI,
    throttle: throttle$1,
    time,
    use,
    util,
    vector,
    version,
    zrUtil: util$1,
    zrender
  }, Symbol.toStringTag, { value: "Module" }));
  var LineSeriesModel = (
    /** @class */
    function(_super) {
      __extends(LineSeriesModel2, _super);
      function LineSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LineSeriesModel2.type;
        _this.hasSymbolVisual = true;
        return _this;
      }
      LineSeriesModel2.prototype.getInitialData = function(option) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        });
      };
      LineSeriesModel2.prototype.getLegendIcon = function(opt) {
        var group = new Group$2();
        var line2 = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
        group.add(line2);
        line2.setStyle(opt.lineStyle);
        var visualType = this.getData().getVisual("symbol");
        var visualRotate = this.getData().getVisual("symbolRotate");
        var symbolType = visualType === "none" ? "circle" : visualType;
        var size = opt.itemHeight * 0.8;
        var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
        group.add(symbol);
        symbol.setStyle(opt.itemStyle);
        var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
        symbol.rotation = symbolRotate * Math.PI / 180;
        symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
        if (symbolType.indexOf("empty") > -1) {
          symbol.style.stroke = symbol.style.fill;
          symbol.style.fill = "#fff";
          symbol.style.lineWidth = 2;
        }
        return group;
      };
      LineSeriesModel2.type = "series.line";
      LineSeriesModel2.dependencies = ["grid", "polar"];
      LineSeriesModel2.defaultOption = {
        // zlevel: 0,
        z: 3,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        clip: true,
        label: {
          position: "top"
        },
        // itemStyle: {
        // },
        endLabel: {
          show: false,
          valueAnimation: true,
          distance: 8
        },
        lineStyle: {
          width: 2,
          type: "solid"
        },
        emphasis: {
          scale: true
        },
        // areaStyle: {
        // origin of areaStyle. Valid values:
        // `'auto'/null/undefined`: from axisLine to data
        // `'start'`: from min to data
        // `'end'`: from data to max
        // origin: 'auto'
        // },
        // false, 'start', 'end', 'middle'
        step: false,
        // Disabled if step is true
        smooth: false,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: true,
        // `false`: follow the label interval strategy.
        // `true`: show all symbols.
        // `'auto'`: If possible, show all symbols, otherwise
        //           follow the label interval strategy.
        showAllSymbol: "auto",
        // Whether to connect break point.
        connectNulls: false,
        // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
        sampling: "none",
        animationEasing: "linear",
        // Disable progressive
        progressive: 0,
        hoverLayerThreshold: Infinity,
        universalTransition: {
          divideShape: "clone"
        },
        triggerLineEvent: false
      };
      return LineSeriesModel2;
    }(SeriesModel)
  );
  function getDefaultLabel(data, dataIndex) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    var len2 = labelDims.length;
    if (len2 === 1) {
      var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
      return rawVal != null ? rawVal + "" : null;
    } else if (len2) {
      var vals = [];
      for (var i2 = 0; i2 < labelDims.length; i2++) {
        vals.push(retrieveRawValue(data, dataIndex, labelDims[i2]));
      }
      return vals.join(" ");
    }
  }
  function getDefaultInterpolatedLabel(data, interpolatedValue) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    if (!isArray$1(interpolatedValue)) {
      return interpolatedValue + "";
    }
    var vals = [];
    for (var i2 = 0; i2 < labelDims.length; i2++) {
      var dimIndex = data.getDimensionIndex(labelDims[i2]);
      if (dimIndex >= 0) {
        vals.push(interpolatedValue[dimIndex]);
      }
    }
    return vals.join(" ");
  }
  var Symbol$1 = (
    /** @class */
    function(_super) {
      __extends(Symbol2, _super);
      function Symbol2(data, idx, seriesScope, opts) {
        var _this = _super.call(this) || this;
        _this.updateData(data, idx, seriesScope, opts);
        return _this;
      }
      Symbol2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
        this.removeAll();
        var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
        symbolPath.attr({
          z2: 100,
          culling: true,
          scaleX: symbolSize[0] / 2,
          scaleY: symbolSize[1] / 2
        });
        symbolPath.drift = driftSymbol;
        this._symbolType = symbolType;
        this.add(symbolPath);
      };
      Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
        this.childAt(0).stopAnimation(null, toLastFrame);
      };
      Symbol2.prototype.getSymbolType = function() {
        return this._symbolType;
      };
      Symbol2.prototype.getSymbolPath = function() {
        return this.childAt(0);
      };
      Symbol2.prototype.highlight = function() {
        enterEmphasis(this.childAt(0));
      };
      Symbol2.prototype.downplay = function() {
        leaveEmphasis(this.childAt(0));
      };
      Symbol2.prototype.setZ = function(zlevel, z2) {
        var symbolPath = this.childAt(0);
        symbolPath.zlevel = zlevel;
        symbolPath.z = z2;
      };
      Symbol2.prototype.setDraggable = function(draggable, hasCursorOption) {
        var symbolPath = this.childAt(0);
        symbolPath.draggable = draggable;
        symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
      };
      Symbol2.prototype.updateData = function(data, idx, seriesScope, opts) {
        this.silent = false;
        var symbolType = data.getItemVisual(idx, "symbol") || "circle";
        var seriesModel = data.hostModel;
        var symbolSize = Symbol2.getSymbolSize(data, idx);
        var isInit = symbolType !== this._symbolType;
        var disableAnimation = opts && opts.disableAnimation;
        if (isInit) {
          var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
          this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
        } else {
          var symbolPath = this.childAt(0);
          symbolPath.silent = false;
          var target = {
            scaleX: symbolSize[0] / 2,
            scaleY: symbolSize[1] / 2
          };
          disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
          saveOldStyle(symbolPath);
        }
        this._updateCommon(data, idx, symbolSize, seriesScope, opts);
        if (isInit) {
          var symbolPath = this.childAt(0);
          if (!disableAnimation) {
            var target = {
              scaleX: this._sizeX,
              scaleY: this._sizeY,
              style: {
                // Always fadeIn. Because it has fadeOut animation when symbol is removed..
                opacity: symbolPath.style.opacity
              }
            };
            symbolPath.scaleX = symbolPath.scaleY = 0;
            symbolPath.style.opacity = 0;
            initProps(symbolPath, target, seriesModel, idx);
          }
        }
        if (disableAnimation) {
          this.childAt(0).stopAnimation("leave");
        }
      };
      Symbol2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
        var symbolPath = this.childAt(0);
        var seriesModel = data.hostModel;
        var emphasisItemStyle;
        var blurItemStyle;
        var selectItemStyle;
        var focus;
        var blurScope;
        var emphasisDisabled;
        var labelStatesModels;
        var hoverScale;
        var cursorStyle;
        if (seriesScope) {
          emphasisItemStyle = seriesScope.emphasisItemStyle;
          blurItemStyle = seriesScope.blurItemStyle;
          selectItemStyle = seriesScope.selectItemStyle;
          focus = seriesScope.focus;
          blurScope = seriesScope.blurScope;
          labelStatesModels = seriesScope.labelStatesModels;
          hoverScale = seriesScope.hoverScale;
          cursorStyle = seriesScope.cursorStyle;
          emphasisDisabled = seriesScope.emphasisDisabled;
        }
        if (!seriesScope || data.hasItemOption) {
          var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
          var emphasisModel = itemModel.getModel("emphasis");
          emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
          selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
          blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
          focus = emphasisModel.get("focus");
          blurScope = emphasisModel.get("blurScope");
          emphasisDisabled = emphasisModel.get("disabled");
          labelStatesModels = getLabelStatesModels(itemModel);
          hoverScale = emphasisModel.getShallow("scale");
          cursorStyle = itemModel.getShallow("cursor");
        }
        var symbolRotate = data.getItemVisual(idx, "symbolRotate");
        symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
        var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
        if (symbolOffset) {
          symbolPath.x = symbolOffset[0];
          symbolPath.y = symbolOffset[1];
        }
        cursorStyle && symbolPath.attr("cursor", cursorStyle);
        var symbolStyle = data.getItemVisual(idx, "style");
        var visualColor = symbolStyle.fill;
        if (symbolPath instanceof ZRImage) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend$1({
            // TODO other properties like x, y ?
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, symbolStyle));
        } else {
          if (symbolPath.__isEmptyBrush) {
            symbolPath.useStyle(extend$1({}, symbolStyle));
          } else {
            symbolPath.useStyle(symbolStyle);
          }
          symbolPath.style.decal = null;
          symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
          symbolPath.style.strokeNoScale = true;
        }
        var liftZ = data.getItemVisual(idx, "liftZ");
        var z2Origin = this._z2;
        if (liftZ != null) {
          if (z2Origin == null) {
            this._z2 = symbolPath.z2;
            symbolPath.z2 += liftZ;
          }
        } else if (z2Origin != null) {
          symbolPath.z2 = z2Origin;
          this._z2 = null;
        }
        var useNameLabel = opts && opts.useNameLabel;
        setLabelStyle(symbolPath, labelStatesModels, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultText: getLabelDefaultText,
          inheritColor: visualColor,
          defaultOpacity: symbolStyle.opacity
        });
        function getLabelDefaultText(idx2) {
          return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
        }
        this._sizeX = symbolSize[0] / 2;
        this._sizeY = symbolSize[1] / 2;
        var emphasisState = symbolPath.ensureState("emphasis");
        emphasisState.style = emphasisItemStyle;
        symbolPath.ensureState("select").style = selectItemStyle;
        symbolPath.ensureState("blur").style = blurItemStyle;
        var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
        emphasisState.scaleX = this._sizeX * scaleRatio;
        emphasisState.scaleY = this._sizeY * scaleRatio;
        this.setSymbolScale(1);
        toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
      };
      Symbol2.prototype.setSymbolScale = function(scale2) {
        this.scaleX = this.scaleY = scale2;
      };
      Symbol2.prototype.fadeOut = function(cb, seriesModel, opt) {
        var symbolPath = this.childAt(0);
        var dataIndex = getECData(this).dataIndex;
        var animationOpt = opt && opt.animation;
        this.silent = symbolPath.silent = true;
        if (opt && opt.fadeLabel) {
          var textContent = symbolPath.getTextContent();
          if (textContent) {
            removeElement(textContent, {
              style: {
                opacity: 0
              }
            }, seriesModel, {
              dataIndex,
              removeOpt: animationOpt,
              cb: function() {
                symbolPath.removeTextContent();
              }
            });
          }
        } else {
          symbolPath.removeTextContent();
        }
        removeElement(symbolPath, {
          style: {
            opacity: 0
          },
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex,
          cb,
          removeOpt: animationOpt
        });
      };
      Symbol2.getSymbolSize = function(data, idx) {
        return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
      };
      return Symbol2;
    }(Group$2)
  );
  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }
  function symbolNeedsDraw(data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
  }
  function normalizeUpdateOpt(opt) {
    if (opt != null && !isObject$3(opt)) {
      opt = {
        isIgnore: opt
      };
    }
    return opt || {};
  }
  function makeSeriesScope(data) {
    var seriesModel = data.hostModel;
    var emphasisModel = seriesModel.getModel("emphasis");
    return {
      emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
      blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
      selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
      focus: emphasisModel.get("focus"),
      blurScope: emphasisModel.get("blurScope"),
      emphasisDisabled: emphasisModel.get("disabled"),
      hoverScale: emphasisModel.get("scale"),
      labelStatesModels: getLabelStatesModels(seriesModel),
      cursorStyle: seriesModel.get("cursor")
    };
  }
  var SymbolDraw = (
    /** @class */
    function() {
      function SymbolDraw2(SymbolCtor) {
        this.group = new Group$2();
        this._SymbolCtor = SymbolCtor || Symbol$1;
      }
      SymbolDraw2.prototype.updateData = function(data, opt) {
        this._progressiveEls = null;
        opt = normalizeUpdateOpt(opt);
        var group = this.group;
        var seriesModel = data.hostModel;
        var oldData = this._data;
        var SymbolCtor = this._SymbolCtor;
        var disableAnimation = opt.disableAnimation;
        var seriesScope = makeSeriesScope(data);
        var symbolUpdateOpt = {
          disableAnimation
        };
        var getSymbolPoint = opt.getSymbolPoint || function(idx) {
          return data.getItemLayout(idx);
        };
        if (!oldData) {
          group.removeAll();
        }
        data.diff(oldData).add(function(newIdx) {
          var point = getSymbolPoint(newIdx);
          if (symbolNeedsDraw(data, point, newIdx, opt)) {
            var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
            symbolEl.setPosition(point);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          var point = getSymbolPoint(newIdx);
          if (!symbolNeedsDraw(data, point, newIdx, opt)) {
            group.remove(symbolEl);
            return;
          }
          var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
          var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
          if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
            group.remove(symbolEl);
            symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
            symbolEl.setPosition(point);
          } else {
            symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
            var target = {
              x: point[0],
              y: point[1]
            };
            disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
          }
          group.add(symbolEl);
          data.setItemGraphicEl(newIdx, symbolEl);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && el.fadeOut(function() {
            group.remove(el);
          }, seriesModel);
        }).execute();
        this._getSymbolPoint = getSymbolPoint;
        this._data = data;
      };
      SymbolDraw2.prototype.updateLayout = function() {
        var _this = this;
        var data = this._data;
        if (data) {
          data.eachItemGraphicEl(function(el, idx) {
            var point = _this._getSymbolPoint(idx);
            el.setPosition(point);
            el.markRedraw();
          });
        }
      };
      SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
        this._seriesScope = makeSeriesScope(data);
        this._data = null;
        this.group.removeAll();
      };
      SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
        this._progressiveEls = [];
        opt = normalizeUpdateOpt(opt);
        function updateIncrementalAndHover(el2) {
          if (!el2.isGroup) {
            el2.incremental = true;
            el2.ensureState("emphasis").hoverLayer = true;
          }
        }
        for (var idx = taskParams.start; idx < taskParams.end; idx++) {
          var point = data.getItemLayout(idx);
          if (symbolNeedsDraw(data, point, idx, opt)) {
            var el = new this._SymbolCtor(data, idx, this._seriesScope);
            el.traverse(updateIncrementalAndHover);
            el.setPosition(point);
            this.group.add(el);
            data.setItemGraphicEl(idx, el);
            this._progressiveEls.push(el);
          }
        }
      };
      SymbolDraw2.prototype.eachRendered = function(cb) {
        traverseElements(this._progressiveEls || this.group, cb);
      };
      SymbolDraw2.prototype.remove = function(enableAnimation) {
        var group = this.group;
        var data = this._data;
        if (data && enableAnimation) {
          data.eachItemGraphicEl(function(el) {
            el.fadeOut(function() {
              group.remove(el);
            }, data.hostModel);
          });
        } else {
          group.removeAll();
        }
      };
      return SymbolDraw2;
    }()
  );
  function prepareDataCoordInfo(coordSys, data, valueOrigin) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis2 = coordSys.getOtherAxis(baseAxis);
    var valueStart = getValueStart(valueAxis2, valueOrigin);
    var baseAxisDim = baseAxis.dim;
    var valueAxisDim = valueAxis2.dim;
    var valueDim = data.mapDimension(valueAxisDim);
    var baseDim = data.mapDimension(baseAxisDim);
    var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
    var dims = map$1(coordSys.dimensions, function(coordDim) {
      return data.mapDimension(coordDim);
    });
    var stacked = false;
    var stackResultDim = data.getCalculationInfo("stackResultDimension");
    if (isDimensionStacked(
      data,
      dims[0]
      /* , dims[1] */
    )) {
      stacked = true;
      dims[0] = stackResultDim;
    }
    if (isDimensionStacked(
      data,
      dims[1]
      /* , dims[0] */
    )) {
      stacked = true;
      dims[1] = stackResultDim;
    }
    return {
      dataDimsForPoint: dims,
      valueStart,
      valueAxisDim,
      baseAxisDim,
      stacked: !!stacked,
      valueDim,
      baseDim,
      baseDataOffset,
      stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
    };
  }
  function getValueStart(valueAxis2, valueOrigin) {
    var valueStart = 0;
    var extent3 = valueAxis2.scale.getExtent();
    if (valueOrigin === "start") {
      valueStart = extent3[0];
    } else if (valueOrigin === "end") {
      valueStart = extent3[1];
    } else if (isNumber$1(valueOrigin) && !isNaN(valueOrigin)) {
      valueStart = valueOrigin;
    } else {
      if (extent3[0] > 0) {
        valueStart = extent3[0];
      } else if (extent3[1] < 0) {
        valueStart = extent3[1];
      }
    }
    return valueStart;
  }
  function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
    var value = NaN;
    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
    }
    if (isNaN(value)) {
      value = dataCoordInfo.valueStart;
    }
    var baseDataOffset = dataCoordInfo.baseDataOffset;
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
    stackedData[1 - baseDataOffset] = value;
    return coordSys.dataToPoint(stackedData);
  }
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function(idx) {
      diffResult.push({
        cmd: "+",
        idx
      });
    }).update(function(newIdx, oldIdx) {
      diffResult.push({
        cmd: "=",
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function(idx) {
      diffResult.push({
        cmd: "-",
        idx
      });
    }).execute();
    return diffResult;
  }
  function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    var diff = diffData(oldData, newData);
    var currPoints = [];
    var nextPoints = [];
    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
    var oldPoints = oldData.getLayout("points") || [];
    var newPoints = newData.getLayout("points") || [];
    for (var i2 = 0; i2 < diff.length; i2++) {
      var diffItem = diff[i2];
      var pointAdded = true;
      var oldIdx2 = void 0;
      var newIdx2 = void 0;
      switch (diffItem.cmd) {
        case "=":
          oldIdx2 = diffItem.idx * 2;
          newIdx2 = diffItem.idx1 * 2;
          var currentX = oldPoints[oldIdx2];
          var currentY = oldPoints[oldIdx2 + 1];
          var nextX = newPoints[newIdx2];
          var nextY = newPoints[newIdx2 + 1];
          if (isNaN(currentX) || isNaN(currentY)) {
            currentX = nextX;
            currentY = nextY;
          }
          currPoints.push(currentX, currentY);
          nextPoints.push(nextX, nextY);
          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;
        case "+":
          var newIdx = diffItem.idx;
          var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
          var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
          newIdx2 = newIdx * 2;
          currPoints.push(oldPt[0], oldPt[1]);
          nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
          var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
          currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(newIdx));
          break;
        case "-":
          pointAdded = false;
      }
      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    }
    sortedIndices.sort(function(a2, b2) {
      return rawIndices[a2] - rawIndices[b2];
    });
    var len2 = currPoints.length;
    var sortedCurrPoints = createFloat32Array(len2);
    var sortedNextPoints = createFloat32Array(len2);
    var sortedCurrStackedPoints = createFloat32Array(len2);
    var sortedNextStackedPoints = createFloat32Array(len2);
    var sortedStatus = [];
    for (var i2 = 0; i2 < sortedIndices.length; i2++) {
      var idx = sortedIndices[i2];
      var i22 = i2 * 2;
      var idx2 = idx * 2;
      sortedCurrPoints[i22] = currPoints[idx2];
      sortedCurrPoints[i22 + 1] = currPoints[idx2 + 1];
      sortedNextPoints[i22] = nextPoints[idx2];
      sortedNextPoints[i22 + 1] = nextPoints[idx2 + 1];
      sortedCurrStackedPoints[i22] = currStackedPoints[idx2];
      sortedCurrStackedPoints[i22 + 1] = currStackedPoints[idx2 + 1];
      sortedNextStackedPoints[i22] = nextStackedPoints[idx2];
      sortedNextStackedPoints[i22 + 1] = nextStackedPoints[idx2 + 1];
      sortedStatus[i2] = status[idx];
    }
    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  }
  var mathMin$1 = Math.min;
  var mathMax$1 = Math.max;
  function isPointNull$1(x2, y2) {
    return isNaN(x2) || isNaN(y2);
  }
  function drawSegment(ctx, points2, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
    var prevX;
    var prevY;
    var cpx0;
    var cpy0;
    var cpx1;
    var cpy1;
    var idx = start2;
    var k2 = 0;
    for (; k2 < segLen; k2++) {
      var x2 = points2[idx * 2];
      var y2 = points2[idx * 2 + 1];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull$1(x2, y2)) {
        if (connectNulls) {
          idx += dir3;
          continue;
        }
        break;
      }
      if (idx === start2) {
        ctx[dir3 > 0 ? "moveTo" : "lineTo"](x2, y2);
        cpx0 = x2;
        cpy0 = y2;
      } else {
        var dx = x2 - prevX;
        var dy = y2 - prevY;
        if (dx * dx + dy * dy < 0.5) {
          idx += dir3;
          continue;
        }
        if (smooth > 0) {
          var nextIdx = idx + dir3;
          var nextX = points2[nextIdx * 2];
          var nextY = points2[nextIdx * 2 + 1];
          while (nextX === x2 && nextY === y2 && k2 < segLen) {
            k2++;
            nextIdx += dir3;
            idx += dir3;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
            x2 = points2[idx * 2];
            y2 = points2[idx * 2 + 1];
            dx = x2 - prevX;
            dy = y2 - prevY;
          }
          var tmpK = k2 + 1;
          if (connectNulls) {
            while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
              tmpK++;
              nextIdx += dir3;
              nextX = points2[nextIdx * 2];
              nextY = points2[nextIdx * 2 + 1];
            }
          }
          var ratioNextSeg = 0.5;
          var vx = 0;
          var vy = 0;
          var nextCpx0 = void 0;
          var nextCpy0 = void 0;
          if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
            cpx1 = x2;
            cpy1 = y2;
          } else {
            vx = nextX - prevX;
            vy = nextY - prevY;
            var dx0 = x2 - prevX;
            var dx1 = nextX - x2;
            var dy0 = y2 - prevY;
            var dy1 = nextY - y2;
            var lenPrevSeg = void 0;
            var lenNextSeg = void 0;
            if (smoothMonotone === "x") {
              lenPrevSeg = Math.abs(dx0);
              lenNextSeg = Math.abs(dx1);
              var dir_1 = vx > 0 ? 1 : -1;
              cpx1 = x2 - dir_1 * lenPrevSeg * smooth;
              cpy1 = y2;
              nextCpx0 = x2 + dir_1 * lenNextSeg * smooth;
              nextCpy0 = y2;
            } else if (smoothMonotone === "y") {
              lenPrevSeg = Math.abs(dy0);
              lenNextSeg = Math.abs(dy1);
              var dir_2 = vy > 0 ? 1 : -1;
              cpx1 = x2;
              cpy1 = y2 - dir_2 * lenPrevSeg * smooth;
              nextCpx0 = x2;
              nextCpy0 = y2 + dir_2 * lenNextSeg * smooth;
            } else {
              lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
              lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              cpx1 = x2 - vx * smooth * (1 - ratioNextSeg);
              cpy1 = y2 - vy * smooth * (1 - ratioNextSeg);
              nextCpx0 = x2 + vx * smooth * ratioNextSeg;
              nextCpy0 = y2 + vy * smooth * ratioNextSeg;
              nextCpx0 = mathMin$1(nextCpx0, mathMax$1(nextX, x2));
              nextCpy0 = mathMin$1(nextCpy0, mathMax$1(nextY, y2));
              nextCpx0 = mathMax$1(nextCpx0, mathMin$1(nextX, x2));
              nextCpy0 = mathMax$1(nextCpy0, mathMin$1(nextY, y2));
              vx = nextCpx0 - x2;
              vy = nextCpy0 - y2;
              cpx1 = x2 - vx * lenPrevSeg / lenNextSeg;
              cpy1 = y2 - vy * lenPrevSeg / lenNextSeg;
              cpx1 = mathMin$1(cpx1, mathMax$1(prevX, x2));
              cpy1 = mathMin$1(cpy1, mathMax$1(prevY, y2));
              cpx1 = mathMax$1(cpx1, mathMin$1(prevX, x2));
              cpy1 = mathMax$1(cpy1, mathMin$1(prevY, y2));
              vx = x2 - cpx1;
              vy = y2 - cpy1;
              nextCpx0 = x2 + vx * lenNextSeg / lenPrevSeg;
              nextCpy0 = y2 + vy * lenNextSeg / lenPrevSeg;
            }
          }
          ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x2, y2);
          cpx0 = nextCpx0;
          cpy0 = nextCpy0;
        } else {
          ctx.lineTo(x2, y2);
        }
      }
      prevX = x2;
      prevY = y2;
      idx += dir3;
    }
    return k2;
  }
  var ECPolylineShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function ECPolylineShape2() {
        this.smooth = 0;
        this.smoothConstraint = true;
      }
      return ECPolylineShape2;
    }()
  );
  var ECPolyline = (
    /** @class */
    function(_super) {
      __extends(ECPolyline2, _super);
      function ECPolyline2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "ec-polyline";
        return _this;
      }
      ECPolyline2.prototype.getDefaultStyle = function() {
        return {
          stroke: "#000",
          fill: null
        };
      };
      ECPolyline2.prototype.getDefaultShape = function() {
        return new ECPolylineShape();
      };
      ECPolyline2.prototype.buildPath = function(ctx, shape) {
        var points2 = shape.points;
        var i2 = 0;
        var len2 = points2.length / 2;
        if (shape.connectNulls) {
          for (; len2 > 0; len2--) {
            if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
              break;
            }
          }
          for (; i2 < len2; i2++) {
            if (!isPointNull$1(points2[i2 * 2], points2[i2 * 2 + 1])) {
              break;
            }
          }
        }
        while (i2 < len2) {
          i2 += drawSegment(ctx, points2, i2, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      };
      ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
        if (!this.path) {
          this.createPathProxy();
          this.buildPath(this.path, this.shape);
        }
        var path = this.path;
        var data = path.data;
        var CMD2 = PathProxy.CMD;
        var x0;
        var y0;
        var isDimX = dim === "x";
        var roots2 = [];
        for (var i2 = 0; i2 < data.length; ) {
          var cmd = data[i2++];
          var x2 = void 0;
          var y2 = void 0;
          var x22 = void 0;
          var y22 = void 0;
          var x3 = void 0;
          var y3 = void 0;
          var t2 = void 0;
          switch (cmd) {
            case CMD2.M:
              x0 = data[i2++];
              y0 = data[i2++];
              break;
            case CMD2.L:
              x2 = data[i2++];
              y2 = data[i2++];
              t2 = isDimX ? (xOrY - x0) / (x2 - x0) : (xOrY - y0) / (y2 - y0);
              if (t2 <= 1 && t2 >= 0) {
                var val = isDimX ? (y2 - y0) * t2 + y0 : (x2 - x0) * t2 + x0;
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
              x0 = x2;
              y0 = y2;
              break;
            case CMD2.C:
              x2 = data[i2++];
              y2 = data[i2++];
              x22 = data[i2++];
              y22 = data[i2++];
              x3 = data[i2++];
              y3 = data[i2++];
              var nRoot = isDimX ? cubicRootAt(x0, x2, x22, x3, xOrY, roots2) : cubicRootAt(y0, y2, y22, y3, xOrY, roots2);
              if (nRoot > 0) {
                for (var i_1 = 0; i_1 < nRoot; i_1++) {
                  var t_1 = roots2[i_1];
                  if (t_1 <= 1 && t_1 >= 0) {
                    var val = isDimX ? cubicAt(y0, y2, y22, y3, t_1) : cubicAt(x0, x2, x22, x3, t_1);
                    return isDimX ? [xOrY, val] : [val, xOrY];
                  }
                }
              }
              x0 = x3;
              y0 = y3;
              break;
          }
        }
      };
      return ECPolyline2;
    }(Path)
  );
  var ECPolygonShape = (
    /** @class */
    function(_super) {
      __extends(ECPolygonShape2, _super);
      function ECPolygonShape2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return ECPolygonShape2;
    }(ECPolylineShape)
  );
  var ECPolygon = (
    /** @class */
    function(_super) {
      __extends(ECPolygon2, _super);
      function ECPolygon2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "ec-polygon";
        return _this;
      }
      ECPolygon2.prototype.getDefaultShape = function() {
        return new ECPolygonShape();
      };
      ECPolygon2.prototype.buildPath = function(ctx, shape) {
        var points2 = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i2 = 0;
        var len2 = points2.length / 2;
        var smoothMonotone = shape.smoothMonotone;
        if (shape.connectNulls) {
          for (; len2 > 0; len2--) {
            if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
              break;
            }
          }
          for (; i2 < len2; i2++) {
            if (!isPointNull$1(points2[i2 * 2], points2[i2 * 2 + 1])) {
              break;
            }
          }
        }
        while (i2 < len2) {
          var k2 = drawSegment(ctx, points2, i2, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i2 + k2 - 1, k2, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i2 += k2 + 1;
          ctx.closePath();
        }
      };
      return ECPolygon2;
    }(Path)
  );
  function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
    var rect = cartesian.getArea();
    var x2 = rect.x;
    var y2 = rect.y;
    var width = rect.width;
    var height = rect.height;
    var lineWidth = seriesModel.get(["lineStyle", "width"]) || 0;
    x2 -= lineWidth / 2;
    y2 -= lineWidth / 2;
    width += lineWidth;
    height += lineWidth;
    width = Math.ceil(width);
    if (x2 !== Math.floor(x2)) {
      x2 = Math.floor(x2);
      width++;
    }
    var clipPath = new Rect({
      shape: {
        x: x2,
        y: y2,
        width,
        height
      }
    });
    if (hasAnimation) {
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isAxisInversed = baseAxis.inverse;
      if (isHorizontal) {
        if (isAxisInversed) {
          clipPath.shape.x += width;
        }
        clipPath.shape.width = 0;
      } else {
        if (!isAxisInversed) {
          clipPath.shape.y += height;
        }
        clipPath.shape.height = 0;
      }
      var duringCb = isFunction$1(during) ? function(percent) {
        during(percent, clipPath);
      } : null;
      initProps(clipPath, {
        shape: {
          width,
          height,
          x: x2,
          y: y2
        }
      }, seriesModel, null, done, duringCb);
    }
    return clipPath;
  }
  function createPolarClipPath(polar, hasAnimation, seriesModel) {
    var sectorArea = polar.getArea();
    var r0 = round$1(sectorArea.r0, 1);
    var r2 = round$1(sectorArea.r, 1);
    var clipPath = new Sector({
      shape: {
        cx: round$1(polar.cx, 1),
        cy: round$1(polar.cy, 1),
        r0,
        r: r2,
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    });
    if (hasAnimation) {
      var isRadial = polar.getBaseAxis().dim === "angle";
      if (isRadial) {
        clipPath.shape.endAngle = sectorArea.startAngle;
      } else {
        clipPath.shape.r = r0;
      }
      initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle,
          r: r2
        }
      }, seriesModel);
    }
    return clipPath;
  }
  function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
    if (!coordSys) {
      return null;
    } else if (coordSys.type === "polar") {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    } else if (coordSys.type === "cartesian2d") {
      return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
    }
    return null;
  }
  function isCoordinateSystemType(coordSys, type) {
    return coordSys.type === type;
  }
  function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
      return;
    }
    for (var i2 = 0; i2 < points1.length; i2++) {
      if (points1[i2] !== points2[i2]) {
        return;
      }
    }
    return true;
  }
  function bboxFromPoints(points2) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i2 = 0; i2 < points2.length; ) {
      var x2 = points2[i2++];
      var y2 = points2[i2++];
      if (!isNaN(x2)) {
        minX = Math.min(x2, minX);
        maxX = Math.max(x2, maxX);
      }
      if (!isNaN(y2)) {
        minY = Math.min(y2, minY);
        maxY = Math.max(y2, maxY);
      }
    }
    return [[minX, minY], [maxX, maxY]];
  }
  function getBoundingDiff(points1, points2) {
    var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
    var _b2 = bboxFromPoints(points2), min22 = _b2[0], max22 = _b2[1];
    return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
  }
  function getSmooth(smooth) {
    return isNumber$1(smooth) ? smooth : smooth ? 0.5 : 0;
  }
  function getStackedOnPoints(coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return [];
    }
    var len2 = data.count();
    var points2 = createFloat32Array(len2 * 2);
    for (var idx = 0; idx < len2; idx++) {
      var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
      points2[idx * 2] = pt[0];
      points2[idx * 2 + 1] = pt[1];
    }
    return points2;
  }
  function turnPointsIntoStep(points2, basePoints, coordSys, stepTurnAt, connectNulls) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
    var stepPoints = [];
    var i2 = 0;
    var stepPt = [];
    var pt = [];
    var nextPt = [];
    var filteredPoints = [];
    if (connectNulls) {
      for (i2 = 0; i2 < points2.length; i2 += 2) {
        var reference = basePoints || points2;
        if (!isNaN(reference[i2]) && !isNaN(reference[i2 + 1])) {
          filteredPoints.push(points2[i2], points2[i2 + 1]);
        }
      }
      points2 = filteredPoints;
    }
    for (i2 = 0; i2 < points2.length - 2; i2 += 2) {
      nextPt[0] = points2[i2 + 2];
      nextPt[1] = points2[i2 + 3];
      pt[0] = points2[i2];
      pt[1] = points2[i2 + 1];
      stepPoints.push(pt[0], pt[1]);
      switch (stepTurnAt) {
        case "end":
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          break;
        case "middle":
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          stepPoints.push(stepPt2[0], stepPt2[1]);
          break;
        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
      }
    }
    stepPoints.push(points2[i2++], points2[i2++]);
    return stepPoints;
  }
  function clipColorStops(colorStops, maxSize) {
    var newColorStops = [];
    var len2 = colorStops.length;
    var prevOutOfRangeColorStop;
    var prevInRangeColorStop;
    function lerpStop(stop0, stop1, clippedCoord) {
      var coord0 = stop0.coord;
      var p2 = (clippedCoord - coord0) / (stop1.coord - coord0);
      var color2 = lerp(p2, [stop0.color, stop1.color]);
      return {
        coord: clippedCoord,
        color: color2
      };
    }
    for (var i2 = 0; i2 < len2; i2++) {
      var stop_1 = colorStops[i2];
      var coord = stop_1.coord;
      if (coord < 0) {
        prevOutOfRangeColorStop = stop_1;
      } else if (coord > maxSize) {
        if (prevInRangeColorStop) {
          newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
        } else if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
        }
        break;
      } else {
        if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
          prevOutOfRangeColorStop = null;
        }
        newColorStops.push(stop_1);
        prevInRangeColorStop = stop_1;
      }
    }
    return newColorStops;
  }
  function getVisualGradient(data, coordSys, api2) {
    var visualMetaList = data.getVisual("visualMeta");
    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      return;
    }
    if (coordSys.type !== "cartesian2d") {
      return;
    }
    var coordDim;
    var visualMeta;
    for (var i2 = visualMetaList.length - 1; i2 >= 0; i2--) {
      var dimInfo = data.getDimensionInfo(visualMetaList[i2].dimension);
      coordDim = dimInfo && dimInfo.coordDim;
      if (coordDim === "x" || coordDim === "y") {
        visualMeta = visualMetaList[i2];
        break;
      }
    }
    if (!visualMeta) {
      return;
    }
    var axis = coordSys.getAxis(coordDim);
    var colorStops = map$1(visualMeta.stops, function(stop2) {
      return {
        coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
        color: stop2.color
      };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();
    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse();
      outerColors.reverse();
    }
    var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api2.getWidth() : api2.getHeight());
    var inRangeStopLen = colorStopsInRange.length;
    if (!inRangeStopLen && stopLen) {
      return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
    }
    var tinyExtent = 10;
    var minCoord = colorStopsInRange[0].coord - tinyExtent;
    var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;
    if (coordSpan < 1e-3) {
      return "transparent";
    }
    each$4(colorStopsInRange, function(stop2) {
      stop2.offset = (stop2.coord - minCoord) / coordSpan;
    });
    colorStopsInRange.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
      color: outerColors[1] || "transparent"
    });
    colorStopsInRange.unshift({
      offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
      color: outerColors[0] || "transparent"
    });
    var gradient = new LinearGradient(0, 0, 0, 0, colorStopsInRange, true);
    gradient[coordDim] = minCoord;
    gradient[coordDim + "2"] = maxCoord;
    return gradient;
  }
  function getIsIgnoreFunc(seriesModel, data, coordSys) {
    var showAllSymbol = seriesModel.get("showAllSymbol");
    var isAuto = showAllSymbol === "auto";
    if (showAllSymbol && !isAuto) {
      return;
    }
    var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
    if (!categoryAxis2) {
      return;
    }
    if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
      return;
    }
    var categoryDataDim = data.mapDimension(categoryAxis2.dim);
    var labelMap = {};
    each$4(categoryAxis2.getViewLabels(), function(labelItem) {
      var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
      labelMap[ordinalNumber] = 1;
    });
    return function(dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
    };
  }
  function canShowAllSymbolForCategory(categoryAxis2, data) {
    var axisExtent = categoryAxis2.getExtent();
    var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
    isNaN(availSize) && (availSize = 0);
    var dataLen = data.count();
    var step = Math.max(1, Math.round(dataLen / 5));
    for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (Symbol$1.getSymbolSize(
        data,
        dataIndex
        // Only for cartesian, where `isHorizontal` exists.
      )[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
        return false;
      }
    }
    return true;
  }
  function isPointNull(x2, y2) {
    return isNaN(x2) || isNaN(y2);
  }
  function getLastIndexNotNull(points2) {
    var len2 = points2.length / 2;
    for (; len2 > 0; len2--) {
      if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
        break;
      }
    }
    return len2 - 1;
  }
  function getPointAtIndex(points2, idx) {
    return [points2[idx * 2], points2[idx * 2 + 1]];
  }
  function getIndexRange(points2, xOrY, dim) {
    var len2 = points2.length / 2;
    var dimIdx = dim === "x" ? 0 : 1;
    var a2;
    var b2;
    var prevIndex = 0;
    var nextIndex = -1;
    for (var i2 = 0; i2 < len2; i2++) {
      b2 = points2[i2 * 2 + dimIdx];
      if (isNaN(b2) || isNaN(points2[i2 * 2 + 1 - dimIdx])) {
        continue;
      }
      if (i2 === 0) {
        a2 = b2;
        continue;
      }
      if (a2 <= xOrY && b2 >= xOrY || a2 >= xOrY && b2 <= xOrY) {
        nextIndex = i2;
        break;
      }
      prevIndex = i2;
      a2 = b2;
    }
    return {
      range: [prevIndex, nextIndex],
      t: (xOrY - a2) / (b2 - a2)
    };
  }
  function anyStateShowEndLabel(seriesModel) {
    if (seriesModel.get(["endLabel", "show"])) {
      return true;
    }
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      if (seriesModel.get([SPECIAL_STATES[i2], "endLabel", "show"])) {
        return true;
      }
    }
    return false;
  }
  function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var endLabelModel_1 = seriesModel.getModel("endLabel");
      var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
      var data_1 = seriesModel.getData();
      var labelAnimationRecord_1 = {
        lastFrameIndex: 0
      };
      var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
        lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
      } : null;
      var isHorizontal = coordSys.getBaseAxis().isHorizontal();
      var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
        var endLabel = lineView._endLabel;
        if (endLabel && hasAnimation) {
          if (labelAnimationRecord_1.originalX != null) {
            endLabel.attr({
              x: labelAnimationRecord_1.originalX,
              y: labelAnimationRecord_1.originalY
            });
          }
        }
      }, during);
      if (!seriesModel.get("clip", true)) {
        var rectShape = clipPath.shape;
        var expandSize = Math.max(rectShape.width, rectShape.height);
        if (isHorizontal) {
          rectShape.y -= expandSize;
          rectShape.height += expandSize * 2;
        } else {
          rectShape.x -= expandSize;
          rectShape.width += expandSize * 2;
        }
      }
      if (during) {
        during(1, clipPath);
      }
      return clipPath;
    } else {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    }
  }
  function getEndLabelStateSpecified(endLabelModel, coordSys) {
    var baseAxis = coordSys.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isBaseInversed = baseAxis.inverse;
    var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
    var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
    return {
      normal: {
        align: endLabelModel.get("align") || align,
        verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
      }
    };
  }
  var LineView = (
    /** @class */
    function(_super) {
      __extends(LineView2, _super);
      function LineView2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      LineView2.prototype.init = function() {
        var lineGroup = new Group$2();
        var symbolDraw = new SymbolDraw();
        this.group.add(symbolDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
        this._changePolyState = bind$2(this._changePolyState, this);
      };
      LineView2.prototype.render = function(seriesModel, ecModel, api2) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var areaStyleModel = seriesModel.getModel("areaStyle");
        var points2 = data.getLayout("points") || [];
        var isCoordSysPolar = coordSys.type === "polar";
        var prevCoordSys = this._coordSys;
        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;
        var lineGroup = this._lineGroup;
        var hasAnimation = !ecModel.ssr && seriesModel.get("animation");
        var isAreaChart = !areaStyleModel.isEmpty();
        var valueOrigin = areaStyleModel.get("origin");
        var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
        var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
        var showSymbol = seriesModel.get("showSymbol");
        var connectNulls = seriesModel.get("connectNulls");
        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        if (!showSymbol) {
          symbolDraw.remove();
        }
        group.add(lineGroup);
        var step = !isCoordSysPolar ? seriesModel.get("step") : false;
        var clipShapeForSymbol;
        if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
          clipShapeForSymbol = coordSys.getArea();
          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1;
            clipShapeForSymbol.y -= 0.1;
            clipShapeForSymbol.width += 0.2;
            clipShapeForSymbol.height += 0.2;
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5;
            clipShapeForSymbol.r += 0.5;
          }
        }
        this._clipShapeForSymbol = clipShapeForSymbol;
        var visualColor = getVisualGradient(data, coordSys, api2) || data.getVisual("style")[data.getVisual("drawType")];
        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function(idx) {
              return [points2[idx * 2], points2[idx * 2 + 1]];
            }
          });
          hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
          if (step) {
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
            }
            points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
          }
          polyline = this._newPolyline(points2);
          if (isAreaChart) {
            polygon = this._newPolygon(points2, stackedOnPoints);
          } else if (polygon) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
          }
          lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
        } else {
          if (isAreaChart && !polygon) {
            polygon = this._newPolygon(points2, stackedOnPoints);
          } else if (polygon && !isAreaChart) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
          }
          var oldClipPath = lineGroup.getClipPath();
          if (oldClipPath) {
            var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
            initProps(oldClipPath, {
              shape: newClipPath.shape
            }, seriesModel);
          } else {
            lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
          }
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function(idx) {
              return [points2[idx * 2], points2[idx * 2 + 1]];
            }
          });
          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
            if (hasAnimation) {
              this._doUpdateAnimation(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls);
            } else {
              if (step) {
                if (stackedOnPoints) {
                  stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points2, coordSys, step, connectNulls);
                }
                points2 = turnPointsIntoStep(points2, null, coordSys, step, connectNulls);
              }
              polyline.setShape({
                points: points2
              });
              polygon && polygon.setShape({
                points: points2,
                stackedOnPoints
              });
            }
          }
        }
        var emphasisModel = seriesModel.getModel("emphasis");
        var focus = emphasisModel.get("focus");
        var blurScope = emphasisModel.get("blurScope");
        var emphasisDisabled = emphasisModel.get("disabled");
        polyline.useStyle(defaults$1(
          // Use color in lineStyle first
          lineStyleModel.getLineStyle(),
          {
            fill: "none",
            stroke: visualColor,
            lineJoin: "bevel"
          }
        ));
        setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
        if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
          var emphasisLineStyle = polyline.getState("emphasis").style;
          emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
        }
        getECData(polyline).seriesIndex = seriesModel.seriesIndex;
        toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
        var smooth = getSmooth(seriesModel.get("smooth"));
        var smoothMonotone = seriesModel.get("smoothMonotone");
        polyline.setShape({
          smooth,
          smoothMonotone,
          connectNulls
        });
        if (polygon) {
          var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
          var stackedOnSmooth = 0;
          polygon.useStyle(defaults$1(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: "bevel",
            decal: data.getVisual("style").decal
          }));
          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
          }
          polygon.setShape({
            smooth,
            stackedOnSmooth,
            smoothMonotone,
            connectNulls
          });
          setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
          getECData(polygon).seriesIndex = seriesModel.seriesIndex;
          toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
        }
        var changePolyState = this._changePolyState;
        data.eachItemGraphicEl(function(el) {
          el && (el.onHoverStateChange = changePolyState);
        });
        this._polyline.onHoverStateChange = changePolyState;
        this._data = data;
        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points2;
        this._step = step;
        this._valueOrigin = valueOrigin;
        if (seriesModel.get("triggerLineEvent")) {
          this.packEventData(seriesModel, polyline);
          polygon && this.packEventData(seriesModel, polygon);
        }
      };
      LineView2.prototype.packEventData = function(seriesModel, el) {
        getECData(el).eventData = {
          componentType: "series",
          componentSubType: "line",
          componentIndex: seriesModel.componentIndex,
          seriesIndex: seriesModel.seriesIndex,
          seriesName: seriesModel.name,
          seriesType: "line"
        };
      };
      LineView2.prototype.highlight = function(seriesModel, ecModel, api2, payload) {
        var data = seriesModel.getData();
        var dataIndex = queryDataIndex(data, payload);
        this._changePolyState("emphasis");
        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          var points2 = data.getLayout("points");
          var symbol = data.getItemGraphicEl(dataIndex);
          if (!symbol) {
            var x2 = points2[dataIndex * 2];
            var y2 = points2[dataIndex * 2 + 1];
            if (isNaN(x2) || isNaN(y2)) {
              return;
            }
            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x2, y2)) {
              return;
            }
            var zlevel = seriesModel.get("zlevel") || 0;
            var z2 = seriesModel.get("z") || 0;
            symbol = new Symbol$1(data, dataIndex);
            symbol.x = x2;
            symbol.y = y2;
            symbol.setZ(zlevel, z2);
            var symbolLabel = symbol.getSymbolPath().getTextContent();
            if (symbolLabel) {
              symbolLabel.zlevel = zlevel;
              symbolLabel.z = z2;
              symbolLabel.z2 = this._polyline.z2 + 1;
            }
            symbol.__temp = true;
            data.setItemGraphicEl(dataIndex, symbol);
            symbol.stopSymbolAnimation(true);
            this.group.add(symbol);
          }
          symbol.highlight();
        } else {
          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api2, payload);
        }
      };
      LineView2.prototype.downplay = function(seriesModel, ecModel, api2, payload) {
        var data = seriesModel.getData();
        var dataIndex = queryDataIndex(data, payload);
        this._changePolyState("normal");
        if (dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null);
              this.group.remove(symbol);
            } else {
              symbol.downplay();
            }
          }
        } else {
          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api2, payload);
        }
      };
      LineView2.prototype._changePolyState = function(toState) {
        var polygon = this._polygon;
        setStatesFlag(this._polyline, toState);
        polygon && setStatesFlag(polygon, toState);
      };
      LineView2.prototype._newPolyline = function(points2) {
        var polyline = this._polyline;
        if (polyline) {
          this._lineGroup.remove(polyline);
        }
        polyline = new ECPolyline({
          shape: {
            points: points2
          },
          segmentIgnoreThreshold: 2,
          z2: 10
        });
        this._lineGroup.add(polyline);
        this._polyline = polyline;
        return polyline;
      };
      LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
        var polygon = this._polygon;
        if (polygon) {
          this._lineGroup.remove(polygon);
        }
        polygon = new ECPolygon({
          shape: {
            points: points2,
            stackedOnPoints
          },
          segmentIgnoreThreshold: 2
        });
        this._lineGroup.add(polygon);
        this._polygon = polygon;
        return polygon;
      };
      LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
        var isHorizontalOrRadial;
        var isCoordSysPolar;
        var baseAxis = coordSys.getBaseAxis();
        var isAxisInverse = baseAxis.inverse;
        if (coordSys.type === "cartesian2d") {
          isHorizontalOrRadial = baseAxis.isHorizontal();
          isCoordSysPolar = false;
        } else if (coordSys.type === "polar") {
          isHorizontalOrRadial = baseAxis.dim === "angle";
          isCoordSysPolar = true;
        }
        var seriesModel = data.hostModel;
        var seriesDuration = seriesModel.get("animationDuration");
        if (isFunction$1(seriesDuration)) {
          seriesDuration = seriesDuration(null);
        }
        var seriesDelay = seriesModel.get("animationDelay") || 0;
        var seriesDelayValue = isFunction$1(seriesDelay) ? seriesDelay(null) : seriesDelay;
        data.eachItemGraphicEl(function(symbol, idx) {
          var el = symbol;
          if (el) {
            var point = [symbol.x, symbol.y];
            var start2 = void 0;
            var end2 = void 0;
            var current = void 0;
            if (clipShape) {
              if (isCoordSysPolar) {
                var polarClip = clipShape;
                var coord = coordSys.pointToCoord(point);
                if (isHorizontalOrRadial) {
                  start2 = polarClip.startAngle;
                  end2 = polarClip.endAngle;
                  current = -coord[1] / 180 * Math.PI;
                } else {
                  start2 = polarClip.r0;
                  end2 = polarClip.r;
                  current = coord[0];
                }
              } else {
                var gridClip = clipShape;
                if (isHorizontalOrRadial) {
                  start2 = gridClip.x;
                  end2 = gridClip.x + gridClip.width;
                  current = symbol.x;
                } else {
                  start2 = gridClip.y + gridClip.height;
                  end2 = gridClip.y;
                  current = symbol.y;
                }
              }
            }
            var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
            if (isAxisInverse) {
              ratio = 1 - ratio;
            }
            var delay = isFunction$1(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
            var symbolPath = el.getSymbolPath();
            var text = symbolPath.getTextContent();
            el.attr({
              scaleX: 0,
              scaleY: 0
            });
            el.animateTo({
              scaleX: 1,
              scaleY: 1
            }, {
              duration: 200,
              setToFinal: true,
              delay
            });
            if (text) {
              text.animateFrom({
                style: {
                  opacity: 0
                }
              }, {
                duration: 300,
                delay
              });
            }
            symbolPath.disableLabelAnimation = true;
          }
        });
      };
      LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
        var endLabelModel = seriesModel.getModel("endLabel");
        if (anyStateShowEndLabel(seriesModel)) {
          var data_2 = seriesModel.getData();
          var polyline = this._polyline;
          var points2 = data_2.getLayout("points");
          if (!points2) {
            polyline.removeTextContent();
            this._endLabel = null;
            return;
          }
          var endLabel = this._endLabel;
          if (!endLabel) {
            endLabel = this._endLabel = new ZRText({
              z2: 200
              // should be higher than item symbol
            });
            endLabel.ignoreClip = true;
            polyline.setTextContent(this._endLabel);
            polyline.disableLabelAnimation = true;
          }
          var dataIndex = getLastIndexNotNull(points2);
          if (dataIndex >= 0) {
            setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
              inheritColor,
              labelFetcher: seriesModel,
              labelDataIndex: dataIndex,
              defaultText: function(dataIndex2, opt, interpolatedValue) {
                return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
              },
              enableTextSetter: true
            }, getEndLabelStateSpecified(endLabelModel, coordSys));
            polyline.textConfig.position = null;
          }
        } else if (this._endLabel) {
          this._polyline.removeTextContent();
          this._endLabel = null;
        }
      };
      LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
        var endLabel = this._endLabel;
        var polyline = this._polyline;
        if (endLabel) {
          if (percent < 1 && animationRecord.originalX == null) {
            animationRecord.originalX = endLabel.x;
            animationRecord.originalY = endLabel.y;
          }
          var points2 = data.getLayout("points");
          var seriesModel = data.hostModel;
          var connectNulls = seriesModel.get("connectNulls");
          var precision = endLabelModel.get("precision");
          var distance2 = endLabelModel.get("distance") || 0;
          var baseAxis = coordSys.getBaseAxis();
          var isHorizontal = baseAxis.isHorizontal();
          var isBaseInversed = baseAxis.inverse;
          var clipShape = clipRect.shape;
          var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
          var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
          var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
          var dim = isHorizontal ? "x" : "y";
          var dataIndexRange = getIndexRange(points2, xOrY, dim);
          var indices = dataIndexRange.range;
          var diff = indices[1] - indices[0];
          var value = void 0;
          if (diff >= 1) {
            if (diff > 1 && !connectNulls) {
              var pt = getPointAtIndex(points2, indices[0]);
              endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              });
              valueAnimation && (value = seriesModel.getRawValue(indices[0]));
            } else {
              var pt = polyline.getPointOn(xOrY, dim);
              pt && endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              });
              var startValue = seriesModel.getRawValue(indices[0]);
              var endValue = seriesModel.getRawValue(indices[1]);
              valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
            }
            animationRecord.lastFrameIndex = indices[0];
          } else {
            var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
            var pt = getPointAtIndex(points2, idx);
            valueAnimation && (value = seriesModel.getRawValue(idx));
            endLabel.attr({
              x: pt[0] + distanceX,
              y: pt[1] + distanceY
            });
          }
          if (valueAnimation) {
            var inner2 = labelInner(endLabel);
            if (typeof inner2.setLabelText === "function") {
              inner2.setLabelText(value);
            }
          }
        }
      };
      LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;
        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next2 = diff.next;
        var stackedOnNext = diff.stackedOnNext;
        if (step) {
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);
          current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);
          next2 = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);
        }
        if (getBoundingDiff(current, next2) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
          polyline.stopAnimation();
          polyline.setShape({
            points: next2
          });
          if (polygon) {
            polygon.stopAnimation();
            polygon.setShape({
              points: next2,
              stackedOnPoints: stackedOnNext
            });
          }
          return;
        }
        polyline.shape.__points = diff.current;
        polyline.shape.points = current;
        var target = {
          shape: {
            points: next2
          }
        };
        if (diff.current !== current) {
          target.shape.__points = diff.next;
        }
        polyline.stopAnimation();
        updateProps$1(polyline, target, seriesModel);
        if (polygon) {
          polygon.setShape({
            // Reuse the points with polyline.
            points: current,
            stackedOnPoints: stackedOnCurrent
          });
          polygon.stopAnimation();
          updateProps$1(polygon, {
            shape: {
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel);
          if (polyline.shape.points !== polygon.shape.points) {
            polygon.shape.points = polyline.shape.points;
          }
        }
        var updatedDataInfo = [];
        var diffStatus = diff.status;
        for (var i2 = 0; i2 < diffStatus.length; i2++) {
          var cmd = diffStatus[i2].cmd;
          if (cmd === "=") {
            var el = data.getItemGraphicEl(diffStatus[i2].idx1);
            if (el) {
              updatedDataInfo.push({
                el,
                ptIdx: i2
                // Index of points
              });
            }
          }
        }
        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function() {
            polygon && polygon.dirtyShape();
            var points2 = polyline.shape.__points;
            for (var i22 = 0; i22 < updatedDataInfo.length; i22++) {
              var el2 = updatedDataInfo[i22].el;
              var offset2 = updatedDataInfo[i22].ptIdx * 2;
              el2.x = points2[offset2];
              el2.y = points2[offset2 + 1];
              el2.markRedraw();
            }
          });
        }
      };
      LineView2.prototype.remove = function(ecModel) {
        var group = this.group;
        var oldData = this._data;
        this._lineGroup.removeAll();
        this._symbolDraw.remove(true);
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
      };
      LineView2.type = "line";
      return LineView2;
    }(ChartView)
  );
  function pointsLayout(seriesType2, forceStoreInTypedArray) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        seriesModel.pipelineContext;
        if (!coordSys) {
          return;
        }
        var dims = map$1(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var dimLen = dims.length;
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        if (isDimensionStacked(data, dims[0])) {
          dims[0] = stackResultDim;
        }
        if (isDimensionStacked(data, dims[1])) {
          dims[1] = stackResultDim;
        }
        var store = data.getStore();
        var dimIdx0 = data.getDimensionIndex(dims[0]);
        var dimIdx1 = data.getDimensionIndex(dims[1]);
        return dimLen && {
          progress: function(params2, data2) {
            var segCount = params2.end - params2.start;
            var points2 = createFloat32Array(segCount * dimLen);
            var tmpIn = [];
            var tmpOut = [];
            for (var i2 = params2.start, offset2 = 0; i2 < params2.end; i2++) {
              var point = void 0;
              if (dimLen === 1) {
                var x2 = store.get(dimIdx0, i2);
                point = coordSys.dataToPoint(x2, null, tmpOut);
              } else {
                tmpIn[0] = store.get(dimIdx0, i2);
                tmpIn[1] = store.get(dimIdx1, i2);
                point = coordSys.dataToPoint(tmpIn, null, tmpOut);
              }
              {
                points2[offset2++] = point[0];
                points2[offset2++] = point[1];
              }
            }
            data2.setLayout("points", points2);
          }
        };
      }
    };
  }
  var samplers = {
    average: function(frame) {
      var sum = 0;
      var count = 0;
      for (var i2 = 0; i2 < frame.length; i2++) {
        if (!isNaN(frame[i2])) {
          sum += frame[i2];
          count++;
        }
      }
      return count === 0 ? NaN : sum / count;
    },
    sum: function(frame) {
      var sum = 0;
      for (var i2 = 0; i2 < frame.length; i2++) {
        sum += frame[i2] || 0;
      }
      return sum;
    },
    max: function(frame) {
      var max3 = -Infinity;
      for (var i2 = 0; i2 < frame.length; i2++) {
        frame[i2] > max3 && (max3 = frame[i2]);
      }
      return isFinite(max3) ? max3 : NaN;
    },
    min: function(frame) {
      var min3 = Infinity;
      for (var i2 = 0; i2 < frame.length; i2++) {
        frame[i2] < min3 && (min3 = frame[i2]);
      }
      return isFinite(min3) ? min3 : NaN;
    },
    // TODO
    // Median
    nearest: function(frame) {
      return frame[0];
    }
  };
  var indexSampler = function(frame) {
    return Math.round(frame.length / 2);
  };
  function dataSample(seriesType2) {
    return {
      seriesType: seriesType2,
      // FIXME:TS never used, so comment it
      // modifyOutputEnd: true,
      reset: function(seriesModel, ecModel, api2) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get("sampling");
        var coordSys = seriesModel.coordinateSystem;
        var count = data.count();
        if (count > 10 && coordSys.type === "cartesian2d" && sampling) {
          var baseAxis = coordSys.getBaseAxis();
          var valueAxis2 = coordSys.getOtherAxis(baseAxis);
          var extent3 = baseAxis.getExtent();
          var dpr2 = api2.getDevicePixelRatio();
          var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
          var rate = Math.round(count / size);
          if (isFinite(rate) && rate > 1) {
            if (sampling === "lttb") {
              seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
            } else if (sampling === "minmax") {
              seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
            }
            var sampler = void 0;
            if (isString$1(sampling)) {
              sampler = samplers[sampling];
            } else if (isFunction$1(sampling)) {
              sampler = sampling;
            }
            if (sampler) {
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
            }
          }
        }
      }
    };
  }
  function install$g(registers) {
    registers.registerChartView(LineView);
    registers.registerSeriesModel(LineSeriesModel);
    registers.registerLayout(pointsLayout("line"));
    registers.registerVisual({
      seriesType: "line",
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
        if (lineStyle && !lineStyle.stroke) {
          lineStyle.stroke = data.getVisual("style").fill;
        }
        data.setVisual("legendLineStyle", lineStyle);
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
  }
  var BaseBarSeriesModel = (
    /** @class */
    function(_super) {
      __extends(BaseBarSeriesModel2, _super);
      function BaseBarSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = BaseBarSeriesModel2.type;
        return _this;
      }
      BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        });
      };
      BaseBarSeriesModel2.prototype.getMarkerPosition = function(value, dims, startingAtTick) {
        var coordSys = this.coordinateSystem;
        if (coordSys && coordSys.clampData) {
          var clampData_1 = coordSys.clampData(value);
          var pt_1 = coordSys.dataToPoint(clampData_1);
          if (startingAtTick) {
            each$4(coordSys.getAxes(), function(axis, idx) {
              if (axis.type === "category" && dims != null) {
                var tickCoords = axis.getTicksCoords();
                var alignTicksWithLabel = axis.getTickModel().get("alignWithLabel");
                var targetTickId = clampData_1[idx];
                var isEnd = dims[idx] === "x1" || dims[idx] === "y1";
                if (isEnd && !alignTicksWithLabel) {
                  targetTickId += 1;
                }
                if (tickCoords.length < 2) {
                  return;
                } else if (tickCoords.length === 2) {
                  pt_1[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);
                  return;
                }
                var leftCoord = void 0;
                var coord = void 0;
                var stepTickValue = 1;
                for (var i2 = 0; i2 < tickCoords.length; i2++) {
                  var tickCoord = tickCoords[i2].coord;
                  var tickValue = i2 === tickCoords.length - 1 ? tickCoords[i2 - 1].tickValue + stepTickValue : tickCoords[i2].tickValue;
                  if (tickValue === targetTickId) {
                    coord = tickCoord;
                    break;
                  } else if (tickValue < targetTickId) {
                    leftCoord = tickCoord;
                  } else if (leftCoord != null && tickValue > targetTickId) {
                    coord = (tickCoord + leftCoord) / 2;
                    break;
                  }
                  if (i2 === 1) {
                    stepTickValue = tickValue - tickCoords[0].tickValue;
                  }
                }
                if (coord == null) {
                  if (!leftCoord) {
                    coord = tickCoords[0].coord;
                  } else if (leftCoord) {
                    coord = tickCoords[tickCoords.length - 1].coord;
                  }
                }
                pt_1[idx] = axis.toGlobalCoord(coord);
              }
            });
          } else {
            var data = this.getData();
            var offset2 = data.getLayout("offset");
            var size = data.getLayout("size");
            var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
            pt_1[offsetIndex] += offset2 + size / 2;
          }
          return pt_1;
        }
        return [NaN, NaN];
      };
      BaseBarSeriesModel2.type = "series.__base_bar__";
      BaseBarSeriesModel2.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        // stack: null
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        barMinHeight: 0,
        barMinAngle: 0,
        // cursor: null,
        large: false,
        largeThreshold: 400,
        progressive: 3e3,
        progressiveChunkMode: "mod"
      };
      return BaseBarSeriesModel2;
    }(SeriesModel)
  );
  SeriesModel.registerClass(BaseBarSeriesModel);
  var BarSeriesModel = (
    /** @class */
    function(_super) {
      __extends(BarSeriesModel2, _super);
      function BarSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = BarSeriesModel2.type;
        return _this;
      }
      BarSeriesModel2.prototype.getInitialData = function() {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true,
          createInvertedIndices: !!this.get("realtimeSort", true) || null
        });
      };
      BarSeriesModel2.prototype.getProgressive = function() {
        return this.get("large") ? this.get("progressive") : false;
      };
      BarSeriesModel2.prototype.getProgressiveThreshold = function() {
        var progressiveThreshold = this.get("progressiveThreshold");
        var largeThreshold = this.get("largeThreshold");
        if (largeThreshold > progressiveThreshold) {
          progressiveThreshold = largeThreshold;
        }
        return progressiveThreshold;
      };
      BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
        return selectors.rect(data.getItemLayout(dataIndex));
      };
      BarSeriesModel2.type = "series.bar";
      BarSeriesModel2.dependencies = ["grid", "polar"];
      BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {
        // If clipped
        // Only available on cartesian2d
        clip: true,
        roundCap: false,
        showBackground: false,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
          borderColor: null,
          borderWidth: 0,
          borderType: "solid",
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        select: {
          itemStyle: {
            borderColor: "#212121"
          }
        },
        realtimeSort: false
      });
      return BarSeriesModel2;
    }(BaseBarSeriesModel)
  );
  var SausageShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function SausageShape2() {
        this.cx = 0;
        this.cy = 0;
        this.r0 = 0;
        this.r = 0;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.clockwise = true;
      }
      return SausageShape2;
    }()
  );
  var SausagePath = (
    /** @class */
    function(_super) {
      __extends(SausagePath2, _super);
      function SausagePath2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "sausage";
        return _this;
      }
      SausagePath2.prototype.getDefaultShape = function() {
        return new SausageShape();
      };
      SausagePath2.prototype.buildPath = function(ctx, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r2 = Math.max(shape.r, 0);
        var dr = (r2 - r0) * 0.5;
        var rCenter = r0 + dr;
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var PI22 = Math.PI * 2;
        var lessThanCircle = clockwise ? endAngle - startAngle < PI22 : startAngle - endAngle < PI22;
        if (!lessThanCircle) {
          startAngle = endAngle - (clockwise ? PI22 : -PI22);
        }
        var unitStartX = Math.cos(startAngle);
        var unitStartY = Math.sin(startAngle);
        var unitEndX = Math.cos(endAngle);
        var unitEndY = Math.sin(endAngle);
        if (lessThanCircle) {
          ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
          ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
        } else {
          ctx.moveTo(unitStartX * r2 + cx, unitStartY * r2 + cy);
        }
        ctx.arc(cx, cy, r2, startAngle, endAngle, !clockwise);
        ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
        if (r0 !== 0) {
          ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
        }
      };
      return SausagePath2;
    }(Path)
  );
  function createSectorCalculateTextPosition(positionMapping, opts) {
    opts = opts || {};
    var isRoundCap = opts.isRoundCap;
    return function(out2, opts2, boundingRect) {
      var textPosition = opts2.position;
      if (!textPosition || textPosition instanceof Array) {
        return calculateTextPosition(out2, opts2, boundingRect);
      }
      var mappedSectorPosition = positionMapping(textPosition);
      var distance2 = opts2.distance != null ? opts2.distance : 5;
      var sector = this.shape;
      var cx = sector.cx;
      var cy = sector.cy;
      var r2 = sector.r;
      var r0 = sector.r0;
      var middleR = (r2 + r0) / 2;
      var startAngle = sector.startAngle;
      var endAngle = sector.endAngle;
      var middleAngle = (startAngle + endAngle) / 2;
      var extraDist = isRoundCap ? Math.abs(r2 - r0) / 2 : 0;
      var mathCos2 = Math.cos;
      var mathSin2 = Math.sin;
      var x2 = cx + r2 * mathCos2(startAngle);
      var y2 = cy + r2 * mathSin2(startAngle);
      var textAlign = "left";
      var textVerticalAlign = "top";
      switch (mappedSectorPosition) {
        case "startArc":
          x2 = cx + (r0 - distance2) * mathCos2(middleAngle);
          y2 = cy + (r0 - distance2) * mathSin2(middleAngle);
          textAlign = "center";
          textVerticalAlign = "top";
          break;
        case "insideStartArc":
          x2 = cx + (r0 + distance2) * mathCos2(middleAngle);
          y2 = cy + (r0 + distance2) * mathSin2(middleAngle);
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "startAngle":
          x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
          y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideStartAngle":
          x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
          y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
          textAlign = "left";
          textVerticalAlign = "middle";
          break;
        case "middle":
          x2 = cx + middleR * mathCos2(middleAngle);
          y2 = cy + middleR * mathSin2(middleAngle);
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "endArc":
          x2 = cx + (r2 + distance2) * mathCos2(middleAngle);
          y2 = cy + (r2 + distance2) * mathSin2(middleAngle);
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideEndArc":
          x2 = cx + (r2 - distance2) * mathCos2(middleAngle);
          y2 = cy + (r2 - distance2) * mathSin2(middleAngle);
          textAlign = "center";
          textVerticalAlign = "top";
          break;
        case "endAngle":
          x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
          y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
          textAlign = "left";
          textVerticalAlign = "middle";
          break;
        case "insideEndAngle":
          x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
          y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        default:
          return calculateTextPosition(out2, opts2, boundingRect);
      }
      out2 = out2 || {};
      out2.x = x2;
      out2.y = y2;
      out2.align = textAlign;
      out2.verticalAlign = textVerticalAlign;
      return out2;
    };
  }
  function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
    if (isNumber$1(rotateType)) {
      sector.setTextConfig({
        rotation: rotateType
      });
      return;
    } else if (isArray$1(textPosition)) {
      sector.setTextConfig({
        rotation: 0
      });
      return;
    }
    var shape = sector.shape;
    var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
    var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var anchorAngle;
    var mappedSectorPosition = positionMapping(textPosition);
    switch (mappedSectorPosition) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        anchorAngle = middleAngle;
        break;
      case "startAngle":
      case "insideStartAngle":
        anchorAngle = startAngle;
        break;
      case "endAngle":
      case "insideEndAngle":
        anchorAngle = endAngle;
        break;
      default:
        sector.setTextConfig({
          rotation: 0
        });
        return;
    }
    var rotate2 = Math.PI * 1.5 - anchorAngle;
    if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
      rotate2 -= Math.PI;
    }
    sector.setTextConfig({
      rotation: rotate2
    });
  }
  function adjustAngleDistanceX(angle, distance2, isEnd) {
    return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
  }
  function adjustAngleDistanceY(angle, distance2, isEnd) {
    return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
  }
  function getSectorCornerRadius(model, shape, zeroIfNull) {
    var cornerRadius = model.get("borderRadius");
    if (cornerRadius == null) {
      return zeroIfNull ? {
        cornerRadius: 0
      } : null;
    }
    if (!isArray$1(cornerRadius)) {
      cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
    }
    var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
    return {
      cornerRadius: map$1(cornerRadius, function(cr) {
        return parsePercent$1(cr, dr);
      })
    };
  }
  var mathMax = Math.max;
  var mathMin = Math.min;
  function getClipArea(coord, data) {
    var coordSysClipArea = coord.getArea && coord.getArea();
    if (isCoordinateSystemType(coord, "cartesian2d")) {
      var baseAxis = coord.getBaseAxis();
      if (baseAxis.type !== "category" || !baseAxis.onBand) {
        var expandWidth = data.getLayout("bandWidth");
        if (baseAxis.isHorizontal()) {
          coordSysClipArea.x -= expandWidth;
          coordSysClipArea.width += expandWidth * 2;
        } else {
          coordSysClipArea.y -= expandWidth;
          coordSysClipArea.height += expandWidth * 2;
        }
      }
    }
    return coordSysClipArea;
  }
  var BarView = (
    /** @class */
    function(_super) {
      __extends(BarView2, _super);
      function BarView2() {
        var _this = _super.call(this) || this;
        _this.type = BarView2.type;
        _this._isFirstFrame = true;
        return _this;
      }
      BarView2.prototype.render = function(seriesModel, ecModel, api2, payload) {
        this._model = seriesModel;
        this._removeOnRenderedListener(api2);
        this._updateDrawMode(seriesModel);
        var coordinateSystemType = seriesModel.get("coordinateSystem");
        if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
          this._progressiveEls = null;
          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api2) : this._renderNormal(seriesModel, ecModel, api2, payload);
        }
      };
      BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
        this._clear();
        this._updateDrawMode(seriesModel);
        this._updateLargeClip(seriesModel);
      };
      BarView2.prototype.incrementalRender = function(params2, seriesModel) {
        this._progressiveEls = [];
        this._incrementalRenderLarge(params2, seriesModel);
      };
      BarView2.prototype.eachRendered = function(cb) {
        traverseElements(this._progressiveEls || this.group, cb);
      };
      BarView2.prototype._updateDrawMode = function(seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;
        if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;
          this._clear();
        }
      };
      BarView2.prototype._renderNormal = function(seriesModel, ecModel, api2, payload) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coord = seriesModel.coordinateSystem;
        var baseAxis = coord.getBaseAxis();
        var isHorizontalOrRadial;
        if (coord.type === "cartesian2d") {
          isHorizontalOrRadial = baseAxis.isHorizontal();
        } else if (coord.type === "polar") {
          isHorizontalOrRadial = baseAxis.dim === "angle";
        }
        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
        var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
        if (realtimeSortCfg) {
          this._enableRealtimeSort(realtimeSortCfg, data, api2);
        }
        var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
        var coordSysClipArea = getClipArea(coord, data);
        group.removeClipPath();
        var roundCap = seriesModel.get("roundCap", true);
        var drawBackground = seriesModel.get("showBackground", true);
        var backgroundModel = seriesModel.getModel("backgroundStyle");
        var barBorderRadius = backgroundModel.get("borderRadius") || 0;
        var bgEls = [];
        var oldBgEls = this._backgroundEls;
        var isInitSort = payload && payload.isInitSort;
        var isChangeOrder = payload && payload.type === "changeAxisOrder";
        function createBackground(dataIndex) {
          var bgLayout = getLayout[coord.type](data, dataIndex);
          var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          } else {
            bgEl.setShape("cornerRadius", barBorderRadius);
          }
          bgEls[dataIndex] = bgEl;
          return bgEl;
        }
        data.diff(oldData).add(function(dataIndex) {
          var itemModel = data.getItemModel(dataIndex);
          var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
          if (drawBackground) {
            createBackground(dataIndex);
          }
          if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
            return;
          }
          var isClipped = false;
          if (needsClip) {
            isClipped = clip[coord.type](coordSysClipArea, layout2);
          }
          var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
          if (realtimeSortCfg) {
            el.forceLabelAnimation = true;
          }
          updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
          if (isInitSort) {
            el.attr({
              shape: layout2
            });
          } else if (realtimeSortCfg) {
            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, dataIndex, isHorizontalOrRadial, false, false);
          } else {
            initProps(el, {
              shape: layout2
            }, seriesModel, dataIndex);
          }
          data.setItemGraphicEl(dataIndex, el);
          group.add(el);
          el.ignore = isClipped;
        }).update(function(newIndex, oldIndex) {
          var itemModel = data.getItemModel(newIndex);
          var layout2 = getLayout[coord.type](data, newIndex, itemModel);
          if (drawBackground) {
            var bgEl = void 0;
            if (oldBgEls.length === 0) {
              bgEl = createBackground(oldIndex);
            } else {
              bgEl = oldBgEls[oldIndex];
              bgEl.useStyle(backgroundModel.getItemStyle());
              if (coord.type === "cartesian2d") {
                bgEl.setShape("r", barBorderRadius);
              } else {
                bgEl.setShape("cornerRadius", barBorderRadius);
              }
              bgEls[newIndex] = bgEl;
            }
            var bgLayout = getLayout[coord.type](data, newIndex);
            var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
            updateProps$1(bgEl, {
              shape
            }, animationModel, newIndex);
          }
          var el = oldData.getItemGraphicEl(oldIndex);
          if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
            group.remove(el);
            return;
          }
          var isClipped = false;
          if (needsClip) {
            isClipped = clip[coord.type](coordSysClipArea, layout2);
            if (isClipped) {
              group.remove(el);
            }
          }
          if (!el) {
            el = elementCreator[coord.type](seriesModel, data, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
          } else {
            saveOldStyle(el);
          }
          if (realtimeSortCfg) {
            el.forceLabelAnimation = true;
          }
          if (isChangeOrder) {
            var textEl = el.getTextContent();
            if (textEl) {
              var labelInnerStore = labelInner(textEl);
              if (labelInnerStore.prevValue != null) {
                labelInnerStore.prevValue = labelInnerStore.value;
              }
            }
          } else {
            updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
          }
          if (isInitSort) {
            el.attr({
              shape: layout2
            });
          } else if (realtimeSortCfg) {
            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
          } else {
            updateProps$1(el, {
              shape: layout2
            }, seriesModel, newIndex, null);
          }
          data.setItemGraphicEl(newIndex, el);
          el.ignore = isClipped;
          group.add(el);
        }).remove(function(dataIndex) {
          var el = oldData.getItemGraphicEl(dataIndex);
          el && removeElementWithFadeOut(el, seriesModel, dataIndex);
        }).execute();
        var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$2());
        bgGroup.removeAll();
        for (var i2 = 0; i2 < bgEls.length; ++i2) {
          bgGroup.add(bgEls[i2]);
        }
        group.add(bgGroup);
        this._backgroundEls = bgEls;
        this._data = data;
      };
      BarView2.prototype._renderLarge = function(seriesModel, ecModel, api2) {
        this._clear();
        createLarge(seriesModel, this.group);
        this._updateLargeClip(seriesModel);
      };
      BarView2.prototype._incrementalRenderLarge = function(params2, seriesModel) {
        this._removeBackground();
        createLarge(seriesModel, this.group, this._progressiveEls, true);
      };
      BarView2.prototype._updateLargeClip = function(seriesModel) {
        var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
        var group = this.group;
        if (clipPath) {
          group.setClipPath(clipPath);
        } else {
          group.removeClipPath();
        }
      };
      BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api2) {
        var _this = this;
        if (!data.count()) {
          return;
        }
        var baseAxis = realtimeSortCfg.baseAxis;
        if (this._isFirstFrame) {
          this._dispatchInitSort(data, realtimeSortCfg, api2);
          this._isFirstFrame = false;
        } else {
          var orderMapping_1 = function(idx) {
            var el = data.getItemGraphicEl(idx);
            var shape = el && el.shape;
            return shape && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
          };
          this._onRendered = function() {
            _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api2);
          };
          api2.getZr().on("rendered", this._onRendered);
        }
      };
      BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
        var info = [];
        data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
          var mappedValue = orderMapping(dataIdx);
          mappedValue = mappedValue == null ? NaN : mappedValue;
          info.push({
            dataIndex: dataIdx,
            mappedValue,
            ordinalNumber
          });
        });
        info.sort(function(a2, b2) {
          return b2.mappedValue - a2.mappedValue;
        });
        return {
          ordinalNumbers: map$1(info, function(item) {
            return item.ordinalNumber;
          })
        };
      };
      BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
        var scale2 = baseAxis.scale;
        var ordinalDataDim = data.mapDimension(baseAxis.dim);
        var lastValue = Number.MAX_VALUE;
        for (var tickNum = 0, len2 = scale2.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
          var rawIdx = data.rawIndexOf(ordinalDataDim, scale2.getRawOrdinalNumber(tickNum));
          var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
          if (value > lastValue) {
            return true;
          }
          lastValue = value;
        }
        return false;
      };
      BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
        var scale2 = baseAxis.scale;
        var extent3 = scale2.getExtent();
        var tickNum = Math.max(0, extent3[0]);
        var tickMax = Math.min(extent3[1], scale2.getOrdinalMeta().categories.length - 1);
        for (; tickNum <= tickMax; ++tickNum) {
          if (orderInfo.ordinalNumbers[tickNum] !== scale2.getRawOrdinalNumber(tickNum)) {
            return true;
          }
        }
      };
      BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api2) {
        if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
          return;
        }
        var sortInfo = this._dataSort(data, baseAxis, orderMapping);
        if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
          this._removeOnRenderedListener(api2);
          api2.dispatchAction({
            type: "changeAxisOrder",
            componentType: baseAxis.dim + "Axis",
            axisId: baseAxis.index,
            sortInfo
          });
        }
      };
      BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api2) {
        var baseAxis = realtimeSortCfg.baseAxis;
        var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
          return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
        });
        api2.dispatchAction({
          type: "changeAxisOrder",
          componentType: baseAxis.dim + "Axis",
          isInitSort: true,
          axisId: baseAxis.index,
          sortInfo: sortResult
        });
      };
      BarView2.prototype.remove = function(ecModel, api2) {
        this._clear(this._model);
        this._removeOnRenderedListener(api2);
      };
      BarView2.prototype.dispose = function(ecModel, api2) {
        this._removeOnRenderedListener(api2);
      };
      BarView2.prototype._removeOnRenderedListener = function(api2) {
        if (this._onRendered) {
          api2.getZr().off("rendered", this._onRendered);
          this._onRendered = null;
        }
      };
      BarView2.prototype._clear = function(model) {
        var group = this.group;
        var data = this._data;
        if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
          this._removeBackground();
          this._backgroundEls = [];
          data.eachItemGraphicEl(function(el) {
            removeElementWithFadeOut(el, model, getECData(el).dataIndex);
          });
        } else {
          group.removeAll();
        }
        this._data = null;
        this._isFirstFrame = true;
      };
      BarView2.prototype._removeBackground = function() {
        this.group.remove(this._backgroundGroup);
        this._backgroundGroup = null;
      };
      BarView2.type = "bar";
      return BarView2;
    }(ChartView)
  );
  var clip = {
    cartesian2d: function(coordSysBoundingRect, layout2) {
      var signWidth = layout2.width < 0 ? -1 : 1;
      var signHeight = layout2.height < 0 ? -1 : 1;
      if (signWidth < 0) {
        layout2.x += layout2.width;
        layout2.width = -layout2.width;
      }
      if (signHeight < 0) {
        layout2.y += layout2.height;
        layout2.height = -layout2.height;
      }
      var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
      var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
      var x2 = mathMax(layout2.x, coordSysBoundingRect.x);
      var x22 = mathMin(layout2.x + layout2.width, coordSysX2);
      var y2 = mathMax(layout2.y, coordSysBoundingRect.y);
      var y22 = mathMin(layout2.y + layout2.height, coordSysY2);
      var xClipped = x22 < x2;
      var yClipped = y22 < y2;
      layout2.x = xClipped && x2 > coordSysX2 ? x22 : x2;
      layout2.y = yClipped && y2 > coordSysY2 ? y22 : y2;
      layout2.width = xClipped ? 0 : x22 - x2;
      layout2.height = yClipped ? 0 : y22 - y2;
      if (signWidth < 0) {
        layout2.x += layout2.width;
        layout2.width = -layout2.width;
      }
      if (signHeight < 0) {
        layout2.y += layout2.height;
        layout2.height = -layout2.height;
      }
      return xClipped || yClipped;
    },
    polar: function(coordSysClipArea, layout2) {
      var signR = layout2.r0 <= layout2.r ? 1 : -1;
      if (signR < 0) {
        var tmp = layout2.r;
        layout2.r = layout2.r0;
        layout2.r0 = tmp;
      }
      var r2 = mathMin(layout2.r, coordSysClipArea.r);
      var r0 = mathMax(layout2.r0, coordSysClipArea.r0);
      layout2.r = r2;
      layout2.r0 = r0;
      var clipped = r2 - r0 < 0;
      if (signR < 0) {
        var tmp = layout2.r;
        layout2.r = layout2.r0;
        layout2.r0 = tmp;
      }
      return clipped;
    }
  };
  var elementCreator = {
    cartesian2d: function(seriesModel, data, newIndex, layout2, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
      var rect = new Rect({
        shape: extend$1({}, layout2),
        z2: 1
      });
      rect.__dataIndex = newIndex;
      rect.name = "item";
      if (animationModel) {
        var rectShape = rect.shape;
        var animateProperty = isHorizontal ? "height" : "width";
        rectShape[animateProperty] = 0;
      }
      return rect;
    },
    polar: function(seriesModel, data, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
      var ShapeClass = !isRadial && roundCap ? SausagePath : Sector;
      var sector = new ShapeClass({
        shape: layout2,
        z2: 1
      });
      sector.name = "item";
      var positionMap2 = createPolarPositionMapping(isRadial);
      sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap2, {
        isRoundCap: ShapeClass === SausagePath
      });
      if (animationModel) {
        var sectorShape = sector.shape;
        var animateProperty = isRadial ? "r" : "endAngle";
        var animateTarget = {};
        sectorShape[animateProperty] = isRadial ? layout2.r0 : layout2.startAngle;
        animateTarget[animateProperty] = layout2[animateProperty];
        (isUpdate ? updateProps$1 : initProps)(sector, {
          shape: animateTarget
          // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
        }, animationModel);
      }
      return sector;
    }
  };
  function shouldRealtimeSort(seriesModel, coordSys) {
    var realtimeSortOption = seriesModel.get("realtimeSort", true);
    var baseAxis = coordSys.getBaseAxis();
    if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
      return {
        baseAxis,
        otherAxis: coordSys.getOtherAxis(baseAxis)
      };
    }
  }
  function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout2, newIndex, isHorizontal, isUpdate, isChangeOrder) {
    var seriesTarget;
    var axisTarget;
    if (isHorizontal) {
      axisTarget = {
        x: layout2.x,
        width: layout2.width
      };
      seriesTarget = {
        y: layout2.y,
        height: layout2.height
      };
    } else {
      axisTarget = {
        y: layout2.y,
        height: layout2.height
      };
      seriesTarget = {
        x: layout2.x,
        width: layout2.width
      };
    }
    if (!isChangeOrder) {
      (isUpdate ? updateProps$1 : initProps)(el, {
        shape: seriesTarget
      }, seriesAnimationModel, newIndex, null);
    }
    var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
    (isUpdate ? updateProps$1 : initProps)(el, {
      shape: axisTarget
    }, axisAnimationModel, newIndex);
  }
  function checkPropertiesNotValid(obj2, props2) {
    for (var i2 = 0; i2 < props2.length; i2++) {
      if (!isFinite(obj2[props2[i2]])) {
        return true;
      }
    }
    return false;
  }
  var rectPropties = ["x", "y", "width", "height"];
  var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
  var isValidLayout = {
    cartesian2d: function(layout2) {
      return !checkPropertiesNotValid(layout2, rectPropties);
    },
    polar: function(layout2) {
      return !checkPropertiesNotValid(layout2, polarPropties);
    }
  };
  var getLayout = {
    // itemModel is only used to get borderWidth, which is not needed
    // when calculating bar background layout.
    cartesian2d: function(data, dataIndex, itemModel) {
      var layout2 = data.getItemLayout(dataIndex);
      var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
      var signX = layout2.width > 0 ? 1 : -1;
      var signY = layout2.height > 0 ? 1 : -1;
      return {
        x: layout2.x + signX * fixedLineWidth / 2,
        y: layout2.y + signY * fixedLineWidth / 2,
        width: layout2.width - signX * fixedLineWidth,
        height: layout2.height - signY * fixedLineWidth
      };
    },
    polar: function(data, dataIndex, itemModel) {
      var layout2 = data.getItemLayout(dataIndex);
      return {
        cx: layout2.cx,
        cy: layout2.cy,
        r0: layout2.r0,
        r: layout2.r,
        startAngle: layout2.startAngle,
        endAngle: layout2.endAngle,
        clockwise: layout2.clockwise
      };
    }
  };
  function isZeroOnPolar(layout2) {
    return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
  }
  function createPolarPositionMapping(isRadial) {
    return /* @__PURE__ */ function(isRadial2) {
      var arcOrAngle = isRadial2 ? "Arc" : "Angle";
      return function(position2) {
        switch (position2) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return position2 + arcOrAngle;
          default:
            return position2;
        }
      };
    }(isRadial);
  }
  function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
    var style = data.getItemVisual(dataIndex, "style");
    if (!isPolar) {
      var borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
      el.setShape("r", borderRadius);
    } else if (!seriesModel.get("roundCap")) {
      var sectorShape = el.shape;
      var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
      extend$1(sectorShape, cornerRadius);
      el.setShape(sectorShape);
    }
    el.useStyle(style);
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && el.attr("cursor", cursorStyle);
    var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
    var labelStatesModels = getLabelStatesModels(itemModel);
    setLabelStyle(el, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
      inheritColor: style.fill,
      defaultOpacity: style.opacity,
      defaultOutsidePosition: labelPositionOutside
    });
    var label = el.getTextContent();
    if (isPolar && label) {
      var position2 = itemModel.get(["label", "position"]);
      el.textConfig.inside = position2 === "middle" ? true : null;
      setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
    }
    setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
      return getDefaultInterpolatedLabel(data, value);
    });
    var emphasisModel = itemModel.getModel(["emphasis"]);
    toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    setStatesStylesFromModel(el, itemModel);
    if (isZeroOnPolar(layout2)) {
      el.style.fill = "none";
      el.style.stroke = "none";
      each$4(el.states, function(state) {
        if (state.style) {
          state.style.fill = state.style.stroke = "none";
        }
      });
    }
  }
  function getLineWidth(itemModel, rawLayout) {
    var borderColor = itemModel.get(["itemStyle", "borderColor"]);
    if (!borderColor || borderColor === "none") {
      return 0;
    }
    var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
    var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
    var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
    return Math.min(lineWidth, width, height);
  }
  var LagePathShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function LagePathShape2() {
      }
      return LagePathShape2;
    }()
  );
  var LargePath = (
    /** @class */
    function(_super) {
      __extends(LargePath2, _super);
      function LargePath2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "largeBar";
        return _this;
      }
      LargePath2.prototype.getDefaultShape = function() {
        return new LagePathShape();
      };
      LargePath2.prototype.buildPath = function(ctx, shape) {
        var points2 = shape.points;
        var baseDimIdx = this.baseDimIdx;
        var valueDimIdx = 1 - this.baseDimIdx;
        var startPoint = [];
        var size = [];
        var barWidth = this.barWidth;
        for (var i2 = 0; i2 < points2.length; i2 += 3) {
          size[baseDimIdx] = barWidth;
          size[valueDimIdx] = points2[i2 + 2];
          startPoint[baseDimIdx] = points2[i2 + baseDimIdx];
          startPoint[valueDimIdx] = points2[i2 + valueDimIdx];
          ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
        }
      };
      return LargePath2;
    }(Path)
  );
  function createLarge(seriesModel, group, progressiveEls, incremental) {
    var data = seriesModel.getData();
    var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
    var largeDataIndices = data.getLayout("largeDataIndices");
    var barWidth = data.getLayout("size");
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var bgPoints = data.getLayout("largeBackgroundPoints");
    if (bgPoints) {
      var bgEl = new LargePath({
        shape: {
          points: bgPoints
        },
        incremental: !!incremental,
        silent: true,
        z2: 0
      });
      bgEl.baseDimIdx = baseDimIdx;
      bgEl.largeDataIndices = largeDataIndices;
      bgEl.barWidth = barWidth;
      bgEl.useStyle(backgroundModel.getItemStyle());
      group.add(bgEl);
      progressiveEls && progressiveEls.push(bgEl);
    }
    var el = new LargePath({
      shape: {
        points: data.getLayout("largePoints")
      },
      incremental: !!incremental,
      ignoreCoarsePointer: true,
      z2: 1
    });
    el.baseDimIdx = baseDimIdx;
    el.largeDataIndices = largeDataIndices;
    el.barWidth = barWidth;
    group.add(el);
    el.useStyle(data.getVisual("style"));
    el.style.stroke = null;
    getECData(el).seriesIndex = seriesModel.seriesIndex;
    if (!seriesModel.get("silent")) {
      el.on("mousedown", largePathUpdateDataIndex);
      el.on("mousemove", largePathUpdateDataIndex);
    }
    progressiveEls && progressiveEls.push(el);
  }
  var largePathUpdateDataIndex = throttle$1(function(event) {
    var largePath = this;
    var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
    getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
  }, 30, false);
  function largePathFindDataIndex(largePath, x2, y2) {
    var baseDimIdx = largePath.baseDimIdx;
    var valueDimIdx = 1 - baseDimIdx;
    var points2 = largePath.shape.points;
    var largeDataIndices = largePath.largeDataIndices;
    var startPoint = [];
    var size = [];
    var barWidth = largePath.barWidth;
    for (var i2 = 0, len2 = points2.length / 3; i2 < len2; i2++) {
      var ii = i2 * 3;
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points2[ii + 2];
      startPoint[baseDimIdx] = points2[ii + baseDimIdx];
      startPoint[valueDimIdx] = points2[ii + valueDimIdx];
      if (size[valueDimIdx] < 0) {
        startPoint[valueDimIdx] += size[valueDimIdx];
        size[valueDimIdx] = -size[valueDimIdx];
      }
      if (x2 >= startPoint[0] && x2 <= startPoint[0] + size[0] && y2 >= startPoint[1] && y2 <= startPoint[1] + size[1]) {
        return largeDataIndices[i2];
      }
    }
    return -1;
  }
  function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
    if (isCoordinateSystemType(coord, "cartesian2d")) {
      var rectShape = layout2;
      var coordLayout = coord.getArea();
      return {
        x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
        y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
        width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
        height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
      };
    } else {
      var coordLayout = coord.getArea();
      var sectorShape = layout2;
      return {
        cx: coordLayout.cx,
        cy: coordLayout.cy,
        r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
        r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
        startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
        endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
      };
    }
  }
  function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
    var ElementClz = coord.type === "polar" ? Sector : Rect;
    return new ElementClz({
      shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
      silent: true,
      z2: 0
    });
  }
  function install$f(registers) {
    registers.registerChartView(BarView);
    registers.registerSeriesModel(BarSeriesModel);
    registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$1, "bar"));
    registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
    registers.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(payload, ecModel) {
      var componentType = payload.componentType || "series";
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function(componentModel) {
        if (payload.sortInfo) {
          componentModel.axis.setCategorySortInfo(payload.sortInfo);
        }
      });
    });
  }
  var PI2 = Math.PI * 2;
  var RADIAN$1 = Math.PI / 180;
  function getViewRect(seriesModel, api2) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
  }
  function getBasicPieLayout(seriesModel, api2) {
    var viewRect2 = getViewRect(seriesModel, api2);
    var center2 = seriesModel.get("center");
    var radius = seriesModel.get("radius");
    if (!isArray$1(radius)) {
      radius = [0, radius];
    }
    var width = parsePercent(viewRect2.width, api2.getWidth());
    var height = parsePercent(viewRect2.height, api2.getHeight());
    var size = Math.min(width, height);
    var r0 = parsePercent(radius[0], size / 2);
    var r2 = parsePercent(radius[1], size / 2);
    var cx;
    var cy;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys) {
      var point = coordSys.dataToPoint(center2);
      cx = point[0] || 0;
      cy = point[1] || 0;
    } else {
      if (!isArray$1(center2)) {
        center2 = [center2, center2];
      }
      cx = parsePercent(center2[0], width) + viewRect2.x;
      cy = parsePercent(center2[1], height) + viewRect2.y;
    }
    return {
      cx,
      cy,
      r0,
      r: r2
    };
  }
  function pieLayout(seriesType2, ecModel, api2) {
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var viewRect2 = getViewRect(seriesModel, api2);
      var _a2 = getBasicPieLayout(seriesModel, api2), cx = _a2.cx, cy = _a2.cy, r2 = _a2.r, r0 = _a2.r0;
      var startAngle = -seriesModel.get("startAngle") * RADIAN$1;
      var endAngle = seriesModel.get("endAngle");
      var padAngle = seriesModel.get("padAngle") * RADIAN$1;
      endAngle = endAngle === "auto" ? startAngle - PI2 : -endAngle * RADIAN$1;
      var minAngle = seriesModel.get("minAngle") * RADIAN$1;
      var minAndPadAngle = minAngle + padAngle;
      var validDataCount = 0;
      data.each(valueDim, function(value) {
        !isNaN(value) && validDataCount++;
      });
      var sum = data.getSum(valueDim);
      var unitRadian = Math.PI / (sum || validDataCount) * 2;
      var clockwise = seriesModel.get("clockwise");
      var roseType = seriesModel.get("roseType");
      var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
      var extent3 = data.getDataExtent(valueDim);
      extent3[0] = 0;
      var dir3 = clockwise ? 1 : -1;
      var angles = [startAngle, endAngle];
      var halfPadAngle = dir3 * padAngle / 2;
      normalizeArcAngles(angles, !clockwise);
      startAngle = angles[0], endAngle = angles[1];
      var layoutData = getSeriesLayoutData(seriesModel);
      layoutData.startAngle = startAngle;
      layoutData.endAngle = endAngle;
      layoutData.clockwise = clockwise;
      var angleRange = Math.abs(endAngle - startAngle);
      var restAngle = angleRange;
      var valueSumLargerThanMinAngle = 0;
      var currentAngle = startAngle;
      data.setLayout({
        viewRect: viewRect2,
        r: r2
      });
      data.each(valueDim, function(value, idx) {
        var angle;
        if (isNaN(value)) {
          data.setItemLayout(idx, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise,
            cx,
            cy,
            r0,
            r: roseType ? NaN : r2
          });
          return;
        }
        if (roseType !== "area") {
          angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        } else {
          angle = angleRange / validDataCount;
        }
        if (angle < minAndPadAngle) {
          angle = minAndPadAngle;
          restAngle -= minAndPadAngle;
        } else {
          valueSumLargerThanMinAngle += value;
        }
        var endAngle2 = currentAngle + dir3 * angle;
        var actualStartAngle = 0;
        var actualEndAngle = 0;
        if (padAngle > angle) {
          actualStartAngle = currentAngle + dir3 * angle / 2;
          actualEndAngle = actualStartAngle;
        } else {
          actualStartAngle = currentAngle + halfPadAngle;
          actualEndAngle = endAngle2 - halfPadAngle;
        }
        data.setItemLayout(idx, {
          angle,
          startAngle: actualStartAngle,
          endAngle: actualEndAngle,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? linearMap(value, extent3, [r0, r2]) : r2
        });
        currentAngle = endAngle2;
      });
      if (restAngle < PI2 && validDataCount) {
        if (restAngle <= 1e-3) {
          var angle_1 = angleRange / validDataCount;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout_1 = data.getItemLayout(idx);
              layout_1.angle = angle_1;
              var actualStartAngle = 0;
              var actualEndAngle = 0;
              if (angle_1 < padAngle) {
                actualStartAngle = startAngle + dir3 * (idx + 1 / 2) * angle_1;
                actualEndAngle = actualStartAngle;
              } else {
                actualStartAngle = startAngle + dir3 * idx * angle_1 + halfPadAngle;
                actualEndAngle = startAngle + dir3 * (idx + 1) * angle_1 - halfPadAngle;
              }
              layout_1.startAngle = actualStartAngle;
              layout_1.endAngle = actualEndAngle;
            }
          });
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle;
          currentAngle = startAngle;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout_2 = data.getItemLayout(idx);
              var angle = layout_2.angle === minAndPadAngle ? minAndPadAngle : value * unitRadian;
              var actualStartAngle = 0;
              var actualEndAngle = 0;
              if (angle < padAngle) {
                actualStartAngle = currentAngle + dir3 * angle / 2;
                actualEndAngle = actualStartAngle;
              } else {
                actualStartAngle = currentAngle + halfPadAngle;
                actualEndAngle = currentAngle + dir3 * angle - halfPadAngle;
              }
              layout_2.startAngle = actualStartAngle;
              layout_2.endAngle = actualEndAngle;
              currentAngle += dir3 * angle;
            }
          });
        }
      }
    });
  }
  var getSeriesLayoutData = makeInner();
  function dataFilter(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: "legend"
        });
        if (!legendModels || !legendModels.length) {
          return;
        }
        var data = seriesModel.getData();
        data.filterSelf(function(idx) {
          var name = data.getName(idx);
          for (var i2 = 0; i2 < legendModels.length; i2++) {
            if (!legendModels[i2].isSelected(name)) {
              return false;
            }
          }
          return true;
        });
      }
    };
  }
  var RADIAN = Math.PI / 180;
  function adjustSingleSide(list2, cx, cy, r2, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
    if (list2.length < 2) {
      return;
    }
    function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
      var rB = semi.rB;
      var rB2 = rB * rB;
      for (var i3 = 0; i3 < semi.list.length; i3++) {
        var item = semi.list[i3];
        var dy = Math.abs(item.label.y - cy);
        var rA = r2 + item.len;
        var rA2 = rA * rA;
        var dx2 = Math.sqrt(Math.abs((1 - dy * dy / rB2) * rA2));
        var newX = cx + (dx2 + item.len2) * dir3;
        var deltaX = newX - item.label.x;
        var newTargetWidth = item.targetTextWidth - deltaX * dir3;
        constrainTextWidth(item, newTargetWidth, true);
        item.label.x = newX;
      }
    }
    function recalculateX(items) {
      var topSemi = {
        list: [],
        maxY: 0
      };
      var bottomSemi = {
        list: [],
        maxY: 0
      };
      for (var i3 = 0; i3 < items.length; i3++) {
        if (items[i3].labelAlignTo !== "none") {
          continue;
        }
        var item = items[i3];
        var semi = item.label.y > cy ? bottomSemi : topSemi;
        var dy = Math.abs(item.label.y - cy);
        if (dy >= semi.maxY) {
          var dx2 = item.label.x - cx - item.len2 * dir3;
          var rA = r2 + item.len;
          var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
          semi.rB = rB;
          semi.maxY = dy;
        }
        semi.list.push(item);
      }
      recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
      recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
    }
    var len2 = list2.length;
    for (var i2 = 0; i2 < len2; i2++) {
      if (list2[i2].position === "outer" && list2[i2].labelAlignTo === "labelLine") {
        var dx = list2[i2].label.x - farthestX;
        list2[i2].linePoints[1][0] += dx;
        list2[i2].label.x = farthestX;
      }
    }
    if (shiftLayoutOnY(list2, viewTop, viewTop + viewHeight)) {
      recalculateX(list2);
    }
  }
  function avoidOverlap(labelLayoutList, cx, cy, r2, viewWidth, viewHeight, viewLeft, viewTop) {
    var leftList = [];
    var rightList = [];
    var leftmostX = Number.MAX_VALUE;
    var rightmostX = -Number.MAX_VALUE;
    for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
      var label = labelLayoutList[i2].label;
      if (isPositionCenter(labelLayoutList[i2])) {
        continue;
      }
      if (label.x < cx) {
        leftmostX = Math.min(leftmostX, label.x);
        leftList.push(labelLayoutList[i2]);
      } else {
        rightmostX = Math.max(rightmostX, label.x);
        rightList.push(labelLayoutList[i2]);
      }
    }
    for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
      var layout2 = labelLayoutList[i2];
      if (!isPositionCenter(layout2) && layout2.linePoints) {
        if (layout2.labelStyleWidth != null) {
          continue;
        }
        var label = layout2.label;
        var linePoints = layout2.linePoints;
        var targetTextWidth = void 0;
        if (layout2.labelAlignTo === "edge") {
          if (label.x < cx) {
            targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
          }
        } else if (layout2.labelAlignTo === "labelLine") {
          if (label.x < cx) {
            targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
          }
        } else {
          if (label.x < cx) {
            targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
          }
        }
        layout2.targetTextWidth = targetTextWidth;
        constrainTextWidth(layout2, targetTextWidth);
      }
    }
    adjustSingleSide(rightList, cx, cy, r2, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
    adjustSingleSide(leftList, cx, cy, r2, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
    for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
      var layout2 = labelLayoutList[i2];
      if (!isPositionCenter(layout2) && layout2.linePoints) {
        var label = layout2.label;
        var linePoints = layout2.linePoints;
        var isAlignToEdge = layout2.labelAlignTo === "edge";
        var padding = label.style.padding;
        var paddingH = padding ? padding[1] + padding[3] : 0;
        var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
        var realTextWidth = layout2.rect.width + extraPaddingH;
        var dist2 = linePoints[1][0] - linePoints[2][0];
        if (isAlignToEdge) {
          if (label.x < cx) {
            linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
          } else {
            linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
          }
        } else {
          if (label.x < cx) {
            linePoints[2][0] = label.x + layout2.labelDistance;
          } else {
            linePoints[2][0] = label.x - layout2.labelDistance;
          }
          linePoints[1][0] = linePoints[2][0] + dist2;
        }
        linePoints[1][1] = linePoints[2][1] = label.y;
      }
    }
  }
  function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
    if (forceRecalculate === void 0) {
      forceRecalculate = false;
    }
    if (layout2.labelStyleWidth != null) {
      return;
    }
    var label = layout2.label;
    var style = label.style;
    var textRect = layout2.rect;
    var bgColor = style.backgroundColor;
    var padding = style.padding;
    var paddingH = padding ? padding[1] + padding[3] : 0;
    var overflow = style.overflow;
    var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
    if (availableWidth < oldOuterWidth || forceRecalculate) {
      var oldHeight = textRect.height;
      if (overflow && overflow.match("break")) {
        label.setStyle("backgroundColor", null);
        label.setStyle("width", availableWidth - paddingH);
        var innerRect = label.getBoundingRect();
        label.setStyle("width", Math.ceil(innerRect.width));
        label.setStyle("backgroundColor", bgColor);
      } else {
        var availableInnerWidth = availableWidth - paddingH;
        var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null
        );
        label.setStyle("width", newWidth);
      }
      var newRect = label.getBoundingRect();
      textRect.width = newRect.width;
      var margin = (label.style.margin || 0) + 2.1;
      textRect.height = newRect.height + margin;
      textRect.y -= (textRect.height - oldHeight) / 2;
    }
  }
  function isPositionCenter(sectorShape) {
    return sectorShape.position === "center";
  }
  function pieLabelLayout(seriesModel) {
    var data = seriesModel.getData();
    var labelLayoutList = [];
    var cx;
    var cy;
    var hasLabelRotate = false;
    var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
    var viewRect2 = data.getLayout("viewRect");
    var r2 = data.getLayout("r");
    var viewWidth = viewRect2.width;
    var viewLeft = viewRect2.x;
    var viewTop = viewRect2.y;
    var viewHeight = viewRect2.height;
    function setNotShow(el) {
      el.ignore = true;
    }
    function isLabelShown(label2) {
      if (!label2.ignore) {
        return true;
      }
      for (var key2 in label2.states) {
        if (label2.states[key2].ignore === false) {
          return true;
        }
      }
      return false;
    }
    data.each(function(idx) {
      var sector = data.getItemGraphicEl(idx);
      var sectorShape = sector.shape;
      var label2 = sector.getTextContent();
      var labelLine2 = sector.getTextGuideLine();
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel("label");
      var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
      var labelDistance = labelModel.get("distanceToLabelLine");
      var labelAlignTo = labelModel.get("alignTo");
      var edgeDistance = parsePercent(labelModel.get("edgeDistance"), viewWidth);
      var bleedMargin = labelModel.get("bleedMargin");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineLen = labelLineModel.get("length");
      labelLineLen = parsePercent(labelLineLen, viewWidth);
      var labelLineLen2 = labelLineModel.get("length2");
      labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
      if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
        each$4(label2.states, setNotShow);
        label2.ignore = true;
        if (labelLine2) {
          each$4(labelLine2.states, setNotShow);
          labelLine2.ignore = true;
        }
        return;
      }
      if (!isLabelShown(label2)) {
        return;
      }
      var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
      var nx = Math.cos(midAngle);
      var ny = Math.sin(midAngle);
      var textX;
      var textY;
      var linePoints2;
      var textAlign;
      cx = sectorShape.cx;
      cy = sectorShape.cy;
      var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
      if (labelPosition === "center") {
        textX = sectorShape.cx;
        textY = sectorShape.cy;
        textAlign = "center";
      } else {
        var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
        var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
        textX = x1 + nx * 3;
        textY = y1 + ny * 3;
        if (!isLabelInside) {
          var x2 = x1 + nx * (labelLineLen + r2 - sectorShape.r);
          var y2 = y1 + ny * (labelLineLen + r2 - sectorShape.r);
          var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
          var y3 = y2;
          if (labelAlignTo === "edge") {
            textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
          } else {
            textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
          }
          textY = y3;
          linePoints2 = [[x1, y1], [x2, y2], [x3, y3]];
        }
        textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
      }
      var PI3 = Math.PI;
      var labelRotate = 0;
      var rotate2 = labelModel.get("rotate");
      if (isNumber$1(rotate2)) {
        labelRotate = rotate2 * (PI3 / 180);
      } else if (labelPosition === "center") {
        labelRotate = 0;
      } else if (rotate2 === "radial" || rotate2 === true) {
        var radialAngle = nx < 0 ? -midAngle + PI3 : -midAngle;
        labelRotate = radialAngle;
      } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
        var rad = Math.atan2(nx, ny);
        if (rad < 0) {
          rad = PI3 * 2 + rad;
        }
        var isDown = ny > 0;
        if (isDown) {
          rad = PI3 + rad;
        }
        labelRotate = rad - PI3;
      }
      hasLabelRotate = !!labelRotate;
      label2.x = textX;
      label2.y = textY;
      label2.rotation = labelRotate;
      label2.setStyle({
        verticalAlign: "middle"
      });
      if (!isLabelInside) {
        var textRect = label2.getBoundingRect().clone();
        textRect.applyTransform(label2.getComputedTransform());
        var margin = (label2.style.margin || 0) + 2.1;
        textRect.y -= margin / 2;
        textRect.height += margin;
        labelLayoutList.push({
          label: label2,
          labelLine: labelLine2,
          position: labelPosition,
          len: labelLineLen,
          len2: labelLineLen2,
          minTurnAngle: labelLineModel.get("minTurnAngle"),
          maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
          surfaceNormal: new Point(nx, ny),
          linePoints: linePoints2,
          textAlign,
          labelDistance,
          labelAlignTo,
          edgeDistance,
          bleedMargin,
          rect: textRect,
          unconstrainedWidth: textRect.width,
          labelStyleWidth: label2.style.width
        });
      } else {
        label2.setStyle({
          align: textAlign
        });
        var selectState2 = label2.states.select;
        if (selectState2) {
          selectState2.x += label2.x;
          selectState2.y += label2.y;
        }
      }
      sector.setTextConfig({
        inside: isLabelInside
      });
    });
    if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
      avoidOverlap(labelLayoutList, cx, cy, r2, viewWidth, viewHeight, viewLeft, viewTop);
    }
    for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
      var layout2 = labelLayoutList[i2];
      var label = layout2.label;
      var labelLine = layout2.labelLine;
      var notShowLabel = isNaN(label.x) || isNaN(label.y);
      if (label) {
        label.setStyle({
          align: layout2.textAlign
        });
        if (notShowLabel) {
          each$4(label.states, setNotShow);
          label.ignore = true;
        }
        var selectState = label.states.select;
        if (selectState) {
          selectState.x += label.x;
          selectState.y += label.y;
        }
      }
      if (labelLine) {
        var linePoints = layout2.linePoints;
        if (notShowLabel || !linePoints) {
          each$4(labelLine.states, setNotShow);
          labelLine.ignore = true;
        } else {
          limitTurnAngle(linePoints, layout2.minTurnAngle);
          limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
          labelLine.setShape({
            points: linePoints
          });
          label.__hostTarget.textGuideLineConfig = {
            anchor: new Point(linePoints[0][0], linePoints[0][1])
          };
        }
      }
    }
  }
  var PiePiece = (
    /** @class */
    function(_super) {
      __extends(PiePiece2, _super);
      function PiePiece2(data, idx, startAngle) {
        var _this = _super.call(this) || this;
        _this.z2 = 2;
        var text = new ZRText();
        _this.setTextContent(text);
        _this.updateData(data, idx, startAngle, true);
        return _this;
      }
      PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
        var sector = this;
        var seriesModel = data.hostModel;
        var itemModel = data.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        var layout2 = data.getItemLayout(idx);
        var sectorShape = extend$1(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
        if (isNaN(sectorShape.startAngle)) {
          sector.setShape(sectorShape);
          return;
        }
        if (firstCreate) {
          sector.setShape(sectorShape);
          var animationType = seriesModel.getShallow("animationType");
          if (seriesModel.ecModel.ssr) {
            initProps(sector, {
              scaleX: 0,
              scaleY: 0
            }, seriesModel, {
              dataIndex: idx,
              isFrom: true
            });
            sector.originX = sectorShape.cx;
            sector.originY = sectorShape.cy;
          } else if (animationType === "scale") {
            sector.shape.r = layout2.r0;
            initProps(sector, {
              shape: {
                r: layout2.r
              }
            }, seriesModel, idx);
          } else {
            if (startAngle != null) {
              sector.setShape({
                startAngle,
                endAngle: startAngle
              });
              initProps(sector, {
                shape: {
                  startAngle: layout2.startAngle,
                  endAngle: layout2.endAngle
                }
              }, seriesModel, idx);
            } else {
              sector.shape.endAngle = layout2.startAngle;
              updateProps$1(sector, {
                shape: {
                  endAngle: layout2.endAngle
                }
              }, seriesModel, idx);
            }
          }
        } else {
          saveOldStyle(sector);
          updateProps$1(sector, {
            shape: sectorShape
          }, seriesModel, idx);
        }
        sector.useStyle(data.getItemVisual(idx, "style"));
        setStatesStylesFromModel(sector, itemModel);
        var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
        var offset2 = seriesModel.get("selectedOffset");
        var dx = Math.cos(midAngle) * offset2;
        var dy = Math.sin(midAngle) * offset2;
        var cursorStyle = itemModel.getShallow("cursor");
        cursorStyle && sector.attr("cursor", cursorStyle);
        this._updateLabel(seriesModel, data, idx);
        sector.ensureState("emphasis").shape = extend$1({
          r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
        }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
        extend$1(sector.ensureState("select"), {
          x: dx,
          y: dy,
          shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
        });
        extend$1(sector.ensureState("blur"), {
          shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
        });
        var labelLine = sector.getTextGuideLine();
        var labelText = sector.getTextContent();
        labelLine && extend$1(labelLine.ensureState("select"), {
          x: dx,
          y: dy
        });
        extend$1(labelText.ensureState("select"), {
          x: dx,
          y: dy
        });
        toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      };
      PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
        var sector = this;
        var itemModel = data.getItemModel(idx);
        var labelLineModel = itemModel.getModel("labelLine");
        var style = data.getItemVisual(idx, "style");
        var visualColor = style && style.fill;
        var visualOpacity = style && style.opacity;
        setLabelStyle(sector, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          inheritColor: visualColor,
          defaultOpacity: visualOpacity,
          defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
        });
        var labelText = sector.getTextContent();
        sector.setTextConfig({
          // reset position, rotation
          position: null,
          rotation: null
        });
        labelText.attr({
          z2: 10
        });
        var labelPosition = seriesModel.get(["label", "position"]);
        if (labelPosition !== "outside" && labelPosition !== "outer") {
          sector.removeTextGuideLine();
        } else {
          var polyline = this.getTextGuideLine();
          if (!polyline) {
            polyline = new Polyline();
            this.setTextGuideLine(polyline);
          }
          setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
            stroke: visualColor,
            opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
          });
        }
      };
      return PiePiece2;
    }(Sector)
  );
  var PieView = (
    /** @class */
    function(_super) {
      __extends(PieView2, _super);
      function PieView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ignoreLabelLineUpdate = true;
        return _this;
      }
      PieView2.prototype.render = function(seriesModel, ecModel, api2, payload) {
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var startAngle;
        if (!oldData && data.count() > 0) {
          var shape = data.getItemLayout(0);
          for (var s2 = 1; isNaN(shape && shape.startAngle) && s2 < data.count(); ++s2) {
            shape = data.getItemLayout(s2);
          }
          if (shape) {
            startAngle = shape.startAngle;
          }
        }
        if (this._emptyCircleSector) {
          group.remove(this._emptyCircleSector);
        }
        if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
          var layoutData = getSeriesLayoutData(seriesModel);
          var sector = new Sector({
            shape: extend$1(getBasicPieLayout(seriesModel, api2), layoutData)
          });
          sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
          this._emptyCircleSector = sector;
          group.add(sector);
        }
        data.diff(oldData).add(function(idx) {
          var piePiece = new PiePiece(data, idx, startAngle);
          data.setItemGraphicEl(idx, piePiece);
          group.add(piePiece);
        }).update(function(newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);
          piePiece.updateData(data, newIdx, startAngle);
          piePiece.off("click");
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function(idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          removeElementWithFadeOut(piePiece, seriesModel, idx);
        }).execute();
        pieLabelLayout(seriesModel);
        if (seriesModel.get("animationTypeUpdate") !== "expansion") {
          this._data = data;
        }
      };
      PieView2.prototype.dispose = function() {
      };
      PieView2.prototype.containPoint = function(point, seriesModel) {
        var data = seriesModel.getData();
        var itemLayout = data.getItemLayout(0);
        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      };
      PieView2.type = "pie";
      return PieView2;
    }(ChartView)
  );
  function createSeriesDataSimply(seriesModel, opt, nameList) {
    opt = isArray$1(opt) && {
      coordDimensions: opt
    } || extend$1({
      encodeDefine: seriesModel.getEncode()
    }, opt);
    var source = seriesModel.getSource();
    var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
    var list2 = new SeriesData(dimensions, seriesModel);
    list2.initData(source, nameList);
    return list2;
  }
  var LegendVisualProvider = (
    /** @class */
    function() {
      function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
        this._getDataWithEncodedVisual = getDataWithEncodedVisual;
        this._getRawData = getRawData2;
      }
      LegendVisualProvider2.prototype.getAllNames = function() {
        var rawData = this._getRawData();
        return rawData.mapArray(rawData.getName);
      };
      LegendVisualProvider2.prototype.containName = function(name) {
        var rawData = this._getRawData();
        return rawData.indexOfName(name) >= 0;
      };
      LegendVisualProvider2.prototype.indexOfName = function(name) {
        var dataWithEncodedVisual = this._getDataWithEncodedVisual();
        return dataWithEncodedVisual.indexOfName(name);
      };
      LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key2) {
        var dataWithEncodedVisual = this._getDataWithEncodedVisual();
        return dataWithEncodedVisual.getItemVisual(dataIndex, key2);
      };
      return LegendVisualProvider2;
    }()
  );
  var innerData = makeInner();
  var PieSeriesModel = (
    /** @class */
    function(_super) {
      __extends(PieSeriesModel2, _super);
      function PieSeriesModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PieSeriesModel2.prototype.init = function(option) {
        _super.prototype.init.apply(this, arguments);
        this.legendVisualProvider = new LegendVisualProvider(bind$2(this.getData, this), bind$2(this.getRawData, this));
        this._defaultLabelLine(option);
      };
      PieSeriesModel2.prototype.mergeOption = function() {
        _super.prototype.mergeOption.apply(this, arguments);
      };
      PieSeriesModel2.prototype.getInitialData = function() {
        return createSeriesDataSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
        });
      };
      PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
        var data = this.getData();
        var dataInner = innerData(data);
        var seats = dataInner.seats;
        if (!seats) {
          var valueList_1 = [];
          data.each(data.mapDimension("value"), function(value) {
            valueList_1.push(value);
          });
          seats = dataInner.seats = getPercentSeats(valueList_1, data.hostModel.get("percentPrecision"));
        }
        var params2 = _super.prototype.getDataParams.call(this, dataIndex);
        params2.percent = seats[dataIndex] || 0;
        params2.$vars.push("percent");
        return params2;
      };
      PieSeriesModel2.prototype._defaultLabelLine = function(option) {
        defaultEmphasis(option, "labelLine", ["show"]);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine;
        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      };
      PieSeriesModel2.type = "series.pie";
      PieSeriesModel2.defaultOption = {
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        colorBy: "data",
        // 默认全局居中
        center: ["50%", "50%"],
        radius: [0, "75%"],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        endAngle: "auto",
        padAngle: 0,
        // 最小角度改为0
        minAngle: 0,
        // If the angle of a sector less than `minShowLabelAngle`,
        // the label will not be displayed.
        minShowLabelAngle: 0,
        // 选中时扇区偏移量
        selectedOffset: 10,
        // 选择模式，默认关闭，可选single，multiple
        // selectedMode: false,
        // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
        // roseType: null,
        percentPrecision: 2,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // cursor: null,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          // color: 'inherit',
          // If rotate around circle
          rotate: 0,
          show: true,
          overflow: "truncate",
          // 'outer', 'inside', 'center'
          position: "outer",
          // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
          alignTo: "none",
          // Closest distance between label and chart edge.
          // Works only position is 'outer' and alignTo is 'edge'.
          edgeDistance: "25%",
          // Works only position is 'outer' and alignTo is not 'edge'.
          bleedMargin: 10,
          // Distance between text and label line.
          distanceToLabelLine: 5
          // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
          // 默认使用全局文本样式，详见 textStyle
          // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
        },
        // Enabled when label.normal.position is 'outer'
        labelLine: {
          show: true,
          // 引导线两段中的第一段长度
          length: 15,
          // 引导线两段中的第二段长度
          length2: 15,
          smooth: false,
          minTurnAngle: 90,
          maxSurfaceAngle: 90,
          lineStyle: {
            // color: 各异,
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          borderWidth: 1,
          borderJoin: "round"
        },
        showEmptyCircle: true,
        emptyCircleStyle: {
          color: "lightgray",
          opacity: 1
        },
        labelLayout: {
          // Hide the overlapped label.
          hideOverlap: true
        },
        emphasis: {
          scale: true,
          scaleSize: 5
        },
        // If use strategy to avoid label overlapping
        avoidLabelOverlap: true,
        // Animation type. Valid values: expansion, scale
        animationType: "expansion",
        animationDuration: 1e3,
        // Animation type when update. Valid values: transition, expansion
        animationTypeUpdate: "transition",
        animationEasingUpdate: "cubicInOut",
        animationDurationUpdate: 500,
        animationEasing: "cubicInOut"
      };
      return PieSeriesModel2;
    }(SeriesModel)
  );
  function negativeDataFilter(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        data.filterSelf(function(idx) {
          var valueDim = data.mapDimension("value");
          var curValue = data.get(valueDim, idx);
          if (isNumber$1(curValue) && !isNaN(curValue) && curValue < 0) {
            return false;
          }
          return true;
        });
      }
    };
  }
  function install$e(registers) {
    registers.registerChartView(PieView);
    registers.registerSeriesModel(PieSeriesModel);
    createLegacyDataSelectAction("pie", registers.registerAction);
    registers.registerLayout(curry$1(pieLayout, "pie"));
    registers.registerProcessor(dataFilter("pie"));
    registers.registerProcessor(negativeDataFilter("pie"));
  }
  var GridModel = (
    /** @class */
    function(_super) {
      __extends(GridModel2, _super);
      function GridModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GridModel2.type = "grid";
      GridModel2.dependencies = ["xAxis", "yAxis"];
      GridModel2.layoutMode = "box";
      GridModel2.defaultOption = {
        show: false,
        // zlevel: 0,
        z: 0,
        left: "10%",
        top: 60,
        right: "10%",
        bottom: 70,
        // If grid size contain label
        containLabel: false,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 1,
        borderColor: "#ccc"
      };
      return GridModel2;
    }(ComponentModel)
  );
  var CartesianAxisModel = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisModel2, _super);
      function CartesianAxisModel2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CartesianAxisModel2.prototype.getCoordSysModel = function() {
        return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
      };
      CartesianAxisModel2.type = "cartesian2dAxis";
      return CartesianAxisModel2;
    }(ComponentModel)
  );
  mixin(CartesianAxisModel, AxisModelCommonMixin);
  var defaultOption = {
    show: true,
    // zlevel: 0,
    z: 0,
    // Inverse the axis.
    inverse: false,
    // Axis name displayed.
    name: "",
    // 'start' | 'middle' | 'end'
    nameLocation: "end",
    // By degree. By default auto rotate by nameLocation.
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    // Use global text style by default.
    nameTextStyle: {},
    // The gap between axisName and axisLine.
    nameGap: 15,
    // Default `false` to support tooltip.
    silent: false,
    // Default `false` to avoid legacy user event listener fail.
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      // The arrow at both ends the the axis.
      symbol: ["none", "none"],
      symbolSize: [10, 15]
    },
    axisTick: {
      show: true,
      // Whether axisTick is inside the grid or outside the grid.
      inside: false,
      // The length of axisTick.
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      // Whether axisLabel is inside the grid or outside the grid.
      inside: false,
      rotate: 0,
      // true | false | null/undefined (auto)
      showMinLabel: null,
      // true | false | null/undefined (auto)
      showMaxLabel: null,
      margin: 8,
      // formatter: null,
      fontSize: 12
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: ["#E0E6F1"],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
      }
    }
  };
  var categoryAxis = merge$1({
    // The gap at both ends of the axis. For categoryAxis, boolean.
    boundaryGap: true,
    // Set false to faster category collection.
    deduplication: null,
    // splitArea: {
    // show: false
    // },
    splitLine: {
      show: false
    },
    axisTick: {
      // If tick is align with label when boundaryGap is true
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, defaultOption);
  var valueAxis = merge$1({
    boundaryGap: [0, 0],
    axisLine: {
      // Not shown when other axis is categoryAxis in cartesian
      show: "auto"
    },
    axisTick: {
      // Not shown when other axis is categoryAxis in cartesian
      show: "auto"
    },
    // TODO
    // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
    splitNumber: 5,
    minorTick: {
      // Minor tick, not available for cateogry axis.
      show: false,
      // Split number of minor ticks. The value should be in range of (0, 100)
      splitNumber: 5,
      // Length of minor tick
      length: 3,
      // Line style
      lineStyle: {
        // Default to be same with axisTick
      }
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, defaultOption);
  var timeAxis = merge$1({
    splitNumber: 6,
    axisLabel: {
      // To eliminate labels that are not nice
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, valueAxis);
  var logAxis = defaults$1({
    logBase: 10
  }, valueAxis);
  const axisDefault = {
    category: categoryAxis,
    value: valueAxis,
    time: timeAxis,
    log: logAxis
  };
  var AXIS_TYPES = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
    each$4(AXIS_TYPES, function(v2, axisType) {
      var defaultOption2 = merge$1(merge$1({}, axisDefault[axisType], true), extraDefaultOption, true);
      var AxisModel = (
        /** @class */
        function(_super) {
          __extends(AxisModel2, _super);
          function AxisModel2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = axisName + "Axis." + axisType;
            return _this;
          }
          AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
            var layoutMode = fetchLayoutMode(this);
            var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
            var themeModel = ecModel.getTheme();
            merge$1(option, themeModel.get(axisType + "Axis"));
            merge$1(option, this.getDefaultOption());
            option.type = getAxisType(option);
            if (layoutMode) {
              mergeLayoutParam(option, inputPositionParams, layoutMode);
            }
          };
          AxisModel2.prototype.optionUpdated = function() {
            var thisOption = this.option;
            if (thisOption.type === "category") {
              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
            }
          };
          AxisModel2.prototype.getCategories = function(rawData) {
            var option = this.option;
            if (option.type === "category") {
              if (rawData) {
                return option.data;
              }
              return this.__ordinalMeta.categories;
            }
          };
          AxisModel2.prototype.getOrdinalMeta = function() {
            return this.__ordinalMeta;
          };
          AxisModel2.type = axisName + "Axis." + axisType;
          AxisModel2.defaultOption = defaultOption2;
          return AxisModel2;
        }(BaseAxisModelClass)
      );
      registers.registerComponentModel(AxisModel);
    });
    registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
  }
  function getAxisType(option) {
    return option.type || (option.data ? "category" : "value");
  }
  var Cartesian = (
    /** @class */
    function() {
      function Cartesian2(name) {
        this.type = "cartesian";
        this._dimList = [];
        this._axes = {};
        this.name = name || "";
      }
      Cartesian2.prototype.getAxis = function(dim) {
        return this._axes[dim];
      };
      Cartesian2.prototype.getAxes = function() {
        return map$1(this._dimList, function(dim) {
          return this._axes[dim];
        }, this);
      };
      Cartesian2.prototype.getAxesByScale = function(scaleType) {
        scaleType = scaleType.toLowerCase();
        return filter(this.getAxes(), function(axis) {
          return axis.scale.type === scaleType;
        });
      };
      Cartesian2.prototype.addAxis = function(axis) {
        var dim = axis.dim;
        this._axes[dim] = axis;
        this._dimList.push(dim);
      };
      return Cartesian2;
    }()
  );
  var cartesian2DDimensions = ["x", "y"];
  function canCalculateAffineTransform(scale2) {
    return scale2.type === "interval" || scale2.type === "time";
  }
  var Cartesian2D = (
    /** @class */
    function(_super) {
      __extends(Cartesian2D2, _super);
      function Cartesian2D2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "cartesian2d";
        _this.dimensions = cartesian2DDimensions;
        return _this;
      }
      Cartesian2D2.prototype.calcAffineTransform = function() {
        this._transform = this._invTransform = null;
        var xAxisScale = this.getAxis("x").scale;
        var yAxisScale = this.getAxis("y").scale;
        if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
          return;
        }
        var xScaleExtent = xAxisScale.getExtent();
        var yScaleExtent = yAxisScale.getExtent();
        var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
        var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
        var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
        var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
        if (!xScaleSpan || !yScaleSpan) {
          return;
        }
        var scaleX = (end2[0] - start2[0]) / xScaleSpan;
        var scaleY = (end2[1] - start2[1]) / yScaleSpan;
        var translateX = start2[0] - xScaleExtent[0] * scaleX;
        var translateY = start2[1] - yScaleExtent[0] * scaleY;
        var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
        this._invTransform = invert([], m2);
      };
      Cartesian2D2.prototype.getBaseAxis = function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
      };
      Cartesian2D2.prototype.containPoint = function(point) {
        var axisX = this.getAxis("x");
        var axisY = this.getAxis("y");
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
      };
      Cartesian2D2.prototype.containData = function(data) {
        return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
      };
      Cartesian2D2.prototype.containZone = function(data1, data2) {
        var zoneDiag1 = this.dataToPoint(data1);
        var zoneDiag2 = this.dataToPoint(data2);
        var area = this.getArea();
        var zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
        return area.intersect(zone);
      };
      Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
        out2 = out2 || [];
        var xVal = data[0];
        var yVal = data[1];
        if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
          return applyTransform$1(out2, data, this._transform);
        }
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
        out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
        return out2;
      };
      Cartesian2D2.prototype.clampData = function(data, out2) {
        var xScale = this.getAxis("x").scale;
        var yScale = this.getAxis("y").scale;
        var xAxisExtent = xScale.getExtent();
        var yAxisExtent = yScale.getExtent();
        var x2 = xScale.parse(data[0]);
        var y2 = yScale.parse(data[1]);
        out2 = out2 || [];
        out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x2), Math.max(xAxisExtent[0], xAxisExtent[1]));
        out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y2), Math.max(yAxisExtent[0], yAxisExtent[1]));
        return out2;
      };
      Cartesian2D2.prototype.pointToData = function(point, clamp2) {
        var out2 = [];
        if (this._invTransform) {
          return applyTransform$1(out2, point, this._invTransform);
        }
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
        out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
        return out2;
      };
      Cartesian2D2.prototype.getOtherAxis = function(axis) {
        return this.getAxis(axis.dim === "x" ? "y" : "x");
      };
      Cartesian2D2.prototype.getArea = function(tolerance) {
        tolerance = tolerance || 0;
        var xExtent = this.getAxis("x").getGlobalExtent();
        var yExtent = this.getAxis("y").getGlobalExtent();
        var x2 = Math.min(xExtent[0], xExtent[1]) - tolerance;
        var y2 = Math.min(yExtent[0], yExtent[1]) - tolerance;
        var width = Math.max(xExtent[0], xExtent[1]) - x2 + tolerance;
        var height = Math.max(yExtent[0], yExtent[1]) - y2 + tolerance;
        return new BoundingRect(x2, y2, width, height);
      };
      return Cartesian2D2;
    }(Cartesian)
  );
  var Axis2D = (
    /** @class */
    function(_super) {
      __extends(Axis2D2, _super);
      function Axis2D2(dim, scale2, coordExtent, axisType, position2) {
        var _this = _super.call(this, dim, scale2, coordExtent) || this;
        _this.index = 0;
        _this.type = axisType || "value";
        _this.position = position2 || "bottom";
        return _this;
      }
      Axis2D2.prototype.isHorizontal = function() {
        var position2 = this.position;
        return position2 === "top" || position2 === "bottom";
      };
      Axis2D2.prototype.getGlobalExtent = function(asc2) {
        var ret = this.getExtent();
        ret[0] = this.toGlobalCoord(ret[0]);
        ret[1] = this.toGlobalCoord(ret[1]);
        asc2 && ret[0] > ret[1] && ret.reverse();
        return ret;
      };
      Axis2D2.prototype.pointToData = function(point, clamp2) {
        return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
      };
      Axis2D2.prototype.setCategorySortInfo = function(info) {
        if (this.type !== "category") {
          return false;
        }
        this.model.option.categorySortInfo = info;
        this.scale.setSortInfo(info);
      };
      return Axis2D2;
    }(Axis)
  );
  function layout(gridModel, axisModel, opt) {
    opt = opt || {};
    var grid = gridModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout2 = {};
    var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
    var rawAxisPosition = axis.position;
    var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
    var axisDim = axis.dim;
    var rect = grid.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    };
    var axisOffset = axisModel.get("offset") || 0;
    var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
    if (otherAxisOnZeroOf) {
      var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    }
    layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
    layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
    layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
    if (axisModel.get(["axisTick", "inside"])) {
      layout2.tickDirection = -layout2.tickDirection;
    }
    if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
      layout2.labelDirection = -layout2.labelDirection;
    }
    var labelRotate = axisModel.get(["axisLabel", "rotate"]);
    layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
    layout2.z2 = 1;
    return layout2;
  }
  function isCartesian2DSeries(seriesModel) {
    return seriesModel.get("coordinateSystem") === "cartesian2d";
  }
  function findAxisModels(seriesModel) {
    var axisModelMap = {
      xAxisModel: null,
      yAxisModel: null
    };
    each$4(axisModelMap, function(v2, key2) {
      var axisType = key2.replace(/Model$/, "");
      var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
      axisModelMap[key2] = axisModel;
    });
    return axisModelMap;
  }
  var mathLog = Math.log;
  function alignScaleTicks(scale2, axisModel, alignToScale) {
    var intervalScaleProto2 = IntervalScale.prototype;
    var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
    var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
    var alignToSplitNumber = alignToTicks.length - 1;
    var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
    var scaleExtent = getScaleExtent(scale2, axisModel);
    var rawExtent = scaleExtent.extent;
    var isMinFixed = scaleExtent.fixMin;
    var isMaxFixed = scaleExtent.fixMax;
    if (scale2.type === "log") {
      var logBase = mathLog(scale2.base);
      rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
    }
    scale2.setExtent(rawExtent[0], rawExtent[1]);
    scale2.calcNiceExtent({
      splitNumber: alignToSplitNumber,
      fixMin: isMinFixed,
      fixMax: isMaxFixed
    });
    var extent3 = intervalScaleProto2.getExtent.call(scale2);
    if (isMinFixed) {
      rawExtent[0] = extent3[0];
    }
    if (isMaxFixed) {
      rawExtent[1] = extent3[1];
    }
    var interval = intervalScaleProto2.getInterval.call(scale2);
    var min3 = rawExtent[0];
    var max3 = rawExtent[1];
    if (isMinFixed && isMaxFixed) {
      interval = (max3 - min3) / alignToSplitNumber;
    } else if (isMinFixed) {
      max3 = rawExtent[0] + interval * alignToSplitNumber;
      while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
        interval = increaseInterval(interval);
        max3 = rawExtent[0] + interval * alignToSplitNumber;
      }
    } else if (isMaxFixed) {
      min3 = rawExtent[1] - interval * alignToSplitNumber;
      while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
        interval = increaseInterval(interval);
        min3 = rawExtent[1] - interval * alignToSplitNumber;
      }
    } else {
      var nicedSplitNumber = scale2.getTicks().length - 1;
      if (nicedSplitNumber > alignToSplitNumber) {
        interval = increaseInterval(interval);
      }
      var range2 = interval * alignToSplitNumber;
      max3 = Math.ceil(rawExtent[1] / interval) * interval;
      min3 = round$1(max3 - range2);
      if (min3 < 0 && rawExtent[0] >= 0) {
        min3 = 0;
        max3 = round$1(range2);
      } else if (max3 > 0 && rawExtent[1] <= 0) {
        max3 = 0;
        min3 = -round$1(range2);
      }
    }
    var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
    var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
    intervalScaleProto2.setExtent.call(scale2, min3 + interval * t0, max3 + interval * t1);
    intervalScaleProto2.setInterval.call(scale2, interval);
    if (t0 || t1) {
      intervalScaleProto2.setNiceExtent.call(scale2, min3 + interval, max3 - interval);
    }
  }
  var Grid = (
    /** @class */
    function() {
      function Grid2(gridModel, ecModel, api2) {
        this.type = "grid";
        this._coordsMap = {};
        this._coordsList = [];
        this._axesMap = {};
        this._axesList = [];
        this.axisPointerEnabled = true;
        this.dimensions = cartesian2DDimensions;
        this._initCartesian(gridModel, ecModel, api2);
        this.model = gridModel;
      }
      Grid2.prototype.getRect = function() {
        return this._rect;
      };
      Grid2.prototype.update = function(ecModel, api2) {
        var axesMap = this._axesMap;
        this._updateScale(ecModel, this.model);
        function updateAxisTicks(axes) {
          var alignTo;
          var axesIndices = keys(axes);
          var len2 = axesIndices.length;
          if (!len2) {
            return;
          }
          var axisNeedsAlign = [];
          for (var i2 = len2 - 1; i2 >= 0; i2--) {
            var idx = +axesIndices[i2];
            var axis = axes[idx];
            var model = axis.model;
            var scale2 = axis.scale;
            if (
              // Only value and log axis without interval support alignTicks.
              isIntervalOrLogScale(scale2) && model.get("alignTicks") && model.get("interval") == null
            ) {
              axisNeedsAlign.push(axis);
            } else {
              niceScaleExtent(scale2, model);
              if (isIntervalOrLogScale(scale2)) {
                alignTo = axis;
              }
            }
          }
          if (axisNeedsAlign.length) {
            if (!alignTo) {
              alignTo = axisNeedsAlign.pop();
              niceScaleExtent(alignTo.scale, alignTo.model);
            }
            each$4(axisNeedsAlign, function(axis2) {
              alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
            });
          }
        }
        updateAxisTicks(axesMap.x);
        updateAxisTicks(axesMap.y);
        var onZeroRecords = {};
        each$4(axesMap.x, function(xAxis) {
          fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
        });
        each$4(axesMap.y, function(yAxis) {
          fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
        });
        this.resize(this.model, api2);
      };
      Grid2.prototype.resize = function(gridModel, api2, ignoreContainLabel) {
        var boxLayoutParams = gridModel.getBoxLayoutParams();
        var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
        var gridRect = getLayoutRect(boxLayoutParams, {
          width: api2.getWidth(),
          height: api2.getHeight()
        });
        this._rect = gridRect;
        var axesList = this._axesList;
        adjustAxes();
        if (isContainLabel) {
          each$4(axesList, function(axis) {
            if (!axis.model.get(["axisLabel", "inside"])) {
              var labelUnionRect = estimateLabelUnionRect(axis);
              if (labelUnionRect) {
                var dim = axis.isHorizontal() ? "height" : "width";
                var margin = axis.model.get(["axisLabel", "margin"]);
                gridRect[dim] -= labelUnionRect[dim] + margin;
                if (axis.position === "top") {
                  gridRect.y += labelUnionRect.height + margin;
                } else if (axis.position === "left") {
                  gridRect.x += labelUnionRect.width + margin;
                }
              }
            }
          });
          adjustAxes();
        }
        each$4(this._coordsList, function(coord) {
          coord.calcAffineTransform();
        });
        function adjustAxes() {
          each$4(axesList, function(axis) {
            var isHorizontal = axis.isHorizontal();
            var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
            var idx = axis.inverse ? 1 : 0;
            axis.setExtent(extent3[idx], extent3[1 - idx]);
            updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
          });
        }
      };
      Grid2.prototype.getAxis = function(dim, axisIndex) {
        var axesMapOnDim = this._axesMap[dim];
        if (axesMapOnDim != null) {
          return axesMapOnDim[axisIndex || 0];
        }
      };
      Grid2.prototype.getAxes = function() {
        return this._axesList.slice();
      };
      Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
        if (xAxisIndex != null && yAxisIndex != null) {
          var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
          return this._coordsMap[key2];
        }
        if (isObject$3(xAxisIndex)) {
          yAxisIndex = xAxisIndex.yAxisIndex;
          xAxisIndex = xAxisIndex.xAxisIndex;
        }
        for (var i2 = 0, coordList = this._coordsList; i2 < coordList.length; i2++) {
          if (coordList[i2].getAxis("x").index === xAxisIndex || coordList[i2].getAxis("y").index === yAxisIndex) {
            return coordList[i2];
          }
        }
      };
      Grid2.prototype.getCartesians = function() {
        return this._coordsList.slice();
      };
      Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
        var target = this._findConvertTarget(finder);
        return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
      };
      Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
        var target = this._findConvertTarget(finder);
        return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
      };
      Grid2.prototype._findConvertTarget = function(finder) {
        var seriesModel = finder.seriesModel;
        var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
        var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
        var gridModel = finder.gridModel;
        var coordsList = this._coordsList;
        var cartesian;
        var axis;
        if (seriesModel) {
          cartesian = seriesModel.coordinateSystem;
          indexOf(coordsList, cartesian) < 0 && (cartesian = null);
        } else if (xAxisModel && yAxisModel) {
          cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        } else if (xAxisModel) {
          axis = this.getAxis("x", xAxisModel.componentIndex);
        } else if (yAxisModel) {
          axis = this.getAxis("y", yAxisModel.componentIndex);
        } else if (gridModel) {
          var grid = gridModel.coordinateSystem;
          if (grid === this) {
            cartesian = this._coordsList[0];
          }
        }
        return {
          cartesian,
          axis
        };
      };
      Grid2.prototype.containPoint = function(point) {
        var coord = this._coordsList[0];
        if (coord) {
          return coord.containPoint(point);
        }
      };
      Grid2.prototype._initCartesian = function(gridModel, ecModel, api2) {
        var _this = this;
        var grid = this;
        var axisPositionUsed = {
          left: false,
          right: false,
          top: false,
          bottom: false
        };
        var axesMap = {
          x: {},
          y: {}
        };
        var axesCount = {
          x: 0,
          y: 0
        };
        ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
        ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
        if (!axesCount.x || !axesCount.y) {
          this._axesMap = {};
          this._axesList = [];
          return;
        }
        this._axesMap = axesMap;
        each$4(axesMap.x, function(xAxis, xAxisIndex) {
          each$4(axesMap.y, function(yAxis, yAxisIndex) {
            var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
            var cartesian = new Cartesian2D(key2);
            cartesian.master = _this;
            cartesian.model = gridModel;
            _this._coordsMap[key2] = cartesian;
            _this._coordsList.push(cartesian);
            cartesian.addAxis(xAxis);
            cartesian.addAxis(yAxis);
          });
        });
        function createAxisCreator(dimName) {
          return function(axisModel, idx) {
            if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
              return;
            }
            var axisPosition = axisModel.get("position");
            if (dimName === "x") {
              if (axisPosition !== "top" && axisPosition !== "bottom") {
                axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
              }
            } else {
              if (axisPosition !== "left" && axisPosition !== "right") {
                axisPosition = axisPositionUsed.left ? "right" : "left";
              }
            }
            axisPositionUsed[axisPosition] = true;
            var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
            var isCategory2 = axis.type === "category";
            axis.onBand = isCategory2 && axisModel.get("boundaryGap");
            axis.inverse = axisModel.get("inverse");
            axisModel.axis = axis;
            axis.model = axisModel;
            axis.grid = grid;
            axis.index = idx;
            grid._axesList.push(axis);
            axesMap[dimName][idx] = axis;
            axesCount[dimName]++;
          };
        }
      };
      Grid2.prototype._updateScale = function(ecModel, gridModel) {
        each$4(this._axesList, function(axis) {
          axis.scale.setExtent(Infinity, -Infinity);
          if (axis.type === "category") {
            var categorySortInfo = axis.model.get("categorySortInfo");
            axis.scale.setSortInfo(categorySortInfo);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          if (isCartesian2DSeries(seriesModel)) {
            var axesModelMap = findAxisModels(seriesModel);
            var xAxisModel = axesModelMap.xAxisModel;
            var yAxisModel = axesModelMap.yAxisModel;
            if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
              return;
            }
            var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
            var data = seriesModel.getData();
            var xAxis = cartesian.getAxis("x");
            var yAxis = cartesian.getAxis("y");
            unionExtent(data, xAxis);
            unionExtent(data, yAxis);
          }
        }, this);
        function unionExtent(data, axis) {
          each$4(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
            axis.scale.unionExtentFromData(data, dim);
          });
        }
      };
      Grid2.prototype.getTooltipAxes = function(dim) {
        var baseAxes = [];
        var otherAxes = [];
        each$4(this.getCartesians(), function(cartesian) {
          var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
          var otherAxis = cartesian.getOtherAxis(baseAxis);
          indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
          indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
        });
        return {
          baseAxes,
          otherAxes
        };
      };
      Grid2.create = function(ecModel, api2) {
        var grids = [];
        ecModel.eachComponent("grid", function(gridModel, idx) {
          var grid = new Grid2(gridModel, ecModel, api2);
          grid.name = "grid_" + idx;
          grid.resize(gridModel, api2, true);
          gridModel.coordinateSystem = grid;
          grids.push(grid);
        });
        ecModel.eachSeries(function(seriesModel) {
          if (!isCartesian2DSeries(seriesModel)) {
            return;
          }
          var axesModelMap = findAxisModels(seriesModel);
          var xAxisModel = axesModelMap.xAxisModel;
          var yAxisModel = axesModelMap.yAxisModel;
          var gridModel = xAxisModel.getCoordSysModel();
          var grid = gridModel.coordinateSystem;
          seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        });
        return grids;
      };
      Grid2.dimensions = cartesian2DDimensions;
      return Grid2;
    }()
  );
  function isAxisUsedInTheGrid(axisModel, gridModel) {
    return axisModel.getCoordSysModel() === gridModel;
  }
  function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
    axis.getAxesOnZeroOf = function() {
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
    };
    var otherAxes = axesMap[otherAxisDim];
    var otherAxisOnZeroOf;
    var axisModel = axis.model;
    var onZero = axisModel.get(["axisLine", "onZero"]);
    var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
    if (!onZero) {
      return;
    }
    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
      }
    } else {
      for (var idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx];
          break;
        }
      }
    }
    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
    }
    function getOnZeroRecordKey(axis2) {
      return axis2.dim + "_" + axis2.index;
    }
  }
  function canOnZeroToAxis(axis) {
    return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
  }
  function updateAxisTransform(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];
    axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === "x" ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
  }
  var PI = Math.PI;
  var AxisBuilder = (
    /** @class */
    function() {
      function AxisBuilder2(axisModel, opt) {
        this.group = new Group$2();
        this.opt = opt;
        this.axisModel = axisModel;
        defaults$1(opt, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: true,
          handleAutoShown: function() {
            return true;
          }
        });
        var transformGroup = new Group$2({
          x: opt.position[0],
          y: opt.position[1],
          rotation: opt.rotation
        });
        transformGroup.updateTransform();
        this._transformGroup = transformGroup;
      }
      AxisBuilder2.prototype.hasBuilder = function(name) {
        return !!builders[name];
      };
      AxisBuilder2.prototype.add = function(name) {
        builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
      };
      AxisBuilder2.prototype.getGroup = function() {
        return this.group;
      };
      AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
        var rotationDiff = remRadian(textRotation - axisRotation);
        var textAlign;
        var textVerticalAlign;
        if (isRadianAroundZero(rotationDiff)) {
          textVerticalAlign = direction > 0 ? "top" : "bottom";
          textAlign = "center";
        } else if (isRadianAroundZero(rotationDiff - PI)) {
          textVerticalAlign = direction > 0 ? "bottom" : "top";
          textAlign = "center";
        } else {
          textVerticalAlign = "middle";
          if (rotationDiff > 0 && rotationDiff < PI) {
            textAlign = direction > 0 ? "right" : "left";
          } else {
            textAlign = direction > 0 ? "left" : "right";
          }
        }
        return {
          rotation: rotationDiff,
          textAlign,
          textVerticalAlign
        };
      };
      AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
        var eventData = {
          componentType: axisModel.mainType,
          componentIndex: axisModel.componentIndex
        };
        eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
        return eventData;
      };
      AxisBuilder2.isLabelSilent = function(axisModel) {
        var tooltipOpt = axisModel.get("tooltip");
        return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
      };
      return AxisBuilder2;
    }()
  );
  var builders = {
    axisLine: function(opt, axisModel, group, transformGroup) {
      var shown = axisModel.get(["axisLine", "show"]);
      if (shown === "auto" && opt.handleAutoShown) {
        shown = opt.handleAutoShown("axisLine");
      }
      if (!shown) {
        return;
      }
      var extent3 = axisModel.axis.getExtent();
      var matrix2 = transformGroup.transform;
      var pt12 = [extent3[0], 0];
      var pt22 = [extent3[1], 0];
      var inverse = pt12[0] > pt22[0];
      if (matrix2) {
        applyTransform$1(pt12, pt12, matrix2);
        applyTransform$1(pt22, pt22, matrix2);
      }
      var lineStyle = extend$1({
        lineCap: "round"
      }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
      var line2 = new Line({
        shape: {
          x1: pt12[0],
          y1: pt12[1],
          x2: pt22[0],
          y2: pt22[1]
        },
        style: lineStyle,
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      });
      subPixelOptimizeLine(line2.shape, line2.style.lineWidth);
      line2.anid = "line";
      group.add(line2);
      var arrows = axisModel.get(["axisLine", "symbol"]);
      if (arrows != null) {
        var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
        if (isString$1(arrows)) {
          arrows = [arrows, arrows];
        }
        if (isString$1(arrowSize) || isNumber$1(arrowSize)) {
          arrowSize = [arrowSize, arrowSize];
        }
        var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
        var symbolWidth_1 = arrowSize[0];
        var symbolHeight_1 = arrowSize[1];
        each$4([{
          rotate: opt.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: opt.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
        }], function(point, index2) {
          if (arrows[index2] !== "none" && arrows[index2] != null) {
            var symbol = createSymbol(arrows[index2], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
            var r2 = point.r + point.offset;
            var pt = inverse ? pt22 : pt12;
            symbol.attr({
              rotation: point.rotate,
              x: pt[0] + r2 * Math.cos(opt.rotation),
              y: pt[1] - r2 * Math.sin(opt.rotation),
              silent: true,
              z2: 11
            });
            group.add(symbol);
          }
        });
      }
    },
    axisTickLabel: function(opt, axisModel, group, transformGroup) {
      var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
      var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
      fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
      buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
      if (axisModel.get(["axisLabel", "hideOverlap"])) {
        var labelList = prepareLayoutList(map$1(labelEls, function(label) {
          return {
            label,
            priority: label.z2,
            defaultAttr: {
              ignore: label.ignore
            }
          };
        }));
        hideOverlap(labelList);
      }
    },
    axisName: function(opt, axisModel, group, transformGroup) {
      var name = retrieve(opt.axisName, axisModel.get("name"));
      if (!name) {
        return;
      }
      var nameLocation = axisModel.get("nameLocation");
      var nameDirection = opt.nameDirection;
      var textStyleModel = axisModel.getModel("nameTextStyle");
      var gap = axisModel.get("nameGap") || 0;
      var extent3 = axisModel.axis.getExtent();
      var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
      var pos = [
        nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
        // Reuse labelOffset.
        isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
      ];
      var labelLayout;
      var nameRotation = axisModel.get("nameRotate");
      if (nameRotation != null) {
        nameRotation = nameRotation * PI / 180;
      }
      var axisNameAvailableWidth;
      if (isNameLocationCenter(nameLocation)) {
        labelLayout = AxisBuilder.innerTextLayout(
          opt.rotation,
          nameRotation != null ? nameRotation : opt.rotation,
          // Adapt to axis.
          nameDirection
        );
      } else {
        labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
        axisNameAvailableWidth = opt.axisNameAvailableWidth;
        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }
      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get("nameTruncate", true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
      var textEl = new ZRText({
        x: pos[0],
        y: pos[1],
        rotation: labelLayout.rotation,
        silent: AxisBuilder.isLabelSilent(axisModel),
        style: createTextStyle$1(textStyleModel, {
          text: name,
          font: textFont,
          overflow: "truncate",
          width: maxWidth,
          ellipsis,
          fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
          align: textStyleModel.get("align") || labelLayout.textAlign,
          verticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
        }),
        z2: 1
      });
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: name
      });
      textEl.__fullText = name;
      textEl.anid = "name";
      if (axisModel.get("triggerEvent")) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisName";
        eventData.name = name;
        getECData(textEl).eventData = eventData;
      }
      transformGroup.add(textEl);
      textEl.updateTransform();
      group.add(textEl);
      textEl.decomposeTransform();
    }
  };
  function endTextLayout(rotation, textPosition, textRotate, extent3) {
    var rotationDiff = remRadian(textRotate - rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent3[0] > extent3[1];
    var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
    if (isRadianAroundZero(rotationDiff - PI / 2)) {
      textVerticalAlign = onLeft ? "bottom" : "top";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
      textVerticalAlign = onLeft ? "top" : "bottom";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
        textAlign = onLeft ? "left" : "right";
      } else {
        textAlign = onLeft ? "right" : "left";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
    if (shouldShowAllLabels(axisModel.axis)) {
      return;
    }
    var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
    var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
    labelEls = labelEls || [];
    tickEls = tickEls || [];
    var firstLabel = labelEls[0];
    var nextLabel = labelEls[1];
    var lastLabel = labelEls[labelEls.length - 1];
    var prevLabel = labelEls[labelEls.length - 2];
    var firstTick = tickEls[0];
    var nextTick2 = tickEls[1];
    var lastTick = tickEls[tickEls.length - 1];
    var prevTick = tickEls[tickEls.length - 2];
    if (showMinLabel === false) {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
      if (showMinLabel) {
        ignoreEl(nextLabel);
        ignoreEl(nextTick2);
      } else {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      }
    }
    if (showMaxLabel === false) {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
      if (showMaxLabel) {
        ignoreEl(prevLabel);
        ignoreEl(prevTick);
      } else {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      }
    }
  }
  function ignoreEl(el) {
    el && (el.ignore = true);
  }
  function isTwoLabelOverlapped(current, next2) {
    var firstRect = current && current.getBoundingRect().clone();
    var nextRect = next2 && next2.getBoundingRect().clone();
    if (!firstRect || !nextRect) {
      return;
    }
    var mRotationBack = identity([]);
    rotate(mRotationBack, mRotationBack, -current.rotation);
    firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
    nextRect.applyTransform(mul([], mRotationBack, next2.getLocalTransform()));
    return firstRect.intersect(nextRect);
  }
  function isNameLocationCenter(nameLocation) {
    return nameLocation === "middle" || nameLocation === "center";
  }
  function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
    var tickEls = [];
    var pt12 = [];
    var pt22 = [];
    for (var i2 = 0; i2 < ticksCoords.length; i2++) {
      var tickCoord = ticksCoords[i2].coord;
      pt12[0] = tickCoord;
      pt12[1] = 0;
      pt22[0] = tickCoord;
      pt22[1] = tickEndCoord;
      if (tickTransform) {
        applyTransform$1(pt12, pt12, tickTransform);
        applyTransform$1(pt22, pt22, tickTransform);
      }
      var tickEl = new Line({
        shape: {
          x1: pt12[0],
          y1: pt12[1],
          x2: pt22[0],
          y2: pt22[1]
        },
        style: tickLineStyle,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);
      tickEl.anid = anidPrefix + "_" + ticksCoords[i2].tickValue;
      tickEls.push(tickEl);
    }
    return tickEls;
  }
  function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
    var axis = axisModel.axis;
    var tickModel = axisModel.getModel("axisTick");
    var shown = tickModel.get("show");
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisTick");
    }
    if (!shown || axis.scale.isBlank()) {
      return;
    }
    var lineStyleModel = tickModel.getModel("lineStyle");
    var tickEndCoord = opt.tickDirection * tickModel.get("length");
    var ticksCoords = axis.getTicksCoords();
    var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults$1(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }), "ticks");
    for (var i2 = 0; i2 < ticksEls.length; i2++) {
      group.add(ticksEls[i2]);
    }
    return ticksEls;
  }
  function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
    var axis = axisModel.axis;
    var minorTickModel = axisModel.getModel("minorTick");
    if (!minorTickModel.get("show") || axis.scale.isBlank()) {
      return;
    }
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var lineStyleModel = minorTickModel.getModel("lineStyle");
    var tickEndCoord = tickDirection * minorTickModel.get("length");
    var minorTickLineStyle = defaults$1(lineStyleModel.getLineStyle(), defaults$1(axisModel.getModel("axisTick").getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }));
    for (var i2 = 0; i2 < minorTicksCoords.length; i2++) {
      var minorTicksEls = createTicks(minorTicksCoords[i2], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i2);
      for (var k2 = 0; k2 < minorTicksEls.length; k2++) {
        group.add(minorTicksEls[k2]);
      }
    }
  }
  function buildAxisLabel(group, transformGroup, axisModel, opt) {
    var axis = axisModel.axis;
    var show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
    if (!show || axis.scale.isBlank()) {
      return;
    }
    var labelModel = axisModel.getModel("axisLabel");
    var labelMargin = labelModel.get("margin");
    var labels = axis.getViewLabels();
    var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI / 180;
    var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
    var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
    var labelEls = [];
    var silent = AxisBuilder.isLabelSilent(axisModel);
    var triggerEvent = axisModel.get("triggerEvent");
    each$4(labels, function(labelItem, index2) {
      var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      var formattedLabel = labelItem.formattedLabel;
      var rawLabel = labelItem.rawLabel;
      var itemLabelModel = labelModel;
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
          itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
        }
      }
      var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
      var tickCoord = axis.dataToCoord(tickValue);
      var align = itemLabelModel.getShallow("align", true) || labelLayout.textAlign;
      var alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
      var alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
      var verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign;
      var verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
      var verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
      var textEl = new ZRText({
        x: tickCoord,
        y: opt.labelOffset + opt.labelDirection * labelMargin,
        rotation: labelLayout.rotation,
        silent,
        z2: 10 + (labelItem.level || 0),
        style: createTextStyle$1(itemLabelModel, {
          text: formattedLabel,
          align: index2 === 0 ? alignMin : index2 === labels.length - 1 ? alignMax : align,
          verticalAlign: index2 === 0 ? verticalAlignMin : index2 === labels.length - 1 ? verticalAlignMax : verticalAlign,
          fill: isFunction$1(textColor) ? textColor(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
            index2
          ) : textColor
        })
      });
      textEl.anid = "label_" + tickValue;
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: formattedLabel,
        formatterParamsExtra: {
          isTruncated: function() {
            return textEl.isTruncated;
          },
          value: rawLabel,
          tickIndex: index2
        }
      });
      if (triggerEvent) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisLabel";
        eventData.value = rawLabel;
        eventData.tickIndex = index2;
        if (axis.type === "category") {
          eventData.dataIndex = tickValue;
        }
        getECData(textEl).eventData = eventData;
      }
      transformGroup.add(textEl);
      textEl.updateTransform();
      labelEls.push(textEl);
      group.add(textEl);
      textEl.decomposeTransform();
    });
    return labelEls;
  }
  function collect(ecModel, api2) {
    var result = {
      /**
       * key: makeKey(axis.model)
       * value: {
       *      axis,
       *      coordSys,
       *      axisPointerModel,
       *      triggerTooltip,
       *      triggerEmphasis,
       *      involveSeries,
       *      snap,
       *      seriesModels,
       *      seriesDataCount
       * }
       */
      axesInfo: {},
      seriesInvolved: false,
      /**
       * key: makeKey(coordSys.model)
       * value: Object: key makeKey(axis.model), value: axisInfo
       */
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    collectAxesInfo(result, ecModel, api2);
    result.seriesInvolved && collectSeriesInfo(result, ecModel);
    return result;
  }
  function collectAxesInfo(result, ecModel, api2) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var globalAxisPointerModel = ecModel.getComponent("axisPointer");
    var linksOption = globalAxisPointerModel.get("link", true) || [];
    var linkGroups = [];
    each$4(api2.getCoordinateSystems(), function(coordSys) {
      if (!coordSys.axisPointerEnabled) {
        return;
      }
      var coordSysKey = makeKey(coordSys.model);
      var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
      result.coordSysMap[coordSysKey] = coordSys;
      var coordSysModel = coordSys.model;
      var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
      each$4(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
      if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
        var triggerAxis = baseTooltipModel.get("trigger") === "axis";
        var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
        var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
        if (triggerAxis || cross) {
          each$4(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
        }
        if (cross) {
          each$4(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
        }
      }
      function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
        var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
        var axisPointerShow = axisPointerModel.get("show");
        if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return;
        }
        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get("triggerTooltip");
        }
        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
        var snap = axisPointerModel.get("snap");
        var triggerEmphasis = axisPointerModel.get("triggerEmphasis");
        var axisKey = makeKey(axis.model);
        var involveSeries = triggerTooltip || snap || axis.type === "category";
        var axisInfo = result.axesInfo[axisKey] = {
          key: axisKey,
          axis,
          coordSys,
          axisPointerModel,
          triggerTooltip,
          triggerEmphasis,
          involveSeries,
          snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: [],
          linkGroup: null
        };
        axesInfoInCoordSys[axisKey] = axisInfo;
        result.seriesInvolved = result.seriesInvolved || involveSeries;
        var groupIndex = getLinkGroupIndex(linksOption, axis);
        if (groupIndex != null) {
          var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          });
          linkGroup.axesInfo[axisKey] = axisInfo;
          linkGroup.mapper = linksOption[groupIndex].mapper;
          axisInfo.linkGroup = linkGroup;
        }
      }
    });
  }
  function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
    var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
    var volatileOption = {};
    each$4(fields, function(field) {
      volatileOption[field] = clone$4(tooltipAxisPointerModel.get(field));
    });
    volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
    if (tooltipAxisPointerModel.get("type") === "cross") {
      volatileOption.type = "line";
    }
    var labelOption = volatileOption.label || (volatileOption.label = {});
    labelOption.show == null && (labelOption.show = false);
    if (fromTooltip === "cross") {
      var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
      if (!triggerTooltip) {
        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
        crossStyle && defaults$1(labelOption, crossStyle.textStyle);
      }
    }
    return axis.model.getModel("axisPointer", new Model(volatileOption, globalAxisPointerModel, ecModel));
  }
  function collectSeriesInfo(result, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
      var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
      if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
        return;
      }
      each$4(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
        var axis = axisInfo.axis;
        if (coordSys.getAxis(axis.dim) === axis) {
          axisInfo.seriesModels.push(seriesModel);
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
          axisInfo.seriesDataCount += seriesModel.getData().count();
        }
      });
    });
  }
  function getLinkGroupIndex(linksOption, axis) {
    var axisModel = axis.model;
    var dim = axis.dim;
    for (var i2 = 0; i2 < linksOption.length; i2++) {
      var linkOption = linksOption[i2] || {};
      if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
        return i2;
      }
    }
  }
  function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === "all" || isArray$1(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
  }
  function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    if (!axisInfo) {
      return;
    }
    var axisPointerModel = axisInfo.axisPointerModel;
    var scale2 = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get("status");
    var value = axisPointerModel.get("value");
    if (value != null) {
      value = scale2.parse(value);
    }
    var useHandle = isHandleTrigger(axisPointerModel);
    if (status == null) {
      option.status = useHandle ? "show" : "hide";
    }
    var extent3 = scale2.getExtent().slice();
    extent3[0] > extent3[1] && extent3.reverse();
    if (
      // Pick a value on axis when initializing.
      value == null || value > extent3[1]
    ) {
      value = extent3[1];
    }
    if (value < extent3[0]) {
      value = extent3[0];
    }
    option.value = value;
    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
    }
  }
  function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
  }
  function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
  }
  function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get(["handle", "show"]);
  }
  function makeKey(model) {
    return model.type + "||" + model.id;
  }
  var axisPointerClazz = {};
  var AxisView = (
    /** @class */
    function(_super) {
      __extends(AxisView2, _super);
      function AxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisView2.type;
        return _this;
      }
      AxisView2.prototype.render = function(axisModel, ecModel, api2, payload) {
        this.axisPointerClass && fixValue(axisModel);
        _super.prototype.render.apply(this, arguments);
        this._doUpdateAxisPointerClass(axisModel, api2, true);
      };
      AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api2, payload) {
        this._doUpdateAxisPointerClass(axisModel, api2, false);
      };
      AxisView2.prototype.remove = function(ecModel, api2) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api2);
      };
      AxisView2.prototype.dispose = function(ecModel, api2) {
        this._disposeAxisPointer(api2);
        _super.prototype.dispose.apply(this, arguments);
      };
      AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api2, forceRender) {
        var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
        if (!Clazz) {
          return;
        }
        var axisPointerModel = getAxisPointerModel(axisModel);
        axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api2, forceRender) : this._disposeAxisPointer(api2);
      };
      AxisView2.prototype._disposeAxisPointer = function(api2) {
        this._axisPointer && this._axisPointer.dispose(api2);
        this._axisPointer = null;
      };
      AxisView2.registerAxisPointerClass = function(type, clazz) {
        axisPointerClazz[type] = clazz;
      };
      AxisView2.getAxisPointerClass = function(type) {
        return type && axisPointerClazz[type];
      };
      AxisView2.type = "axis";
      return AxisView2;
    }(ComponentView)
  );
  var inner$3 = makeInner();
  function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    });
    if (!ticksCoords.length) {
      return;
    }
    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = inner$3(axisView).splitAreaColors;
    var newSplitAreaColors = createHashMap();
    var colorIndex = 0;
    if (lastSplitAreaColors) {
      for (var i2 = 0; i2 < ticksCoords.length; i2++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i2].tickValue);
        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i2) % areaColorsLen;
          break;
        }
      }
    }
    var prev2 = axis.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = isArray$1(areaColors) ? areaColors : [areaColors];
    for (var i2 = 1; i2 < ticksCoords.length; i2++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i2].coord);
      var x2 = void 0;
      var y2 = void 0;
      var width = void 0;
      var height = void 0;
      if (axis.isHorizontal()) {
        x2 = prev2;
        y2 = gridRect.y;
        width = tickCoord - x2;
        height = gridRect.height;
        prev2 = x2 + width;
      } else {
        x2 = gridRect.x;
        y2 = prev2;
        width = gridRect.width;
        height = tickCoord - y2;
        prev2 = y2 + height;
      }
      var tickValue = ticksCoords[i2 - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
      axisGroup.add(new Rect({
        anid: tickValue != null ? "area_" + tickValue : null,
        shape: {
          x: x2,
          y: y2,
          width,
          height
        },
        style: defaults$1({
          fill: areaColors[colorIndex]
        }, areaStyle),
        autoBatch: true,
        silent: true
      }));
      colorIndex = (colorIndex + 1) % areaColorsLen;
    }
    inner$3(axisView).splitAreaColors = newSplitAreaColors;
  }
  function rectCoordAxisHandleRemove(axisView) {
    inner$3(axisView).splitAreaColors = null;
  }
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
  var CartesianAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisView2, _super);
      function CartesianAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianAxisView2.type;
        _this.axisPointerClass = "CartesianAxisPointer";
        return _this;
      }
      CartesianAxisView2.prototype.render = function(axisModel, ecModel, api2, payload) {
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new Group$2();
        this.group.add(this._axisGroup);
        if (!axisModel.get("show")) {
          return;
        }
        var gridModel = axisModel.getCoordSysModel();
        var layout$12 = layout(gridModel, axisModel);
        var axisBuilder = new AxisBuilder(axisModel, extend$1({
          handleAutoShown: function(elementType) {
            var cartesians = gridModel.coordinateSystem.getCartesians();
            for (var i2 = 0; i2 < cartesians.length; i2++) {
              if (isIntervalOrLogScale(cartesians[i2].getOtherAxis(axisModel.axis).scale)) {
                return true;
              }
            }
            return false;
          }
        }, layout$12));
        each$4(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this._axisGroup.add(axisBuilder.getGroup());
        each$4(selfBuilderAttrs, function(name) {
          if (axisModel.get([name, "show"])) {
            axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
          }
        }, this);
        var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
        if (!isInitialSortFromBarRacing) {
          groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        }
        _super.prototype.render.call(this, axisModel, ecModel, api2, payload);
      };
      CartesianAxisView2.prototype.remove = function() {
        rectCoordAxisHandleRemove(this);
      };
      CartesianAxisView2.type = "cartesianAxis";
      return CartesianAxisView2;
    }(AxisView)
  );
  var axisElementBuilders = {
    splitLine: function(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var showMinLine = splitLineModel.get("showMinLine") !== false;
      var showMaxLine = splitLineModel.get("showMaxLine") !== false;
      lineColors = isArray$1(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i2 = 0; i2 < ticksCoords.length; i2++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i2].coord);
        if (i2 === 0 && !showMinLine || i2 === ticksCoords.length - 1 && !showMaxLine) {
          continue;
        }
        var tickValue = ticksCoords[i2].tickValue;
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        var line2 = new Line({
          anid: tickValue != null ? "line_" + tickValue : null,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: defaults$1({
            stroke: lineColors[colorIndex]
          }, lineStyle),
          silent: true
        });
        subPixelOptimizeLine(line2.shape, lineStyle.lineWidth);
        axisGroup.add(line2);
      }
    },
    minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      var minorSplitLineModel = axisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var minorTicksCoords = axis.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i2 = 0; i2 < minorTicksCoords.length; i2++) {
        for (var k2 = 0; k2 < minorTicksCoords[i2].length; k2++) {
          var tickCoord = axis.toGlobalCoord(minorTicksCoords[i2][k2].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var line2 = new Line({
            anid: "minor_line_" + minorTicksCoords[i2][k2].tickValue,
            autoBatch: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle,
            silent: true
          });
          subPixelOptimizeLine(line2.shape, lineStyle.lineWidth);
          axisGroup.add(line2);
        }
      }
    },
    splitArea: function(axisView, axisGroup, axisModel, gridModel) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
    }
  };
  var CartesianXAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianXAxisView2, _super);
      function CartesianXAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianXAxisView2.type;
        return _this;
      }
      CartesianXAxisView2.type = "xAxis";
      return CartesianXAxisView2;
    }(CartesianAxisView)
  );
  var CartesianYAxisView = (
    /** @class */
    function(_super) {
      __extends(CartesianYAxisView2, _super);
      function CartesianYAxisView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CartesianXAxisView.type;
        return _this;
      }
      CartesianYAxisView2.type = "yAxis";
      return CartesianYAxisView2;
    }(CartesianAxisView)
  );
  var GridView = (
    /** @class */
    function(_super) {
      __extends(GridView2, _super);
      function GridView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "grid";
        return _this;
      }
      GridView2.prototype.render = function(gridModel, ecModel) {
        this.group.removeAll();
        if (gridModel.get("show")) {
          this.group.add(new Rect({
            shape: gridModel.coordinateSystem.getRect(),
            style: defaults$1({
              fill: gridModel.get("backgroundColor")
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }));
        }
      };
      GridView2.type = "grid";
      return GridView2;
    }(ComponentView)
  );
  var extraOption = {
    // gridIndex: 0,
    // gridId: '',
    offset: 0
  };
  function install$d(registers) {
    registers.registerComponentView(GridView);
    registers.registerComponentModel(GridModel);
    registers.registerCoordinateSystem("cartesian2d", Grid);
    axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
    axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
    registers.registerComponentView(CartesianXAxisView);
    registers.registerComponentView(CartesianYAxisView);
    registers.registerPreprocessor(function(option) {
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });
  }
  var PointerShape = (
    /** @class */
    /* @__PURE__ */ function() {
      function PointerShape2() {
        this.angle = 0;
        this.width = 10;
        this.r = 10;
        this.x = 0;
        this.y = 0;
      }
      return PointerShape2;
    }()
  );
  var PointerPath = (
    /** @class */
    function(_super) {
      __extends(PointerPath2, _super);
      function PointerPath2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.type = "pointer";
        return _this;
      }
      PointerPath2.prototype.getDefaultShape = function() {
        return new PointerShape();
      };
      PointerPath2.prototype.buildPath = function(ctx, shape) {
        var mathCos2 = Math.cos;
        var mathSin2 = Math.sin;
        var r2 = shape.r;
        var width = shape.width;
        var angle = shape.angle;
        var x2 = shape.x - mathCos2(angle) * width * (width >= r2 / 3 ? 1 : 2);
        var y2 = shape.y - mathSin2(angle) * width * (width >= r2 / 3 ? 1 : 2);
        angle = shape.angle - Math.PI / 2;
        ctx.moveTo(x2, y2);
        ctx.lineTo(shape.x + mathCos2(angle) * width, shape.y + mathSin2(angle) * width);
        ctx.lineTo(shape.x + mathCos2(shape.angle) * r2, shape.y + mathSin2(shape.angle) * r2);
        ctx.lineTo(shape.x - mathCos2(angle) * width, shape.y - mathSin2(angle) * width);
        ctx.lineTo(x2, y2);
      };
      return PointerPath2;
    }(Path)
  );
  function parsePosition(seriesModel, api2) {
    var center2 = seriesModel.get("center");
    var width = api2.getWidth();
    var height = api2.getHeight();
    var size = Math.min(width, height);
    var cx = parsePercent(center2[0], api2.getWidth());
    var cy = parsePercent(center2[1], api2.getHeight());
    var r2 = parsePercent(seriesModel.get("radius"), size / 2);
    return {
      cx,
      cy,
      r: r2
    };
  }
  function formatLabel(value, labelFormatter) {
    var label = value == null ? "" : value + "";
    if (labelFormatter) {
      if (isString$1(labelFormatter)) {
        label = labelFormatter.replace("{value}", label);
      } else if (isFunction$1(labelFormatter)) {
        label = labelFormatter(value);
      }
    }
    return label;
  }
  var GaugeView = (
    /** @class */
    function(_super) {
      __extends(GaugeView2, _super);
      function GaugeView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = GaugeView2.type;
        return _this;
      }
      GaugeView2.prototype.render = function(seriesModel, ecModel, api2) {
        this.group.removeAll();
        var colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
        var posInfo = parsePosition(seriesModel, api2);
        this._renderMain(seriesModel, ecModel, api2, colorList, posInfo);
        this._data = seriesModel.getData();
      };
      GaugeView2.prototype.dispose = function() {
      };
      GaugeView2.prototype._renderMain = function(seriesModel, ecModel, api2, colorList, posInfo) {
        var group = this.group;
        var clockwise = seriesModel.get("clockwise");
        var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
        var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
        var axisLineModel = seriesModel.getModel("axisLine");
        var roundCap = axisLineModel.get("roundCap");
        var MainPath = roundCap ? SausagePath : Sector;
        var showAxis = axisLineModel.get("show");
        var lineStyleModel = axisLineModel.getModel("lineStyle");
        var axisLineWidth = lineStyleModel.get("width");
        var angles = [startAngle, endAngle];
        normalizeArcAngles(angles, !clockwise);
        startAngle = angles[0];
        endAngle = angles[1];
        var angleRangeSpan = endAngle - startAngle;
        var prevEndAngle = startAngle;
        var sectors = [];
        for (var i2 = 0; showAxis && i2 < colorList.length; i2++) {
          var percent = Math.min(Math.max(colorList[i2][0], 0), 1);
          endAngle = startAngle + angleRangeSpan * percent;
          var sector = new MainPath({
            shape: {
              startAngle: prevEndAngle,
              endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise,
              r0: posInfo.r - axisLineWidth,
              r: posInfo.r
            },
            silent: true
          });
          sector.setStyle({
            fill: colorList[i2][1]
          });
          sector.setStyle(lineStyleModel.getLineStyle(
            // Because we use sector to simulate arc
            // so the properties for stroking are useless
            ["color", "width"]
          ));
          sectors.push(sector);
          prevEndAngle = endAngle;
        }
        sectors.reverse();
        each$4(sectors, function(sector2) {
          return group.add(sector2);
        });
        var getColor = function(percent2) {
          if (percent2 <= 0) {
            return colorList[0][1];
          }
          var i3;
          for (i3 = 0; i3 < colorList.length; i3++) {
            if (colorList[i3][0] >= percent2 && (i3 === 0 ? 0 : colorList[i3 - 1][0]) < percent2) {
              return colorList[i3][1];
            }
          }
          return colorList[i3 - 1][1];
        };
        this._renderTicks(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
        this._renderTitleAndDetail(seriesModel, ecModel, api2, getColor, posInfo);
        this._renderAnchor(seriesModel, posInfo);
        this._renderPointer(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
      };
      GaugeView2.prototype._renderTicks = function(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
        var group = this.group;
        var cx = posInfo.cx;
        var cy = posInfo.cy;
        var r2 = posInfo.r;
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var splitLineModel = seriesModel.getModel("splitLine");
        var tickModel = seriesModel.getModel("axisTick");
        var labelModel = seriesModel.getModel("axisLabel");
        var splitNumber = seriesModel.get("splitNumber");
        var subSplitNumber = tickModel.get("splitNumber");
        var splitLineLen = parsePercent(splitLineModel.get("length"), r2);
        var tickLen = parsePercent(tickModel.get("length"), r2);
        var angle = startAngle;
        var step = (endAngle - startAngle) / splitNumber;
        var subStep = step / subSplitNumber;
        var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
        var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
        var splitLineDistance = splitLineModel.get("distance");
        var unitX;
        var unitY;
        for (var i2 = 0; i2 <= splitNumber; i2++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          if (splitLineModel.get("show")) {
            var distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
            var splitLine = new Line({
              shape: {
                x1: unitX * (r2 - distance2) + cx,
                y1: unitY * (r2 - distance2) + cy,
                x2: unitX * (r2 - splitLineLen - distance2) + cx,
                y2: unitY * (r2 - splitLineLen - distance2) + cy
              },
              style: splitLineStyle,
              silent: true
            });
            if (splitLineStyle.stroke === "auto") {
              splitLine.setStyle({
                stroke: getColor(i2 / splitNumber)
              });
            }
            group.add(splitLine);
          }
          if (labelModel.get("show")) {
            var distance2 = labelModel.get("distance") + splitLineDistance;
            var label = formatLabel(round$1(i2 / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
            var autoColor = getColor(i2 / splitNumber);
            var textStyleX = unitX * (r2 - splitLineLen - distance2) + cx;
            var textStyleY = unitY * (r2 - splitLineLen - distance2) + cy;
            var rotateType = labelModel.get("rotate");
            var rotate2 = 0;
            if (rotateType === "radial") {
              rotate2 = -angle + 2 * Math.PI;
              if (rotate2 > Math.PI / 2) {
                rotate2 += Math.PI;
              }
            } else if (rotateType === "tangential") {
              rotate2 = -angle - Math.PI / 2;
            } else if (isNumber$1(rotateType)) {
              rotate2 = rotateType * Math.PI / 180;
            }
            if (rotate2 === 0) {
              group.add(new ZRText({
                style: createTextStyle$1(labelModel, {
                  text: label,
                  x: textStyleX,
                  y: textStyleY,
                  verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
                  align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
                }, {
                  inheritColor: autoColor
                }),
                silent: true
              }));
            } else {
              group.add(new ZRText({
                style: createTextStyle$1(labelModel, {
                  text: label,
                  x: textStyleX,
                  y: textStyleY,
                  verticalAlign: "middle",
                  align: "center"
                }, {
                  inheritColor: autoColor
                }),
                silent: true,
                originX: textStyleX,
                originY: textStyleY,
                rotation: rotate2
              }));
            }
          }
          if (tickModel.get("show") && i2 !== splitNumber) {
            var distance2 = tickModel.get("distance");
            distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
            for (var j2 = 0; j2 <= subSplitNumber; j2++) {
              unitX = Math.cos(angle);
              unitY = Math.sin(angle);
              var tickLine = new Line({
                shape: {
                  x1: unitX * (r2 - distance2) + cx,
                  y1: unitY * (r2 - distance2) + cy,
                  x2: unitX * (r2 - tickLen - distance2) + cx,
                  y2: unitY * (r2 - tickLen - distance2) + cy
                },
                silent: true,
                style: tickLineStyle
              });
              if (tickLineStyle.stroke === "auto") {
                tickLine.setStyle({
                  stroke: getColor((i2 + j2 / subSplitNumber) / splitNumber)
                });
              }
              group.add(tickLine);
              angle += subStep;
            }
            angle -= subStep;
          } else {
            angle += step;
          }
        }
      };
      GaugeView2.prototype._renderPointer = function(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
        var group = this.group;
        var oldData = this._data;
        var oldProgressData = this._progressEls;
        var progressList = [];
        var showPointer2 = seriesModel.get(["pointer", "show"]);
        var progressModel = seriesModel.getModel("progress");
        var showProgress = progressModel.get("show");
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var valueExtent = [minVal, maxVal];
        var angleExtent = [startAngle, endAngle];
        function createPointer(idx, angle) {
          var itemModel = data.getItemModel(idx);
          var pointerModel = itemModel.getModel("pointer");
          var pointerWidth = parsePercent(pointerModel.get("width"), posInfo.r);
          var pointerLength = parsePercent(pointerModel.get("length"), posInfo.r);
          var pointerStr = seriesModel.get(["pointer", "icon"]);
          var pointerOffset = pointerModel.get("offsetCenter");
          var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);
          var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);
          var pointerKeepAspect = pointerModel.get("keepAspect");
          var pointer;
          if (pointerStr) {
            pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
          } else {
            pointer = new PointerPath({
              shape: {
                angle: -Math.PI / 2,
                width: pointerWidth,
                r: pointerLength,
                x: pointerOffsetX,
                y: pointerOffsetY
              }
            });
          }
          pointer.rotation = -(angle + Math.PI / 2);
          pointer.x = posInfo.cx;
          pointer.y = posInfo.cy;
          return pointer;
        }
        function createProgress(idx, endAngle2) {
          var roundCap = progressModel.get("roundCap");
          var ProgressPath = roundCap ? SausagePath : Sector;
          var isOverlap = progressModel.get("overlap");
          var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
          var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
          var r2 = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
          var progress = new ProgressPath({
            shape: {
              startAngle,
              endAngle: endAngle2,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise,
              r0,
              r: r2
            }
          });
          isOverlap && (progress.z2 = linearMap(data.get(valueDim, idx), [minVal, maxVal], [100, 0], true));
          return progress;
        }
        if (showProgress || showPointer2) {
          data.diff(oldData).add(function(idx) {
            var val = data.get(valueDim, idx);
            if (showPointer2) {
              var pointer = createPointer(idx, startAngle);
              initProps(pointer, {
                rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
              }, seriesModel);
              group.add(pointer);
              data.setItemGraphicEl(idx, pointer);
            }
            if (showProgress) {
              var progress = createProgress(idx, startAngle);
              var isClip = progressModel.get("clip");
              initProps(progress, {
                shape: {
                  endAngle: linearMap(val, valueExtent, angleExtent, isClip)
                }
              }, seriesModel);
              group.add(progress);
              setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
              progressList[idx] = progress;
            }
          }).update(function(newIdx, oldIdx) {
            var val = data.get(valueDim, newIdx);
            if (showPointer2) {
              var previousPointer = oldData.getItemGraphicEl(oldIdx);
              var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
              var pointer = createPointer(newIdx, previousRotate);
              pointer.rotation = previousRotate;
              updateProps$1(pointer, {
                rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
              }, seriesModel);
              group.add(pointer);
              data.setItemGraphicEl(newIdx, pointer);
            }
            if (showProgress) {
              var previousProgress = oldProgressData[oldIdx];
              var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
              var progress = createProgress(newIdx, previousEndAngle);
              var isClip = progressModel.get("clip");
              updateProps$1(progress, {
                shape: {
                  endAngle: linearMap(val, valueExtent, angleExtent, isClip)
                }
              }, seriesModel);
              group.add(progress);
              setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
              progressList[newIdx] = progress;
            }
          }).execute();
          data.each(function(idx) {
            var itemModel = data.getItemModel(idx);
            var emphasisModel = itemModel.getModel("emphasis");
            var focus = emphasisModel.get("focus");
            var blurScope = emphasisModel.get("blurScope");
            var emphasisDisabled = emphasisModel.get("disabled");
            if (showPointer2) {
              var pointer = data.getItemGraphicEl(idx);
              var symbolStyle = data.getItemVisual(idx, "style");
              var visualColor = symbolStyle.fill;
              if (pointer instanceof ZRImage) {
                var pathStyle = pointer.style;
                pointer.useStyle(extend$1({
                  image: pathStyle.image,
                  x: pathStyle.x,
                  y: pathStyle.y,
                  width: pathStyle.width,
                  height: pathStyle.height
                }, symbolStyle));
              } else {
                pointer.useStyle(symbolStyle);
                pointer.type !== "pointer" && pointer.setColor(visualColor);
              }
              pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
              if (pointer.style.fill === "auto") {
                pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
              }
              pointer.z2EmphasisLift = 0;
              setStatesStylesFromModel(pointer, itemModel);
              toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
            }
            if (showProgress) {
              var progress = progressList[idx];
              progress.useStyle(data.getItemVisual(idx, "style"));
              progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
              progress.z2EmphasisLift = 0;
              setStatesStylesFromModel(progress, itemModel);
              toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
            }
          });
          this._progressEls = progressList;
        }
      };
      GaugeView2.prototype._renderAnchor = function(seriesModel, posInfo) {
        var anchorModel = seriesModel.getModel("anchor");
        var showAnchor = anchorModel.get("show");
        if (showAnchor) {
          var anchorSize = anchorModel.get("size");
          var anchorType = anchorModel.get("icon");
          var offsetCenter = anchorModel.get("offsetCenter");
          var anchorKeepAspect = anchorModel.get("keepAspect");
          var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
          anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
          anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
          this.group.add(anchor);
        }
      };
      GaugeView2.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api2, getColor, posInfo) {
        var _this = this;
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var contentGroup = new Group$2();
        var newTitleEls = [];
        var newDetailEls = [];
        var hasAnimation = seriesModel.isAnimationEnabled();
        var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
        data.diff(this._data).add(function(idx) {
          newTitleEls[idx] = new ZRText({
            silent: true
          });
          newDetailEls[idx] = new ZRText({
            silent: true
          });
        }).update(function(idx, oldIdx) {
          newTitleEls[idx] = _this._titleEls[oldIdx];
          newDetailEls[idx] = _this._detailEls[oldIdx];
        }).execute();
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          var value = data.get(valueDim, idx);
          var itemGroup = new Group$2();
          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
          var itemTitleModel = itemModel.getModel("title");
          if (itemTitleModel.get("show")) {
            var titleOffsetCenter = itemTitleModel.get("offsetCenter");
            var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);
            var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);
            var labelEl = newTitleEls[idx];
            labelEl.attr({
              z2: showPointerAbove ? 0 : 2,
              style: createTextStyle$1(itemTitleModel, {
                x: titleX,
                y: titleY,
                text: data.getName(idx),
                align: "center",
                verticalAlign: "middle"
              }, {
                inheritColor: autoColor
              })
            });
            itemGroup.add(labelEl);
          }
          var itemDetailModel = itemModel.getModel("detail");
          if (itemDetailModel.get("show")) {
            var detailOffsetCenter = itemDetailModel.get("offsetCenter");
            var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);
            var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);
            var width = parsePercent(itemDetailModel.get("width"), posInfo.r);
            var height = parsePercent(itemDetailModel.get("height"), posInfo.r);
            var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
            var labelEl = newDetailEls[idx];
            var formatter_1 = itemDetailModel.get("formatter");
            labelEl.attr({
              z2: showPointerAbove ? 0 : 2,
              style: createTextStyle$1(itemDetailModel, {
                x: detailX,
                y: detailY,
                text: formatLabel(value, formatter_1),
                width: isNaN(width) ? null : width,
                height: isNaN(height) ? null : height,
                align: "center",
                verticalAlign: "middle"
              }, {
                inheritColor: detailColor
              })
            });
            setLabelValueAnimation(labelEl, {
              normal: itemDetailModel
            }, value, function(value2) {
              return formatLabel(value2, formatter_1);
            });
            hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
              getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
                return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
              }
            });
            itemGroup.add(labelEl);
          }
          contentGroup.add(itemGroup);
        });
        this.group.add(contentGroup);
        this._titleEls = newTitleEls;
        this._detailEls = newDetailEls;
      };
      GaugeView2.type = "gauge";
      return GaugeView2;
    }(ChartView)
  );
  var GaugeSeriesModel = (
    /** @class */
    function(_super) {
      __extends(GaugeSeriesModel2, _super);
      function GaugeSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = GaugeSeriesModel2.type;
        _this.visualStyleAccessPath = "itemStyle";
        return _this;
      }
      GaugeSeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return createSeriesDataSimply(this, ["value"]);
      };
      GaugeSeriesModel2.type = "series.gauge";
      GaugeSeriesModel2.defaultOption = {
        // zlevel: 0,
        z: 2,
        colorBy: "data",
        // 默认全局居中
        center: ["50%", "50%"],
        legendHoverLink: true,
        radius: "75%",
        startAngle: 225,
        endAngle: -45,
        clockwise: true,
        // 最小值
        min: 0,
        // 最大值
        max: 100,
        // 分割段数，默认为10
        splitNumber: 10,
        // 坐标轴线
        axisLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          roundCap: false,
          lineStyle: {
            color: [[1, "#E6EBF8"]],
            width: 10
          }
        },
        // 坐标轴线
        progress: {
          // 默认显示，属性show控制显示与否
          show: false,
          overlap: true,
          width: 10,
          roundCap: false,
          clip: true
        },
        // 分隔线
        splitLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          // 属性length控制线长
          length: 10,
          distance: 10,
          // 属性lineStyle（详见lineStyle）控制线条样式
          lineStyle: {
            color: "#63677A",
            width: 3,
            type: "solid"
          }
        },
        // 坐标轴小标记
        axisTick: {
          // 属性show控制显示与否，默认不显示
          show: true,
          // 每份split细分多少段
          splitNumber: 5,
          // 属性length控制线长
          length: 6,
          distance: 10,
          // 属性lineStyle控制线条样式
          lineStyle: {
            color: "#63677A",
            width: 1,
            type: "solid"
          }
        },
        axisLabel: {
          show: true,
          distance: 15,
          // formatter: null,
          color: "#464646",
          fontSize: 12,
          rotate: 0
        },
        pointer: {
          icon: null,
          offsetCenter: [0, 0],
          show: true,
          showAbove: true,
          length: "60%",
          width: 6,
          keepAspect: false
        },
        anchor: {
          show: false,
          showAbove: false,
          size: 6,
          icon: "circle",
          offsetCenter: [0, 0],
          keepAspect: false,
          itemStyle: {
            color: "#fff",
            borderWidth: 0,
            borderColor: "#5470c6"
          }
        },
        title: {
          show: true,
          // x, y，单位px
          offsetCenter: [0, "20%"],
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#464646",
          fontSize: 16,
          valueAnimation: false
        },
        detail: {
          show: true,
          backgroundColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          borderColor: "#ccc",
          width: 100,
          height: null,
          padding: [5, 10],
          // x, y，单位px
          offsetCenter: [0, "40%"],
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#464646",
          fontSize: 30,
          fontWeight: "bold",
          lineHeight: 30,
          valueAnimation: false
        }
      };
      return GaugeSeriesModel2;
    }(SeriesModel)
  );
  function install$c(registers) {
    registers.registerChartView(GaugeView);
    registers.registerSeriesModel(GaugeSeriesModel);
  }
  var STYLE_VISUAL_TYPE = {
    color: "fill",
    borderColor: "stroke"
  };
  var NON_STYLE_VISUAL_PROPS = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  };
  var customInnerStore = makeInner();
  var CustomSeriesModel = (
    /** @class */
    function(_super) {
      __extends(CustomSeriesModel2, _super);
      function CustomSeriesModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CustomSeriesModel2.type;
        return _this;
      }
      CustomSeriesModel2.prototype.optionUpdated = function() {
        this.currentZLevel = this.get("zlevel", true);
        this.currentZ = this.get("z", true);
      };
      CustomSeriesModel2.prototype.getInitialData = function(option, ecModel) {
        return createSeriesData(null, this);
      };
      CustomSeriesModel2.prototype.getDataParams = function(dataIndex, dataType, el) {
        var params2 = _super.prototype.getDataParams.call(this, dataIndex, dataType);
        el && (params2.info = customInnerStore(el).info);
        return params2;
      };
      CustomSeriesModel2.type = "series.custom";
      CustomSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
      CustomSeriesModel2.defaultOption = {
        coordinateSystem: "cartesian2d",
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        // Custom series will not clip by default.
        // Some case will use custom series to draw label
        // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
        clip: false
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
      };
      return CustomSeriesModel2;
    }(SeriesModel)
  );
  function dataToCoordSize$3(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map$1(["x", "y"], function(dim, dimIdx) {
      var axis = this.getAxis(dim);
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    }, this);
  }
  function cartesianPrepareCustom(coordSys) {
    var rect = coordSys.master.getRect();
    return {
      coordSys: {
        // The name exposed to user is always 'cartesian2d' but not 'grid'.
        type: "cartesian2d",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: bind$2(dataToCoordSize$3, coordSys)
      }
    };
  }
  function dataToCoordSize$2(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map$1([0, 1], function(dimIdx) {
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var p1 = [];
      var p2 = [];
      p1[dimIdx] = val - halfSize;
      p2[dimIdx] = val + halfSize;
      p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
      return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
    }, this);
  }
  function geoPrepareCustom(coordSys) {
    var rect = coordSys.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        zoom: coordSys.getZoom()
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: bind$2(dataToCoordSize$2, coordSys)
      }
    };
  }
  function dataToCoordSize$1(dataSize, dataItem) {
    var axis = this.getAxis();
    var val = dataItem instanceof Array ? dataItem[0] : dataItem;
    var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }
  function singlePrepareCustom(coordSys) {
    var rect = coordSys.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(val) {
          return coordSys.dataToPoint(val);
        },
        size: bind$2(dataToCoordSize$1, coordSys)
      }
    };
  }
  function dataToCoordSize(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map$1(["Radius", "Angle"], function(dim, dimIdx) {
      var getterName = "get" + dim + "Axis";
      var axis = this[getterName]();
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
      if (dim === "Angle") {
        result = result * Math.PI / 180;
      }
      return result;
    }, this);
  }
  function polarPrepareCustom(coordSys) {
    var radiusAxis = coordSys.getRadiusAxis();
    var angleAxis = coordSys.getAngleAxis();
    var radius = radiusAxis.getExtent();
    radius[0] > radius[1] && radius.reverse();
    return {
      coordSys: {
        type: "polar",
        cx: coordSys.cx,
        cy: coordSys.cy,
        r: radius[1],
        r0: radius[0]
      },
      api: {
        coord: function(data) {
          var radius2 = radiusAxis.dataToRadius(data[0]);
          var angle = angleAxis.dataToAngle(data[1]);
          var coord = coordSys.coordToPoint([radius2, angle]);
          coord.push(radius2, angle * Math.PI / 180);
          return coord;
        },
        size: bind$2(dataToCoordSize, coordSys)
      }
    };
  }
  function calendarPrepareCustom(coordSys) {
    var rect = coordSys.getRect();
    var rangeInfo = coordSys.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        cellWidth: coordSys.getCellWidth(),
        cellHeight: coordSys.getCellHeight(),
        rangeInfo: {
          start: rangeInfo.start,
          end: rangeInfo.end,
          weeks: rangeInfo.weeks,
          dayCount: rangeInfo.allDay
        }
      },
      api: {
        coord: function(data, clamp2) {
          return coordSys.dataToPoint(data, clamp2);
        }
      }
    };
  }
  function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
    return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
  }
  function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
    var srcStyle = hostStyle;
    var textConfig;
    var textContent;
    var textContentStyle;
    if (elType === "text") {
      textContentStyle = srcStyle;
    } else {
      textContentStyle = {};
      hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
      hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
      hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
      hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
      hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
      hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
      hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
      hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
      textContent = {
        type: "text",
        style: textContentStyle,
        // ec4 does not support rectText trigger.
        // And when text position is different in normal and emphasis
        // => hover text trigger emphasis;
        // => text position changed, leave mouse pointer immediately;
        // That might cause incorrect state.
        silent: true
      };
      textConfig = {};
      var hasOwnPos = hasOwn(srcStyle, "textPosition");
      if (isNormal) {
        textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
      } else {
        hasOwnPos && (textConfig.position = srcStyle.textPosition);
      }
      hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
      hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
      hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
      hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
    }
    convertEC4CompatibleRichItem(textContentStyle, hostStyle);
    each$4(textContentStyle.rich, function(richItem) {
      convertEC4CompatibleRichItem(richItem, richItem);
    });
    return {
      textConfig,
      textContent
    };
  }
  function convertEC4CompatibleRichItem(out2, richItem) {
    if (!richItem) {
      return;
    }
    richItem.font = richItem.textFont || richItem.font;
    hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
    hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
    hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
    hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
    hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
    hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
    hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
    hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
    hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
    hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
    hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
    hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
    hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
    hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
    hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
  }
  function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
    var out2 = itemStl;
    out2.textPosition = out2.textPosition || txCfg.position || "inside";
    txCfg.offset != null && (out2.textOffset = txCfg.offset);
    txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
    txCfg.distance != null && (out2.textDistance = txCfg.distance);
    var isInside = out2.textPosition.indexOf("inside") >= 0;
    var hostFill = itemStl.fill || "#000";
    convertToEC4RichItem(out2, txStl);
    var textFillNotSet = out2.textFill == null;
    if (isInside) {
      if (textFillNotSet) {
        out2.textFill = txCfg.insideFill || "#fff";
        !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
        !out2.textStroke && (out2.textStroke = hostFill);
        out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
      }
    } else {
      if (textFillNotSet) {
        out2.textFill = itemStl.fill || txCfg.outsideFill || "#000";
      }
      !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
    }
    out2.text = txStl.text;
    out2.rich = txStl.rich;
    each$4(txStl.rich, function(richItem) {
      convertToEC4RichItem(richItem, richItem);
    });
    return out2;
  }
  function convertToEC4RichItem(out2, richItem) {
    if (!richItem) {
      return;
    }
    hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
    hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
    hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
    hasOwn(richItem, "font") && (out2.font = richItem.font);
    hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
    hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
    hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
    hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
    hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
    hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
    hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
    hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
    hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
    hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
    hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
    hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
    hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
    hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
    hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
    hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
    hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
    hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
    hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
    hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
    hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
    hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
  }
  var LEGACY_TRANSFORM_PROPS_MAP = {
    position: ["x", "y"],
    scale: ["scaleX", "scaleY"],
    origin: ["originX", "originY"]
  };
  var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
  reduce(TRANSFORMABLE_PROPS, function(obj2, key2) {
    obj2[key2] = 1;
    return obj2;
  }, {});
  TRANSFORMABLE_PROPS.join(", ");
  var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
  var transitionInnerStore = makeInner();
  function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
    var animationProp = animationType + "Animation";
    var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
    var userDuring = transitionInnerStore(el).userDuring;
    if (config.duration > 0) {
      config.during = userDuring ? bind$2(duringCall, {
        el,
        userDuring
      }) : null;
      config.setToFinal = true;
      config.scope = animationType;
    }
    extend$1(config, elOption[animationProp]);
    return config;
  }
  function applyUpdateTransition(el, elOption, animatableModel, opts) {
    opts = opts || {};
    var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
    var hasAnimation = animatableModel.isAnimationEnabled();
    var store = transitionInnerStore(el);
    var styleOpt = elOption.style;
    store.userDuring = elOption.during;
    var transFromProps = {};
    var propsToSet = {};
    prepareTransformAllPropsFinal(el, elOption, propsToSet);
    prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
    prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
    if (!isInit && hasAnimation) {
      prepareTransformTransitionFrom(el, elOption, transFromProps);
      prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
      prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
      prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
    }
    propsToSet.style = styleOpt;
    applyPropsDirectly(el, propsToSet, clearStyle);
    applyMiscProps(el, elOption);
    if (hasAnimation) {
      if (isInit) {
        var enterFromProps_1 = {};
        each$4(ELEMENT_ANIMATABLE_PROPS, function(propName) {
          var prop = propName ? elOption[propName] : elOption;
          if (prop && prop.enterFrom) {
            if (propName) {
              enterFromProps_1[propName] = enterFromProps_1[propName] || {};
            }
            extend$1(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
          }
        });
        var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
        if (config.duration > 0) {
          el.animateFrom(enterFromProps_1, config);
        }
      } else {
        applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
      }
    }
    updateLeaveTo(el, elOption);
    styleOpt ? el.dirty() : el.markRedraw();
  }
  function updateLeaveTo(el, elOption) {
    var leaveToProps = transitionInnerStore(el).leaveToProps;
    for (var i2 = 0; i2 < ELEMENT_ANIMATABLE_PROPS.length; i2++) {
      var propName = ELEMENT_ANIMATABLE_PROPS[i2];
      var prop = propName ? elOption[propName] : elOption;
      if (prop && prop.leaveTo) {
        if (!leaveToProps) {
          leaveToProps = transitionInnerStore(el).leaveToProps = {};
        }
        if (propName) {
          leaveToProps[propName] = leaveToProps[propName] || {};
        }
        extend$1(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
      }
    }
  }
  function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
    if (el) {
      var parent_1 = el.parent;
      var leaveToProps = transitionInnerStore(el).leaveToProps;
      if (leaveToProps) {
        var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
        config.done = function() {
          parent_1.remove(el);
        };
        el.animateTo(leaveToProps, config);
      } else {
        parent_1.remove(el);
      }
    }
  }
  function isTransitionAll(transition) {
    return transition === "all";
  }
  function applyPropsDirectly(el, allPropsFinal, clearStyle) {
    var styleOpt = allPropsFinal.style;
    if (!el.isGroup && styleOpt) {
      if (clearStyle) {
        el.useStyle({});
        var animators = el.animators;
        for (var i2 = 0; i2 < animators.length; i2++) {
          var animator = animators[i2];
          if (animator.targetName === "style") {
            animator.changeTarget(el.style);
          }
        }
      }
      el.setStyle(styleOpt);
    }
    if (allPropsFinal) {
      allPropsFinal.style = null;
      allPropsFinal && el.attr(allPropsFinal);
      allPropsFinal.style = styleOpt;
    }
  }
  function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
    if (transFromProps) {
      var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(transFromProps, config);
      }
    }
  }
  function applyMiscProps(el, elOption) {
    hasOwn(elOption, "silent") && (el.silent = elOption.silent);
    hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
    if (el instanceof Displayable) {
      hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
    }
    if (el instanceof Path) {
      hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
    }
  }
  var tmpDuringScope = {};
  var transitionDuringAPI = {
    // Usually other props do not need to be changed in animation during.
    setTransform: function(key2, val) {
      tmpDuringScope.el[key2] = val;
      return this;
    },
    getTransform: function(key2) {
      return tmpDuringScope.el[key2];
    },
    setShape: function(key2, val) {
      var el = tmpDuringScope.el;
      var shape = el.shape || (el.shape = {});
      shape[key2] = val;
      el.dirtyShape && el.dirtyShape();
      return this;
    },
    getShape: function(key2) {
      var shape = tmpDuringScope.el.shape;
      if (shape) {
        return shape[key2];
      }
    },
    setStyle: function(key2, val) {
      var el = tmpDuringScope.el;
      var style = el.style;
      if (style) {
        style[key2] = val;
        el.dirtyStyle && el.dirtyStyle();
      }
      return this;
    },
    getStyle: function(key2) {
      var style = tmpDuringScope.el.style;
      if (style) {
        return style[key2];
      }
    },
    setExtra: function(key2, val) {
      var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
      extra[key2] = val;
      return this;
    },
    getExtra: function(key2) {
      var extra = tmpDuringScope.el.extra;
      if (extra) {
        return extra[key2];
      }
    }
  };
  function duringCall() {
    var scope = this;
    var el = scope.el;
    if (!el) {
      return;
    }
    var latestUserDuring = transitionInnerStore(el).userDuring;
    var scopeUserDuring = scope.userDuring;
    if (latestUserDuring !== scopeUserDuring) {
      scope.el = scope.userDuring = null;
      return;
    }
    tmpDuringScope.el = el;
    scopeUserDuring(transitionDuringAPI);
  }
  function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
    var attrOpt = elOption[mainAttr];
    if (!attrOpt) {
      return;
    }
    var elPropsInAttr = fromEl[mainAttr];
    var transFromPropsInAttr;
    if (elPropsInAttr) {
      var transition = elOption.transition;
      var attrTransition = attrOpt.transition;
      if (attrTransition) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
        if (isTransitionAll(attrTransition)) {
          extend$1(transFromPropsInAttr, elPropsInAttr);
        } else {
          var transitionKeys2 = normalizeToArray(attrTransition);
          for (var i2 = 0; i2 < transitionKeys2.length; i2++) {
            var key2 = transitionKeys2[i2];
            var elVal = elPropsInAttr[key2];
            transFromPropsInAttr[key2] = elVal;
          }
        }
      } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
        var elPropsInAttrKeys = keys(elPropsInAttr);
        for (var i2 = 0; i2 < elPropsInAttrKeys.length; i2++) {
          var key2 = elPropsInAttrKeys[i2];
          var elVal = elPropsInAttr[key2];
          if (isNonStyleTransitionEnabled(attrOpt[key2], elVal)) {
            transFromPropsInAttr[key2] = elVal;
          }
        }
      }
    }
  }
  function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
    var attrOpt = elOption[mainAttr];
    if (!attrOpt) {
      return;
    }
    var allPropsInAttr = allProps[mainAttr] = {};
    var keysInAttr = keys(attrOpt);
    for (var i2 = 0; i2 < keysInAttr.length; i2++) {
      var key2 = keysInAttr[i2];
      allPropsInAttr[key2] = cloneValue(attrOpt[key2]);
    }
  }
  function prepareTransformTransitionFrom(el, elOption, transFromProps) {
    var transition = elOption.transition;
    var transitionKeys2 = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
    for (var i2 = 0; i2 < transitionKeys2.length; i2++) {
      var key2 = transitionKeys2[i2];
      if (key2 === "style" || key2 === "shape" || key2 === "extra") {
        continue;
      }
      var elVal = el[key2];
      transFromProps[key2] = elVal;
    }
  }
  function prepareTransformAllPropsFinal(el, elOption, allProps) {
    for (var i2 = 0; i2 < LEGACY_TRANSFORM_PROPS.length; i2++) {
      var legacyName = LEGACY_TRANSFORM_PROPS[i2];
      var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
      var legacyArr = elOption[legacyName];
      if (legacyArr) {
        allProps[xyName[0]] = legacyArr[0];
        allProps[xyName[1]] = legacyArr[1];
      }
    }
    for (var i2 = 0; i2 < TRANSFORMABLE_PROPS.length; i2++) {
      var key2 = TRANSFORMABLE_PROPS[i2];
      if (elOption[key2] != null) {
        allProps[key2] = elOption[key2];
      }
    }
  }
  function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
    if (!styleOpt) {
      return;
    }
    var fromElStyle = fromEl.style;
    var transFromStyleProps;
    if (fromElStyle) {
      var styleTransition = styleOpt.transition;
      var elTransition = elOption.transition;
      if (styleTransition && !isTransitionAll(styleTransition)) {
        var transitionKeys2 = normalizeToArray(styleTransition);
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        for (var i2 = 0; i2 < transitionKeys2.length; i2++) {
          var key2 = transitionKeys2[i2];
          var elVal = fromElStyle[key2];
          transFromStyleProps[key2] = elVal;
        }
      } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
        var animationProps = fromEl.getAnimationStyleProps();
        var animationStyleProps = animationProps ? animationProps.style : null;
        if (animationStyleProps) {
          !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
          var styleKeys = keys(styleOpt);
          for (var i2 = 0; i2 < styleKeys.length; i2++) {
            var key2 = styleKeys[i2];
            if (animationStyleProps[key2]) {
              var elVal = fromElStyle[key2];
              transFromStyleProps[key2] = elVal;
            }
          }
        }
      }
    }
  }
  function isNonStyleTransitionEnabled(optVal, elVal) {
    return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
  }
  var getStateToRestore = makeInner();
  var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
  function stopPreviousKeyframeAnimationAndRestore(el) {
    el.stopAnimation("keyframe");
    el.attr(getStateToRestore(el));
  }
  function applyKeyframeAnimation(el, animationOpts, animatableModel) {
    if (!animatableModel.isAnimationEnabled() || !animationOpts) {
      return;
    }
    if (isArray$1(animationOpts)) {
      each$4(animationOpts, function(singleAnimationOpts) {
        applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
      });
      return;
    }
    var keyframes = animationOpts.keyframes;
    var duration = animationOpts.duration;
    if (animatableModel && duration == null) {
      var config = getAnimationConfig("enter", animatableModel, 0);
      duration = config && config.duration;
    }
    if (!keyframes || !duration) {
      return;
    }
    var stateToRestore = getStateToRestore(el);
    each$4(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
      if (targetPropName && !el[targetPropName]) {
        return;
      }
      var animator;
      keyframes.sort(function(a2, b2) {
        return a2.percent - b2.percent;
      });
      each$4(keyframes, function(kf) {
        var animators = el.animators;
        var kfValues = targetPropName ? kf[targetPropName] : kf;
        if (!kfValues) {
          return;
        }
        var propKeys = keys(kfValues);
        if (!targetPropName) {
          propKeys = filter(propKeys, function(key2) {
            return indexOf(KEYFRAME_EXCLUDE_KEYS, key2) < 0;
          });
        }
        if (!propKeys.length) {
          return;
        }
        if (!animator) {
          animator = el.animate(targetPropName, animationOpts.loop, true);
          animator.scope = "keyframe";
        }
        for (var i2 = 0; i2 < animators.length; i2++) {
          if (animators[i2] !== animator && animators[i2].targetName === animator.targetName) {
            animators[i2].stopTracks(propKeys);
          }
        }
        targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
        var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
        each$4(propKeys, function(key2) {
          savedTarget[key2] = ((targetPropName ? el[targetPropName] : el) || {})[key2];
        });
        animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
      });
      if (!animator) {
        return;
      }
      animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
    });
  }
  var EMPHASIS = "emphasis";
  var NORMAL = "normal";
  var BLUR = "blur";
  var SELECT = "select";
  var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
  var PATH_ITEM_STYLE = {
    normal: ["itemStyle"],
    emphasis: [EMPHASIS, "itemStyle"],
    blur: [BLUR, "itemStyle"],
    select: [SELECT, "itemStyle"]
  };
  var PATH_LABEL = {
    normal: ["label"],
    emphasis: [EMPHASIS, "label"],
    blur: [BLUR, "label"],
    select: [SELECT, "label"]
  };
  var DEFAULT_TRANSITION = ["x", "y"];
  var GROUP_DIFF_PREFIX = "e\0\0";
  var attachedTxInfoTmp = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  };
  var prepareCustoms = {
    cartesian2d: cartesianPrepareCustom,
    geo: geoPrepareCustom,
    single: singlePrepareCustom,
    polar: polarPrepareCustom,
    calendar: calendarPrepareCustom
  };
  function isPath(el) {
    return el instanceof Path;
  }
  function isDisplayable(el) {
    return el instanceof Displayable;
  }
  function copyElement(sourceEl, targetEl) {
    targetEl.copyTransform(sourceEl);
    if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
      targetEl.setStyle(sourceEl.style);
      targetEl.z = sourceEl.z;
      targetEl.z2 = sourceEl.z2;
      targetEl.zlevel = sourceEl.zlevel;
      targetEl.invisible = sourceEl.invisible;
      targetEl.ignore = sourceEl.ignore;
      if (isPath(targetEl) && isPath(sourceEl)) {
        targetEl.setShape(sourceEl.shape);
      }
    }
  }
  var CustomChartView = (
    /** @class */
    function(_super) {
      __extends(CustomChartView2, _super);
      function CustomChartView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CustomChartView2.type;
        return _this;
      }
      CustomChartView2.prototype.render = function(customSeries, ecModel, api2, payload) {
        this._progressiveEls = null;
        var oldData = this._data;
        var data = customSeries.getData();
        var group = this.group;
        var renderItem = makeRenderItem(customSeries, data, ecModel, api2);
        if (!oldData) {
          group.removeAll();
        }
        data.diff(oldData).add(function(newIdx) {
          createOrUpdateItem(api2, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && applyLeaveTransition(el, customInnerStore(el).option, customSeries);
        }).update(function(newIdx, oldIdx) {
          var oldEl = oldData.getItemGraphicEl(oldIdx);
          createOrUpdateItem(api2, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).execute();
        var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
        if (clipPath) {
          group.setClipPath(clipPath);
        } else {
          group.removeClipPath();
        }
        this._data = data;
      };
      CustomChartView2.prototype.incrementalPrepareRender = function(customSeries, ecModel, api2) {
        this.group.removeAll();
        this._data = null;
      };
      CustomChartView2.prototype.incrementalRender = function(params2, customSeries, ecModel, api2, payload) {
        var data = customSeries.getData();
        var renderItem = makeRenderItem(customSeries, data, ecModel, api2);
        var progressiveEls = this._progressiveEls = [];
        function setIncrementalAndHoverLayer(el2) {
          if (!el2.isGroup) {
            el2.incremental = true;
            el2.ensureState("emphasis").hoverLayer = true;
          }
        }
        for (var idx = params2.start; idx < params2.end; idx++) {
          var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
          if (el) {
            el.traverse(setIncrementalAndHoverLayer);
            progressiveEls.push(el);
          }
        }
      };
      CustomChartView2.prototype.eachRendered = function(cb) {
        traverseElements(this._progressiveEls || this.group, cb);
      };
      CustomChartView2.prototype.filterForExposedEvent = function(eventType2, query, targetEl, packedEvent) {
        var elementName = query.element;
        if (elementName == null || targetEl.name === elementName) {
          return true;
        }
        while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
          if (targetEl.name === elementName) {
            return true;
          }
        }
        return false;
      };
      CustomChartView2.type = "custom";
      return CustomChartView2;
    }(ChartView)
  );
  function createEl(elOption) {
    var graphicType = elOption.type;
    var el;
    if (graphicType === "path") {
      var shape = elOption.shape;
      var pathRect = shape.width != null && shape.height != null ? {
        x: shape.x || 0,
        y: shape.y || 0,
        width: shape.width,
        height: shape.height
      } : null;
      var pathData = getPathData(shape);
      el = makePath(pathData, null, pathRect, shape.layout || "center");
      customInnerStore(el).customPathData = pathData;
    } else if (graphicType === "image") {
      el = new ZRImage({});
      customInnerStore(el).customImagePath = elOption.style.image;
    } else if (graphicType === "text") {
      el = new ZRText({});
    } else if (graphicType === "group") {
      el = new Group$2();
    } else if (graphicType === "compoundPath") {
      throw new Error('"compoundPath" is not supported yet.');
    } else {
      var Clz = getShapeClass(graphicType);
      if (!Clz) {
        var errMsg = "";
        throwError(errMsg);
      }
      el = new Clz();
    }
    customInnerStore(el).customGraphicType = graphicType;
    el.name = elOption.name;
    el.z2EmphasisLift = 1;
    el.z2SelectLift = 1;
    return el;
  }
  function updateElNormal(api2, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
    stopPreviousKeyframeAnimationAndRestore(el);
    var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
    if (txCfgOpt) {
      el.setTextConfig(txCfgOpt);
    }
    if (elOption && elOption.transition == null) {
      elOption.transition = DEFAULT_TRANSITION;
    }
    var styleOpt = elOption && elOption.style;
    if (styleOpt) {
      if (el.type === "text") {
        var textOptionStyle = styleOpt;
        hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
        hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
      }
      var decalPattern = void 0;
      var decalObj = isPath(el) ? styleOpt.decal : null;
      if (api2 && decalObj) {
        decalObj.dirty = true;
        decalPattern = createOrUpdatePatternFromDecal(decalObj, api2);
      }
      styleOpt.__decalPattern = decalPattern;
    }
    if (isDisplayable(el)) {
      if (styleOpt) {
        var decalPattern = styleOpt.__decalPattern;
        if (decalPattern) {
          styleOpt.decal = decalPattern;
        }
      }
    }
    applyUpdateTransition(el, elOption, seriesModel, {
      dataIndex,
      isInit,
      clearStyle: true
    });
    applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
  }
  function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
    var elDisplayable = el.isGroup ? null : el;
    var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
    if (elDisplayable) {
      var stateObj = elDisplayable.ensureState(state);
      if (styleOpt === false) {
        var existingEmphasisState = elDisplayable.getState(state);
        if (existingEmphasisState) {
          existingEmphasisState.style = null;
        }
      } else {
        stateObj.style = styleOpt || null;
      }
      if (txCfgOpt) {
        stateObj.textConfig = txCfgOpt;
      }
      setDefaultStateProxy(elDisplayable);
    }
  }
  function updateZ(el, elOption, seriesModel) {
    if (el.isGroup) {
      return;
    }
    var elDisplayable = el;
    var currentZ = seriesModel.currentZ;
    var currentZLevel = seriesModel.currentZLevel;
    elDisplayable.z = currentZ;
    elDisplayable.zlevel = currentZLevel;
    var optZ2 = elOption.z2;
    optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
    for (var i2 = 0; i2 < STATES.length; i2++) {
      updateZForEachState(elDisplayable, elOption, STATES[i2]);
    }
  }
  function updateZForEachState(elDisplayable, elOption, state) {
    var isNormal = state === NORMAL;
    var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
    var optZ2 = elStateOpt ? elStateOpt.z2 : null;
    var stateObj;
    if (optZ2 != null) {
      stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
      stateObj.z2 = optZ2 || 0;
    }
  }
  function makeRenderItem(customSeries, data, ecModel, api2) {
    var renderItem = customSeries.get("renderItem");
    var coordSys = customSeries.coordinateSystem;
    var prepareResult2 = {};
    if (coordSys) {
      prepareResult2 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
    }
    var userAPI = defaults$1({
      getWidth: api2.getWidth,
      getHeight: api2.getHeight,
      getZr: api2.getZr,
      getDevicePixelRatio: api2.getDevicePixelRatio,
      value,
      style,
      ordinalRawValue,
      styleEmphasis,
      visual,
      barLayout,
      currentSeriesIndices,
      font
    }, prepareResult2.api || {});
    var userParams = {
      // The life cycle of context: current round of rendering.
      // The global life cycle is probably not necessary, because
      // user can store global status by themselves.
      context: {},
      seriesId: customSeries.id,
      seriesName: customSeries.name,
      seriesIndex: customSeries.seriesIndex,
      coordSys: prepareResult2.coordSys,
      dataInsideLength: data.count(),
      encode: wrapEncodeDef(customSeries.getData())
    };
    var currDataIndexInside;
    var currItemModel;
    var currItemStyleModels = {};
    var currLabelModels = {};
    var seriesItemStyleModels = {};
    var seriesLabelModels = {};
    for (var i2 = 0; i2 < STATES.length; i2++) {
      var stateName = STATES[i2];
      seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
      seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
    }
    function getItemModel(dataIndexInside) {
      return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
    }
    function getItemStyleModel(dataIndexInside, state) {
      return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
    }
    function getLabelModel(dataIndexInside, state) {
      return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);
    }
    return function(dataIndexInside, payload) {
      currDataIndexInside = dataIndexInside;
      currItemModel = null;
      currItemStyleModels = {};
      currLabelModels = {};
      return renderItem && renderItem(defaults$1({
        dataIndexInside,
        dataIndex: data.getRawIndex(dataIndexInside),
        // Can be used for optimization when zoom or roam.
        actionType: payload ? payload.type : null
      }, userParams), userAPI);
    };
    function value(dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
    }
    function ordinalRawValue(dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      dim = dim || 0;
      var dimInfo = data.getDimensionInfo(dim);
      if (!dimInfo) {
        var dimIndex = data.getDimensionIndex(dim);
        return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
      }
      var val = data.get(dimInfo.name, dataIndexInside);
      var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
      return ordinalMeta ? ordinalMeta.categories[val] : val;
    }
    function style(userProps, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      var style2 = data.getItemVisual(dataIndexInside, "style");
      var visualColor = style2 && style2.fill;
      var opacity = style2 && style2.opacity;
      var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
      visualColor != null && (itemStyle.fill = visualColor);
      opacity != null && (itemStyle.opacity = opacity);
      var opt = {
        inheritColor: isString$1(visualColor) ? visualColor : "#000"
      };
      var labelModel = getLabelModel(dataIndexInside, NORMAL);
      var textStyle = createTextStyle$1(labelModel, null, opt, false, true);
      textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
      var textConfig = createTextConfig(labelModel, opt, false);
      preFetchFromExtra(userProps, itemStyle);
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
      userProps && applyUserPropsAfter(itemStyle, userProps);
      itemStyle.legacy = true;
      return itemStyle;
    }
    function styleEmphasis(userProps, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
      var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
      var textStyle = createTextStyle$1(labelModel, null, null, true, true);
      textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
      var textConfig = createTextConfig(labelModel, null, true);
      preFetchFromExtra(userProps, itemStyle);
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
      userProps && applyUserPropsAfter(itemStyle, userProps);
      itemStyle.legacy = true;
      return itemStyle;
    }
    function applyUserPropsAfter(itemStyle, extra) {
      for (var key2 in extra) {
        if (hasOwn(extra, key2)) {
          itemStyle[key2] = extra[key2];
        }
      }
    }
    function preFetchFromExtra(extra, itemStyle) {
      if (extra) {
        extra.textFill && (itemStyle.textFill = extra.textFill);
        extra.textPosition && (itemStyle.textPosition = extra.textPosition);
      }
    }
    function visual(visualType, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
        var style_1 = data.getItemVisual(dataIndexInside, "style");
        return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
      }
      if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
        return data.getItemVisual(dataIndexInside, visualType);
      }
    }
    function barLayout(opt) {
      if (coordSys.type === "cartesian2d") {
        var baseAxis = coordSys.getBaseAxis();
        return getLayoutOnAxis(defaults$1({
          axis: baseAxis
        }, opt));
      }
    }
    function currentSeriesIndices() {
      return ecModel.getCurrentSeriesIndices();
    }
    function font(opt) {
      return getFont(opt, ecModel);
    }
  }
  function wrapEncodeDef(data) {
    var encodeDef = {};
    each$4(data.dimensions, function(dimName) {
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isExtraCoord) {
        var coordDim = dimInfo.coordDim;
        var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
        dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
      }
    });
    return encodeDef;
  }
  function createOrUpdateItem(api2, existsEl, dataIndex, elOption, seriesModel, group, data) {
    if (!elOption) {
      group.remove(existsEl);
      return;
    }
    var el = doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group);
    el && data.setItemGraphicEl(dataIndex, el);
    el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
    return el;
  }
  function doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group) {
    var toBeReplacedIdx = -1;
    var oldEl = existsEl;
    if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
      toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
      existsEl = null;
    }
    var isInit = !existsEl;
    var el = existsEl;
    if (!el) {
      el = createEl(elOption);
      if (oldEl) {
        copyElement(oldEl, el);
      }
    } else {
      el.clearStates();
    }
    if (elOption.morph === false) {
      el.disableMorphing = true;
    } else if (el.disableMorphing) {
      el.disableMorphing = false;
    }
    attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
    attachedTxInfoTmp.isLegacy = false;
    doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
    doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
    updateElNormal(api2, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
    hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
    for (var i2 = 0; i2 < STATES.length; i2++) {
      var stateName = STATES[i2];
      if (stateName !== NORMAL) {
        var otherStateOpt = retrieveStateOption(elOption, stateName);
        var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
        updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
      }
    }
    updateZ(el, elOption, seriesModel);
    if (elOption.type === "group") {
      mergeChildren(api2, el, dataIndex, elOption, seriesModel);
    }
    if (toBeReplacedIdx >= 0) {
      group.replaceAt(el, toBeReplacedIdx);
    } else {
      group.add(el);
    }
    return el;
  }
  function doesElNeedRecreate(el, elOption, seriesModel) {
    var elInner = customInnerStore(el);
    var elOptionType = elOption.type;
    var elOptionShape = elOption.shape;
    var elOptionStyle = elOption.style;
    return (
      // Always create new if universal transition is enabled.
      // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
      seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath
    );
  }
  function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
    var clipPathOpt = elOption.clipPath;
    if (clipPathOpt === false) {
      if (el && el.getClipPath()) {
        el.removeClipPath();
      }
    } else if (clipPathOpt) {
      var clipPath = el.getClipPath();
      if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
        clipPath = null;
      }
      if (!clipPath) {
        clipPath = createEl(clipPathOpt);
        el.setClipPath(clipPath);
      }
      updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
    }
  }
  function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
    if (el.isGroup) {
      return;
    }
    processTxInfo(elOption, null, attachedTxInfo);
    processTxInfo(elOption, EMPHASIS, attachedTxInfo);
    var txConOptNormal = attachedTxInfo.normal.conOpt;
    var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
    var txConOptBlur = attachedTxInfo.blur.conOpt;
    var txConOptSelect = attachedTxInfo.select.conOpt;
    if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
      var textContent = el.getTextContent();
      if (txConOptNormal === false) {
        textContent && el.removeTextContent();
      } else {
        txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
          type: "text"
        };
        if (!textContent) {
          textContent = createEl(txConOptNormal);
          el.setTextContent(textContent);
        } else {
          textContent.clearStates();
        }
        updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
        var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
        for (var i2 = 0; i2 < STATES.length; i2++) {
          var stateName = STATES[i2];
          if (stateName !== NORMAL) {
            var txConOptOtherState = attachedTxInfo[stateName].conOpt;
            updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
          }
        }
        txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
      }
    }
  }
  function processTxInfo(elOption, state, attachedTxInfo) {
    var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
    var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
    var elType = elOption.type;
    var txCfg = stateOpt ? stateOpt.textConfig : null;
    var txConOptNormal = elOption.textContent;
    var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
    if (styleOpt && // Because emphasis style has little info to detect legacy,
    // if normal is legacy, emphasis is trade as legacy.
    (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
      attachedTxInfo.isLegacy = true;
      var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
      if (!txCfg && convertResult.textConfig) {
        txCfg = convertResult.textConfig;
      }
      if (!txConOpt && convertResult.textContent) {
        txConOpt = convertResult.textContent;
      }
    }
    if (!state && txConOpt) {
      var txConOptNormal_1 = txConOpt;
      !txConOptNormal_1.type && (txConOptNormal_1.type = "text");
    }
    var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
    info.cfg = txCfg;
    info.conOpt = txConOpt;
  }
  function retrieveStateOption(elOption, state) {
    return !state ? elOption : elOption ? elOption[state] : null;
  }
  function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
    var style = stateOption && stateOption.style;
    if (style == null && state === EMPHASIS && stateOptionNormal) {
      style = stateOptionNormal.styleEmphasis;
    }
    return style;
  }
  function mergeChildren(api2, el, dataIndex, elOption, seriesModel) {
    var newChildren = elOption.children;
    var newLen = newChildren ? newChildren.length : 0;
    var mergeChildren2 = elOption.$mergeChildren;
    var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
    var notMerge = mergeChildren2 === false;
    if (!newLen && !byName && !notMerge) {
      return;
    }
    if (byName) {
      diffGroupChildren({
        api: api2,
        oldChildren: el.children() || [],
        newChildren: newChildren || [],
        dataIndex,
        seriesModel,
        group: el
      });
      return;
    }
    notMerge && el.removeAll();
    var index2 = 0;
    for (; index2 < newLen; index2++) {
      var newChild = newChildren[index2];
      var oldChild = el.childAt(index2);
      if (newChild) {
        if (newChild.ignore == null) {
          newChild.ignore = false;
        }
        doCreateOrUpdateEl(api2, oldChild, dataIndex, newChild, seriesModel, el);
      } else {
        oldChild.ignore = true;
      }
    }
    for (var i2 = el.childCount() - 1; i2 >= index2; i2--) {
      var child = el.childAt(i2);
      removeChildFromGroup(el, child, seriesModel);
    }
  }
  function removeChildFromGroup(group, child, seriesModel) {
    child && applyLeaveTransition(child, customInnerStore(group).option, seriesModel);
  }
  function diffGroupChildren(context) {
    new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
  }
  function getKey(item, idx) {
    var name = item && item.name;
    return name != null ? name : GROUP_DIFF_PREFIX + idx;
  }
  function processAddUpdate(newIndex, oldIndex) {
    var context = this.context;
    var childOption = newIndex != null ? context.newChildren[newIndex] : null;
    var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
    doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
  }
  function processRemove(oldIndex) {
    var context = this.context;
    var child = context.oldChildren[oldIndex];
    child && applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
  }
  function getPathData(shape) {
    return shape && (shape.pathData || shape.d);
  }
  function hasOwnPathData(shape) {
    return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
  }
  function install$b(registers) {
    registers.registerChartView(CustomChartView);
    registers.registerSeriesModel(CustomSeriesModel);
  }
  var inner$2 = makeInner();
  var clone$1 = clone$4;
  var bind$1 = bind$2;
  var BaseAxisPointer = (
    /** @class */
    function() {
      function BaseAxisPointer2() {
        this._dragging = false;
        this.animationThreshold = 15;
      }
      BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api2, forceRender) {
        var value = axisPointerModel.get("value");
        var status = axisPointerModel.get("status");
        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api2;
        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return;
        }
        this._lastValue = value;
        this._lastStatus = status;
        var group = this._group;
        var handle2 = this._handle;
        if (!status || status === "hide") {
          group && group.hide();
          handle2 && handle2.hide();
          return;
        }
        group && group.show();
        handle2 && handle2.show();
        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api2);
        var graphicKey = elOption.graphicKey;
        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api2);
        }
        this._lastGraphicKey = graphicKey;
        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
        if (!group) {
          group = this._group = new Group$2();
          this.createPointerEl(group, elOption, axisModel, axisPointerModel);
          this.createLabelEl(group, elOption, axisModel, axisPointerModel);
          api2.getZr().add(group);
        } else {
          var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
          this.updatePointerEl(group, elOption, doUpdateProps);
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }
        updateMandatoryProps(group, axisPointerModel, true);
        this._renderHandle(value);
      };
      BaseAxisPointer2.prototype.remove = function(api2) {
        this.clear(api2);
      };
      BaseAxisPointer2.prototype.dispose = function(api2) {
        this.clear(api2);
      };
      BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
        var animation = axisPointerModel.get("animation");
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === "category";
        var useSnap = axisPointerModel.get("snap");
        if (!useSnap && !isCategoryAxis) {
          return false;
        }
        if (animation === "auto" || animation == null) {
          var animationThreshold = this.animationThreshold;
          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true;
          }
          if (useSnap) {
            var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
            var axisExtent = axis.getExtent();
            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
          }
          return false;
        }
        return animation === true;
      };
      BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api2) {
      };
      BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;
        if (pointerOption) {
          var pointerEl = inner$2(group).pointerEl = new graphic$1[pointerOption.type](clone$1(elOption.pointer));
          group.add(pointerEl);
        }
      };
      BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          var labelEl = inner$2(group).labelEl = new ZRText(clone$1(elOption.label));
          group.add(labelEl);
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      };
      BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
        var pointerEl = inner$2(group).pointerEl;
        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style);
          updateProps2(pointerEl, {
            shape: elOption.pointer.shape
          });
        }
      };
      BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
        var labelEl = inner$2(group).labelEl;
        if (labelEl) {
          labelEl.setStyle(elOption.label.style);
          updateProps2(labelEl, {
            // Consider text length change in vertical axis, animation should
            // be used on shape, otherwise the effect will be weird.
            // TODOTODO
            // shape: elOption.label.shape,
            x: elOption.label.x,
            y: elOption.label.y
          });
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      };
      BaseAxisPointer2.prototype._renderHandle = function(value) {
        if (this._dragging || !this.updateHandleTransform) {
          return;
        }
        var axisPointerModel = this._axisPointerModel;
        var zr = this._api.getZr();
        var handle2 = this._handle;
        var handleModel = axisPointerModel.getModel("handle");
        var status = axisPointerModel.get("status");
        if (!handleModel.get("show") || !status || status === "hide") {
          handle2 && zr.remove(handle2);
          this._handle = null;
          return;
        }
        var isInit;
        if (!this._handle) {
          isInit = true;
          handle2 = this._handle = createIcon(handleModel.get("icon"), {
            cursor: "move",
            draggable: true,
            onmousemove: function(e2) {
              stop(e2.event);
            },
            onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),
            drift: bind$1(this._onHandleDragMove, this),
            ondragend: bind$1(this._onHandleDragEnd, this)
          });
          zr.add(handle2);
        }
        updateMandatoryProps(handle2, axisPointerModel, false);
        handle2.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var handleSize = handleModel.get("size");
        if (!isArray$1(handleSize)) {
          handleSize = [handleSize, handleSize];
        }
        handle2.scaleX = handleSize[0] / 2;
        handle2.scaleY = handleSize[1] / 2;
        createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
        this._moveHandleToValue(value, isInit);
      };
      BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
        updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
      };
      BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
        var handle2 = this._handle;
        if (!handle2) {
          return;
        }
        this._dragging = true;
        var trans = this.updateHandleTransform(getHandleTransProps(handle2), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;
        handle2.stopAnimation();
        handle2.attr(getHandleTransProps(trans));
        inner$2(handle2).lastProp = null;
        this._doDispatchAxisPointer();
      };
      BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
        var handle2 = this._handle;
        if (!handle2) {
          return;
        }
        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        });
      };
      BaseAxisPointer2.prototype._onHandleDragEnd = function() {
        this._dragging = false;
        var handle2 = this._handle;
        if (!handle2) {
          return;
        }
        var value = this._axisPointerModel.get("value");
        this._moveHandleToValue(value);
        this._api.dispatchAction({
          type: "hideTip"
        });
      };
      BaseAxisPointer2.prototype.clear = function(api2) {
        this._lastValue = null;
        this._lastStatus = null;
        var zr = api2.getZr();
        var group = this._group;
        var handle2 = this._handle;
        if (zr && group) {
          this._lastGraphicKey = null;
          group && zr.remove(group);
          handle2 && zr.remove(handle2);
          this._group = null;
          this._handle = null;
          this._payloadInfo = null;
        }
        clear(this, "_doDispatchAxisPointer");
      };
      BaseAxisPointer2.prototype.doClear = function() {
      };
      BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      };
      return BaseAxisPointer2;
    }()
  );
  function updateProps(animationModel, moveAnimation, el, props2) {
    if (!propsEqual(inner$2(el).lastProp, props2)) {
      inner$2(el).lastProp = props2;
      moveAnimation ? updateProps$1(el, props2, animationModel) : (el.stopAnimation(), el.attr(props2));
    }
  }
  function propsEqual(lastProps, newProps) {
    if (isObject$3(lastProps) && isObject$3(newProps)) {
      var equals_1 = true;
      each$4(newProps, function(item, key2) {
        equals_1 = equals_1 && propsEqual(lastProps[key2], item);
      });
      return !!equals_1;
    } else {
      return lastProps === newProps;
    }
  }
  function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
  }
  function getHandleTransProps(trans) {
    return {
      x: trans.x || 0,
      y: trans.y || 0,
      rotation: trans.rotation || 0
    };
  }
  function updateMandatoryProps(group, axisPointerModel, silent) {
    var z2 = axisPointerModel.get("z");
    var zlevel = axisPointerModel.get("zlevel");
    group && group.traverse(function(el) {
      if (el.type !== "group") {
        z2 != null && (el.z = z2);
        zlevel != null && (el.zlevel = zlevel);
        el.silent = silent;
      }
    });
  }
  function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get("type");
    var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
    var style;
    if (axisPointerType === "line") {
      style = styleModel.getLineStyle();
      style.fill = null;
    } else if (axisPointerType === "shadow") {
      style = styleModel.getAreaStyle();
      style.stroke = null;
    }
    return style;
  }
  function buildLabelElOption(elOption, axisModel, axisPointerModel, api2, labelPos) {
    var value = axisPointerModel.get("value");
    var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    });
    var labelModel = axisPointerModel.getModel("label");
    var paddings = normalizeCssArray(labelModel.get("padding") || 0);
    var font = labelModel.getFont();
    var textRect = getBoundingRect(text, font);
    var position2 = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2];
    var align = labelPos.align;
    align === "right" && (position2[0] -= width);
    align === "center" && (position2[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === "bottom" && (position2[1] -= height);
    verticalAlign === "middle" && (position2[1] -= height / 2);
    confineInContainer(position2, width, height, api2);
    var bgColor = labelModel.get("backgroundColor");
    if (!bgColor || bgColor === "auto") {
      bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
    }
    elOption.label = {
      // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
      x: position2[0],
      y: position2[1],
      style: createTextStyle$1(labelModel, {
        text,
        font,
        fill: labelModel.getTextColor(),
        padding: paddings,
        backgroundColor: bgColor
      }),
      // Label should be over axisPointer.
      z2: 10
    };
  }
  function confineInContainer(position2, width, height, api2) {
    var viewWidth = api2.getWidth();
    var viewHeight = api2.getHeight();
    position2[0] = Math.min(position2[0] + width, viewWidth) - width;
    position2[1] = Math.min(position2[1] + height, viewHeight) - height;
    position2[0] = Math.max(position2[0], 0);
    position2[1] = Math.max(position2[1], 0);
  }
  function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
    value = axis.scale.parse(value);
    var text = axis.scale.getLabel({
      value
    }, {
      // If `precision` is set, width can be fixed (like '12.00500'), which
      // helps to debounce when when moving label.
      precision: opt.precision
    });
    var formatter = opt.formatter;
    if (formatter) {
      var params_1 = {
        value: getAxisRawValue(axis, {
          value
        }),
        axisDimension: axis.dim,
        axisIndex: axis.index,
        seriesData: []
      };
      each$4(seriesDataIndices, function(idxItem) {
        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
        var dataIndex = idxItem.dataIndexInside;
        var dataParams = series && series.getDataParams(dataIndex);
        dataParams && params_1.seriesData.push(dataParams);
      });
      if (isString$1(formatter)) {
        text = formatter.replace("{value}", text);
      } else if (isFunction$1(formatter)) {
        text = formatter(params_1);
      }
    }
    return text;
  }
  function getTransformedPosition(axis, value, layoutInfo) {
    var transform2 = create();
    rotate(transform2, transform2, layoutInfo.rotation);
    translate(transform2, transform2, layoutInfo.position);
    return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform2);
  }
  function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2) {
    var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api2, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    });
  }
  function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    };
  }
  function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
  var CartesianAxisPointer = (
    /** @class */
    function(_super) {
      __extends(CartesianAxisPointer2, _super);
      function CartesianAxisPointer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api2) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get("type");
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = layout(grid.model, axisModel);
        buildCartesianSingleLabelElOption(
          // @ts-ignore
          value,
          elOption,
          layoutInfo,
          axisModel,
          axisPointerModel,
          api2
        );
      };
      CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
        var layoutInfo = layout(axisModel.axis.grid.model, axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
        var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
        return {
          x: pos[0],
          y: pos[1],
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      };
      CartesianAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === "x" ? 0 : 1;
        var currPosition = [transform2.x, transform2.y];
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        var tooltipOptions = [{
          verticalAlign: "middle"
        }, {
          align: "center"
        }];
        return {
          x: currPosition[0],
          y: currPosition[1],
          rotation: transform2.rotation,
          cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        };
      };
      return CartesianAxisPointer2;
    }(BaseAxisPointer)
  );
  function getCartesian(grid, axis) {
    var opt = {};
    opt[axis.dim + "AxisIndex"] = axis.index;
    return grid.getCartesian(opt);
  }
  var pointerShapeBuilder = {
    line: function(axis, pixelValue, otherExtent) {
      var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis, pixelValue, otherExtent) {
      var bandWidth = Math.max(1, axis.getBandWidth());
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
      };
    }
  };
  function getAxisDimIndex(axis) {
    return axis.dim === "x" ? 0 : 1;
  }
  var AxisPointerModel = (
    /** @class */
    function(_super) {
      __extends(AxisPointerModel2, _super);
      function AxisPointerModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisPointerModel2.type;
        return _this;
      }
      AxisPointerModel2.type = "axisPointer";
      AxisPointerModel2.defaultOption = {
        // 'auto' means that show when triggered by tooltip or handle.
        show: "auto",
        // zlevel: 0,
        z: 50,
        type: "line",
        // axispointer triggered by tootip determine snap automatically,
        // see `modelHelper`.
        snap: false,
        triggerTooltip: true,
        triggerEmphasis: true,
        value: null,
        status: null,
        link: [],
        // Do not set 'auto' here, otherwise global animation: false
        // will not effect at this axispointer.
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: "#B9BEC9",
          width: 1,
          type: "dashed"
        },
        shadowStyle: {
          color: "rgba(210,219,238,0.2)"
        },
        label: {
          show: true,
          formatter: null,
          precision: "auto",
          margin: 3,
          color: "#fff",
          padding: [5, 7, 5, 7],
          backgroundColor: "auto",
          borderColor: null,
          borderWidth: 0,
          borderRadius: 3
        },
        handle: {
          show: false,
          // eslint-disable-next-line
          icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
          size: 45,
          // handle margin is from symbol center to axis, which is stable when circular move.
          margin: 50,
          // color: '#1b8bbd'
          // color: '#2f4554'
          color: "#333",
          shadowBlur: 3,
          shadowColor: "#aaa",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          // For mobile performance
          throttle: 40
        }
      };
      return AxisPointerModel2;
    }(ComponentModel)
  );
  var inner$1 = makeInner();
  var each$1 = each$4;
  function register(key2, api2, handler) {
    if (env.node) {
      return;
    }
    var zr = api2.getZr();
    inner$1(zr).records || (inner$1(zr).records = {});
    initGlobalListeners(zr, api2);
    var record = inner$1(zr).records[key2] || (inner$1(zr).records[key2] = {});
    record.handler = handler;
  }
  function initGlobalListeners(zr, api2) {
    if (inner$1(zr).initialized) {
      return;
    }
    inner$1(zr).initialized = true;
    useHandler("click", curry$1(doEnter, "click"));
    useHandler("mousemove", curry$1(doEnter, "mousemove"));
    useHandler("globalout", onLeave);
    function useHandler(eventType2, cb) {
      zr.on(eventType2, function(e2) {
        var dis = makeDispatchAction$1(api2);
        each$1(inner$1(zr).records, function(record) {
          record && cb(record, e2, dis.dispatchAction);
        });
        dispatchTooltipFinally(dis.pendings, api2);
      });
    }
  }
  function dispatchTooltipFinally(pendings, api2) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;
    var actuallyPayload;
    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1];
    }
    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null;
      api2.dispatchAction(actuallyPayload);
    }
  }
  function onLeave(record, e2, dispatchAction) {
    record.handler("leave", null, dispatchAction);
  }
  function doEnter(currTrigger, record, e2, dispatchAction) {
    record.handler(currTrigger, e2, dispatchAction);
  }
  function makeDispatchAction$1(api2) {
    var pendings = {
      showTip: [],
      hideTip: []
    };
    var dispatchAction = function(payload) {
      var pendingList = pendings[payload.type];
      if (pendingList) {
        pendingList.push(payload);
      } else {
        payload.dispatchAction = dispatchAction;
        api2.dispatchAction(payload);
      }
    };
    return {
      dispatchAction,
      pendings
    };
  }
  function unregister(key2, api2) {
    if (env.node) {
      return;
    }
    var zr = api2.getZr();
    var record = (inner$1(zr).records || {})[key2];
    if (record) {
      inner$1(zr).records[key2] = null;
    }
  }
  var AxisPointerView = (
    /** @class */
    function(_super) {
      __extends(AxisPointerView2, _super);
      function AxisPointerView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = AxisPointerView2.type;
        return _this;
      }
      AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api2) {
        var globalTooltipModel = ecModel.getComponent("tooltip");
        var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
        register("axisPointer", api2, function(currTrigger, e2, dispatchAction) {
          if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction({
              type: "updateAxisPointer",
              currTrigger,
              x: e2 && e2.offsetX,
              y: e2 && e2.offsetY
            });
          }
        });
      };
      AxisPointerView2.prototype.remove = function(ecModel, api2) {
        unregister("axisPointer", api2);
      };
      AxisPointerView2.prototype.dispose = function(ecModel, api2) {
        unregister("axisPointer", api2);
      };
      AxisPointerView2.type = "axisPointer";
      return AxisPointerView2;
    }(ComponentView)
  );
  function findPointFromSeries(finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;
    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      };
    }
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, finder);
    if (dataIndex == null || dataIndex < 0 || isArray$1(dataIndex)) {
      return {
        point: []
      };
    }
    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;
    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
      if (finder.isStacked) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var valueAxisDim = valueAxis2.dim;
        var baseAxisDim = baseAxis.dim;
        var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
        var baseDim = data.mapDimension(baseAxisDim);
        var stackedData = [];
        stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
        stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
        point = coordSys.dataToPoint(stackedData) || [];
      } else {
        point = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex)) || [];
      }
    } else if (el) {
      var rect = el.getBoundingRect().clone();
      rect.applyTransform(el.transform);
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }
    return {
      point,
      el
    };
  }
  var inner = makeInner();
  function axisTrigger(payload, ecModel, api2) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction = payload.dispatchAction || bind$2(api2.dispatchAction, api2);
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (!coordSysAxesInfo) {
      return;
    }
    if (illegalPoint(point)) {
      point = findPointFromSeries({
        seriesIndex: finder.seriesIndex,
        // Do not use dataIndexInside from other ec instance.
        // FIXME: auto detect it?
        dataIndex: finder.dataIndex
      }, ecModel).point;
    }
    var isIllegalPoint = illegalPoint(point);
    var inputAxesInfo = finder.axesInfo;
    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === "leave" || illegalPoint(point);
    var outputPayload = {};
    var showValueMap = {};
    var dataByCoordSys = {
      list: [],
      map: {}
    };
    var updaters = {
      showPointer: curry$1(showPointer, showValueMap),
      showTooltip: curry$1(showTooltip, dataByCoordSys)
    };
    each$4(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
      var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
      each$4(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key2) {
        var axis = axisInfo.axis;
        var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          var val = inputAxisInfo && inputAxisInfo.value;
          if (val == null && !isIllegalPoint) {
            val = axis.pointToData(point);
          }
          val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
        }
      });
    });
    var linkTriggers = {};
    each$4(axesInfo, function(tarAxisInfo, tarKey) {
      var linkGroup = tarAxisInfo.linkGroup;
      if (linkGroup && !showValueMap[tarKey]) {
        each$4(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
          var srcValItem = showValueMap[srcKey];
          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            var val = srcValItem.value;
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
            linkTriggers[tarAxisInfo.key] = val;
          }
        });
      }
    });
    each$4(linkTriggers, function(val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
    });
    updateModelActually(showValueMap, axesInfo, outputPayload);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
    dispatchHighDownActually(axesInfo, dispatchAction, api2);
    return outputPayload;
  }
  function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
    var axis = axisInfo.axis;
    if (axis.scale.isBlank() || !axis.containData(newValue)) {
      return;
    }
    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue);
      return;
    }
    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue;
    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      extend$1(outputFinder, payloadBatch[0]);
    }
    if (!noSnap && axisInfo.snap) {
      if (axis.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue;
      }
    }
    updaters.showPointer(axisInfo, newValue, payloadBatch);
    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
  }
  function buildPayloadsBySeries(value, axisInfo) {
    var axis = axisInfo.axis;
    var dim = axis.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    each$4(axisInfo.seriesModels, function(series, idx) {
      var dataDim = series.getData().mapDimensionsAll(dim);
      var seriesNestestValue;
      var dataIndices;
      if (series.getAxisTooltipData) {
        var result = series.getAxisTooltipData(dataDim, value, axis);
        dataIndices = result.dataIndices;
        seriesNestestValue = result.nestestValue;
      } else {
        dataIndices = series.getData().indicesOfNearest(
          dataDim[0],
          value,
          // Add a threshold to avoid find the wrong dataIndex
          // when data length is not same.
          // false,
          axis.type === "category" ? 0.5 : null
        );
        if (!dataIndices.length) {
          return;
        }
        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
      }
      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return;
      }
      var diff = value - seriesNestestValue;
      var dist2 = Math.abs(diff);
      if (dist2 <= minDist) {
        if (dist2 < minDist || diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          snapToValue = seriesNestestValue;
          payloadBatch.length = 0;
        }
        each$4(dataIndices, function(dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          });
        });
      }
    });
    return {
      payloadBatch,
      snapToValue
    };
  }
  function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value,
      payloadBatch
    };
  }
  function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis = axisInfo.axis;
    var axisModel = axis.model;
    var axisPointerModel = axisInfo.axisPointerModel;
    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return;
    }
    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];
    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      };
      dataByCoordSys.list.push(coordSysItem);
    }
    coordSysItem.dataByAxis.push({
      axisDim: axis.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: axisPointerModel.get(["label", "precision"]),
        formatter: axisPointerModel.get(["label", "formatter"])
      },
      seriesDataIndices: payloadBatch.slice()
    });
  }
  function updateModelActually(showValueMap, axesInfo, outputPayload) {
    var outputAxesInfo = outputPayload.axesInfo = [];
    each$4(axesInfo, function(axisInfo, key2) {
      var option = axisInfo.axisPointerModel.option;
      var valItem = showValueMap[key2];
      if (valItem) {
        !axisInfo.useHandle && (option.status = "show");
        option.value = valItem.value;
        option.seriesDataIndices = (valItem.payloadBatch || []).slice();
      } else {
        !axisInfo.useHandle && (option.status = "hide");
      }
      option.status === "show" && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      });
    });
  }
  function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction({
        type: "hideTip"
      });
      return;
    }
    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    dispatchAction({
      type: "showTip",
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    });
  }
  function dispatchHighDownActually(axesInfo, dispatchAction, api2) {
    var zr = api2.getZr();
    var highDownKey = "axisPointerLastHighlights";
    var lastHighlights = inner(zr)[highDownKey] || {};
    var newHighlights = inner(zr)[highDownKey] = {};
    each$4(axesInfo, function(axisInfo, key2) {
      var option = axisInfo.axisPointerModel.option;
      option.status === "show" && axisInfo.triggerEmphasis && each$4(option.seriesDataIndices, function(batchItem) {
        var key3 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
        newHighlights[key3] = batchItem;
      });
    });
    var toHighlight = [];
    var toDownplay = [];
    each$4(lastHighlights, function(batchItem, key2) {
      !newHighlights[key2] && toDownplay.push(batchItem);
    });
    each$4(newHighlights, function(batchItem, key2) {
      !lastHighlights[key2] && toHighlight.push(batchItem);
    });
    toDownplay.length && api2.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toDownplay
    });
    toHighlight.length && api2.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toHighlight
    });
  }
  function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i2 = 0; i2 < (inputAxesInfo || []).length; i2++) {
      var inputAxisInfo = inputAxesInfo[i2];
      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo;
      }
    }
  }
  function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
    item.axisName = item[dim + "AxisName"] = axisModel.name;
    item.axisId = item[dim + "AxisId"] = axisModel.id;
    return item;
  }
  function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
  }
  function install$a(registers) {
    AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
    registers.registerComponentModel(AxisPointerModel);
    registers.registerComponentView(AxisPointerView);
    registers.registerPreprocessor(function(option) {
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link;
        if (link && !isArray$1(link)) {
          option.axisPointer.link = [link];
        }
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api2) {
      ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api2);
    });
    registers.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, axisTrigger);
  }
  function install$9(registers) {
    use(install$d);
    use(install$a);
  }
  var CalendarModel = (
    /** @class */
    function(_super) {
      __extends(CalendarModel2, _super);
      function CalendarModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CalendarModel2.type;
        return _this;
      }
      CalendarModel2.prototype.init = function(option, parentModel, ecModel) {
        var inputPositionParams = getLayoutParams(option);
        _super.prototype.init.apply(this, arguments);
        mergeAndNormalizeLayoutParams$1(option, inputPositionParams);
      };
      CalendarModel2.prototype.mergeOption = function(option) {
        _super.prototype.mergeOption.apply(this, arguments);
        mergeAndNormalizeLayoutParams$1(this.option, option);
      };
      CalendarModel2.prototype.getCellSize = function() {
        return this.option.cellSize;
      };
      CalendarModel2.type = "calendar";
      CalendarModel2.defaultOption = {
        // zlevel: 0,
        z: 2,
        left: 80,
        top: 60,
        cellSize: 20,
        // horizontal vertical
        orient: "horizontal",
        // month separate line style
        splitLine: {
          show: true,
          lineStyle: {
            color: "#000",
            width: 1,
            type: "solid"
          }
        },
        // rect style  temporarily unused emphasis
        itemStyle: {
          color: "#fff",
          borderWidth: 1,
          borderColor: "#ccc"
        },
        // week text style
        dayLabel: {
          show: true,
          firstDay: 0,
          // start end
          position: "start",
          margin: "50%",
          color: "#000"
        },
        // month text style
        monthLabel: {
          show: true,
          // start end
          position: "start",
          margin: 5,
          // center or left
          align: "center",
          formatter: null,
          color: "#000"
        },
        // year text style
        yearLabel: {
          show: true,
          // top bottom left right
          position: null,
          margin: 30,
          formatter: null,
          color: "#ccc",
          fontFamily: "sans-serif",
          fontWeight: "bolder",
          fontSize: 20
        }
      };
      return CalendarModel2;
    }(ComponentModel)
  );
  function mergeAndNormalizeLayoutParams$1(target, raw) {
    var cellSize = target.cellSize;
    var cellSizeArr;
    if (!isArray$1(cellSize)) {
      cellSizeArr = target.cellSize = [cellSize, cellSize];
    } else {
      cellSizeArr = cellSize;
    }
    if (cellSizeArr.length === 1) {
      cellSizeArr[1] = cellSizeArr[0];
    }
    var ignoreSize = map$1([0, 1], function(hvIdx) {
      if (sizeCalculable(raw, hvIdx)) {
        cellSizeArr[hvIdx] = "auto";
      }
      return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
    });
    mergeLayoutParam(target, raw, {
      type: "box",
      ignoreSize
    });
  }
  var CalendarView = (
    /** @class */
    function(_super) {
      __extends(CalendarView2, _super);
      function CalendarView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = CalendarView2.type;
        return _this;
      }
      CalendarView2.prototype.render = function(calendarModel, ecModel, api2) {
        var group = this.group;
        group.removeAll();
        var coordSys = calendarModel.coordinateSystem;
        var rangeData = coordSys.getRangeInfo();
        var orient = coordSys.getOrient();
        var localeModel = ecModel.getLocaleModel();
        this._renderDayRect(calendarModel, rangeData, group);
        this._renderLines(calendarModel, rangeData, orient, group);
        this._renderYearText(calendarModel, rangeData, orient, group);
        this._renderMonthText(calendarModel, localeModel, orient, group);
        this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
      };
      CalendarView2.prototype._renderDayRect = function(calendarModel, rangeData, group) {
        var coordSys = calendarModel.coordinateSystem;
        var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
        var sw = coordSys.getCellWidth();
        var sh = coordSys.getCellHeight();
        for (var i2 = rangeData.start.time; i2 <= rangeData.end.time; i2 = coordSys.getNextNDay(i2, 1).time) {
          var point = coordSys.dataToRect([i2], false).tl;
          var rect = new Rect({
            shape: {
              x: point[0],
              y: point[1],
              width: sw,
              height: sh
            },
            cursor: "default",
            style: itemRectStyleModel
          });
          group.add(rect);
        }
      };
      CalendarView2.prototype._renderLines = function(calendarModel, rangeData, orient, group) {
        var self2 = this;
        var coordSys = calendarModel.coordinateSystem;
        var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
        var show = calendarModel.get(["splitLine", "show"]);
        var lineWidth = lineStyleModel.lineWidth;
        this._tlpoints = [];
        this._blpoints = [];
        this._firstDayOfMonth = [];
        this._firstDayPoints = [];
        var firstDay = rangeData.start;
        for (var i2 = 0; firstDay.time <= rangeData.end.time; i2++) {
          addPoints(firstDay.formatedDate);
          if (i2 === 0) {
            firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
          }
          var date = firstDay.date;
          date.setMonth(date.getMonth() + 1);
          firstDay = coordSys.getDateInfo(date);
        }
        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
        function addPoints(date3) {
          self2._firstDayOfMonth.push(coordSys.getDateInfo(date3));
          self2._firstDayPoints.push(coordSys.dataToRect([date3], false).tl);
          var points2 = self2._getLinePointsOfOneWeek(calendarModel, date3, orient);
          self2._tlpoints.push(points2[0]);
          self2._blpoints.push(points2[points2.length - 1]);
          show && self2._drawSplitline(points2, lineStyleModel, group);
        }
        show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
        show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
      };
      CalendarView2.prototype._getEdgesPoints = function(points2, lineWidth, orient) {
        var rs = [points2[0].slice(), points2[points2.length - 1].slice()];
        var idx = orient === "horizontal" ? 0 : 1;
        rs[0][idx] = rs[0][idx] - lineWidth / 2;
        rs[1][idx] = rs[1][idx] + lineWidth / 2;
        return rs;
      };
      CalendarView2.prototype._drawSplitline = function(points2, lineStyle, group) {
        var poyline = new Polyline({
          z2: 20,
          shape: {
            points: points2
          },
          style: lineStyle
        });
        group.add(poyline);
      };
      CalendarView2.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient) {
        var coordSys = calendarModel.coordinateSystem;
        var parsedDate = coordSys.getDateInfo(date);
        var points2 = [];
        for (var i2 = 0; i2 < 7; i2++) {
          var tmpD = coordSys.getNextNDay(parsedDate.time, i2);
          var point = coordSys.dataToRect([tmpD.time], false);
          points2[2 * tmpD.day] = point.tl;
          points2[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
        }
        return points2;
      };
      CalendarView2.prototype._formatterLabel = function(formatter, params2) {
        if (isString$1(formatter) && formatter) {
          return formatTplSimple(formatter, params2);
        }
        if (isFunction$1(formatter)) {
          return formatter(params2);
        }
        return params2.nameMap;
      };
      CalendarView2.prototype._yearTextPositionControl = function(textEl, point, orient, position2, margin) {
        var x2 = point[0];
        var y2 = point[1];
        var aligns = ["center", "bottom"];
        if (position2 === "bottom") {
          y2 += margin;
          aligns = ["center", "top"];
        } else if (position2 === "left") {
          x2 -= margin;
        } else if (position2 === "right") {
          x2 += margin;
          aligns = ["center", "top"];
        } else {
          y2 -= margin;
        }
        var rotate2 = 0;
        if (position2 === "left" || position2 === "right") {
          rotate2 = Math.PI / 2;
        }
        return {
          rotation: rotate2,
          x: x2,
          y: y2,
          style: {
            align: aligns[0],
            verticalAlign: aligns[1]
          }
        };
      };
      CalendarView2.prototype._renderYearText = function(calendarModel, rangeData, orient, group) {
        var yearLabel = calendarModel.getModel("yearLabel");
        if (!yearLabel.get("show")) {
          return;
        }
        var margin = yearLabel.get("margin");
        var pos = yearLabel.get("position");
        if (!pos) {
          pos = orient !== "horizontal" ? "top" : "left";
        }
        var points2 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
        var xc = (points2[0][0] + points2[1][0]) / 2;
        var yc = (points2[0][1] + points2[1][1]) / 2;
        var idx = orient === "horizontal" ? 0 : 1;
        var posPoints = {
          top: [xc, points2[idx][1]],
          bottom: [xc, points2[1 - idx][1]],
          left: [points2[1 - idx][0], yc],
          right: [points2[idx][0], yc]
        };
        var name = rangeData.start.y;
        if (+rangeData.end.y > +rangeData.start.y) {
          name = name + "-" + rangeData.end.y;
        }
        var formatter = yearLabel.get("formatter");
        var params2 = {
          start: rangeData.start.y,
          end: rangeData.end.y,
          nameMap: name
        };
        var content = this._formatterLabel(formatter, params2);
        var yearText = new ZRText({
          z2: 30,
          style: createTextStyle$1(yearLabel, {
            text: content
          }),
          silent: yearLabel.get("silent")
        });
        yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
        group.add(yearText);
      };
      CalendarView2.prototype._monthTextPositionControl = function(point, isCenter, orient, position2, margin) {
        var align = "left";
        var vAlign = "top";
        var x2 = point[0];
        var y2 = point[1];
        if (orient === "horizontal") {
          y2 = y2 + margin;
          if (isCenter) {
            align = "center";
          }
          if (position2 === "start") {
            vAlign = "bottom";
          }
        } else {
          x2 = x2 + margin;
          if (isCenter) {
            vAlign = "middle";
          }
          if (position2 === "start") {
            align = "right";
          }
        }
        return {
          x: x2,
          y: y2,
          align,
          verticalAlign: vAlign
        };
      };
      CalendarView2.prototype._renderMonthText = function(calendarModel, localeModel, orient, group) {
        var monthLabel = calendarModel.getModel("monthLabel");
        if (!monthLabel.get("show")) {
          return;
        }
        var nameMap = monthLabel.get("nameMap");
        var margin = monthLabel.get("margin");
        var pos = monthLabel.get("position");
        var align = monthLabel.get("align");
        var termPoints = [this._tlpoints, this._blpoints];
        if (!nameMap || isString$1(nameMap)) {
          if (nameMap) {
            localeModel = getLocaleModel(nameMap) || localeModel;
          }
          nameMap = localeModel.get(["time", "monthAbbr"]) || [];
        }
        var idx = pos === "start" ? 0 : 1;
        var axis = orient === "horizontal" ? 0 : 1;
        margin = pos === "start" ? -margin : margin;
        var isCenter = align === "center";
        var labelSilent = monthLabel.get("silent");
        for (var i2 = 0; i2 < termPoints[idx].length - 1; i2++) {
          var tmp = termPoints[idx][i2].slice();
          var firstDay = this._firstDayOfMonth[i2];
          if (isCenter) {
            var firstDayPoints = this._firstDayPoints[i2];
            tmp[axis] = (firstDayPoints[axis] + termPoints[0][i2 + 1][axis]) / 2;
          }
          var formatter = monthLabel.get("formatter");
          var name_1 = nameMap[+firstDay.m - 1];
          var params2 = {
            yyyy: firstDay.y,
            yy: (firstDay.y + "").slice(2),
            MM: firstDay.m,
            M: +firstDay.m,
            nameMap: name_1
          };
          var content = this._formatterLabel(formatter, params2);
          var monthText = new ZRText({
            z2: 30,
            style: extend$1(createTextStyle$1(monthLabel, {
              text: content
            }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin)),
            silent: labelSilent
          });
          group.add(monthText);
        }
      };
      CalendarView2.prototype._weekTextPositionControl = function(point, orient, position2, margin, cellSize) {
        var align = "center";
        var vAlign = "middle";
        var x2 = point[0];
        var y2 = point[1];
        var isStart = position2 === "start";
        if (orient === "horizontal") {
          x2 = x2 + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
          align = isStart ? "right" : "left";
        } else {
          y2 = y2 + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
          vAlign = isStart ? "bottom" : "top";
        }
        return {
          x: x2,
          y: y2,
          align,
          verticalAlign: vAlign
        };
      };
      CalendarView2.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient, group) {
        var dayLabel = calendarModel.getModel("dayLabel");
        if (!dayLabel.get("show")) {
          return;
        }
        var coordSys = calendarModel.coordinateSystem;
        var pos = dayLabel.get("position");
        var nameMap = dayLabel.get("nameMap");
        var margin = dayLabel.get("margin");
        var firstDayOfWeek = coordSys.getFirstDayOfWeek();
        if (!nameMap || isString$1(nameMap)) {
          if (nameMap) {
            localeModel = getLocaleModel(nameMap) || localeModel;
          }
          var dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
          nameMap = dayOfWeekShort || map$1(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
            return val[0];
          });
        }
        var start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
        var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
        margin = parsePercent(margin, Math.min(cellSize[1], cellSize[0]));
        if (pos === "start") {
          start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
          margin = -margin;
        }
        var labelSilent = dayLabel.get("silent");
        for (var i2 = 0; i2 < 7; i2++) {
          var tmpD = coordSys.getNextNDay(start2, i2);
          var point = coordSys.dataToRect([tmpD.time], false).center;
          var day = i2;
          day = Math.abs((i2 + firstDayOfWeek) % 7);
          var weekText = new ZRText({
            z2: 30,
            style: extend$1(createTextStyle$1(dayLabel, {
              text: nameMap[day]
            }), this._weekTextPositionControl(point, orient, pos, margin, cellSize)),
            silent: labelSilent
          });
          group.add(weekText);
        }
      };
      CalendarView2.type = "calendar";
      return CalendarView2;
    }(ComponentView)
  );
  var PROXIMATE_ONE_DAY = 864e5;
  var Calendar = (
    /** @class */
    function() {
      function Calendar2(calendarModel, ecModel, api2) {
        this.type = "calendar";
        this.dimensions = Calendar2.dimensions;
        this.getDimensionsInfo = Calendar2.getDimensionsInfo;
        this._model = calendarModel;
      }
      Calendar2.getDimensionsInfo = function() {
        return [{
          name: "time",
          type: "time"
        }, "value"];
      };
      Calendar2.prototype.getRangeInfo = function() {
        return this._rangeInfo;
      };
      Calendar2.prototype.getModel = function() {
        return this._model;
      };
      Calendar2.prototype.getRect = function() {
        return this._rect;
      };
      Calendar2.prototype.getCellWidth = function() {
        return this._sw;
      };
      Calendar2.prototype.getCellHeight = function() {
        return this._sh;
      };
      Calendar2.prototype.getOrient = function() {
        return this._orient;
      };
      Calendar2.prototype.getFirstDayOfWeek = function() {
        return this._firstDayOfWeek;
      };
      Calendar2.prototype.getDateInfo = function(date) {
        date = parseDate(date);
        var y2 = date.getFullYear();
        var m2 = date.getMonth() + 1;
        var mStr = m2 < 10 ? "0" + m2 : "" + m2;
        var d2 = date.getDate();
        var dStr = d2 < 10 ? "0" + d2 : "" + d2;
        var day = date.getDay();
        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
        return {
          y: y2 + "",
          m: mStr,
          d: dStr,
          day,
          time: date.getTime(),
          formatedDate: y2 + "-" + mStr + "-" + dStr,
          date
        };
      };
      Calendar2.prototype.getNextNDay = function(date, n2) {
        n2 = n2 || 0;
        if (n2 === 0) {
          return this.getDateInfo(date);
        }
        date = new Date(this.getDateInfo(date).time);
        date.setDate(date.getDate() + n2);
        return this.getDateInfo(date);
      };
      Calendar2.prototype.update = function(ecModel, api2) {
        this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
        this._orient = this._model.get("orient");
        this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
        this._rangeInfo = this._getRangeInfo(this._initRangeOption());
        var weeks = this._rangeInfo.weeks || 1;
        var whNames = ["width", "height"];
        var cellSize = this._model.getCellSize().slice();
        var layoutParams = this._model.getBoxLayoutParams();
        var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
        each$4([0, 1], function(idx) {
          if (cellSizeSpecified(cellSize, idx)) {
            layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
          }
        });
        var whGlobal = {
          width: api2.getWidth(),
          height: api2.getHeight()
        };
        var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
        each$4([0, 1], function(idx) {
          if (!cellSizeSpecified(cellSize, idx)) {
            cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
          }
        });
        function cellSizeSpecified(cellSize2, idx) {
          return cellSize2[idx] != null && cellSize2[idx] !== "auto";
        }
        this._sw = cellSize[0];
        this._sh = cellSize[1];
      };
      Calendar2.prototype.dataToPoint = function(data, clamp2) {
        isArray$1(data) && (data = data[0]);
        clamp2 == null && (clamp2 = true);
        var dayInfo = this.getDateInfo(data);
        var range2 = this._rangeInfo;
        var date = dayInfo.formatedDate;
        if (clamp2 && !(dayInfo.time >= range2.start.time && dayInfo.time < range2.end.time + PROXIMATE_ONE_DAY)) {
          return [NaN, NaN];
        }
        var week = dayInfo.day;
        var nthWeek = this._getRangeInfo([range2.start.time, date]).nthWeek;
        if (this._orient === "vertical") {
          return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
        }
        return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
      };
      Calendar2.prototype.pointToData = function(point) {
        var date = this.pointToDate(point);
        return date && date.time;
      };
      Calendar2.prototype.dataToRect = function(data, clamp2) {
        var point = this.dataToPoint(data, clamp2);
        return {
          contentShape: {
            x: point[0] - (this._sw - this._lineWidth) / 2,
            y: point[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth
          },
          center: point,
          tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
          tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
          br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
          bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
        };
      };
      Calendar2.prototype.pointToDate = function(point) {
        var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
        var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
        var range2 = this._rangeInfo.range;
        if (this._orient === "vertical") {
          return this._getDateByWeeksAndDay(nthY, nthX - 1, range2);
        }
        return this._getDateByWeeksAndDay(nthX, nthY - 1, range2);
      };
      Calendar2.prototype.convertToPixel = function(ecModel, finder, value) {
        var coordSys = getCoordSys(finder);
        return coordSys === this ? coordSys.dataToPoint(value) : null;
      };
      Calendar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
        var coordSys = getCoordSys(finder);
        return coordSys === this ? coordSys.pointToData(pixel) : null;
      };
      Calendar2.prototype.containPoint = function(point) {
        console.warn("Not implemented.");
        return false;
      };
      Calendar2.prototype._initRangeOption = function() {
        var range2 = this._model.get("range");
        var normalizedRange;
        if (isArray$1(range2) && range2.length === 1) {
          range2 = range2[0];
        }
        if (!isArray$1(range2)) {
          var rangeStr = range2.toString();
          if (/^\d{4}$/.test(rangeStr)) {
            normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
          }
          if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
            var start2 = this.getDateInfo(rangeStr);
            var firstDay = start2.date;
            firstDay.setMonth(firstDay.getMonth() + 1);
            var end2 = this.getNextNDay(firstDay, -1);
            normalizedRange = [start2.formatedDate, end2.formatedDate];
          }
          if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
            normalizedRange = [rangeStr, rangeStr];
          }
        } else {
          normalizedRange = range2;
        }
        if (!normalizedRange) {
          return range2;
        }
        var tmp = this._getRangeInfo(normalizedRange);
        if (tmp.start.time > tmp.end.time) {
          normalizedRange.reverse();
        }
        return normalizedRange;
      };
      Calendar2.prototype._getRangeInfo = function(range2) {
        var parsedRange = [this.getDateInfo(range2[0]), this.getDateInfo(range2[1])];
        var reversed;
        if (parsedRange[0].time > parsedRange[1].time) {
          reversed = true;
          parsedRange.reverse();
        }
        var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
        var date = new Date(parsedRange[0].time);
        var startDateNum = date.getDate();
        var endDateNum = parsedRange[1].date.getDate();
        date.setDate(startDateNum + allDay - 1);
        var dateNum = date.getDate();
        if (dateNum !== endDateNum) {
          var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
          while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
            allDay -= sign;
            date.setDate(dateNum - sign);
          }
        }
        var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
        var nthWeek = reversed ? -weeks + 1 : weeks - 1;
        reversed && parsedRange.reverse();
        return {
          range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
          start: parsedRange[0],
          end: parsedRange[1],
          allDay,
          weeks,
          // From 0.
          nthWeek,
          fweek: parsedRange[0].day,
          lweek: parsedRange[1].day
        };
      };
      Calendar2.prototype._getDateByWeeksAndDay = function(nthWeek, day, range2) {
        var rangeInfo = this._getRangeInfo(range2);
        if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
          return null;
        }
        var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
        var date = new Date(rangeInfo.start.time);
        date.setDate(+rangeInfo.start.d + nthDay);
        return this.getDateInfo(date);
      };
      Calendar2.create = function(ecModel, api2) {
        var calendarList = [];
        ecModel.eachComponent("calendar", function(calendarModel) {
          var calendar = new Calendar2(calendarModel);
          calendarList.push(calendar);
          calendarModel.coordinateSystem = calendar;
        });
        ecModel.eachSeries(function(calendarSeries) {
          if (calendarSeries.get("coordinateSystem") === "calendar") {
            calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
          }
        });
        return calendarList;
      };
      Calendar2.dimensions = ["time", "value"];
      return Calendar2;
    }()
  );
  function getCoordSys(finder) {
    var calendarModel = finder.calendarModel;
    var seriesModel = finder.seriesModel;
    var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
    return coordSys;
  }
  function install$8(registers) {
    registers.registerComponentModel(CalendarModel);
    registers.registerComponentView(CalendarView);
    registers.registerCoordinateSystem("calendar", Calendar);
  }
  function makeBackground(rect, componentModel) {
    var padding = normalizeCssArray(componentModel.get("padding"));
    var style = componentModel.getItemStyle(["color", "opacity"]);
    style.fill = componentModel.get("backgroundColor");
    rect = new Rect({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get("borderRadius")
      },
      style,
      silent: true,
      z2: -1
    });
    return rect;
  }
  var TooltipModel = (
    /** @class */
    function(_super) {
      __extends(TooltipModel2, _super);
      function TooltipModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TooltipModel2.type;
        return _this;
      }
      TooltipModel2.type = "tooltip";
      TooltipModel2.dependencies = ["axisPointer"];
      TooltipModel2.defaultOption = {
        // zlevel: 0,
        z: 60,
        show: true,
        // tooltip main content
        showContent: true,
        // 'trigger' only works on coordinate system.
        // 'item' | 'axis' | 'none'
        trigger: "item",
        // 'click' | 'mousemove' | 'none'
        triggerOn: "mousemove|click",
        alwaysShowContent: false,
        displayMode: "single",
        renderMode: "auto",
        // whether restraint content inside viewRect.
        // If renderMode: 'richText', default true.
        // If renderMode: 'html', defaut false (for backward compat).
        confine: null,
        showDelay: 0,
        hideDelay: 100,
        // Animation transition time, unit is second
        transitionDuration: 0.4,
        enterable: false,
        backgroundColor: "#fff",
        // box shadow
        shadowBlur: 10,
        shadowColor: "rgba(0, 0, 0, .2)",
        shadowOffsetX: 1,
        shadowOffsetY: 2,
        // tooltip border radius, unit is px, default is 4
        borderRadius: 4,
        // tooltip border width, unit is px, default is 0 (no border)
        borderWidth: 1,
        // Tooltip inside padding, default is 5 for all direction
        // Array is allowed to set up, right, bottom, left, same with css
        // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
        padding: null,
        // Extra css text
        extraCssText: "",
        // axis indicator, trigger by axis
        axisPointer: {
          // default is line
          // legal values: 'line' | 'shadow' | 'cross'
          type: "line",
          // Valid when type is line, appoint tooltip line locate on which line. Optional
          // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
          // default is 'auto', chose the axis which type is category.
          // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
          axis: "auto",
          animation: "auto",
          animationDurationUpdate: 200,
          animationEasingUpdate: "exponentialOut",
          crossStyle: {
            color: "#999",
            width: 1,
            type: "dashed",
            // TODO formatter
            textStyle: {}
          }
          // lineStyle and shadowStyle should not be specified here,
          // otherwise it will always override those styles on option.axisPointer.
        },
        textStyle: {
          color: "#666",
          fontSize: 14
        }
      };
      return TooltipModel2;
    }(ComponentModel)
  );
  function shouldTooltipConfine(tooltipModel) {
    var confineOption = tooltipModel.get("confine");
    return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
  }
  function testStyle(styleProps) {
    if (!env.domSupported) {
      return;
    }
    var style = document.documentElement.style;
    for (var i2 = 0, len2 = styleProps.length; i2 < len2; i2++) {
      if (styleProps[i2] in style) {
        return styleProps[i2];
      }
    }
  }
  var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
  var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
  function toCSSVendorPrefix(styleVendor, styleProp) {
    if (!styleVendor) {
      return styleProp;
    }
    styleProp = toCamelCase$1(styleProp, true);
    var idx = styleVendor.indexOf(styleProp);
    styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
    return styleVendor.toLowerCase();
  }
  function getComputedStyle$1(el, style) {
    var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
    return stl ? stl[style] : null;
  }
  var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
  var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
  var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env.transform3dSupported ? "will-change:transform;" : "");
  function mirrorPos(pos) {
    pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
    return pos;
  }
  function assembleArrow(tooltipModel, borderColor, arrowPosition) {
    if (!isString$1(arrowPosition) || arrowPosition === "inside") {
      return "";
    }
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var borderWidth = tooltipModel.get("borderWidth");
    borderColor = convertToColorString(borderColor);
    var arrowPos = mirrorPos(arrowPosition);
    var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
    var positionStyle = "";
    var transformStyle = CSS_TRANSFORM_VENDOR + ":";
    var rotateDeg;
    if (indexOf(["left", "right"], arrowPos) > -1) {
      positionStyle += "top:50%";
      transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
    } else {
      positionStyle += "left:50%";
      transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
    }
    var rotateRadian = rotateDeg * Math.PI / 180;
    var arrowWH = arrowSize + borderWidth;
    var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
    var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
    positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
    var borderStyle = borderColor + " solid " + borderWidth + "px;";
    var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;z-index:-1;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
    return '<div style="' + styleCss.join("") + '"></div>';
  }
  function assembleTransition(duration, onlyFade) {
    var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
    var transitionOption = " " + duration / 2 + "s " + transitionCurve;
    var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
    if (!onlyFade) {
      transitionOption = " " + duration + "s " + transitionCurve;
      transitionText += env.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
    }
    return CSS_TRANSITION_VENDOR + ":" + transitionText;
  }
  function assembleTransform(x2, y2, toString2) {
    var x0 = x2.toFixed(0) + "px";
    var y0 = y2.toFixed(0) + "px";
    if (!env.transformSupported) {
      return toString2 ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
    }
    var is3d = env.transform3dSupported;
    var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
    return toString2 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
  }
  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get("fontSize");
    var color2 = textStyleModel.getTextColor();
    color2 && cssText.push("color:" + color2);
    cssText.push("font:" + textStyleModel.getFont());
    var lineHeight = retrieve2(textStyleModel.get("lineHeight"), Math.round(fontSize * 3 / 2));
    fontSize && cssText.push("line-height:" + lineHeight + "px");
    var shadowColor = textStyleModel.get("textShadowColor");
    var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
    var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
    var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
    shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
    each$4(["decoration", "align"], function(name) {
      var val = textStyleModel.get(name);
      val && cssText.push("text-" + name + ":" + val);
    });
    return cssText.join(";");
  }
  function assembleCssText(tooltipModel, enableTransition, onlyFade) {
    var cssText = [];
    var transitionDuration = tooltipModel.get("transitionDuration");
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var shadowBlur = tooltipModel.get("shadowBlur");
    var shadowColor = tooltipModel.get("shadowColor");
    var shadowOffsetX = tooltipModel.get("shadowOffsetX");
    var shadowOffsetY = tooltipModel.get("shadowOffsetY");
    var textStyleModel = tooltipModel.getModel("textStyle");
    var padding = getPaddingFromTooltipModel(tooltipModel, "html");
    var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
    cssText.push("box-shadow:" + boxShadow);
    enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
    if (backgroundColor2) {
      cssText.push("background-color:" + backgroundColor2);
    }
    each$4(["width", "color", "radius"], function(name) {
      var borderName = "border-" + name;
      var camelCase = toCamelCase$1(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
    });
    cssText.push(assembleFont(textStyleModel));
    if (padding != null) {
      cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
    }
    return cssText.join(";") + ";";
  }
  function makeStyleCoord$1(out2, zr, container, zrX, zrY) {
    var zrPainter = zr && zr.painter;
    if (container) {
      var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
      if (zrViewportRoot) {
        transformLocalCoord(out2, zrViewportRoot, container, zrX, zrY);
      }
    } else {
      out2[0] = zrX;
      out2[1] = zrY;
      var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
      if (viewportRootOffset) {
        out2[0] += viewportRootOffset.offsetLeft;
        out2[1] += viewportRootOffset.offsetTop;
      }
    }
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var TooltipHTMLContent = (
    /** @class */
    function() {
      function TooltipHTMLContent2(api2, opt) {
        this._show = false;
        this._styleCoord = [0, 0, 0, 0];
        this._enterable = true;
        this._alwaysShowContent = false;
        this._firstShow = true;
        this._longHide = true;
        if (env.wxa) {
          return null;
        }
        var el = document.createElement("div");
        el.domBelongToZr = true;
        this.el = el;
        var zr = this._zr = api2.getZr();
        var appendTo = opt.appendTo;
        var container = appendTo && (isString$1(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction$1(appendTo) && appendTo(api2.getDom()));
        makeStyleCoord$1(this._styleCoord, zr, container, api2.getWidth() / 2, api2.getHeight() / 2);
        (container || api2.getDom()).appendChild(el);
        this._api = api2;
        this._container = container;
        var self2 = this;
        el.onmouseenter = function() {
          if (self2._enterable) {
            clearTimeout(self2._hideTimeout);
            self2._show = true;
          }
          self2._inContent = true;
        };
        el.onmousemove = function(e2) {
          e2 = e2 || window.event;
          if (!self2._enterable) {
            var handler = zr.handler;
            var zrViewportRoot = zr.painter.getViewportRoot();
            normalizeEvent(zrViewportRoot, e2, true);
            handler.dispatch("mousemove", e2);
          }
        };
        el.onmouseleave = function() {
          self2._inContent = false;
          if (self2._enterable) {
            if (self2._show) {
              self2.hideLater(self2._hideDelay);
            }
          }
        };
      }
      TooltipHTMLContent2.prototype.update = function(tooltipModel) {
        if (!this._container) {
          var container = this._api.getDom();
          var position2 = getComputedStyle$1(container, "position");
          var domStyle = container.style;
          if (domStyle.position !== "absolute" && position2 !== "absolute") {
            domStyle.position = "relative";
          }
        }
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveIfResized();
        this._alwaysShowContent = alwaysShowContent;
        this.el.className = tooltipModel.get("className") || "";
      };
      TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
        clearTimeout(this._hideTimeout);
        clearTimeout(this._longHideTimeout);
        var el = this.el;
        var style = el.style;
        var styleCoord = this._styleCoord;
        if (!el.innerHTML) {
          style.display = "none";
        } else {
          style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
        }
        this._show = true;
        this._firstShow = false;
        this._longHide = false;
      };
      TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
        var el = this.el;
        if (content == null) {
          el.innerHTML = "";
          return;
        }
        var arrow = "";
        if (isString$1(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
          arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
        }
        if (isString$1(content)) {
          el.innerHTML = content + arrow;
        } else if (content) {
          el.innerHTML = "";
          if (!isArray$1(content)) {
            content = [content];
          }
          for (var i2 = 0; i2 < content.length; i2++) {
            if (isDom(content[i2]) && content[i2].parentNode !== el) {
              el.appendChild(content[i2]);
            }
          }
          if (arrow && el.childNodes.length) {
            var arrowEl = document.createElement("div");
            arrowEl.innerHTML = arrow;
            el.appendChild(arrowEl);
          }
        }
      };
      TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
        this._enterable = enterable;
      };
      TooltipHTMLContent2.prototype.getSize = function() {
        var el = this.el;
        return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];
      };
      TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
        if (!this.el) {
          return;
        }
        var styleCoord = this._styleCoord;
        makeStyleCoord$1(styleCoord, this._zr, this._container, zrX, zrY);
        if (styleCoord[0] != null && styleCoord[1] != null) {
          var style_1 = this.el.style;
          var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
          each$4(transforms, function(transform2) {
            style_1[transform2[0]] = transform2[1];
          });
        }
      };
      TooltipHTMLContent2.prototype._moveIfResized = function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
      };
      TooltipHTMLContent2.prototype.hide = function() {
        var _this = this;
        var style = this.el.style;
        style.visibility = "hidden";
        style.opacity = "0";
        env.transform3dSupported && (style.willChange = "");
        this._show = false;
        this._longHideTimeout = setTimeout(function() {
          return _this._longHide = true;
        }, 500);
      };
      TooltipHTMLContent2.prototype.hideLater = function(time2) {
        if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
          if (time2) {
            this._hideDelay = time2;
            this._show = false;
            this._hideTimeout = setTimeout(bind$2(this.hide, this), time2);
          } else {
            this.hide();
          }
        }
      };
      TooltipHTMLContent2.prototype.isShow = function() {
        return this._show;
      };
      TooltipHTMLContent2.prototype.dispose = function() {
        clearTimeout(this._hideTimeout);
        clearTimeout(this._longHideTimeout);
        var parentNode = this.el.parentNode;
        parentNode && parentNode.removeChild(this.el);
        this.el = this._container = null;
      };
      return TooltipHTMLContent2;
    }()
  );
  var TooltipRichContent = (
    /** @class */
    function() {
      function TooltipRichContent2(api2) {
        this._show = false;
        this._styleCoord = [0, 0, 0, 0];
        this._alwaysShowContent = false;
        this._enterable = true;
        this._zr = api2.getZr();
        makeStyleCoord(this._styleCoord, this._zr, api2.getWidth() / 2, api2.getHeight() / 2);
      }
      TooltipRichContent2.prototype.update = function(tooltipModel) {
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveIfResized();
        this._alwaysShowContent = alwaysShowContent;
      };
      TooltipRichContent2.prototype.show = function() {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout);
        }
        this.el.show();
        this._show = true;
      };
      TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
        var _this = this;
        if (isObject$3(content)) {
          throwError("");
        }
        if (this.el) {
          this._zr.remove(this.el);
        }
        var textStyleModel = tooltipModel.getModel("textStyle");
        this.el = new ZRText({
          style: {
            rich: markupStyleCreator.richTextStyles,
            text: content,
            lineHeight: 22,
            borderWidth: 1,
            borderColor,
            textShadowColor: textStyleModel.get("textShadowColor"),
            fill: tooltipModel.get(["textStyle", "color"]),
            padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
            verticalAlign: "top",
            align: "left"
          },
          z: tooltipModel.get("z")
        });
        each$4(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
          _this.el.style[propName] = tooltipModel.get(propName);
        });
        each$4(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
          _this.el.style[propName] = textStyleModel.get(propName) || 0;
        });
        this._zr.add(this.el);
        var self2 = this;
        this.el.on("mouseover", function() {
          if (self2._enterable) {
            clearTimeout(self2._hideTimeout);
            self2._show = true;
          }
          self2._inContent = true;
        });
        this.el.on("mouseout", function() {
          if (self2._enterable) {
            if (self2._show) {
              self2.hideLater(self2._hideDelay);
            }
          }
          self2._inContent = false;
        });
      };
      TooltipRichContent2.prototype.setEnterable = function(enterable) {
        this._enterable = enterable;
      };
      TooltipRichContent2.prototype.getSize = function() {
        var el = this.el;
        var bounding = this.el.getBoundingRect();
        var shadowOuterSize = calcShadowOuterSize(el.style);
        return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
      };
      TooltipRichContent2.prototype.moveTo = function(x2, y2) {
        var el = this.el;
        if (el) {
          var styleCoord = this._styleCoord;
          makeStyleCoord(styleCoord, this._zr, x2, y2);
          x2 = styleCoord[0];
          y2 = styleCoord[1];
          var style = el.style;
          var borderWidth = mathMaxWith0(style.borderWidth || 0);
          var shadowOuterSize = calcShadowOuterSize(style);
          el.x = x2 + borderWidth + shadowOuterSize.left;
          el.y = y2 + borderWidth + shadowOuterSize.top;
          el.markRedraw();
        }
      };
      TooltipRichContent2.prototype._moveIfResized = function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
      };
      TooltipRichContent2.prototype.hide = function() {
        if (this.el) {
          this.el.hide();
        }
        this._show = false;
      };
      TooltipRichContent2.prototype.hideLater = function(time2) {
        if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
          if (time2) {
            this._hideDelay = time2;
            this._show = false;
            this._hideTimeout = setTimeout(bind$2(this.hide, this), time2);
          } else {
            this.hide();
          }
        }
      };
      TooltipRichContent2.prototype.isShow = function() {
        return this._show;
      };
      TooltipRichContent2.prototype.dispose = function() {
        this._zr.remove(this.el);
      };
      return TooltipRichContent2;
    }()
  );
  function mathMaxWith0(val) {
    return Math.max(0, val);
  }
  function calcShadowOuterSize(style) {
    var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
    var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
    var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
    return {
      left: mathMaxWith0(shadowBlur - shadowOffsetX),
      right: mathMaxWith0(shadowBlur + shadowOffsetX),
      top: mathMaxWith0(shadowBlur - shadowOffsetY),
      bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
    };
  }
  function makeStyleCoord(out2, zr, zrX, zrY) {
    out2[0] = zrX;
    out2[1] = zrY;
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var proxyRect = new Rect({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  });
  var TooltipView = (
    /** @class */
    function(_super) {
      __extends(TooltipView2, _super);
      function TooltipView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TooltipView2.type;
        return _this;
      }
      TooltipView2.prototype.init = function(ecModel, api2) {
        if (env.node || !api2.getDom()) {
          return;
        }
        var tooltipModel = ecModel.getComponent("tooltip");
        var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
        this._tooltipContent = renderMode === "richText" ? new TooltipRichContent(api2) : new TooltipHTMLContent(api2, {
          appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true)
        });
      };
      TooltipView2.prototype.render = function(tooltipModel, ecModel, api2) {
        if (env.node || !api2.getDom()) {
          return;
        }
        this.group.removeAll();
        this._tooltipModel = tooltipModel;
        this._ecModel = ecModel;
        this._api = api2;
        var tooltipContent = this._tooltipContent;
        tooltipContent.update(tooltipModel);
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        this._initGlobalListener();
        this._keepShow();
        if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
          createOrUpdate(this, "_updatePosition", 50, "fixRate");
        } else {
          clear(this, "_updatePosition");
        }
      };
      TooltipView2.prototype._initGlobalListener = function() {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get("triggerOn");
        register("itemTooltip", this._api, bind$2(function(currTrigger, e2, dispatchAction) {
          if (triggerOn !== "none") {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e2, dispatchAction);
            } else if (currTrigger === "leave") {
              this._hide(dispatchAction);
            }
          }
        }, this));
      };
      TooltipView2.prototype._keepShow = function() {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api2 = this._api;
        var triggerOn = tooltipModel.get("triggerOn");
        if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
          var self_1 = this;
          clearTimeout(this._refreshUpdateTimeout);
          this._refreshUpdateTimeout = setTimeout(function() {
            !api2.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api2, {
              x: self_1._lastX,
              y: self_1._lastY,
              dataByCoordSys: self_1._lastDataByCoordSys
            });
          });
        }
      };
      TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api2, payload) {
        if (payload.from === this.uid || env.node || !api2.getDom()) {
          return;
        }
        var dispatchAction = makeDispatchAction(payload, api2);
        this._ticket = "";
        var dataByCoordSys = payload.dataByCoordSys;
        var cmptRef = findComponentReference(payload, ecModel, api2);
        if (cmptRef) {
          var rect = cmptRef.el.getBoundingRect().clone();
          rect.applyTransform(cmptRef.el.transform);
          this._tryShow({
            offsetX: rect.x + rect.width / 2,
            offsetY: rect.y + rect.height / 2,
            target: cmptRef.el,
            position: payload.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, dispatchAction);
        } else if (payload.tooltip && payload.x != null && payload.y != null) {
          var el = proxyRect;
          el.x = payload.x;
          el.y = payload.y;
          el.update();
          getECData(el).tooltipConfig = {
            name: null,
            option: payload.tooltip
          };
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction);
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction);
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api2, payload)) {
            return;
          }
          var pointInfo = findPointFromSeries(payload, ecModel);
          var cx = pointInfo.point[0];
          var cy = pointInfo.point[1];
          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              target: pointInfo.el,
              position: payload.position,
              // When manully trigger, the mouse is not on the el, so we'd better to
              // position tooltip on the bottom of the el and display arrow is possible.
              positionDefault: "bottom"
            }, dispatchAction);
          }
        } else if (payload.x != null && payload.y != null) {
          api2.dispatchAction({
            type: "updateAxisPointer",
            x: payload.x,
            y: payload.y
          });
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api2.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction);
        }
      };
      TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api2, payload) {
        var tooltipContent = this._tooltipContent;
        if (this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
        }
        this._lastX = this._lastY = this._lastDataByCoordSys = null;
        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction(payload, api2));
        }
      };
      TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api2, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return;
        }
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (!seriesModel) {
          return;
        }
        var data = seriesModel.getData();
        var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
        if (tooltipCascadedModel.get("trigger") !== "axis") {
          return;
        }
        api2.dispatchAction({
          type: "updateAxisPointer",
          seriesIndex,
          dataIndex,
          position: payload.position
        });
        return true;
      };
      TooltipView2.prototype._tryShow = function(e2, dispatchAction) {
        var el = e2.target;
        var tooltipModel = this._tooltipModel;
        if (!tooltipModel) {
          return;
        }
        this._lastX = e2.offsetX;
        this._lastY = e2.offsetY;
        var dataByCoordSys = e2.dataByCoordSys;
        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e2);
        } else if (el) {
          var ecData = getECData(el);
          if (ecData.ssrType === "legend") {
            return;
          }
          this._lastDataByCoordSys = null;
          var seriesDispatcher_1;
          var cmptDispatcher_1;
          findEventDispatcher(el, function(target) {
            if (getECData(target).dataIndex != null) {
              seriesDispatcher_1 = target;
              return true;
            }
            if (getECData(target).tooltipConfig != null) {
              cmptDispatcher_1 = target;
              return true;
            }
          }, true);
          if (seriesDispatcher_1) {
            this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction);
          } else if (cmptDispatcher_1) {
            this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction);
          } else {
            this._hide(dispatchAction);
          }
        } else {
          this._lastDataByCoordSys = null;
          this._hide(dispatchAction);
        }
      };
      TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
        var delay = tooltipModel.get("showDelay");
        cb = bind$2(cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
      };
      TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e2.offsetX, e2.offsetY];
        var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
        var renderMode = this._renderMode;
        var cbParamsList = [];
        var articleMarkup = createTooltipMarkup("section", {
          blocks: [],
          noHeader: true
        });
        var markupTextArrLegacy = [];
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        each$4(dataByCoordSys, function(itemCoordSys) {
          each$4(itemCoordSys.dataByAxis, function(axisItem) {
            var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
            var axisValue = axisItem.value;
            if (!axisModel || axisValue == null) {
              return;
            }
            var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
            var axisSectionMarkup = createTooltipMarkup("section", {
              header: axisValueLabel,
              noHeader: !trim$1(axisValueLabel),
              sortBlocks: true,
              blocks: []
            });
            articleMarkup.blocks.push(axisSectionMarkup);
            each$4(axisItem.seriesDataIndices, function(idxItem) {
              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
              var dataIndex = idxItem.dataIndexInside;
              var cbParams = series.getDataParams(dataIndex);
              if (cbParams.dataIndex < 0) {
                return;
              }
              cbParams.axisDim = axisItem.axisDim;
              cbParams.axisIndex = axisItem.axisIndex;
              cbParams.axisType = axisItem.axisType;
              cbParams.axisId = axisItem.axisId;
              cbParams.axisValue = getAxisRawValue(axisModel.axis, {
                value: axisValue
              });
              cbParams.axisValueLabel = axisValueLabel;
              cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
              var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
              var frag = seriesTooltipResult.frag;
              if (frag) {
                var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
                axisSectionMarkup.blocks.push(valueFormatter ? extend$1({
                  valueFormatter
                }, frag) : frag);
              }
              if (seriesTooltipResult.text) {
                markupTextArrLegacy.push(seriesTooltipResult.text);
              }
              cbParamsList.push(cbParams);
            });
          });
        });
        articleMarkup.blocks.reverse();
        markupTextArrLegacy.reverse();
        var positionExpr = e2.position;
        var orderMode = singleTooltipModel.get("order");
        var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
        builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
        var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
        var allMarkupText = markupTextArrLegacy.join(blockBreak);
        this._showOrMove(singleTooltipModel, function() {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
          } else {
            this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
          }
        });
      };
      TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction) {
        var ecModel = this._ecModel;
        var ecData = getECData(dispatcher);
        var seriesIndex = ecData.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        var dataModel = ecData.dataModel || seriesModel;
        var dataIndex = ecData.dataIndex;
        var dataType = ecData.dataType;
        var data = dataModel.getData(dataType);
        var renderMode = this._renderMode;
        var positionDefault = e2.positionDefault;
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
          position: positionDefault
        } : null);
        var tooltipTrigger = tooltipModel.get("trigger");
        if (tooltipTrigger != null && tooltipTrigger !== "item") {
          return;
        }
        var params2 = dataModel.getDataParams(dataIndex, dataType);
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        params2.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params2.color), renderMode);
        var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
        var orderMode = tooltipModel.get("order");
        var valueFormatter = tooltipModel.get("valueFormatter");
        var frag = seriesTooltipResult.frag;
        var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend$1({
          valueFormatter
        }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
        var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
        this._showOrMove(tooltipModel, function() {
          this._showTooltipContent(tooltipModel, markupText, params2, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
        });
        dispatchAction({
          type: "showTip",
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex,
          from: this.uid
        });
      };
      TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction) {
        var isHTMLRenderMode = this._renderMode === "html";
        var ecData = getECData(el);
        var tooltipConfig = ecData.tooltipConfig;
        var tooltipOpt = tooltipConfig.option || {};
        var encodeHTMLContent = tooltipOpt.encodeHTMLContent;
        if (isString$1(tooltipOpt)) {
          var content = tooltipOpt;
          tooltipOpt = {
            content,
            // Fixed formatter
            formatter: content
          };
          encodeHTMLContent = true;
        }
        if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {
          tooltipOpt = clone$4(tooltipOpt);
          tooltipOpt.content = encodeHTML(tooltipOpt.content);
        }
        var tooltipModelCascade = [tooltipOpt];
        var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
        if (cmpt) {
          tooltipModelCascade.push(cmpt);
        }
        tooltipModelCascade.push({
          formatter: tooltipOpt.content
        });
        var positionDefault = e2.positionDefault;
        var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
          position: positionDefault
        } : null);
        var defaultHtml = subTooltipModel.get("content");
        var asyncTicket = Math.random() + "";
        var markupStyleCreator = new TooltipMarkupStyleCreator();
        this._showOrMove(subTooltipModel, function() {
          var formatterParams = clone$4(subTooltipModel.get("formatterParams") || {});
          this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
        });
        dispatchAction({
          type: "showTip",
          from: this.uid
        });
      };
      TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params2, asyncTicket, x2, y2, positionExpr, el, markupStyleCreator) {
        this._ticket = "";
        if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
          return;
        }
        var tooltipContent = this._tooltipContent;
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        var formatter = tooltipModel.get("formatter");
        positionExpr = positionExpr || tooltipModel.get("position");
        var html = defaultHtml;
        var nearPoint = this._getNearestPoint([x2, y2], params2, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
        var nearPointColor = nearPoint.color;
        if (formatter) {
          if (isString$1(formatter)) {
            var useUTC = tooltipModel.ecModel.get("useUTC");
            var params0 = isArray$1(params2) ? params2[0] : params2;
            var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
            html = formatter;
            if (isTimeAxis) {
              html = format$1(params0.axisValue, html, useUTC);
            }
            html = formatTpl(html, params2, true);
          } else if (isFunction$1(formatter)) {
            var callback = bind$2(function(cbTicket, html2) {
              if (cbTicket === this._ticket) {
                tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
                this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params2, el);
              }
            }, this);
            this._ticket = asyncTicket;
            html = formatter(params2, asyncTicket, callback);
          } else {
            html = formatter;
          }
        }
        tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
        tooltipContent.show(tooltipModel, nearPointColor);
        this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params2, el);
      };
      TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger2, borderColor) {
        if (trigger2 === "axis" || isArray$1(tooltipDataParams)) {
          return {
            color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
          };
        }
        if (!isArray$1(tooltipDataParams)) {
          return {
            color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
          };
        }
      };
      TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x2, y2, content, params2, el) {
        var viewWidth = this._api.getWidth();
        var viewHeight = this._api.getHeight();
        positionExpr = positionExpr || tooltipModel.get("position");
        var contentSize = content.getSize();
        var align = tooltipModel.get("align");
        var vAlign = tooltipModel.get("verticalAlign");
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);
        if (isFunction$1(positionExpr)) {
          positionExpr = positionExpr([x2, y2], params2, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          });
        }
        if (isArray$1(positionExpr)) {
          x2 = parsePercent(positionExpr[0], viewWidth);
          y2 = parsePercent(positionExpr[1], viewHeight);
        } else if (isObject$3(positionExpr)) {
          var boxLayoutPosition = positionExpr;
          boxLayoutPosition.width = contentSize[0];
          boxLayoutPosition.height = contentSize[1];
          var layoutRect = getLayoutRect(boxLayoutPosition, {
            width: viewWidth,
            height: viewHeight
          });
          x2 = layoutRect.x;
          y2 = layoutRect.y;
          align = null;
          vAlign = null;
        } else if (isString$1(positionExpr) && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
          x2 = pos[0];
          y2 = pos[1];
        } else {
          var pos = refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
          x2 = pos[0];
          y2 = pos[1];
        }
        align && (x2 -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
        vAlign && (y2 -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
        if (shouldTooltipConfine(tooltipModel)) {
          var pos = confineTooltipPosition(x2, y2, content, viewWidth, viewHeight);
          x2 = pos[0];
          y2 = pos[1];
        }
        content.moveTo(x2, y2);
      };
      TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
        var lastCoordSys = this._lastDataByCoordSys;
        var lastCbParamsList = this._cbParamsList;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
        contentNotChanged && each$4(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
          var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
          contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
          contentNotChanged && each$4(lastDataByAxis, function(lastItem, indexAxis) {
            var thisItem = thisDataByAxis[indexAxis] || {};
            var lastIndices = lastItem.seriesDataIndices || [];
            var newIndices = thisItem.seriesDataIndices || [];
            contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
            contentNotChanged && each$4(lastIndices, function(lastIdxItem, j2) {
              var newIdxItem = newIndices[j2];
              contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
            });
            lastCbParamsList && each$4(lastItem.seriesDataIndices, function(idxItem) {
              var seriesIdx = idxItem.seriesIndex;
              var cbParams = cbParamsList[seriesIdx];
              var lastCbParams = lastCbParamsList[seriesIdx];
              if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
                contentNotChanged = false;
              }
            });
          });
        });
        this._lastDataByCoordSys = dataByCoordSys;
        this._cbParamsList = cbParamsList;
        return !!contentNotChanged;
      };
      TooltipView2.prototype._hide = function(dispatchAction) {
        this._lastDataByCoordSys = null;
        dispatchAction({
          type: "hideTip",
          from: this.uid
        });
      };
      TooltipView2.prototype.dispose = function(ecModel, api2) {
        if (env.node || !api2.getDom()) {
          return;
        }
        clear(this, "_updatePosition");
        this._tooltipContent.dispose();
        unregister("itemTooltip", api2);
      };
      TooltipView2.type = "tooltip";
      return TooltipView2;
    }(ComponentView)
  );
  function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
    var ecModel = globalTooltipModel.ecModel;
    var resultModel;
    if (defaultTooltipOption) {
      resultModel = new Model(defaultTooltipOption, ecModel, ecModel);
      resultModel = new Model(globalTooltipModel.option, resultModel, ecModel);
    } else {
      resultModel = globalTooltipModel;
    }
    for (var i2 = modelCascade.length - 1; i2 >= 0; i2--) {
      var tooltipOpt = modelCascade[i2];
      if (tooltipOpt) {
        if (tooltipOpt instanceof Model) {
          tooltipOpt = tooltipOpt.get("tooltip", true);
        }
        if (isString$1(tooltipOpt)) {
          tooltipOpt = {
            formatter: tooltipOpt
          };
        }
        if (tooltipOpt) {
          resultModel = new Model(tooltipOpt, resultModel, ecModel);
        }
      }
    }
    return resultModel;
  }
  function makeDispatchAction(payload, api2) {
    return payload.dispatchAction || bind$2(api2.dispatchAction, api2);
  }
  function refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, gapH, gapV) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    if (gapH != null) {
      if (x2 + width + gapH + 2 > viewWidth) {
        x2 -= width + gapH;
      } else {
        x2 += gapH;
      }
    }
    if (gapV != null) {
      if (y2 + height + gapV > viewHeight) {
        y2 -= height + gapV;
      } else {
        y2 += gapV;
      }
    }
    return [x2, y2];
  }
  function confineTooltipPosition(x2, y2, content, viewWidth, viewHeight) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    x2 = Math.min(x2 + width, viewWidth) - width;
    y2 = Math.min(y2 + height, viewHeight) - height;
    x2 = Math.max(x2, 0);
    y2 = Math.max(y2, 0);
    return [x2, y2];
  }
  function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var offset2 = Math.ceil(Math.SQRT2 * borderWidth) + 8;
    var x2 = 0;
    var y2 = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position2) {
      case "inside":
        x2 = rect.x + rectWidth / 2 - domWidth / 2;
        y2 = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "top":
        x2 = rect.x + rectWidth / 2 - domWidth / 2;
        y2 = rect.y - domHeight - offset2;
        break;
      case "bottom":
        x2 = rect.x + rectWidth / 2 - domWidth / 2;
        y2 = rect.y + rectHeight + offset2;
        break;
      case "left":
        x2 = rect.x - domWidth - offset2;
        y2 = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "right":
        x2 = rect.x + rectWidth + offset2;
        y2 = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x2, y2];
  }
  function isCenterAlign(align) {
    return align === "center" || align === "middle";
  }
  function findComponentReference(payload, ecModel, api2) {
    var queryOptionMap = preParseFinder(payload).queryOptionMap;
    var componentMainType = queryOptionMap.keys()[0];
    if (!componentMainType || componentMainType === "series") {
      return;
    }
    var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
      useDefault: false,
      enableAll: false,
      enableNone: false
    });
    var model = queryResult.models[0];
    if (!model) {
      return;
    }
    var view = api2.getViewOfComponentModel(model);
    var el;
    view.group.traverse(function(subEl) {
      var tooltipConfig = getECData(subEl).tooltipConfig;
      if (tooltipConfig && tooltipConfig.name === payload.name) {
        el = subEl;
        return true;
      }
    });
    if (el) {
      return {
        componentMainType,
        componentIndex: model.componentIndex,
        el
      };
    }
  }
  function install$7(registers) {
    use(install$a);
    registers.registerComponentModel(TooltipModel);
    registers.registerComponentView(TooltipView);
    registers.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, noop$1);
    registers.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, noop$1);
  }
  var TitleModel = (
    /** @class */
    function(_super) {
      __extends(TitleModel2, _super);
      function TitleModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TitleModel2.type;
        _this.layoutMode = {
          type: "box",
          ignoreSize: true
        };
        return _this;
      }
      TitleModel2.type = "title";
      TitleModel2.defaultOption = {
        // zlevel: 0,
        z: 6,
        show: true,
        text: "",
        target: "blank",
        subtext: "",
        subtarget: "blank",
        left: 0,
        top: 0,
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: "bold",
          color: "#464646"
        },
        subtextStyle: {
          fontSize: 12,
          color: "#6E7079"
        }
      };
      return TitleModel2;
    }(ComponentModel)
  );
  var TitleView = (
    /** @class */
    function(_super) {
      __extends(TitleView2, _super);
      function TitleView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = TitleView2.type;
        return _this;
      }
      TitleView2.prototype.render = function(titleModel, ecModel, api2) {
        this.group.removeAll();
        if (!titleModel.get("show")) {
          return;
        }
        var group = this.group;
        var textStyleModel = titleModel.getModel("textStyle");
        var subtextStyleModel = titleModel.getModel("subtextStyle");
        var textAlign = titleModel.get("textAlign");
        var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
        var textEl = new ZRText({
          style: createTextStyle$1(textStyleModel, {
            text: titleModel.get("text"),
            fill: textStyleModel.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var textRect = textEl.getBoundingRect();
        var subText = titleModel.get("subtext");
        var subTextEl = new ZRText({
          style: createTextStyle$1(subtextStyleModel, {
            text: subText,
            fill: subtextStyleModel.getTextColor(),
            y: textRect.height + titleModel.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var link = titleModel.get("link");
        var sublink = titleModel.get("sublink");
        var triggerEvent = titleModel.get("triggerEvent", true);
        textEl.silent = !link && !triggerEvent;
        subTextEl.silent = !sublink && !triggerEvent;
        if (link) {
          textEl.on("click", function() {
            windowOpen(link, "_" + titleModel.get("target"));
          });
        }
        if (sublink) {
          subTextEl.on("click", function() {
            windowOpen(sublink, "_" + titleModel.get("subtarget"));
          });
        }
        getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
          componentType: "title",
          componentIndex: titleModel.componentIndex
        } : null;
        group.add(textEl);
        subText && group.add(subTextEl);
        var groupRect = group.getBoundingRect();
        var layoutOption = titleModel.getBoxLayoutParams();
        layoutOption.width = groupRect.width;
        layoutOption.height = groupRect.height;
        var layoutRect = getLayoutRect(layoutOption, {
          width: api2.getWidth(),
          height: api2.getHeight()
        }, titleModel.get("padding"));
        if (!textAlign) {
          textAlign = titleModel.get("left") || titleModel.get("right");
          if (textAlign === "middle") {
            textAlign = "center";
          }
          if (textAlign === "right") {
            layoutRect.x += layoutRect.width;
          } else if (textAlign === "center") {
            layoutRect.x += layoutRect.width / 2;
          }
        }
        if (!textVerticalAlign) {
          textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
          if (textVerticalAlign === "center") {
            textVerticalAlign = "middle";
          }
          if (textVerticalAlign === "bottom") {
            layoutRect.y += layoutRect.height;
          } else if (textVerticalAlign === "middle") {
            layoutRect.y += layoutRect.height / 2;
          }
          textVerticalAlign = textVerticalAlign || "top";
        }
        group.x = layoutRect.x;
        group.y = layoutRect.y;
        group.markRedraw();
        var alignStyle = {
          align: textAlign,
          verticalAlign: textVerticalAlign
        };
        textEl.setStyle(alignStyle);
        subTextEl.setStyle(alignStyle);
        groupRect = group.getBoundingRect();
        var padding = layoutRect.margin;
        var style = titleModel.getItemStyle(["color", "opacity"]);
        style.fill = titleModel.get("backgroundColor");
        var rect = new Rect({
          shape: {
            x: groupRect.x - padding[3],
            y: groupRect.y - padding[0],
            width: groupRect.width + padding[1] + padding[3],
            height: groupRect.height + padding[0] + padding[2],
            r: titleModel.get("borderRadius")
          },
          style,
          subPixelOptimize: true,
          silent: true
        });
        group.add(rect);
      };
      TitleView2.type = "title";
      return TitleView2;
    }(ComponentView)
  );
  function install$6(registers) {
    registers.registerComponentModel(TitleModel);
    registers.registerComponentView(TitleView);
  }
  var getDefaultSelectorOptions = function(ecModel, type) {
    if (type === "all") {
      return {
        type: "all",
        title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
      };
    } else if (type === "inverse") {
      return {
        type: "inverse",
        title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
      };
    }
  };
  var LegendModel = (
    /** @class */
    function(_super) {
      __extends(LegendModel2, _super);
      function LegendModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LegendModel2.type;
        _this.layoutMode = {
          type: "box",
          // legend.width/height are maxWidth/maxHeight actually,
          // whereas real width/height is calculated by its content.
          // (Setting {left: 10, right: 10} does not make sense).
          // So consider the case:
          // `setOption({legend: {left: 10});`
          // then `setOption({legend: {right: 10});`
          // The previous `left` should be cleared by setting `ignoreSize`.
          ignoreSize: true
        };
        return _this;
      }
      LegendModel2.prototype.init = function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        option.selected = option.selected || {};
        this._updateSelector(option);
      };
      LegendModel2.prototype.mergeOption = function(option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel);
        this._updateSelector(option);
      };
      LegendModel2.prototype._updateSelector = function(option) {
        var selector = option.selector;
        var ecModel = this.ecModel;
        if (selector === true) {
          selector = option.selector = ["all", "inverse"];
        }
        if (isArray$1(selector)) {
          each$4(selector, function(item, index2) {
            isString$1(item) && (item = {
              type: item
            });
            selector[index2] = merge$1(item, getDefaultSelectorOptions(ecModel, item.type));
          });
        }
      };
      LegendModel2.prototype.optionUpdated = function() {
        this._updateData(this.ecModel);
        var legendData = this._data;
        if (legendData[0] && this.get("selectedMode") === "single") {
          var hasSelected = false;
          for (var i2 = 0; i2 < legendData.length; i2++) {
            var name_1 = legendData[i2].get("name");
            if (this.isSelected(name_1)) {
              this.select(name_1);
              hasSelected = true;
              break;
            }
          }
          !hasSelected && this.select(legendData[0].get("name"));
        }
      };
      LegendModel2.prototype._updateData = function(ecModel) {
        var potentialData = [];
        var availableNames = [];
        ecModel.eachRawSeries(function(seriesModel) {
          var seriesName = seriesModel.name;
          availableNames.push(seriesName);
          var isPotential;
          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;
            var names2 = provider.getAllNames();
            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names2);
            }
            if (names2.length) {
              potentialData = potentialData.concat(names2);
            } else {
              isPotential = true;
            }
          } else {
            isPotential = true;
          }
          if (isPotential && isNameSpecified(seriesModel)) {
            potentialData.push(seriesModel.name);
          }
        });
        this._availableNames = availableNames;
        var rawData = this.get("data") || potentialData;
        var legendNameMap = createHashMap();
        var legendData = map$1(rawData, function(dataItem) {
          if (isString$1(dataItem) || isNumber$1(dataItem)) {
            dataItem = {
              name: dataItem
            };
          }
          if (legendNameMap.get(dataItem.name)) {
            return null;
          }
          legendNameMap.set(dataItem.name, true);
          return new Model(dataItem, this, this.ecModel);
        }, this);
        this._data = filter(legendData, function(item) {
          return !!item;
        });
      };
      LegendModel2.prototype.getData = function() {
        return this._data;
      };
      LegendModel2.prototype.select = function(name) {
        var selected = this.option.selected;
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          var data = this._data;
          each$4(data, function(dataItem) {
            selected[dataItem.get("name")] = false;
          });
        }
        selected[name] = true;
      };
      LegendModel2.prototype.unSelect = function(name) {
        if (this.get("selectedMode") !== "single") {
          this.option.selected[name] = false;
        }
      };
      LegendModel2.prototype.toggleSelected = function(name) {
        var selected = this.option.selected;
        if (!selected.hasOwnProperty(name)) {
          selected[name] = true;
        }
        this[selected[name] ? "unSelect" : "select"](name);
      };
      LegendModel2.prototype.allSelect = function() {
        var data = this._data;
        var selected = this.option.selected;
        each$4(data, function(dataItem) {
          selected[dataItem.get("name", true)] = true;
        });
      };
      LegendModel2.prototype.inverseSelect = function() {
        var data = this._data;
        var selected = this.option.selected;
        each$4(data, function(dataItem) {
          var name = dataItem.get("name", true);
          if (!selected.hasOwnProperty(name)) {
            selected[name] = true;
          }
          selected[name] = !selected[name];
        });
      };
      LegendModel2.prototype.isSelected = function(name) {
        var selected = this.option.selected;
        return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
      };
      LegendModel2.prototype.getOrient = function() {
        return this.get("orient") === "vertical" ? {
          index: 1,
          name: "vertical"
        } : {
          index: 0,
          name: "horizontal"
        };
      };
      LegendModel2.type = "legend.plain";
      LegendModel2.dependencies = ["series"];
      LegendModel2.defaultOption = {
        // zlevel: 0,
        z: 4,
        show: true,
        orient: "horizontal",
        left: "center",
        // right: 'center',
        top: 0,
        // bottom: null,
        align: "auto",
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: "inherit",
        symbolKeepAspect: true,
        inactiveColor: "#ccc",
        inactiveBorderColor: "#ccc",
        inactiveBorderWidth: "auto",
        itemStyle: {
          color: "inherit",
          opacity: "inherit",
          borderColor: "inherit",
          borderWidth: "auto",
          borderCap: "inherit",
          borderJoin: "inherit",
          borderDashOffset: "inherit",
          borderMiterLimit: "inherit"
        },
        lineStyle: {
          width: "auto",
          color: "inherit",
          inactiveColor: "#ccc",
          inactiveWidth: 2,
          opacity: "inherit",
          type: "inherit",
          cap: "inherit",
          join: "inherit",
          dashOffset: "inherit",
          miterLimit: "inherit"
        },
        textStyle: {
          color: "#333"
        },
        selectedMode: true,
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: "sans-serif",
          color: "#666",
          borderWidth: 1,
          borderColor: "#666"
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: "#eee",
            backgroundColor: "#666"
          }
        },
        selectorPosition: "auto",
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: false
        }
      };
      return LegendModel2;
    }(ComponentModel)
  );
  var curry = curry$1;
  var each = each$4;
  var Group$1 = Group$2;
  var LegendView = (
    /** @class */
    function(_super) {
      __extends(LegendView2, _super);
      function LegendView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LegendView2.type;
        _this.newlineDisabled = false;
        return _this;
      }
      LegendView2.prototype.init = function() {
        this.group.add(this._contentGroup = new Group$1());
        this.group.add(this._selectorGroup = new Group$1());
        this._isFirstRender = true;
      };
      LegendView2.prototype.getContentGroup = function() {
        return this._contentGroup;
      };
      LegendView2.prototype.getSelectorGroup = function() {
        return this._selectorGroup;
      };
      LegendView2.prototype.render = function(legendModel, ecModel, api2) {
        var isFirstRender = this._isFirstRender;
        this._isFirstRender = false;
        this.resetInner();
        if (!legendModel.get("show", true)) {
          return;
        }
        var itemAlign = legendModel.get("align");
        var orient = legendModel.get("orient");
        if (!itemAlign || itemAlign === "auto") {
          itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
        }
        var selector = legendModel.get("selector", true);
        var selectorPosition = legendModel.get("selectorPosition", true);
        if (selector && (!selectorPosition || selectorPosition === "auto")) {
          selectorPosition = orient === "horizontal" ? "end" : "start";
        }
        this.renderInner(itemAlign, legendModel, ecModel, api2, selector, orient, selectorPosition);
        var positionInfo = legendModel.getBoxLayoutParams();
        var viewportSize = {
          width: api2.getWidth(),
          height: api2.getHeight()
        };
        var padding = legendModel.get("padding");
        var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
        var layoutRect = getLayoutRect(defaults$1({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), viewportSize, padding);
        this.group.x = layoutRect.x - mainRect.x;
        this.group.y = layoutRect.y - mainRect.y;
        this.group.markRedraw();
        this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
      };
      LegendView2.prototype.resetInner = function() {
        this.getContentGroup().removeAll();
        this._backgroundEl && this.group.remove(this._backgroundEl);
        this.getSelectorGroup().removeAll();
      };
      LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api2, selector, orient, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var legendDrawnMap = createHashMap();
        var selectMode = legendModel.get("selectedMode");
        var excludeSeriesId = [];
        ecModel.eachRawSeries(function(seriesModel) {
          !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
        });
        each(legendModel.getData(), function(legendItemModel, dataIndex) {
          var name = legendItemModel.get("name");
          if (!this.newlineDisabled && (name === "" || name === "\n")) {
            var g2 = new Group$1();
            g2.newline = true;
            contentGroup.add(g2);
            return;
          }
          var seriesModel = ecModel.getSeriesByName(name)[0];
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel) {
            var data = seriesModel.getData();
            var lineVisualStyle = data.getVisual("legendLineStyle") || {};
            var legendIcon = data.getVisual("legendIcon");
            var style = data.getVisual("style");
            var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api2);
            itemGroup.on("click", curry(dispatchSelectAction, name, null, api2, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api2, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api2, excludeSeriesId));
            if (ecModel.ssr) {
              itemGroup.eachChild(function(child) {
                var ecData = getECData(child);
                ecData.seriesIndex = seriesModel.seriesIndex;
                ecData.dataIndex = dataIndex;
                ecData.ssrType = "legend";
              });
            }
            legendDrawnMap.set(name, true);
          } else {
            ecModel.eachRawSeries(function(seriesModel2) {
              if (legendDrawnMap.get(name)) {
                return;
              }
              if (seriesModel2.legendVisualProvider) {
                var provider = seriesModel2.legendVisualProvider;
                if (!provider.containName(name)) {
                  return;
                }
                var idx = provider.indexOfName(name);
                var style2 = provider.getItemVisual(idx, "style");
                var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
                var colorArr = parse(style2.fill);
                if (colorArr && colorArr[3] === 0) {
                  colorArr[3] = 0.2;
                  style2 = extend$1(extend$1({}, style2), {
                    fill: stringify(colorArr, "rgba")
                  });
                }
                var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api2);
                itemGroup2.on("click", curry(dispatchSelectAction, null, name, api2, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name, api2, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name, api2, excludeSeriesId));
                if (ecModel.ssr) {
                  itemGroup2.eachChild(function(child) {
                    var ecData = getECData(child);
                    ecData.seriesIndex = seriesModel2.seriesIndex;
                    ecData.dataIndex = dataIndex;
                    ecData.ssrType = "legend";
                  });
                }
                legendDrawnMap.set(name, true);
              }
            }, this);
          }
        }, this);
        if (selector) {
          this._createSelector(selector, legendModel, api2, orient, selectorPosition);
        }
      };
      LegendView2.prototype._createSelector = function(selector, legendModel, api2, orient, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        each(selector, function createSelectorButton(selectorItem) {
          var type = selectorItem.type;
          var labelText = new ZRText({
            style: {
              x: 0,
              y: 0,
              align: "center",
              verticalAlign: "middle"
            },
            onclick: function() {
              api2.dispatchAction({
                type: type === "all" ? "legendAllSelect" : "legendInverseSelect",
                legendId: legendModel.id
              });
            }
          });
          selectorGroup.add(labelText);
          var labelModel = legendModel.getModel("selectorLabel");
          var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
          setLabelStyle(labelText, {
            normal: labelModel,
            emphasis: emphasisLabelModel
          }, {
            defaultText: selectorItem.title
          });
          enableHoverEmphasis(labelText);
        });
      };
      LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api2) {
        var drawType = seriesModel.visualDrawType;
        var itemWidth = legendModel.get("itemWidth");
        var itemHeight = legendModel.get("itemHeight");
        var isSelected = legendModel.isSelected(name);
        var iconRotate = legendItemModel.get("symbolRotate");
        var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
        var legendIconType = legendItemModel.get("icon");
        legendIcon = legendIconType || legendIcon || "roundRect";
        var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2);
        var itemGroup = new Group$1();
        var textStyleModel = legendItemModel.getModel("textStyle");
        if (isFunction$1(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
          itemGroup.add(seriesModel.getLegendIcon({
            itemWidth,
            itemHeight,
            icon: legendIcon,
            iconRotate,
            itemStyle: style.itemStyle,
            lineStyle: style.lineStyle,
            symbolKeepAspect
          }));
        } else {
          var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
          itemGroup.add(getDefaultLegendIcon({
            itemWidth,
            itemHeight,
            icon: legendIcon,
            iconRotate: rotate2,
            itemStyle: style.itemStyle,
            symbolKeepAspect
          }));
        }
        var textX = itemAlign === "left" ? itemWidth + 5 : -5;
        var textAlign = itemAlign;
        var formatter = legendModel.get("formatter");
        var content = name;
        if (isString$1(formatter) && formatter) {
          content = formatter.replace("{name}", name != null ? name : "");
        } else if (isFunction$1(formatter)) {
          content = formatter(name);
        }
        var textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
        itemGroup.add(new ZRText({
          style: createTextStyle$1(textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            fill: textColor,
            align: textAlign,
            verticalAlign: "middle"
          }, {
            inheritColor: textColor
          })
        }));
        var hitRect = new Rect({
          shape: itemGroup.getBoundingRect(),
          style: {
            // Cannot use 'invisible' because SVG SSR will miss the node
            fill: "transparent"
          }
        });
        var tooltipModel = legendItemModel.getModel("tooltip");
        if (tooltipModel.get("show")) {
          setTooltipConfig({
            el: hitRect,
            componentModel: legendModel,
            itemName: name,
            itemTooltipOption: tooltipModel.option
          });
        }
        itemGroup.add(hitRect);
        itemGroup.eachChild(function(child) {
          child.silent = true;
        });
        hitRect.silent = !selectMode;
        this.getContentGroup().add(itemGroup);
        enableHoverEmphasis(itemGroup);
        itemGroup.__legendDataIndex = dataIndex;
        return itemGroup;
      };
      LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var selectorGroup = this.getSelectorGroup();
        box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
        var contentRect = contentGroup.getBoundingRect();
        var contentPos = [-contentRect.x, -contentRect.y];
        selectorGroup.markRedraw();
        contentGroup.markRedraw();
        if (selector) {
          box(
            // Buttons in selectorGroup always layout horizontally
            "horizontal",
            selectorGroup,
            legendModel.get("selectorItemGap", true)
          );
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var selectorButtonGap = legendModel.get("selectorButtonGap", true);
          var orientIdx = legendModel.getOrient().index;
          var wh = orientIdx === 0 ? "width" : "height";
          var hw = orientIdx === 0 ? "height" : "width";
          var yx = orientIdx === 0 ? "y" : "x";
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
          }
          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
          selectorGroup.x = selectorPos[0];
          selectorGroup.y = selectorPos[1];
          contentGroup.x = contentPos[0];
          contentGroup.y = contentPos[1];
          var mainRect = {
            x: 0,
            y: 0
          };
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
          return mainRect;
        } else {
          contentGroup.x = contentPos[0];
          contentGroup.y = contentPos[1];
          return this.group.getBoundingRect();
        }
      };
      LegendView2.prototype.remove = function() {
        this.getContentGroup().removeAll();
        this._isFirstRender = true;
      };
      LegendView2.type = "legend.plain";
      return LegendView2;
    }(ComponentView)
  );
  function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2) {
    function handleCommonProps(style, visualStyle) {
      if (style.lineWidth === "auto") {
        style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
      }
      each(style, function(propVal, propName) {
        style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
      });
    }
    var itemStyleModel = legendItemModel.getModel("itemStyle");
    var itemStyle = itemStyleModel.getItemStyle();
    var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
    var decalStyle = itemStyleModel.getShallow("decal");
    itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api2);
    if (itemStyle.fill === "inherit") {
      itemStyle.fill = itemVisualStyle[drawType];
    }
    if (itemStyle.stroke === "inherit") {
      itemStyle.stroke = itemVisualStyle[iconBrushType];
    }
    if (itemStyle.opacity === "inherit") {
      itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
    }
    handleCommonProps(itemStyle, itemVisualStyle);
    var legendLineModel = legendItemModel.getModel("lineStyle");
    var lineStyle = legendLineModel.getLineStyle();
    handleCommonProps(lineStyle, lineVisualStyle);
    itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
    itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
    lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
    if (!isSelected) {
      var borderWidth = legendItemModel.get("inactiveBorderWidth");
      var visualHasBorder = itemStyle[iconBrushType];
      itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
      itemStyle.fill = legendItemModel.get("inactiveColor");
      itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
      lineStyle.stroke = legendLineModel.get("inactiveColor");
      lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
    }
    return {
      itemStyle,
      lineStyle
    };
  }
  function getDefaultLegendIcon(opt) {
    var symboType = opt.icon || "roundRect";
    var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
    icon.setStyle(opt.itemStyle);
    icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
    icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symboType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  }
  function dispatchSelectAction(seriesName, dataName, api2, excludeSeriesId) {
    dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId);
    api2.dispatchAction({
      type: "legendToggleSelect",
      name: seriesName != null ? seriesName : dataName
    });
    dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId);
  }
  function isUseHoverLayer(api2) {
    var list2 = api2.getZr().storage.getDisplayList();
    var emphasisState;
    var i2 = 0;
    var len2 = list2.length;
    while (i2 < len2 && !(emphasisState = list2[i2].states.emphasis)) {
      i2++;
    }
    return emphasisState && emphasisState.hoverLayer;
  }
  function dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId) {
    if (!isUseHoverLayer(api2)) {
      api2.dispatchAction({
        type: "highlight",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId) {
    if (!isUseHoverLayer(api2)) {
      api2.dispatchAction({
        type: "downplay",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function legendFilter(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function(series) {
        for (var i2 = 0; i2 < legendModels.length; i2++) {
          if (!legendModels[i2].isSelected(series.name)) {
            return false;
          }
        }
        return true;
      });
    }
  }
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var isAllSelect = methodName === "allSelect" || methodName === "inverseSelect";
    var selectedMap = {};
    var actionLegendIndices = [];
    ecModel.eachComponent({
      mainType: "legend",
      query: payload
    }, function(legendModel) {
      if (isAllSelect) {
        legendModel[methodName]();
      } else {
        legendModel[methodName](payload.name);
      }
      makeSelectedMap(legendModel, selectedMap);
      actionLegendIndices.push(legendModel.componentIndex);
    });
    var allSelectedMap = {};
    ecModel.eachComponent("legend", function(legendModel) {
      each$4(selectedMap, function(isSelected, name) {
        legendModel[isSelected ? "select" : "unSelect"](name);
      });
      makeSelectedMap(legendModel, allSelectedMap);
    });
    return isAllSelect ? {
      selected: allSelectedMap,
      // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
      legendIndex: actionLegendIndices
    } : {
      name: payload.name,
      selected: allSelectedMap
    };
  }
  function makeSelectedMap(legendModel, out2) {
    var selectedMap = out2 || {};
    each$4(legendModel.getData(), function(model) {
      var name = model.get("name");
      if (name === "\n" || name === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name);
      if (hasOwn(selectedMap, name)) {
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
    return selectedMap;
  }
  function installLegendAction(registers) {
    registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
    registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
    registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
    registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
    registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
  }
  function install$5(registers) {
    registers.registerComponentModel(LegendModel);
    registers.registerComponentView(LegendView);
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    registers.registerSubTypeDefaulter("legend", function() {
      return "plain";
    });
    installLegendAction(registers);
  }
  var ScrollableLegendModel = (
    /** @class */
    function(_super) {
      __extends(ScrollableLegendModel2, _super);
      function ScrollableLegendModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScrollableLegendModel2.type;
        return _this;
      }
      ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex;
      };
      ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
        var inputPositionParams = getLayoutParams(option);
        _super.prototype.init.call(this, option, parentModel, ecModel);
        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
      };
      ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel);
        mergeAndNormalizeLayoutParams(this, this.option, option);
      };
      ScrollableLegendModel2.type = "legend.scroll";
      ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel.defaultOption, {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: "end",
        pageFormatter: "{current}/{total}",
        pageIcons: {
          horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
          vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
        },
        pageIconColor: "#2f4554",
        pageIconInactiveColor: "#aaa",
        pageIconSize: 15,
        pageTextStyle: {
          color: "#333"
        },
        animationDurationUpdate: 800
      });
      return ScrollableLegendModel2;
    }(LegendModel)
  );
  function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
    var orient = legendModel.getOrient();
    var ignoreSize = [1, 1];
    ignoreSize[orient.index] = 0;
    mergeLayoutParam(target, raw, {
      type: "box",
      ignoreSize: !!ignoreSize
    });
  }
  var Group = Group$2;
  var WH = ["width", "height"];
  var XY = ["x", "y"];
  var ScrollableLegendView = (
    /** @class */
    function(_super) {
      __extends(ScrollableLegendView2, _super);
      function ScrollableLegendView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = ScrollableLegendView2.type;
        _this.newlineDisabled = true;
        _this._currentIndex = 0;
        return _this;
      }
      ScrollableLegendView2.prototype.init = function() {
        _super.prototype.init.call(this);
        this.group.add(this._containerGroup = new Group());
        this._containerGroup.add(this.getContentGroup());
        this.group.add(this._controllerGroup = new Group());
      };
      ScrollableLegendView2.prototype.resetInner = function() {
        _super.prototype.resetInner.call(this);
        this._controllerGroup.removeAll();
        this._containerGroup.removeClipPath();
        this._containerGroup.__rectSize = null;
      };
      ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api2, selector, orient, selectorPosition) {
        var self2 = this;
        _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api2, selector, orient, selectorPosition);
        var controllerGroup = this._controllerGroup;
        var pageIconSize = legendModel.get("pageIconSize", true);
        var pageIconSizeArr = isArray$1(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
        createPageButton("pagePrev", 0);
        var pageTextStyleModel = legendModel.getModel("pageTextStyle");
        controllerGroup.add(new ZRText({
          name: "pageText",
          style: {
            // Placeholder to calculate a proper layout.
            text: "xx/xx",
            fill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            verticalAlign: "middle",
            align: "center"
          },
          silent: true
        }));
        createPageButton("pageNext", 1);
        function createPageButton(name, iconIdx) {
          var pageDataIndexName = name + "DataIndex";
          var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
            // Buttons will be created in each render, so we do not need
            // to worry about avoiding using legendModel kept in scope.
            onclick: bind$2(self2._pageGo, self2, pageDataIndexName, legendModel, api2)
          }, {
            x: -pageIconSizeArr[0] / 2,
            y: -pageIconSizeArr[1] / 2,
            width: pageIconSizeArr[0],
            height: pageIconSizeArr[1]
          });
          icon.name = name;
          controllerGroup.add(icon);
        }
      };
      ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var hw = WH[1 - orientIdx];
        var yx = XY[1 - orientIdx];
        selector && box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          selectorGroup,
          legendModel.get("selectorItemGap", true)
        );
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var processMaxSize = clone$4(maxSize);
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
        if (selector) {
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
          } else {
            var offset2 = selectorRect[wh] + selectorButtonGap;
            selectorPos[orientIdx] -= offset2;
            mainRect[xy] -= offset2;
          }
          mainRect[wh] += selectorRect[wh] + selectorButtonGap;
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
          selectorGroup.x = selectorPos[0];
          selectorGroup.y = selectorPos[1];
          selectorGroup.markRedraw();
        }
        return mainRect;
      };
      ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
        var contentGroup = this.getContentGroup();
        var containerGroup = this._containerGroup;
        var controllerGroup = this._controllerGroup;
        box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
        box(
          // Buttons in controller are layout always horizontally.
          "horizontal",
          controllerGroup,
          legendModel.get("pageButtonItemGap", true)
        );
        var contentRect = contentGroup.getBoundingRect();
        var controllerRect = controllerGroup.getBoundingRect();
        var showController = this._showController = contentRect[wh] > maxSize[wh];
        var contentPos = [-contentRect.x, -contentRect.y];
        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup[xy];
        }
        var containerPos = [0, 0];
        var controllerPos = [-controllerRect.x, -controllerRect.y];
        var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
        if (showController) {
          var pageButtonPosition = legendModel.get("pageButtonPosition", true);
          if (pageButtonPosition === "end") {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
          } else {
            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
          }
        }
        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
        contentGroup.setPosition(contentPos);
        containerGroup.setPosition(containerPos);
        controllerGroup.setPosition(controllerPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
        containerGroup.__rectSize = maxSize[wh];
        if (showController) {
          var clipShape = {
            x: 0,
            y: 0
          };
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
          clipShape[hw] = mainRect[hw];
          containerGroup.setClipPath(new Rect({
            shape: clipShape
          }));
          containerGroup.__rectSize = clipShape[wh];
        } else {
          controllerGroup.eachChild(function(child) {
            child.attr({
              invisible: true,
              silent: true
            });
          });
        }
        var pageInfo = this._getPageInfo(legendModel);
        pageInfo.pageIndex != null && updateProps$1(
          contentGroup,
          {
            x: pageInfo.contentPosition[0],
            y: pageInfo.contentPosition[1]
          },
          // When switch from "show controller" to "not show controller", view should be
          // updated immediately without animation, otherwise causes weird effect.
          showController ? legendModel : null
        );
        this._updatePageInfoView(legendModel, pageInfo);
        return mainRect;
      };
      ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api2) {
        var scrollDataIndex = this._getPageInfo(legendModel)[to];
        scrollDataIndex != null && api2.dispatchAction({
          type: "legendScroll",
          scrollDataIndex,
          legendId: legendModel.id
        });
      };
      ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
        var controllerGroup = this._controllerGroup;
        each$4(["pagePrev", "pageNext"], function(name) {
          var key2 = name + "DataIndex";
          var canJump = pageInfo[key2] != null;
          var icon = controllerGroup.childOfName(name);
          if (icon) {
            icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
            icon.cursor = canJump ? "pointer" : "default";
          }
        });
        var pageText = controllerGroup.childOfName("pageText");
        var pageFormatter = legendModel.get("pageFormatter");
        var pageIndex = pageInfo.pageIndex;
        var current = pageIndex != null ? pageIndex + 1 : 0;
        var total = pageInfo.pageCount;
        pageText && pageFormatter && pageText.setStyle("text", isString$1(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
          current,
          total
        }));
      };
      ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
        var scrollDataIndex = legendModel.get("scrollDataIndex", true);
        var contentGroup = this.getContentGroup();
        var containerRectSize = this._containerGroup.__rectSize;
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
        var children = contentGroup.children();
        var targetItem = children[targetItemIndex];
        var itemCount = children.length;
        var pCount = !itemCount ? 0 : 1;
        var result = {
          contentPosition: [contentGroup.x, contentGroup.y],
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        };
        if (!targetItem) {
          return result;
        }
        var targetItemInfo = getItemInfo(targetItem);
        result.contentPosition[orientIdx] = -targetItemInfo.s;
        for (var i2 = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i2 <= itemCount; ++i2) {
          currItemInfo = getItemInfo(children[i2]);
          if (
            // Half of the last item is out of the window.
            !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)
          ) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo;
            } else {
              winStartItemInfo = currItemInfo;
            }
            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i;
              }
              ++result.pageCount;
            }
          }
          winEndItemInfo = currItemInfo;
        }
        for (var i2 = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i2 >= -1; --i2) {
          currItemInfo = getItemInfo(children[i2]);
          if (
            // If the the end item does not intersect with the window started
            // from the current item, a page can be settled.
            (!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i
          ) {
            winEndItemInfo = winStartItemInfo;
            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
            ++result.pageIndex;
          }
          winStartItemInfo = currItemInfo;
        }
        return result;
        function getItemInfo(el) {
          if (el) {
            var itemRect = el.getBoundingRect();
            var start2 = itemRect[xy] + el[xy];
            return {
              s: start2,
              e: start2 + itemRect[wh],
              i: el.__legendDataIndex
            };
          }
        }
        function intersect2(itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
        }
      };
      ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
        if (!this._showController) {
          return 0;
        }
        var index2;
        var contentGroup = this.getContentGroup();
        var defaultIndex;
        contentGroup.eachChild(function(child, idx) {
          var legendDataIdx = child.__legendDataIndex;
          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx;
          }
          if (legendDataIdx === targetDataIndex) {
            index2 = idx;
          }
        });
        return index2 != null ? index2 : defaultIndex;
      };
      ScrollableLegendView2.type = "legend.scroll";
      return ScrollableLegendView2;
    }(LegendView)
  );
  function installScrollableLegendAction(registers) {
    registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: payload
      }, function(legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });
  }
  function install$4(registers) {
    use(install$5);
    registers.registerComponentModel(ScrollableLegendModel);
    registers.registerComponentView(ScrollableLegendView);
    installScrollableLegendAction(registers);
  }
  function install$3(registers) {
    use(install$5);
    use(install$4);
  }
  var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
    value: "eq",
    // PENDING: not good for literal semantic?
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
    // Might be misleading for sake of the difference between '==' and '===',
    // so don't support them.
    // '==': 'eq',
    // '===': 'seq',
    // '!==': 'sne'
    // PENDING: Whether support some common alias "ge", "le", "neq"?
    // ge: 'gte',
    // le: 'lte',
    // neq: 'ne',
  };
  var RegExpEvaluator = (
    /** @class */
    function() {
      function RegExpEvaluator2(rVal) {
        var condValue = this._condVal = isString$1(rVal) ? new RegExp(rVal) : isRegExp$1(rVal) ? rVal : null;
        if (condValue == null) {
          var errMsg = "";
          throwError(errMsg);
        }
      }
      RegExpEvaluator2.prototype.evaluate = function(lVal) {
        var type = typeof lVal;
        return isString$1(type) ? this._condVal.test(lVal) : isNumber$1(type) ? this._condVal.test(lVal + "") : false;
      };
      return RegExpEvaluator2;
    }()
  );
  var ConstConditionInternal = (
    /** @class */
    function() {
      function ConstConditionInternal2() {
      }
      ConstConditionInternal2.prototype.evaluate = function() {
        return this.value;
      };
      return ConstConditionInternal2;
    }()
  );
  var AndConditionInternal = (
    /** @class */
    function() {
      function AndConditionInternal2() {
      }
      AndConditionInternal2.prototype.evaluate = function() {
        var children = this.children;
        for (var i2 = 0; i2 < children.length; i2++) {
          if (!children[i2].evaluate()) {
            return false;
          }
        }
        return true;
      };
      return AndConditionInternal2;
    }()
  );
  var OrConditionInternal = (
    /** @class */
    function() {
      function OrConditionInternal2() {
      }
      OrConditionInternal2.prototype.evaluate = function() {
        var children = this.children;
        for (var i2 = 0; i2 < children.length; i2++) {
          if (children[i2].evaluate()) {
            return true;
          }
        }
        return false;
      };
      return OrConditionInternal2;
    }()
  );
  var NotConditionInternal = (
    /** @class */
    function() {
      function NotConditionInternal2() {
      }
      NotConditionInternal2.prototype.evaluate = function() {
        return !this.child.evaluate();
      };
      return NotConditionInternal2;
    }()
  );
  var RelationalConditionInternal = (
    /** @class */
    function() {
      function RelationalConditionInternal2() {
      }
      RelationalConditionInternal2.prototype.evaluate = function() {
        var needParse = !!this.valueParser;
        var getValue2 = this.getValue;
        var tarValRaw = getValue2(this.valueGetterParam);
        var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
        for (var i2 = 0; i2 < this.subCondList.length; i2++) {
          if (!this.subCondList[i2].evaluate(needParse ? tarValParsed : tarValRaw)) {
            return false;
          }
        }
        return true;
      };
      return RelationalConditionInternal2;
    }()
  );
  function parseOption(exprOption, getters) {
    if (exprOption === true || exprOption === false) {
      var cond = new ConstConditionInternal();
      cond.value = exprOption;
      return cond;
    }
    var errMsg = "";
    if (!isObjectNotArray(exprOption)) {
      throwError(errMsg);
    }
    if (exprOption.and) {
      return parseAndOrOption("and", exprOption, getters);
    } else if (exprOption.or) {
      return parseAndOrOption("or", exprOption, getters);
    } else if (exprOption.not) {
      return parseNotOption(exprOption, getters);
    }
    return parseRelationalOption(exprOption, getters);
  }
  function parseAndOrOption(op, exprOption, getters) {
    var subOptionArr = exprOption[op];
    var errMsg = "";
    if (!isArray$1(subOptionArr)) {
      throwError(errMsg);
    }
    if (!subOptionArr.length) {
      throwError(errMsg);
    }
    var cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
    cond.children = map$1(subOptionArr, function(subOption) {
      return parseOption(subOption, getters);
    });
    if (!cond.children.length) {
      throwError(errMsg);
    }
    return cond;
  }
  function parseNotOption(exprOption, getters) {
    var subOption = exprOption.not;
    var errMsg = "";
    if (!isObjectNotArray(subOption)) {
      throwError(errMsg);
    }
    var cond = new NotConditionInternal();
    cond.child = parseOption(subOption, getters);
    if (!cond.child) {
      throwError(errMsg);
    }
    return cond;
  }
  function parseRelationalOption(exprOption, getters) {
    var errMsg = "";
    var valueGetterParam = getters.prepareGetValue(exprOption);
    var subCondList = [];
    var exprKeys = keys(exprOption);
    var parserName = exprOption.parser;
    var valueParser = parserName ? getRawValueParser(parserName) : null;
    for (var i2 = 0; i2 < exprKeys.length; i2++) {
      var keyRaw = exprKeys[i2];
      if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
        continue;
      }
      var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
      var condValueRaw = exprOption[keyRaw];
      var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
      var evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
      if (!evaluator) {
        throwError(errMsg);
      }
      subCondList.push(evaluator);
    }
    if (!subCondList.length) {
      throwError(errMsg);
    }
    var cond = new RelationalConditionInternal();
    cond.valueGetterParam = valueGetterParam;
    cond.valueParser = valueParser;
    cond.getValue = getters.getValue;
    cond.subCondList = subCondList;
    return cond;
  }
  function isObjectNotArray(val) {
    return isObject$3(val) && !isArrayLike(val);
  }
  var ConditionalExpressionParsed = (
    /** @class */
    function() {
      function ConditionalExpressionParsed2(exprOption, getters) {
        this._cond = parseOption(exprOption, getters);
      }
      ConditionalExpressionParsed2.prototype.evaluate = function() {
        return this._cond.evaluate();
      };
      return ConditionalExpressionParsed2;
    }()
  );
  function parseConditionalExpression(exprOption, getters) {
    return new ConditionalExpressionParsed(exprOption, getters);
  }
  var filterTransform = {
    type: "echarts:filter",
    // PENDING: enhance to filter by index rather than create new data
    transform: function(params2) {
      var upstream = params2.upstream;
      var rawItem;
      var condition = parseConditionalExpression(params2.config, {
        valueGetterAttrMap: createHashMap({
          dimension: true
        }),
        prepareGetValue: function(exprOption) {
          var errMsg = "";
          var dimLoose = exprOption.dimension;
          if (!hasOwn(exprOption, "dimension")) {
            throwError(errMsg);
          }
          var dimInfo = upstream.getDimensionInfo(dimLoose);
          if (!dimInfo) {
            throwError(errMsg);
          }
          return {
            dimIdx: dimInfo.index
          };
        },
        getValue: function(param) {
          return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
        }
      });
      var resultData = [];
      for (var i2 = 0, len2 = upstream.count(); i2 < len2; i2++) {
        rawItem = upstream.getRawDataItem(i2);
        if (condition.evaluate()) {
          resultData.push(rawItem);
        }
      }
      return {
        data: resultData
      };
    }
  };
  var sortTransform = {
    type: "echarts:sort",
    transform: function(params2) {
      var upstream = params2.upstream;
      var config = params2.config;
      var errMsg = "";
      var orderExprList = normalizeToArray(config);
      if (!orderExprList.length) {
        throwError(errMsg);
      }
      var orderDefList = [];
      each$4(orderExprList, function(orderExpr) {
        var dimLoose = orderExpr.dimension;
        var order = orderExpr.order;
        var parserName = orderExpr.parser;
        var incomparable = orderExpr.incomparable;
        if (dimLoose == null) {
          throwError(errMsg);
        }
        if (order !== "asc" && order !== "desc") {
          throwError(errMsg);
        }
        if (incomparable && incomparable !== "min" && incomparable !== "max") {
          var errMsg_1 = "";
          throwError(errMsg_1);
        }
        if (order !== "asc" && order !== "desc") {
          var errMsg_2 = "";
          throwError(errMsg_2);
        }
        var dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          throwError(errMsg);
        }
        var parser = parserName ? getRawValueParser(parserName) : null;
        if (parserName && !parser) {
          throwError(errMsg);
        }
        orderDefList.push({
          dimIdx: dimInfo.index,
          parser,
          comparator: new SortOrderComparator(order, incomparable)
        });
      });
      var sourceFormat = upstream.sourceFormat;
      if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
        throwError(errMsg);
      }
      var resultData = [];
      for (var i2 = 0, len2 = upstream.count(); i2 < len2; i2++) {
        resultData.push(upstream.getRawDataItem(i2));
      }
      resultData.sort(function(item0, item1) {
        for (var i22 = 0; i22 < orderDefList.length; i22++) {
          var orderDef = orderDefList[i22];
          var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
          var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
          if (orderDef.parser) {
            val0 = orderDef.parser(val0);
            val1 = orderDef.parser(val1);
          }
          var result = orderDef.comparator.evaluate(val0, val1);
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      });
      return {
        data: resultData
      };
    }
  };
  function install$2(registers) {
    registers.registerTransform(filterTransform);
    registers.registerTransform(sortTransform);
  }
  var DatasetModel = (
    /** @class */
    function(_super) {
      __extends(DatasetModel2, _super);
      function DatasetModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "dataset";
        return _this;
      }
      DatasetModel2.prototype.init = function(option, parentModel, ecModel) {
        _super.prototype.init.call(this, option, parentModel, ecModel);
        this._sourceManager = new SourceManager(this);
        disableTransformOptionMerge(this);
      };
      DatasetModel2.prototype.mergeOption = function(newOption, ecModel) {
        _super.prototype.mergeOption.call(this, newOption, ecModel);
        disableTransformOptionMerge(this);
      };
      DatasetModel2.prototype.optionUpdated = function() {
        this._sourceManager.dirty();
      };
      DatasetModel2.prototype.getSourceManager = function() {
        return this._sourceManager;
      };
      DatasetModel2.type = "dataset";
      DatasetModel2.defaultOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
      };
      return DatasetModel2;
    }(ComponentModel)
  );
  var DatasetView = (
    /** @class */
    function(_super) {
      __extends(DatasetView2, _super);
      function DatasetView2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "dataset";
        return _this;
      }
      DatasetView2.type = "dataset";
      return DatasetView2;
    }(ComponentView)
  );
  function install$1(registers) {
    registers.registerComponentModel(DatasetModel);
    registers.registerComponentView(DatasetView);
  }
  var CMD = PathProxy.CMD;
  function aroundEqual(a2, b2) {
    return Math.abs(a2 - b2) < 1e-5;
  }
  function pathToBezierCurves(path) {
    var data = path.data;
    var len2 = path.len();
    var bezierArrayGroups = [];
    var currentSubpath;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    function createNewSubpath(x3, y3) {
      if (currentSubpath && currentSubpath.length > 2) {
        bezierArrayGroups.push(currentSubpath);
      }
      currentSubpath = [x3, y3];
    }
    function addLine(x02, y02, x12, y12) {
      if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
        currentSubpath.push(x02, y02, x12, y12, x12, y12);
      }
    }
    function addArc(startAngle2, endAngle2, cx2, cy2, rx2, ry2) {
      var delta = Math.abs(endAngle2 - startAngle2);
      var len3 = Math.tan(delta / 4) * 4 / 3;
      var dir3 = endAngle2 < startAngle2 ? -1 : 1;
      var c1 = Math.cos(startAngle2);
      var s1 = Math.sin(startAngle2);
      var c2 = Math.cos(endAngle2);
      var s2 = Math.sin(endAngle2);
      var x12 = c1 * rx2 + cx2;
      var y12 = s1 * ry2 + cy2;
      var x4 = c2 * rx2 + cx2;
      var y4 = s2 * ry2 + cy2;
      var hx = rx2 * len3 * dir3;
      var hy = ry2 * len3 * dir3;
      currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
    }
    var x1;
    var y1;
    var x2;
    var y2;
    for (var i2 = 0; i2 < len2; ) {
      var cmd = data[i2++];
      var isFirst = i2 === 1;
      if (isFirst) {
        xi = data[i2];
        yi = data[i2 + 1];
        x0 = xi;
        y0 = yi;
        if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
          currentSubpath = [x0, y0];
        }
      }
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i2++];
          yi = y0 = data[i2++];
          createNewSubpath(x0, y0);
          break;
        case CMD.L:
          x1 = data[i2++];
          y1 = data[i2++];
          addLine(xi, yi, x1, y1);
          xi = x1;
          yi = y1;
          break;
        case CMD.C:
          currentSubpath.push(data[i2++], data[i2++], data[i2++], data[i2++], xi = data[i2++], yi = data[i2++]);
          break;
        case CMD.Q:
          x1 = data[i2++];
          y1 = data[i2++];
          x2 = data[i2++];
          y2 = data[i2++];
          currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
          xi = x2;
          yi = y2;
          break;
        case CMD.A:
          var cx = data[i2++];
          var cy = data[i2++];
          var rx = data[i2++];
          var ry = data[i2++];
          var startAngle = data[i2++];
          var endAngle = data[i2++] + startAngle;
          i2 += 1;
          var anticlockwise = !data[i2++];
          x1 = Math.cos(startAngle) * rx + cx;
          y1 = Math.sin(startAngle) * ry + cy;
          if (isFirst) {
            x0 = x1;
            y0 = y1;
            createNewSubpath(x0, y0);
          } else {
            addLine(xi, yi, x1, y1);
          }
          xi = Math.cos(endAngle) * rx + cx;
          yi = Math.sin(endAngle) * ry + cy;
          var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
          for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
            var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
            addArc(angle, nextAngle, cx, cy, rx, ry);
          }
          break;
        case CMD.R:
          x0 = xi = data[i2++];
          y0 = yi = data[i2++];
          x1 = x0 + data[i2++];
          y1 = y0 + data[i2++];
          createNewSubpath(x1, y0);
          addLine(x1, y0, x1, y1);
          addLine(x1, y1, x0, y1);
          addLine(x0, y1, x0, y0);
          addLine(x0, y0, x1, y0);
          break;
        case CMD.Z:
          currentSubpath && addLine(xi, yi, x0, y0);
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    return bezierArrayGroups;
  }
  function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale2) {
    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
      out2.push(x3, y3);
      return;
    }
    var PIXEL_DISTANCE = 2 / scale2;
    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
    var dx = x3 - x0;
    var dy = y3 - y0;
    var d2 = Math.sqrt(dx * dx + dy * dy);
    dx /= d2;
    dy /= d2;
    var dx1 = x1 - x0;
    var dy1 = y1 - y0;
    var dx2 = x2 - x3;
    var dy2 = y2 - y3;
    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
      out2.push(x3, y3);
      return;
    }
    var projLen1 = dx * dx1 + dy * dy1;
    var projLen2 = -dx * dx2 - dy * dy2;
    var d1Sqr = cp1LenSqr - projLen1 * projLen1;
    var d2Sqr = cp2LenSqr - projLen2 * projLen2;
    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
      out2.push(x3, y3);
      return;
    }
    var tmpSegX = [];
    var tmpSegY = [];
    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale2);
    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale2);
  }
  function pathToPolygons(path, scale2) {
    var bezierArrayGroups = pathToBezierCurves(path);
    var polygons = [];
    scale2 = scale2 || 1;
    for (var i2 = 0; i2 < bezierArrayGroups.length; i2++) {
      var beziers = bezierArrayGroups[i2];
      var polygon = [];
      var x0 = beziers[0];
      var y0 = beziers[1];
      polygon.push(x0, y0);
      for (var k2 = 2; k2 < beziers.length; ) {
        var x1 = beziers[k2++];
        var y1 = beziers[k2++];
        var x2 = beziers[k2++];
        var y2 = beziers[k2++];
        var x3 = beziers[k2++];
        var y3 = beziers[k2++];
        adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale2);
        x0 = x3;
        y0 = y3;
      }
      polygons.push(polygon);
    }
    return polygons;
  }
  function getDividingGrids(dimSize, rowDim, count) {
    var rowSize = dimSize[rowDim];
    var columnSize = dimSize[1 - rowDim];
    var ratio = Math.abs(rowSize / columnSize);
    var rowCount = Math.ceil(Math.sqrt(ratio * count));
    var columnCount = Math.floor(count / rowCount);
    if (columnCount === 0) {
      columnCount = 1;
      rowCount = count;
    }
    var grids = [];
    for (var i2 = 0; i2 < rowCount; i2++) {
      grids.push(columnCount);
    }
    var currentCount = rowCount * columnCount;
    var remained = count - currentCount;
    if (remained > 0) {
      for (var i2 = 0; i2 < remained; i2++) {
        grids[i2 % rowCount] += 1;
      }
    }
    return grids;
  }
  function divideSector(sectorShape, count, outShapes) {
    var r0 = sectorShape.r0;
    var r2 = sectorShape.r;
    var startAngle = sectorShape.startAngle;
    var endAngle = sectorShape.endAngle;
    var angle = Math.abs(endAngle - startAngle);
    var arcLen = angle * r2;
    var deltaR = r2 - r0;
    var isAngleRow = arcLen > Math.abs(deltaR);
    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);
    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;
    for (var row = 0; row < grids.length; row++) {
      var columnSize = (isAngleRow ? deltaR : angle) / grids[row];
      for (var column2 = 0; column2 < grids[row]; column2++) {
        var newShape = {};
        if (isAngleRow) {
          newShape.startAngle = startAngle + rowSize * row;
          newShape.endAngle = startAngle + rowSize * (row + 1);
          newShape.r0 = r0 + columnSize * column2;
          newShape.r = r0 + columnSize * (column2 + 1);
        } else {
          newShape.startAngle = startAngle + columnSize * column2;
          newShape.endAngle = startAngle + columnSize * (column2 + 1);
          newShape.r0 = r0 + rowSize * row;
          newShape.r = r0 + rowSize * (row + 1);
        }
        newShape.clockwise = sectorShape.clockwise;
        newShape.cx = sectorShape.cx;
        newShape.cy = sectorShape.cy;
        outShapes.push(newShape);
      }
    }
  }
  function divideRect(rectShape, count, outShapes) {
    var width = rectShape.width;
    var height = rectShape.height;
    var isHorizontalRow = width > height;
    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);
    var rowSizeDim = isHorizontalRow ? "width" : "height";
    var columnSizeDim = isHorizontalRow ? "height" : "width";
    var rowDim = isHorizontalRow ? "x" : "y";
    var columnDim = isHorizontalRow ? "y" : "x";
    var rowSize = rectShape[rowSizeDim] / grids.length;
    for (var row = 0; row < grids.length; row++) {
      var columnSize = rectShape[columnSizeDim] / grids[row];
      for (var column2 = 0; column2 < grids[row]; column2++) {
        var newShape = {};
        newShape[rowDim] = row * rowSize;
        newShape[columnDim] = column2 * columnSize;
        newShape[rowSizeDim] = rowSize;
        newShape[columnSizeDim] = columnSize;
        newShape.x += rectShape.x;
        newShape.y += rectShape.y;
        outShapes.push(newShape);
      }
    }
  }
  function crossProduct2d(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }
  function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y;
    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
    if (Math.abs(nmCrossProduct) < 1e-6) {
      return null;
    }
    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var p2 = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
    if (p2 < 0 || p2 > 1) {
      return null;
    }
    return new Point(p2 * mx + a1x, p2 * my + a1y);
  }
  function projPtOnLine(pt, lineA, lineB) {
    var dir3 = new Point();
    Point.sub(dir3, lineB, lineA);
    dir3.normalize();
    var dir22 = new Point();
    Point.sub(dir22, pt, lineA);
    var len2 = dir22.dot(dir3);
    return len2;
  }
  function addToPoly(poly, pt) {
    var last2 = poly[poly.length - 1];
    if (last2 && last2[0] === pt[0] && last2[1] === pt[1]) {
      return;
    }
    poly.push(pt);
  }
  function splitPolygonByLine(points2, lineA, lineB) {
    var len2 = points2.length;
    var intersections = [];
    for (var i2 = 0; i2 < len2; i2++) {
      var p0 = points2[i2];
      var p1 = points2[(i2 + 1) % len2];
      var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
      if (intersectionPt) {
        intersections.push({
          projPt: projPtOnLine(intersectionPt, lineA, lineB),
          pt: intersectionPt,
          idx: i2
        });
      }
    }
    if (intersections.length < 2) {
      return [{ points: points2 }, { points: points2 }];
    }
    intersections.sort(function(a2, b2) {
      return a2.projPt - b2.projPt;
    });
    var splitPt0 = intersections[0];
    var splitPt1 = intersections[intersections.length - 1];
    if (splitPt1.idx < splitPt0.idx) {
      var tmp = splitPt0;
      splitPt0 = splitPt1;
      splitPt1 = tmp;
    }
    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
    var newPolyA = [splitPt0Arr];
    var newPolyB = [splitPt1Arr];
    for (var i2 = splitPt0.idx + 1; i2 <= splitPt1.idx; i2++) {
      addToPoly(newPolyA, points2[i2].slice());
    }
    addToPoly(newPolyA, splitPt1Arr);
    addToPoly(newPolyA, splitPt0Arr);
    for (var i2 = splitPt1.idx + 1; i2 <= splitPt0.idx + len2; i2++) {
      addToPoly(newPolyB, points2[i2 % len2].slice());
    }
    addToPoly(newPolyB, splitPt0Arr);
    addToPoly(newPolyB, splitPt1Arr);
    return [{
      points: newPolyA
    }, {
      points: newPolyB
    }];
  }
  function binaryDividePolygon(polygonShape) {
    var points2 = polygonShape.points;
    var min3 = [];
    var max3 = [];
    fromPoints(points2, min3, max3);
    var boundingRect = new BoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    var width = boundingRect.width;
    var height = boundingRect.height;
    var x2 = boundingRect.x;
    var y2 = boundingRect.y;
    var pt02 = new Point();
    var pt12 = new Point();
    if (width > height) {
      pt02.x = pt12.x = x2 + width / 2;
      pt02.y = y2;
      pt12.y = y2 + height;
    } else {
      pt02.y = pt12.y = y2 + height / 2;
      pt02.x = x2;
      pt12.x = x2 + width;
    }
    return splitPolygonByLine(points2, pt02, pt12);
  }
  function binaryDivideRecursive(divider, shape, count, out2) {
    if (count === 1) {
      out2.push(shape);
    } else {
      var mid = Math.floor(count / 2);
      var sub2 = divider(shape);
      binaryDivideRecursive(divider, sub2[0], mid, out2);
      binaryDivideRecursive(divider, sub2[1], count - mid, out2);
    }
    return out2;
  }
  function clone(path, count) {
    var paths = [];
    for (var i2 = 0; i2 < count; i2++) {
      paths.push(clonePath(path));
    }
    return paths;
  }
  function copyPathProps(source, target) {
    target.setStyle(source.style);
    target.z = source.z;
    target.z2 = source.z2;
    target.zlevel = source.zlevel;
  }
  function polygonConvert(points2) {
    var out2 = [];
    for (var i2 = 0; i2 < points2.length; ) {
      out2.push([points2[i2++], points2[i2++]]);
    }
    return out2;
  }
  function split(path, count) {
    var outShapes = [];
    var shape = path.shape;
    var OutShapeCtor;
    switch (path.type) {
      case "rect":
        divideRect(shape, count, outShapes);
        OutShapeCtor = Rect;
        break;
      case "sector":
        divideSector(shape, count, outShapes);
        OutShapeCtor = Sector;
        break;
      case "circle":
        divideSector({
          r0: 0,
          r: shape.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: shape.cx,
          cy: shape.cy
        }, count, outShapes);
        OutShapeCtor = Sector;
        break;
      default:
        var m2 = path.getComputedTransform();
        var scale2 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
        var polygons = map$1(pathToPolygons(path.getUpdatedPathProxy(), scale2), function(poly) {
          return polygonConvert(poly);
        });
        var polygonCount = polygons.length;
        if (polygonCount === 0) {
          binaryDivideRecursive(binaryDividePolygon, {
            points: polygons[0]
          }, count, outShapes);
        } else if (polygonCount === count) {
          for (var i2 = 0; i2 < polygonCount; i2++) {
            outShapes.push({
              points: polygons[i2]
            });
          }
        } else {
          var totalArea_1 = 0;
          var items = map$1(polygons, function(poly) {
            var min3 = [];
            var max3 = [];
            fromPoints(poly, min3, max3);
            var area = (max3[1] - min3[1]) * (max3[0] - min3[0]);
            totalArea_1 += area;
            return { poly, area };
          });
          items.sort(function(a2, b2) {
            return b2.area - a2.area;
          });
          var left = count;
          for (var i2 = 0; i2 < polygonCount; i2++) {
            var item = items[i2];
            if (left <= 0) {
              break;
            }
            var selfCount = i2 === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count);
            if (selfCount < 0) {
              continue;
            }
            binaryDivideRecursive(binaryDividePolygon, {
              points: item.poly
            }, selfCount, outShapes);
            left -= selfCount;
          }
        }
        OutShapeCtor = Polygon;
        break;
    }
    if (!OutShapeCtor) {
      return clone(path, count);
    }
    var out2 = [];
    for (var i2 = 0; i2 < outShapes.length; i2++) {
      var subPath = new OutShapeCtor();
      subPath.setShape(outShapes[i2]);
      copyPathProps(path, subPath);
      out2.push(subPath);
    }
    return out2;
  }
  function alignSubpath(subpath1, subpath2) {
    var len1 = subpath1.length;
    var len2 = subpath2.length;
    if (len1 === len2) {
      return [subpath1, subpath2];
    }
    var tmpSegX = [];
    var tmpSegY = [];
    var shorterPath = len1 < len2 ? subpath1 : subpath2;
    var shorterLen = Math.min(len1, len2);
    var diff = Math.abs(len2 - len1) / 6;
    var shorterBezierCount = (shorterLen - 2) / 6;
    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
    var newSubpath = [shorterPath[0], shorterPath[1]];
    var remained = diff;
    for (var i2 = 2; i2 < shorterLen; ) {
      var x0 = shorterPath[i2 - 2];
      var y0 = shorterPath[i2 - 1];
      var x1 = shorterPath[i2++];
      var y1 = shorterPath[i2++];
      var x2 = shorterPath[i2++];
      var y2 = shorterPath[i2++];
      var x3 = shorterPath[i2++];
      var y3 = shorterPath[i2++];
      if (remained <= 0) {
        newSubpath.push(x1, y1, x2, y2, x3, y3);
        continue;
      }
      var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
      for (var k2 = 1; k2 <= actualSubDivCount; k2++) {
        var p2 = k2 / actualSubDivCount;
        cubicSubdivide(x0, x1, x2, x3, p2, tmpSegX);
        cubicSubdivide(y0, y1, y2, y3, p2, tmpSegY);
        x0 = tmpSegX[3];
        y0 = tmpSegY[3];
        newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
        x1 = tmpSegX[5];
        y1 = tmpSegY[5];
        x2 = tmpSegX[6];
        y2 = tmpSegY[6];
      }
      remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
  }
  function createSubpath(lastSubpathSubpath, otherSubpath) {
    var len2 = lastSubpathSubpath.length;
    var lastX = lastSubpathSubpath[len2 - 2];
    var lastY = lastSubpathSubpath[len2 - 1];
    var newSubpath = [];
    for (var i2 = 0; i2 < otherSubpath.length; ) {
      newSubpath[i2++] = lastX;
      newSubpath[i2++] = lastY;
    }
    return newSubpath;
  }
  function alignBezierCurves(array1, array22) {
    var _a2;
    var lastSubpath1;
    var lastSubpath2;
    var newArray1 = [];
    var newArray2 = [];
    for (var i2 = 0; i2 < Math.max(array1.length, array22.length); i2++) {
      var subpath1 = array1[i2];
      var subpath2 = array22[i2];
      var newSubpath1 = void 0;
      var newSubpath2 = void 0;
      if (!subpath1) {
        newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
        newSubpath2 = subpath2;
      } else if (!subpath2) {
        newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
        newSubpath1 = subpath1;
      } else {
        _a2 = alignSubpath(subpath1, subpath2), newSubpath1 = _a2[0], newSubpath2 = _a2[1];
        lastSubpath1 = newSubpath1;
        lastSubpath2 = newSubpath2;
      }
      newArray1.push(newSubpath1);
      newArray2.push(newSubpath2);
    }
    return [newArray1, newArray2];
  }
  function centroid(array) {
    var signedArea = 0;
    var cx = 0;
    var cy = 0;
    var len2 = array.length;
    for (var i2 = 0, j2 = len2 - 2; i2 < len2; j2 = i2, i2 += 2) {
      var x0 = array[j2];
      var y0 = array[j2 + 1];
      var x1 = array[i2];
      var y1 = array[i2 + 1];
      var a2 = x0 * y1 - x1 * y0;
      signedArea += a2;
      cx += (x0 + x1) * a2;
      cy += (y0 + y1) * a2;
    }
    if (signedArea === 0) {
      return [array[0] || 0, array[1] || 0];
    }
    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
  }
  function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    var bezierCount = (fromSubBeziers.length - 2) / 6;
    var bestScore = Infinity;
    var bestOffset = 0;
    var len2 = fromSubBeziers.length;
    var len22 = len2 - 2;
    for (var offset2 = 0; offset2 < bezierCount; offset2++) {
      var cursorOffset = offset2 * 6;
      var score = 0;
      for (var k2 = 0; k2 < len2; k2 += 2) {
        var idx = k2 === 0 ? cursorOffset : (cursorOffset + k2 - 2) % len22 + 2;
        var x0 = fromSubBeziers[idx] - fromCp[0];
        var y0 = fromSubBeziers[idx + 1] - fromCp[1];
        var x1 = toSubBeziers[k2] - toCp[0];
        var y1 = toSubBeziers[k2 + 1] - toCp[1];
        var dx = x1 - x0;
        var dy = y1 - y0;
        score += dx * dx + dy * dy;
      }
      if (score < bestScore) {
        bestScore = score;
        bestOffset = offset2;
      }
    }
    return bestOffset;
  }
  function reverse(array) {
    var newArr = [];
    var len2 = array.length;
    for (var i2 = 0; i2 < len2; i2 += 2) {
      newArr[i2] = array[len2 - i2 - 2];
      newArr[i2 + 1] = array[len2 - i2 - 1];
    }
    return newArr;
  }
  function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
    var result = [];
    var fromNeedsReverse;
    for (var i2 = 0; i2 < fromArr.length; i2++) {
      var fromSubpathBezier = fromArr[i2];
      var toSubpathBezier = toArr2[i2];
      var fromCp = centroid(fromSubpathBezier);
      var toCp = centroid(toSubpathBezier);
      if (fromNeedsReverse == null) {
        fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
      }
      var newFromSubpathBezier = [];
      var newToSubpathBezier = [];
      var bestAngle = 0;
      var bestScore = Infinity;
      var tmpArr2 = [];
      var len2 = fromSubpathBezier.length;
      if (fromNeedsReverse) {
        fromSubpathBezier = reverse(fromSubpathBezier);
      }
      var offset2 = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
      var len22 = len2 - 2;
      for (var k2 = 0; k2 < len22; k2 += 2) {
        var idx = (offset2 + k2) % len22 + 2;
        newFromSubpathBezier[k2 + 2] = fromSubpathBezier[idx] - fromCp[0];
        newFromSubpathBezier[k2 + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
      }
      newFromSubpathBezier[0] = fromSubpathBezier[offset2] - fromCp[0];
      newFromSubpathBezier[1] = fromSubpathBezier[offset2 + 1] - fromCp[1];
      {
        var step = searchAngleRange / searchAngleIteration;
        for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
          var sa = Math.sin(angle);
          var ca = Math.cos(angle);
          var score = 0;
          for (var k2 = 0; k2 < fromSubpathBezier.length; k2 += 2) {
            var x0 = newFromSubpathBezier[k2];
            var y0 = newFromSubpathBezier[k2 + 1];
            var x1 = toSubpathBezier[k2] - toCp[0];
            var y1 = toSubpathBezier[k2 + 1] - toCp[1];
            var newX1 = x1 * ca - y1 * sa;
            var newY1 = x1 * sa + y1 * ca;
            tmpArr2[k2] = newX1;
            tmpArr2[k2 + 1] = newY1;
            var dx = newX1 - x0;
            var dy = newY1 - y0;
            score += dx * dx + dy * dy;
          }
          if (score < bestScore) {
            bestScore = score;
            bestAngle = angle;
            for (var m2 = 0; m2 < tmpArr2.length; m2++) {
              newToSubpathBezier[m2] = tmpArr2[m2];
            }
          }
        }
      }
      result.push({
        from: newFromSubpathBezier,
        to: newToSubpathBezier,
        fromCp,
        toCp,
        rotation: -bestAngle
      });
    }
    return result;
  }
  function isCombineMorphing(path) {
    return path.__isCombineMorphing;
  }
  var SAVED_METHOD_PREFIX = "__mOriginal_";
  function saveAndModifyMethod(obj2, methodName, modifiers) {
    var savedMethodName = SAVED_METHOD_PREFIX + methodName;
    var originalMethod = obj2[savedMethodName] || obj2[methodName];
    if (!obj2[savedMethodName]) {
      obj2[savedMethodName] = obj2[methodName];
    }
    var replace2 = modifiers.replace;
    var after = modifiers.after;
    var before = modifiers.before;
    obj2[methodName] = function() {
      var args = arguments;
      var res;
      before && before.apply(this, args);
      if (replace2) {
        res = replace2.apply(this, args);
      } else {
        res = originalMethod.apply(this, args);
      }
      after && after.apply(this, args);
      return res;
    };
  }
  function restoreMethod(obj2, methodName) {
    var savedMethodName = SAVED_METHOD_PREFIX + methodName;
    if (obj2[savedMethodName]) {
      obj2[methodName] = obj2[savedMethodName];
      obj2[savedMethodName] = null;
    }
  }
  function applyTransformOnBeziers(bezierCurves, mm) {
    for (var i2 = 0; i2 < bezierCurves.length; i2++) {
      var subBeziers = bezierCurves[i2];
      for (var k2 = 0; k2 < subBeziers.length; ) {
        var x2 = subBeziers[k2];
        var y2 = subBeziers[k2 + 1];
        subBeziers[k2++] = mm[0] * x2 + mm[2] * y2 + mm[4];
        subBeziers[k2++] = mm[1] * x2 + mm[3] * y2 + mm[5];
      }
    }
  }
  function prepareMorphPath(fromPath, toPath) {
    var fromPathProxy = fromPath.getUpdatedPathProxy();
    var toPathProxy = toPath.getUpdatedPathProxy();
    var _a2 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a2[0], toBezierCurves = _a2[1];
    var fromPathTransform = fromPath.getComputedTransform();
    var toPathTransform = toPath.getComputedTransform();
    function updateIdentityTransform() {
      this.transform = null;
    }
    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
    saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
    toPath.transform = null;
    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
    var tmpArr2 = [];
    saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
      var t2 = toPath.__morphT;
      var onet = 1 - t2;
      var newCp = [];
      for (var i2 = 0; i2 < morphingData.length; i2++) {
        var item = morphingData[i2];
        var from2 = item.from;
        var to = item.to;
        var angle = item.rotation * t2;
        var fromCp = item.fromCp;
        var toCp = item.toCp;
        var sa = Math.sin(angle);
        var ca = Math.cos(angle);
        lerp$1(newCp, fromCp, toCp, t2);
        for (var m2 = 0; m2 < from2.length; m2 += 2) {
          var x0_1 = from2[m2];
          var y0_1 = from2[m2 + 1];
          var x1 = to[m2];
          var y1 = to[m2 + 1];
          var x2 = x0_1 * onet + x1 * t2;
          var y2 = y0_1 * onet + y1 * t2;
          tmpArr2[m2] = x2 * ca - y2 * sa + newCp[0];
          tmpArr2[m2 + 1] = x2 * sa + y2 * ca + newCp[1];
        }
        var x0 = tmpArr2[0];
        var y0 = tmpArr2[1];
        path.moveTo(x0, y0);
        for (var m2 = 2; m2 < from2.length; ) {
          var x1 = tmpArr2[m2++];
          var y1 = tmpArr2[m2++];
          var x22 = tmpArr2[m2++];
          var y22 = tmpArr2[m2++];
          var x3 = tmpArr2[m2++];
          var y3 = tmpArr2[m2++];
          if (x0 === x1 && y0 === y1 && x22 === x3 && y22 === y3) {
            path.lineTo(x3, y3);
          } else {
            path.bezierCurveTo(x1, y1, x22, y22, x3, y3);
          }
          x0 = x3;
          y0 = y3;
        }
      }
    } });
  }
  function morphPath(fromPath, toPath, animationOpts) {
    if (!fromPath || !toPath) {
      return toPath;
    }
    var oldDone = animationOpts.done;
    var oldDuring = animationOpts.during;
    prepareMorphPath(fromPath, toPath);
    toPath.__morphT = 0;
    function restoreToPath() {
      restoreMethod(toPath, "buildPath");
      restoreMethod(toPath, "updateTransform");
      toPath.__morphT = -1;
      toPath.createPathProxy();
      toPath.dirtyShape();
    }
    toPath.animateTo({
      __morphT: 1
    }, defaults$1({
      during: function(p2) {
        toPath.dirtyShape();
        oldDuring && oldDuring(p2);
      },
      done: function() {
        restoreToPath();
        oldDone && oldDone();
      }
    }, animationOpts));
    return toPath;
  }
  function hilbert(x2, y2, minX, minY, maxX, maxY) {
    var bits = 16;
    x2 = maxX === minX ? 0 : Math.round(32767 * (x2 - minX) / (maxX - minX));
    y2 = maxY === minY ? 0 : Math.round(32767 * (y2 - minY) / (maxY - minY));
    var d2 = 0;
    var tmp;
    for (var s2 = (1 << bits) / 2; s2 > 0; s2 /= 2) {
      var rx = 0;
      var ry = 0;
      if ((x2 & s2) > 0) {
        rx = 1;
      }
      if ((y2 & s2) > 0) {
        ry = 1;
      }
      d2 += s2 * s2 * (3 * rx ^ ry);
      if (ry === 0) {
        if (rx === 1) {
          x2 = s2 - 1 - x2;
          y2 = s2 - 1 - y2;
        }
        tmp = x2;
        x2 = y2;
        y2 = tmp;
      }
    }
    return d2;
  }
  function sortPaths(pathList) {
    var xMin = Infinity;
    var yMin = Infinity;
    var xMax = -Infinity;
    var yMax = -Infinity;
    var cps = map$1(pathList, function(path) {
      var rect = path.getBoundingRect();
      var m2 = path.getComputedTransform();
      var x2 = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
      var y2 = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
      xMin = Math.min(x2, xMin);
      yMin = Math.min(y2, yMin);
      xMax = Math.max(x2, xMax);
      yMax = Math.max(y2, yMax);
      return [x2, y2];
    });
    var items = map$1(cps, function(cp, idx) {
      return {
        cp,
        z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
        path: pathList[idx]
      };
    });
    return items.sort(function(a2, b2) {
      return a2.z - b2.z;
    }).map(function(item) {
      return item.path;
    });
  }
  function defaultDividePath(param) {
    return split(param.path, param.count);
  }
  function createEmptyReturn() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function combineMorph(fromList, toPath, animationOpts) {
    var fromPathList = [];
    function addFromPath(fromList2) {
      for (var i3 = 0; i3 < fromList2.length; i3++) {
        var from3 = fromList2[i3];
        if (isCombineMorphing(from3)) {
          addFromPath(from3.childrenRef());
        } else if (from3 instanceof Path) {
          fromPathList.push(from3);
        }
      }
    }
    addFromPath(fromList);
    var separateCount = fromPathList.length;
    if (!separateCount) {
      return createEmptyReturn();
    }
    var dividePath = animationOpts.dividePath || defaultDividePath;
    var toSubPathList = dividePath({
      path: toPath,
      count: separateCount
    });
    if (toSubPathList.length !== separateCount) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
    fromPathList = sortPaths(fromPathList);
    toSubPathList = sortPaths(toSubPathList);
    var oldDone = animationOpts.done;
    var oldDuring = animationOpts.during;
    var individualDelay = animationOpts.individualDelay;
    var identityTransform = new Transformable();
    for (var i2 = 0; i2 < separateCount; i2++) {
      var from2 = fromPathList[i2];
      var to = toSubPathList[i2];
      to.parent = toPath;
      to.copyTransform(identityTransform);
      if (!individualDelay) {
        prepareMorphPath(from2, to);
      }
    }
    toPath.__isCombineMorphing = true;
    toPath.childrenRef = function() {
      return toSubPathList;
    };
    function addToSubPathListToZr(zr) {
      for (var i3 = 0; i3 < toSubPathList.length; i3++) {
        toSubPathList[i3].addSelfToZr(zr);
      }
    }
    saveAndModifyMethod(toPath, "addSelfToZr", {
      after: function(zr) {
        addToSubPathListToZr(zr);
      }
    });
    saveAndModifyMethod(toPath, "removeSelfFromZr", {
      after: function(zr) {
        for (var i3 = 0; i3 < toSubPathList.length; i3++) {
          toSubPathList[i3].removeSelfFromZr(zr);
        }
      }
    });
    function restoreToPath() {
      toPath.__isCombineMorphing = false;
      toPath.__morphT = -1;
      toPath.childrenRef = null;
      restoreMethod(toPath, "addSelfToZr");
      restoreMethod(toPath, "removeSelfFromZr");
    }
    var toLen = toSubPathList.length;
    if (individualDelay) {
      var animating_1 = toLen;
      var eachDone = function() {
        animating_1--;
        if (animating_1 === 0) {
          restoreToPath();
          oldDone && oldDone();
        }
      };
      for (var i2 = 0; i2 < toLen; i2++) {
        var indivdualAnimationOpts = individualDelay ? defaults$1({
          delay: (animationOpts.delay || 0) + individualDelay(i2, toLen, fromPathList[i2], toSubPathList[i2]),
          done: eachDone
        }, animationOpts) : animationOpts;
        morphPath(fromPathList[i2], toSubPathList[i2], indivdualAnimationOpts);
      }
    } else {
      toPath.__morphT = 0;
      toPath.animateTo({
        __morphT: 1
      }, defaults$1({
        during: function(p2) {
          for (var i3 = 0; i3 < toLen; i3++) {
            var child = toSubPathList[i3];
            child.__morphT = toPath.__morphT;
            child.dirtyShape();
          }
          oldDuring && oldDuring(p2);
        },
        done: function() {
          restoreToPath();
          for (var i3 = 0; i3 < fromList.length; i3++) {
            restoreMethod(fromList[i3], "updateTransform");
          }
          oldDone && oldDone();
        }
      }, animationOpts));
    }
    if (toPath.__zr) {
      addToSubPathListToZr(toPath.__zr);
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toSubPathList,
      count: toLen
    };
  }
  function separateMorph(fromPath, toPathList, animationOpts) {
    var toLen = toPathList.length;
    var fromPathList = [];
    var dividePath = animationOpts.dividePath || defaultDividePath;
    function addFromPath(fromList) {
      for (var i3 = 0; i3 < fromList.length; i3++) {
        var from2 = fromList[i3];
        if (isCombineMorphing(from2)) {
          addFromPath(from2.childrenRef());
        } else if (from2 instanceof Path) {
          fromPathList.push(from2);
        }
      }
    }
    if (isCombineMorphing(fromPath)) {
      addFromPath(fromPath.childrenRef());
      var fromLen = fromPathList.length;
      if (fromLen < toLen) {
        var k2 = 0;
        for (var i2 = fromLen; i2 < toLen; i2++) {
          fromPathList.push(clonePath(fromPathList[k2++ % fromLen]));
        }
      }
      fromPathList.length = toLen;
    } else {
      fromPathList = dividePath({ path: fromPath, count: toLen });
      var fromPathTransform = fromPath.getComputedTransform();
      for (var i2 = 0; i2 < fromPathList.length; i2++) {
        fromPathList[i2].setLocalTransform(fromPathTransform);
      }
      if (fromPathList.length !== toLen) {
        console.error("Invalid morphing: unmatched splitted path");
        return createEmptyReturn();
      }
    }
    fromPathList = sortPaths(fromPathList);
    toPathList = sortPaths(toPathList);
    var individualDelay = animationOpts.individualDelay;
    for (var i2 = 0; i2 < toLen; i2++) {
      var indivdualAnimationOpts = individualDelay ? defaults$1({
        delay: (animationOpts.delay || 0) + individualDelay(i2, toLen, fromPathList[i2], toPathList[i2])
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i2], toPathList[i2], indivdualAnimationOpts);
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toPathList,
      count: toPathList.length
    };
  }
  function isMultiple(elements) {
    return isArray$1(elements[0]);
  }
  function prepareMorphBatches(one, many) {
    var batches = [];
    var batchCount = one.length;
    for (var i2 = 0; i2 < batchCount; i2++) {
      batches.push({
        one: one[i2],
        many: []
      });
    }
    for (var i2 = 0; i2 < many.length; i2++) {
      var len2 = many[i2].length;
      var k2 = void 0;
      for (k2 = 0; k2 < len2; k2++) {
        batches[k2 % batchCount].many.push(many[i2][k2]);
      }
    }
    var off = 0;
    for (var i2 = batchCount - 1; i2 >= 0; i2--) {
      if (!batches[i2].many.length) {
        var moveFrom = batches[off].many;
        if (moveFrom.length <= 1) {
          if (off) {
            off = 0;
          } else {
            return batches;
          }
        }
        var len2 = moveFrom.length;
        var mid = Math.ceil(len2 / 2);
        batches[i2].many = moveFrom.slice(mid, len2);
        batches[off].many = moveFrom.slice(0, mid);
        off++;
      }
    }
    return batches;
  }
  var pathDividers = {
    clone: function(params2) {
      var ret = [];
      var approxOpacity = 1 - Math.pow(1 - params2.path.style.opacity, 1 / params2.count);
      for (var i2 = 0; i2 < params2.count; i2++) {
        var cloned = clonePath(params2.path);
        cloned.setStyle("opacity", approxOpacity);
        ret.push(cloned);
      }
      return ret;
    },
    // Use the default divider
    split: null
  };
  function applyMorphAnimation(from2, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
    if (!from2.length || !to.length) {
      return;
    }
    var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
    if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
      return;
    }
    var animationDelay = seriesModel.getModel("universalTransition").get("delay");
    var animationCfg = Object.assign({
      // Need to setToFinal so the further calculation based on the style can be correct.
      // Like emphasis color.
      setToFinal: true
    }, updateAnimationCfg);
    var many;
    var one;
    if (isMultiple(from2)) {
      many = from2;
      one = to;
    }
    if (isMultiple(to)) {
      many = to;
      one = from2;
    }
    function morphOneBatch(batch2, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
      var batchMany = batch2.many;
      var batchOne = batch2.one;
      if (batchMany.length === 1 && !forceManyOne) {
        var batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
        var batchTo = fromIsMany2 ? batchOne : batchMany[0];
        if (isCombineMorphing(batchFrom)) {
          morphOneBatch({
            many: [batchFrom],
            one: batchTo
          }, true, animateIndex2, animateCount2, true);
        } else {
          var individualAnimationCfg = animationDelay ? defaults$1({
            delay: animationDelay(animateIndex2, animateCount2)
          }, animationCfg) : animationCfg;
          morphPath(batchFrom, batchTo, individualAnimationCfg);
          animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
        }
      } else {
        var separateAnimationCfg = defaults$1({
          dividePath: pathDividers[divideShape],
          individualDelay: animationDelay && function(idx, count2, fromPath, toPath) {
            return animationDelay(idx + animateIndex2, animateCount2);
          }
        }, animationCfg);
        var _a2 = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a2.fromIndividuals, toIndividuals = _a2.toIndividuals;
        var count = fromIndividuals.length;
        for (var k2 = 0; k2 < count; k2++) {
          var individualAnimationCfg = animationDelay ? defaults$1({
            delay: animationDelay(k2, count)
          }, animationCfg) : animationCfg;
          animateOtherProps(fromIndividuals[k2], toIndividuals[k2], fromIsMany2 ? batchMany[k2] : batch2.one, fromIsMany2 ? batch2.one : batchMany[k2], individualAnimationCfg);
        }
      }
    }
    var fromIsMany = many ? many === from2 : from2.length > to.length;
    var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from2, [fromIsMany ? from2 : to]);
    var animateCount = 0;
    for (var i2 = 0; i2 < morphBatches.length; i2++) {
      animateCount += morphBatches[i2].many.length;
    }
    var animateIndex = 0;
    for (var i2 = 0; i2 < morphBatches.length; i2++) {
      morphOneBatch(morphBatches[i2], fromIsMany, animateIndex, animateCount);
      animateIndex += morphBatches[i2].many.length;
    }
  }
  function getPathList(elements) {
    if (!elements) {
      return [];
    }
    if (isArray$1(elements)) {
      var pathList_1 = [];
      for (var i2 = 0; i2 < elements.length; i2++) {
        pathList_1.push(getPathList(elements[i2]));
      }
      return pathList_1;
    }
    var pathList = [];
    elements.traverse(function(el) {
      if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {
        pathList.push(el);
      }
    });
    return pathList;
  }
  var DATA_COUNT_THRESHOLD = 1e4;
  var TRANSITION_NONE = 0;
  var TRANSITION_P2C = 1;
  var TRANSITION_C2P = 2;
  var getUniversalTransitionGlobalStore = makeInner();
  function getDimension(data, visualDimension) {
    var dimensions = data.dimensions;
    for (var i2 = 0; i2 < dimensions.length; i2++) {
      var dimInfo = data.getDimensionInfo(dimensions[i2]);
      if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {
        return dimensions[i2];
      }
    }
  }
  function getValueByDimension(data, dataIndex, dimension) {
    var dimInfo = data.getDimensionInfo(dimension);
    var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
    if (dimInfo) {
      var value = data.get(dimInfo.name, dataIndex);
      if (dimOrdinalMeta) {
        return dimOrdinalMeta.categories[value] || value + "";
      }
      return value + "";
    }
  }
  function getGroupId(data, dataIndex, dataGroupId, isChild) {
    var visualDimension = isChild ? "itemChildGroupId" : "itemGroupId";
    var groupIdDim = getDimension(data, visualDimension);
    if (groupIdDim) {
      var groupId = getValueByDimension(data, dataIndex, groupIdDim);
      return groupId;
    }
    var rawDataItem = data.getRawDataItem(dataIndex);
    var property2 = isChild ? "childGroupId" : "groupId";
    if (rawDataItem && rawDataItem[property2]) {
      return rawDataItem[property2] + "";
    }
    if (isChild) {
      return;
    }
    return dataGroupId || data.getId(dataIndex);
  }
  function flattenDataDiffItems(list2) {
    var items = [];
    each$4(list2, function(seriesInfo) {
      var data = seriesInfo.data;
      var dataGroupId = seriesInfo.dataGroupId;
      if (data.count() > DATA_COUNT_THRESHOLD) {
        return;
      }
      var indices = data.getIndices();
      for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
        items.push({
          data,
          groupId: getGroupId(data, dataIndex, dataGroupId, false),
          childGroupId: getGroupId(data, dataIndex, dataGroupId, true),
          divide: seriesInfo.divide,
          dataIndex
        });
      }
    });
    return items;
  }
  function fadeInElement(newEl, newSeries, newIndex) {
    newEl.traverse(function(el) {
      if (el instanceof Path) {
        initProps(el, {
          style: {
            opacity: 0
          }
        }, newSeries, {
          dataIndex: newIndex,
          isFrom: true
        });
      }
    });
  }
  function removeEl(el) {
    if (el.parent) {
      var computedTransform = el.getComputedTransform();
      el.setLocalTransform(computedTransform);
      el.parent.remove(el);
    }
  }
  function stopAnimation(el) {
    el.stopAnimation();
    if (el.isGroup) {
      el.traverse(function(child) {
        child.stopAnimation();
      });
    }
  }
  function animateElementStyles(el, dataIndex, seriesModel) {
    var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
    animationConfig && el.traverse(function(child) {
      if (child instanceof Displayable) {
        var oldStyle = getOldStyle(child);
        if (oldStyle) {
          child.animateFrom({
            style: oldStyle
          }, animationConfig);
        }
      }
    });
  }
  function isAllIdSame(oldDiffItems, newDiffItems) {
    var len2 = oldDiffItems.length;
    if (len2 !== newDiffItems.length) {
      return false;
    }
    for (var i2 = 0; i2 < len2; i2++) {
      var oldItem = oldDiffItems[i2];
      var newItem = newDiffItems[i2];
      if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
        return false;
      }
    }
    return true;
  }
  function transitionBetween(oldList, newList, api2) {
    var oldDiffItems = flattenDataDiffItems(oldList);
    var newDiffItems = flattenDataDiffItems(newList);
    function updateMorphingPathProps(from2, to, rawFrom, rawTo, animationCfg) {
      if (rawFrom || from2) {
        to.animateFrom({
          style: rawFrom && rawFrom !== from2 ? extend$1(extend$1({}, rawFrom.style), from2.style) : from2.style
        }, animationCfg);
      }
    }
    var hasMorphAnimation = false;
    var direction = TRANSITION_NONE;
    var oldGroupIds = createHashMap();
    var oldChildGroupIds = createHashMap();
    oldDiffItems.forEach(function(item) {
      item.groupId && oldGroupIds.set(item.groupId, true);
      item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);
    });
    for (var i2 = 0; i2 < newDiffItems.length; i2++) {
      var newGroupId = newDiffItems[i2].groupId;
      if (oldChildGroupIds.get(newGroupId)) {
        direction = TRANSITION_P2C;
        break;
      }
      var newChildGroupId = newDiffItems[i2].childGroupId;
      if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {
        direction = TRANSITION_C2P;
        break;
      }
    }
    function createKeyGetter(isOld, onlyGetId) {
      return function(diffItem) {
        var data = diffItem.data;
        var dataIndex = diffItem.dataIndex;
        if (onlyGetId) {
          return data.getId(dataIndex);
        }
        if (isOld) {
          return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;
        } else {
          return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;
        }
      };
    }
    var useId2 = isAllIdSame(oldDiffItems, newDiffItems);
    var isElementStillInChart = {};
    if (!useId2) {
      for (var i2 = 0; i2 < newDiffItems.length; i2++) {
        var newItem = newDiffItems[i2];
        var el = newItem.data.getItemGraphicEl(newItem.dataIndex);
        if (el) {
          isElementStillInChart[el.id] = true;
        }
      }
    }
    function updateOneToOne(newIndex, oldIndex) {
      var oldItem = oldDiffItems[oldIndex];
      var newItem2 = newDiffItems[newIndex];
      var newSeries = newItem2.data.hostModel;
      var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
      var newEl = newItem2.data.getItemGraphicEl(newItem2.dataIndex);
      if (oldEl === newEl) {
        newEl && animateElementStyles(newEl, newItem2.dataIndex, newSeries);
        return;
      }
      if (
        // We can't use the elements that already being morphed
        oldEl && isElementStillInChart[oldEl.id]
      ) {
        return;
      }
      if (newEl) {
        stopAnimation(newEl);
        if (oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
          hasMorphAnimation = true;
          applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
        } else {
          fadeInElement(newEl, newSeries, newIndex);
        }
      }
    }
    new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId2), createKeyGetter(false, useId2), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
      var newItem2 = newDiffItems[newIndex];
      var newData = newItem2.data;
      var newSeries = newData.hostModel;
      var newEl = newData.getItemGraphicEl(newItem2.dataIndex);
      var oldElsList = filter(map$1(oldIndices, function(idx) {
        return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
      }), function(oldEl) {
        return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];
      });
      if (newEl) {
        stopAnimation(newEl);
        if (oldElsList.length) {
          each$4(oldElsList, function(oldEl) {
            stopAnimation(oldEl);
            removeEl(oldEl);
          });
          hasMorphAnimation = true;
          applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
        } else {
          fadeInElement(newEl, newSeries, newItem2.dataIndex);
        }
      }
    }).updateOneToMany(function(newIndices, oldIndex) {
      var oldItem = oldDiffItems[oldIndex];
      var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
      if (oldEl && isElementStillInChart[oldEl.id]) {
        return;
      }
      var newElsList = filter(map$1(newIndices, function(idx) {
        return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
      }), function(el2) {
        return el2 && el2 !== oldEl;
      });
      var newSeris = newDiffItems[newIndices[0]].data.hostModel;
      if (newElsList.length) {
        each$4(newElsList, function(newEl) {
          return stopAnimation(newEl);
        });
        if (oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
          hasMorphAnimation = true;
          applyMorphAnimation(
            getPathList(oldEl),
            getPathList(newElsList),
            oldItem.divide,
            // Use divide on old.
            newSeris,
            newIndices[0],
            updateMorphingPathProps
          );
        } else {
          each$4(newElsList, function(newEl) {
            return fadeInElement(newEl, newSeris, newIndices[0]);
          });
        }
      }
    }).updateManyToMany(function(newIndices, oldIndices) {
      new DataDiffer(oldIndices, newIndices, function(rawIdx) {
        return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
      }, function(rawIdx) {
        return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
      }).update(function(newIndex, oldIndex) {
        updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
      }).execute();
    }).execute();
    if (hasMorphAnimation) {
      each$4(newList, function(_a2) {
        var data = _a2.data;
        var seriesModel = data.hostModel;
        var view = seriesModel && api2.getViewOfSeriesModel(seriesModel);
        var animationCfg = getAnimationConfig("update", seriesModel, 0);
        if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
          view.group.traverse(function(el2) {
            if (el2 instanceof Path && !el2.animators.length) {
              el2.animateFrom({
                style: {
                  opacity: 0
                }
              }, animationCfg);
            }
          });
        }
      });
    }
  }
  function getSeriesTransitionKey(series) {
    var seriesKey = series.getModel("universalTransition").get("seriesKey");
    if (!seriesKey) {
      return series.id;
    }
    return seriesKey;
  }
  function convertArraySeriesKeyToString(seriesKey) {
    if (isArray$1(seriesKey)) {
      return seriesKey.sort().join(",");
    }
    return seriesKey;
  }
  function getDivideShapeFromData(data) {
    if (data.hostModel) {
      return data.hostModel.getModel("universalTransition").get("divideShape");
    }
  }
  function findTransitionSeriesBatches(globalStore, params2) {
    var updateBatches = createHashMap();
    var oldDataMap = createHashMap();
    var oldDataMapForSplit = createHashMap();
    each$4(globalStore.oldSeries, function(series, idx) {
      var oldDataGroupId = globalStore.oldDataGroupIds[idx];
      var oldData = globalStore.oldData[idx];
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      oldDataMap.set(transitionKeyStr, {
        dataGroupId: oldDataGroupId,
        data: oldData
      });
      if (isArray$1(transitionKey)) {
        each$4(transitionKey, function(key2) {
          oldDataMapForSplit.set(key2, {
            key: transitionKeyStr,
            dataGroupId: oldDataGroupId,
            data: oldData
          });
        });
      }
    });
    each$4(params2.updatedSeries, function(series) {
      if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
        var newDataGroupId = series.get("dataGroupId");
        var newData = series.getData();
        var transitionKey = getSeriesTransitionKey(series);
        var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
        var oldData = oldDataMap.get(transitionKeyStr);
        if (oldData) {
          updateBatches.set(transitionKeyStr, {
            oldSeries: [{
              dataGroupId: oldData.dataGroupId,
              divide: getDivideShapeFromData(oldData.data),
              data: oldData.data
            }],
            newSeries: [{
              dataGroupId: newDataGroupId,
              divide: getDivideShapeFromData(newData),
              data: newData
            }]
          });
        } else {
          if (isArray$1(transitionKey)) {
            var oldSeries_1 = [];
            each$4(transitionKey, function(key2) {
              var oldData2 = oldDataMap.get(key2);
              if (oldData2.data) {
                oldSeries_1.push({
                  dataGroupId: oldData2.dataGroupId,
                  divide: getDivideShapeFromData(oldData2.data),
                  data: oldData2.data
                });
              }
            });
            if (oldSeries_1.length) {
              updateBatches.set(transitionKeyStr, {
                oldSeries: oldSeries_1,
                newSeries: [{
                  dataGroupId: newDataGroupId,
                  data: newData,
                  divide: getDivideShapeFromData(newData)
                }]
              });
            }
          } else {
            var oldData_1 = oldDataMapForSplit.get(transitionKey);
            if (oldData_1) {
              var batch2 = updateBatches.get(oldData_1.key);
              if (!batch2) {
                batch2 = {
                  oldSeries: [{
                    dataGroupId: oldData_1.dataGroupId,
                    data: oldData_1.data,
                    divide: getDivideShapeFromData(oldData_1.data)
                  }],
                  newSeries: []
                };
                updateBatches.set(oldData_1.key, batch2);
              }
              batch2.newSeries.push({
                dataGroupId: newDataGroupId,
                data: newData,
                divide: getDivideShapeFromData(newData)
              });
            }
          }
        }
      }
    });
    return updateBatches;
  }
  function querySeries(series, finder) {
    for (var i2 = 0; i2 < series.length; i2++) {
      var found = finder.seriesIndex != null && finder.seriesIndex === series[i2].seriesIndex || finder.seriesId != null && finder.seriesId === series[i2].id;
      if (found) {
        return i2;
      }
    }
  }
  function transitionSeriesFromOpt(transitionOpt, globalStore, params2, api2) {
    var from2 = [];
    var to = [];
    each$4(normalizeToArray(transitionOpt.from), function(finder) {
      var idx = querySeries(globalStore.oldSeries, finder);
      if (idx >= 0) {
        from2.push({
          dataGroupId: globalStore.oldDataGroupIds[idx],
          data: globalStore.oldData[idx],
          // TODO can specify divideShape in transition.
          divide: getDivideShapeFromData(globalStore.oldData[idx]),
          groupIdDim: finder.dimension
        });
      }
    });
    each$4(normalizeToArray(transitionOpt.to), function(finder) {
      var idx = querySeries(params2.updatedSeries, finder);
      if (idx >= 0) {
        var data = params2.updatedSeries[idx].getData();
        to.push({
          dataGroupId: globalStore.oldDataGroupIds[idx],
          data,
          divide: getDivideShapeFromData(data),
          groupIdDim: finder.dimension
        });
      }
    });
    if (from2.length > 0 && to.length > 0) {
      transitionBetween(from2, to, api2);
    }
  }
  function installUniversalTransition(registers) {
    registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api2, params2) {
      each$4(normalizeToArray(params2.seriesTransition), function(transOpt) {
        each$4(normalizeToArray(transOpt.to), function(finder) {
          var series = params2.updatedSeries;
          for (var i2 = 0; i2 < series.length; i2++) {
            if (finder.seriesIndex != null && finder.seriesIndex === series[i2].seriesIndex || finder.seriesId != null && finder.seriesId === series[i2].id) {
              series[i2][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
            }
          }
        });
      });
    });
    registers.registerUpdateLifecycle("series:transition", function(ecModel, api2, params2) {
      var globalStore = getUniversalTransitionGlobalStore(api2);
      if (globalStore.oldSeries && params2.updatedSeries && params2.optionChanged) {
        var transitionOpt = params2.seriesTransition;
        if (transitionOpt) {
          each$4(normalizeToArray(transitionOpt), function(opt) {
            transitionSeriesFromOpt(opt, globalStore, params2, api2);
          });
        } else {
          var updateBatches_1 = findTransitionSeriesBatches(globalStore, params2);
          each$4(updateBatches_1.keys(), function(key2) {
            var batch2 = updateBatches_1.get(key2);
            transitionBetween(batch2.oldSeries, batch2.newSeries, api2);
          });
        }
        each$4(params2.updatedSeries, function(series) {
          if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
            series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
          }
        });
      }
      var allSeries = ecModel.getSeries();
      var savedSeries = globalStore.oldSeries = [];
      var savedDataGroupIds = globalStore.oldDataGroupIds = [];
      var savedData = globalStore.oldData = [];
      for (var i2 = 0; i2 < allSeries.length; i2++) {
        var data = allSeries[i2].getData();
        if (data.count() < DATA_COUNT_THRESHOLD) {
          savedSeries.push(allSeries[i2]);
          savedDataGroupIds.push(allSeries[i2].get("dataGroupId"));
          savedData.push(data);
        }
      }
    });
  }
  function createDom(id, painter, dpr2) {
    var newDom = platformApi.createCanvas();
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;
    if (newDomStyle) {
      newDomStyle.position = "absolute";
      newDomStyle.left = "0";
      newDomStyle.top = "0";
      newDomStyle.width = width + "px";
      newDomStyle.height = height + "px";
      newDom.setAttribute("data-zr-dom-id", id);
    }
    newDom.width = width * dpr2;
    newDom.height = height * dpr2;
    return newDom;
  }
  var Layer = function(_super) {
    __extends(Layer2, _super);
    function Layer2(id, painter, dpr2) {
      var _this = _super.call(this) || this;
      _this.motionBlur = false;
      _this.lastFrameAlpha = 0.7;
      _this.dpr = 1;
      _this.virtual = false;
      _this.config = {};
      _this.incremental = false;
      _this.zlevel = 0;
      _this.maxRepaintRectCount = 5;
      _this.__dirty = true;
      _this.__firstTimePaint = true;
      _this.__used = false;
      _this.__drawIndex = 0;
      _this.__startIndex = 0;
      _this.__endIndex = 0;
      _this.__prevStartIndex = null;
      _this.__prevEndIndex = null;
      var dom;
      dpr2 = dpr2 || devicePixelRatio;
      if (typeof id === "string") {
        dom = createDom(id, painter, dpr2);
      } else if (isObject$3(id)) {
        dom = id;
        id = dom.id;
      }
      _this.id = id;
      _this.dom = dom;
      var domStyle = dom.style;
      if (domStyle) {
        disableUserSelect(dom);
        dom.onselectstart = function() {
          return false;
        };
        domStyle.padding = "0";
        domStyle.margin = "0";
        domStyle.borderWidth = "0";
      }
      _this.painter = painter;
      _this.dpr = dpr2;
      return _this;
    }
    Layer2.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    };
    Layer2.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex;
      this.__prevEndIndex = this.__endIndex;
    };
    Layer2.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d");
      this.ctx.dpr = this.dpr;
    };
    Layer2.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    };
    Layer2.prototype.createBackBuffer = function() {
      var dpr2 = this.dpr;
      this.domBack = createDom("back-" + this.id, this.painter, dpr2);
      this.ctxBack = this.domBack.getContext("2d");
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    };
    Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
      if (this.__firstTimePaint) {
        this.__firstTimePaint = false;
        return null;
      }
      var mergedRepaintRects = [];
      var maxRepaintRectCount = this.maxRepaintRectCount;
      var full = false;
      var pendingRect = new BoundingRect(0, 0, 0, 0);
      function addRectToMergePool(rect) {
        if (!rect.isFinite() || rect.isZero()) {
          return;
        }
        if (mergedRepaintRects.length === 0) {
          var boundingRect = new BoundingRect(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        } else {
          var isMerged = false;
          var minDeltaArea = Infinity;
          var bestRectToMergeIdx = 0;
          for (var i3 = 0; i3 < mergedRepaintRects.length; ++i3) {
            var mergedRect = mergedRepaintRects[i3];
            if (mergedRect.intersect(rect)) {
              var pendingRect_1 = new BoundingRect(0, 0, 0, 0);
              pendingRect_1.copy(mergedRect);
              pendingRect_1.union(rect);
              mergedRepaintRects[i3] = pendingRect_1;
              isMerged = true;
              break;
            } else if (full) {
              pendingRect.copy(rect);
              pendingRect.union(mergedRect);
              var aArea = rect.width * rect.height;
              var bArea = mergedRect.width * mergedRect.height;
              var pendingArea = pendingRect.width * pendingRect.height;
              var deltaArea = pendingArea - aArea - bArea;
              if (deltaArea < minDeltaArea) {
                minDeltaArea = deltaArea;
                bestRectToMergeIdx = i3;
              }
            }
          }
          if (full) {
            mergedRepaintRects[bestRectToMergeIdx].union(rect);
            isMerged = true;
          }
          if (!isMerged) {
            var boundingRect = new BoundingRect(0, 0, 0, 0);
            boundingRect.copy(rect);
            mergedRepaintRects.push(boundingRect);
          }
          if (!full) {
            full = mergedRepaintRects.length >= maxRepaintRectCount;
          }
        }
      }
      for (var i2 = this.__startIndex; i2 < this.__endIndex; ++i2) {
        var el = displayList[i2];
        if (el) {
          var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
          var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
          var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
          if (curRect) {
            addRectToMergePool(curRect);
          }
        }
      }
      for (var i2 = this.__prevStartIndex; i2 < this.__prevEndIndex; ++i2) {
        var el = prevList[i2];
        var shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
        if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
          var prevRect = el.getPrevPaintRect();
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
        }
      }
      var hasIntersections;
      do {
        hasIntersections = false;
        for (var i2 = 0; i2 < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i2].isZero()) {
            mergedRepaintRects.splice(i2, 1);
            continue;
          }
          for (var j2 = i2 + 1; j2 < mergedRepaintRects.length; ) {
            if (mergedRepaintRects[i2].intersect(mergedRepaintRects[j2])) {
              hasIntersections = true;
              mergedRepaintRects[i2].union(mergedRepaintRects[j2]);
              mergedRepaintRects.splice(j2, 1);
            } else {
              j2++;
            }
          }
          i2++;
        }
      } while (hasIntersections);
      this._paintRects = mergedRepaintRects;
      return mergedRepaintRects;
    };
    Layer2.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    };
    Layer2.prototype.resize = function(width, height) {
      var dpr2 = this.dpr;
      var dom = this.dom;
      var domStyle = dom.style;
      var domBack = this.domBack;
      if (domStyle) {
        domStyle.width = width + "px";
        domStyle.height = height + "px";
      }
      dom.width = width * dpr2;
      dom.height = height * dpr2;
      if (domBack) {
        domBack.width = width * dpr2;
        domBack.height = height * dpr2;
        if (dpr2 !== 1) {
          this.ctxBack.scale(dpr2, dpr2);
        }
      }
    };
    Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
      var dom = this.dom;
      var ctx = this.ctx;
      var width = dom.width;
      var height = dom.height;
      clearColor = clearColor || this.clearColor;
      var haveMotionBLur = this.motionBlur && !clearAll;
      var lastFrameAlpha = this.lastFrameAlpha;
      var dpr2 = this.dpr;
      var self2 = this;
      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer();
        }
        this.ctxBack.globalCompositeOperation = "copy";
        this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
      }
      var domBack = this.domBack;
      function doClear(x2, y2, width2, height2) {
        ctx.clearRect(x2, y2, width2, height2);
        if (clearColor && clearColor !== "transparent") {
          var clearColorGradientOrPattern = void 0;
          if (isGradientObject(clearColor)) {
            var shouldCache = clearColor.global || clearColor.__width === width2 && clearColor.__height === height2;
            clearColorGradientOrPattern = shouldCache && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width: width2,
              height: height2
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
            clearColor.__width = width2;
            clearColor.__height = height2;
          } else if (isImagePatternObject(clearColor)) {
            clearColor.scaleX = clearColor.scaleX || dpr2;
            clearColor.scaleY = clearColor.scaleY || dpr2;
            clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
              dirty: function() {
                self2.setUnpainted();
                self2.painter.refresh();
              }
            });
          }
          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(x2, y2, width2, height2);
          ctx.restore();
        }
        if (haveMotionBLur) {
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, x2, y2, width2, height2);
          ctx.restore();
        }
      }
      if (!repaintRects || haveMotionBLur) {
        doClear(0, 0, width, height);
      } else if (repaintRects.length) {
        each$4(repaintRects, function(rect) {
          doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
        });
      }
    };
    return Layer2;
  }(Eventful);
  var HOVER_LAYER_ZLEVEL = 1e5;
  var CANVAS_ZLEVEL = 314159;
  var EL_AFTER_INCREMENTAL_INC = 0.01;
  var INCREMENTAL_INC = 1e-3;
  function isLayerValid(layer) {
    if (!layer) {
      return false;
    }
    if (layer.__builtin__) {
      return true;
    }
    if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
      return false;
    }
    return true;
  }
  function createRoot(width, height) {
    var domRoot = document.createElement("div");
    domRoot.style.cssText = [
      "position:relative",
      "width:" + width + "px",
      "height:" + height + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";";
    return domRoot;
  }
  var CanvasPainter = function() {
    function CanvasPainter2(root2, storage, opts, id) {
      this.type = "canvas";
      this._zlevelList = [];
      this._prevDisplayList = [];
      this._layers = {};
      this._layerConfig = {};
      this._needsManuallyCompositing = false;
      this.type = "canvas";
      var singleCanvas = !root2.nodeName || root2.nodeName.toUpperCase() === "CANVAS";
      this._opts = opts = extend$1({}, opts || {});
      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      this._singleCanvas = singleCanvas;
      this.root = root2;
      var rootStyle = root2.style;
      if (rootStyle) {
        disableUserSelect(root2);
        root2.innerHTML = "";
      }
      this.storage = storage;
      var zlevelList = this._zlevelList;
      this._prevDisplayList = [];
      var layers = this._layers;
      if (!singleCanvas) {
        this._width = getSize(root2, 0, opts);
        this._height = getSize(root2, 1, opts);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root2.appendChild(domRoot);
      } else {
        var rootCanvas = root2;
        var width = rootCanvas.width;
        var height = rootCanvas.height;
        if (opts.width != null) {
          width = opts.width;
        }
        if (opts.height != null) {
          height = opts.height;
        }
        this.dpr = opts.devicePixelRatio || 1;
        rootCanvas.width = width * this.dpr;
        rootCanvas.height = height * this.dpr;
        this._width = width;
        this._height = height;
        var mainLayer = new Layer(rootCanvas, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext();
        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL;
        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root2;
      }
    }
    CanvasPainter2.prototype.getType = function() {
      return "canvas";
    };
    CanvasPainter2.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    };
    CanvasPainter2.prototype.getViewportRoot = function() {
      return this._domRoot;
    };
    CanvasPainter2.prototype.getViewportRootOffset = function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    };
    CanvasPainter2.prototype.refresh = function(paintAll) {
      var list2 = this.storage.getDisplayList(true);
      var prevList = this._prevDisplayList;
      var zlevelList = this._zlevelList;
      this._redrawId = Math.random();
      this._paintList(list2, prevList, paintAll, this._redrawId);
      for (var i2 = 0; i2 < zlevelList.length; i2++) {
        var z2 = zlevelList[i2];
        var layer = this._layers[z2];
        if (!layer.__builtin__ && layer.refresh) {
          var clearColor = i2 === 0 ? this._backgroundColor : null;
          layer.refresh(clearColor);
        }
      }
      if (this._opts.useDirtyRect) {
        this._prevDisplayList = list2.slice();
      }
      return this;
    };
    CanvasPainter2.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    };
    CanvasPainter2.prototype._paintHoverList = function(list2) {
      var len2 = list2.length;
      var hoverLayer = this._hoverlayer;
      hoverLayer && hoverLayer.clear();
      if (!len2) {
        return;
      }
      var scope = {
        inHover: true,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var ctx;
      for (var i2 = 0; i2 < len2; i2++) {
        var el = list2[i2];
        if (el.__inHover) {
          if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
          }
          if (!ctx) {
            ctx = hoverLayer.ctx;
            ctx.save();
          }
          brush(ctx, el, scope, i2 === len2 - 1);
        }
      }
      if (ctx) {
        ctx.restore();
      }
    };
    CanvasPainter2.prototype.getHoverLayer = function() {
      return this.getLayer(HOVER_LAYER_ZLEVEL);
    };
    CanvasPainter2.prototype.paintOne = function(ctx, el) {
      brushSingle(ctx, el);
    };
    CanvasPainter2.prototype._paintList = function(list2, prevList, paintAll, redrawId) {
      if (this._redrawId !== redrawId) {
        return;
      }
      paintAll = paintAll || false;
      this._updateLayerStatus(list2);
      var _a2 = this._doPaintList(list2, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
      if (this._needsManuallyCompositing) {
        this._compositeManually();
      }
      if (needsRefreshHover) {
        this._paintHoverList(list2);
      }
      if (!finished) {
        var self_1 = this;
        requestAnimationFrame$1(function() {
          self_1._paintList(list2, prevList, paintAll, redrawId);
        });
      } else {
        this.eachLayer(function(layer) {
          layer.afterBrush && layer.afterBrush();
        });
      }
    };
    CanvasPainter2.prototype._compositeManually = function() {
      var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
      var width = this._domRoot.width;
      var height = this._domRoot.height;
      ctx.clearRect(0, 0, width, height);
      this.eachBuiltinLayer(function(layer) {
        if (layer.virtual) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        }
      });
    };
    CanvasPainter2.prototype._doPaintList = function(list2, prevList, paintAll) {
      var _this = this;
      var layerList = [];
      var useDirtyRect = this._opts.useDirtyRect;
      for (var zi = 0; zi < this._zlevelList.length; zi++) {
        var zlevel = this._zlevelList[zi];
        var layer = this._layers[zlevel];
        if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
          layerList.push(layer);
        }
      }
      var finished = true;
      var needsRefreshHover = false;
      var _loop_1 = function(k22) {
        var layer2 = layerList[k22];
        var ctx = layer2.ctx;
        var repaintRects = useDirtyRect && layer2.createRepaintRects(list2, prevList, this_1._width, this_1._height);
        var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
        var useTimer = !paintAll && layer2.incremental && Date.now;
        var startTime = useTimer && Date.now();
        var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
        if (layer2.__startIndex === layer2.__endIndex) {
          layer2.clear(false, clearColor, repaintRects);
        } else if (start2 === layer2.__startIndex) {
          var firstEl = list2[start2];
          if (!firstEl.incremental || !firstEl.notClear || paintAll) {
            layer2.clear(false, clearColor, repaintRects);
          }
        }
        if (start2 === -1) {
          console.error("For some unknown reason. drawIndex is -1");
          start2 = layer2.__startIndex;
        }
        var i2;
        var repaint = function(repaintRect) {
          var scope = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: _this._width,
            viewHeight: _this._height
          };
          for (i2 = start2; i2 < layer2.__endIndex; i2++) {
            var el = list2[i2];
            if (el.__inHover) {
              needsRefreshHover = true;
            }
            _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i2 === layer2.__endIndex - 1);
            if (useTimer) {
              var dTime = Date.now() - startTime;
              if (dTime > 15) {
                break;
              }
            }
          }
          if (scope.prevElClipPaths) {
            ctx.restore();
          }
        };
        if (repaintRects) {
          if (repaintRects.length === 0) {
            i2 = layer2.__endIndex;
          } else {
            var dpr2 = this_1.dpr;
            for (var r2 = 0; r2 < repaintRects.length; ++r2) {
              var rect = repaintRects[r2];
              ctx.save();
              ctx.beginPath();
              ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
              ctx.clip();
              repaint(rect);
              ctx.restore();
            }
          }
        } else {
          ctx.save();
          repaint();
          ctx.restore();
        }
        layer2.__drawIndex = i2;
        if (layer2.__drawIndex < layer2.__endIndex) {
          finished = false;
        }
      };
      var this_1 = this;
      for (var k2 = 0; k2 < layerList.length; k2++) {
        _loop_1(k2);
      }
      if (env.wxa) {
        each$4(this._layers, function(layer2) {
          if (layer2 && layer2.ctx && layer2.ctx.draw) {
            layer2.ctx.draw();
          }
        });
      }
      return {
        finished,
        needsRefreshHover
      };
    };
    CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
      var ctx = currentLayer.ctx;
      if (useDirtyRect) {
        var paintRect = el.getPaintRect();
        if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
          brush(ctx, el, scope, isLast);
          el.setPrevPaintRect(paintRect);
        }
      } else {
        brush(ctx, el, scope, isLast);
      }
    };
    CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
      if (this._singleCanvas && !this._needsManuallyCompositing) {
        zlevel = CANVAS_ZLEVEL;
      }
      var layer = this._layers[zlevel];
      if (!layer) {
        layer = new Layer("zr_" + zlevel, this, this.dpr);
        layer.zlevel = zlevel;
        layer.__builtin__ = true;
        if (this._layerConfig[zlevel]) {
          merge$1(layer, this._layerConfig[zlevel], true);
        } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
          merge$1(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
        }
        if (virtual) {
          layer.virtual = virtual;
        }
        this.insertLayer(zlevel, layer);
        layer.initContext();
      }
      return layer;
    };
    CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
      var layersMap = this._layers;
      var zlevelList = this._zlevelList;
      var len2 = zlevelList.length;
      var domRoot = this._domRoot;
      var prevLayer = null;
      var i2 = -1;
      if (layersMap[zlevel]) {
        return;
      }
      if (!isLayerValid(layer)) {
        return;
      }
      if (len2 > 0 && zlevel > zlevelList[0]) {
        for (i2 = 0; i2 < len2 - 1; i2++) {
          if (zlevelList[i2] < zlevel && zlevelList[i2 + 1] > zlevel) {
            break;
          }
        }
        prevLayer = layersMap[zlevelList[i2]];
      }
      zlevelList.splice(i2 + 1, 0, zlevel);
      layersMap[zlevel] = layer;
      if (!layer.virtual) {
        if (prevLayer) {
          var prevDom = prevLayer.dom;
          if (prevDom.nextSibling) {
            domRoot.insertBefore(layer.dom, prevDom.nextSibling);
          } else {
            domRoot.appendChild(layer.dom);
          }
        } else {
          if (domRoot.firstChild) {
            domRoot.insertBefore(layer.dom, domRoot.firstChild);
          } else {
            domRoot.appendChild(layer.dom);
          }
        }
      }
      layer.painter || (layer.painter = this);
    };
    CanvasPainter2.prototype.eachLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i2 = 0; i2 < zlevelList.length; i2++) {
        var z2 = zlevelList[i2];
        cb.call(context, this._layers[z2], z2);
      }
    };
    CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i2 = 0; i2 < zlevelList.length; i2++) {
        var z2 = zlevelList[i2];
        var layer = this._layers[z2];
        if (layer.__builtin__) {
          cb.call(context, layer, z2);
        }
      }
    };
    CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i2 = 0; i2 < zlevelList.length; i2++) {
        var z2 = zlevelList[i2];
        var layer = this._layers[z2];
        if (!layer.__builtin__) {
          cb.call(context, layer, z2);
        }
      }
    };
    CanvasPainter2.prototype.getLayers = function() {
      return this._layers;
    };
    CanvasPainter2.prototype._updateLayerStatus = function(list2) {
      this.eachBuiltinLayer(function(layer2, z2) {
        layer2.__dirty = layer2.__used = false;
      });
      function updatePrevLayer(idx) {
        if (prevLayer) {
          if (prevLayer.__endIndex !== idx) {
            prevLayer.__dirty = true;
          }
          prevLayer.__endIndex = idx;
        }
      }
      if (this._singleCanvas) {
        for (var i_1 = 1; i_1 < list2.length; i_1++) {
          var el = list2[i_1];
          if (el.zlevel !== list2[i_1 - 1].zlevel || el.incremental) {
            this._needsManuallyCompositing = true;
            break;
          }
        }
      }
      var prevLayer = null;
      var incrementalLayerCount = 0;
      var prevZlevel;
      var i2;
      for (i2 = 0; i2 < list2.length; i2++) {
        var el = list2[i2];
        var zlevel = el.zlevel;
        var layer = void 0;
        if (prevZlevel !== zlevel) {
          prevZlevel = zlevel;
          incrementalLayerCount = 0;
        }
        if (el.incremental) {
          layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
          layer.incremental = true;
          incrementalLayerCount = 1;
        } else {
          layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
        }
        if (!layer.__builtin__) {
          logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
        }
        if (layer !== prevLayer) {
          layer.__used = true;
          if (layer.__startIndex !== i2) {
            layer.__dirty = true;
          }
          layer.__startIndex = i2;
          if (!layer.incremental) {
            layer.__drawIndex = i2;
          } else {
            layer.__drawIndex = -1;
          }
          updatePrevLayer(i2);
          prevLayer = layer;
        }
        if (el.__dirty & REDRAW_BIT && !el.__inHover) {
          layer.__dirty = true;
          if (layer.incremental && layer.__drawIndex < 0) {
            layer.__drawIndex = i2;
          }
        }
      }
      updatePrevLayer(i2);
      this.eachBuiltinLayer(function(layer2, z2) {
        if (!layer2.__used && layer2.getElementCount() > 0) {
          layer2.__dirty = true;
          layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
        }
        if (layer2.__dirty && layer2.__drawIndex < 0) {
          layer2.__drawIndex = layer2.__startIndex;
        }
      });
    };
    CanvasPainter2.prototype.clear = function() {
      this.eachBuiltinLayer(this._clearLayer);
      return this;
    };
    CanvasPainter2.prototype._clearLayer = function(layer) {
      layer.clear();
    };
    CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
      this._backgroundColor = backgroundColor2;
      each$4(this._layers, function(layer) {
        layer.setUnpainted();
      });
    };
    CanvasPainter2.prototype.configLayer = function(zlevel, config) {
      if (config) {
        var layerConfig = this._layerConfig;
        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config;
        } else {
          merge$1(layerConfig[zlevel], config, true);
        }
        for (var i2 = 0; i2 < this._zlevelList.length; i2++) {
          var _zlevel = this._zlevelList[i2];
          if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
            var layer = this._layers[_zlevel];
            merge$1(layer, layerConfig[zlevel], true);
          }
        }
      }
    };
    CanvasPainter2.prototype.delLayer = function(zlevel) {
      var layers = this._layers;
      var zlevelList = this._zlevelList;
      var layer = layers[zlevel];
      if (!layer) {
        return;
      }
      layer.dom.parentNode.removeChild(layer.dom);
      delete layers[zlevel];
      zlevelList.splice(indexOf(zlevelList, zlevel), 1);
    };
    CanvasPainter2.prototype.resize = function(width, height) {
      if (!this._domRoot.style) {
        if (width == null || height == null) {
          return;
        }
        this._width = width;
        this._height = height;
        this.getLayer(CANVAS_ZLEVEL).resize(width, height);
      } else {
        var domRoot = this._domRoot;
        domRoot.style.display = "none";
        var opts = this._opts;
        var root2 = this.root;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = getSize(root2, 0, opts);
        height = getSize(root2, 1, opts);
        domRoot.style.display = "";
        if (this._width !== width || height !== this._height) {
          domRoot.style.width = width + "px";
          domRoot.style.height = height + "px";
          for (var id in this._layers) {
            if (this._layers.hasOwnProperty(id)) {
              this._layers[id].resize(width, height);
            }
          }
          this.refresh(true);
        }
        this._width = width;
        this._height = height;
      }
      return this;
    };
    CanvasPainter2.prototype.clearLayer = function(zlevel) {
      var layer = this._layers[zlevel];
      if (layer) {
        layer.clear();
      }
    };
    CanvasPainter2.prototype.dispose = function() {
      this.root.innerHTML = "";
      this.root = this.storage = this._domRoot = this._layers = null;
    };
    CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
      opts = opts || {};
      if (this._singleCanvas && !this._compositeManually) {
        return this._layers[CANVAS_ZLEVEL].dom;
      }
      var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
      imageLayer.initContext();
      imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
      var ctx = imageLayer.ctx;
      if (opts.pixelRatio <= this.dpr) {
        this.refresh();
        var width_1 = imageLayer.dom.width;
        var height_1 = imageLayer.dom.height;
        this.eachLayer(function(layer) {
          if (layer.__builtin__) {
            ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
          } else if (layer.renderToCanvas) {
            ctx.save();
            layer.renderToCanvas(ctx);
            ctx.restore();
          }
        });
      } else {
        var scope = {
          inHover: false,
          viewWidth: this._width,
          viewHeight: this._height
        };
        var displayList = this.storage.getDisplayList(true);
        for (var i2 = 0, len2 = displayList.length; i2 < len2; i2++) {
          var el = displayList[i2];
          brush(ctx, el, scope, i2 === len2 - 1);
        }
      }
      return imageLayer.dom;
    };
    CanvasPainter2.prototype.getWidth = function() {
      return this._width;
    };
    CanvasPainter2.prototype.getHeight = function() {
      return this._height;
    };
    return CanvasPainter2;
  }();
  function install(registers) {
    registers.registerPainter("canvas", CanvasPainter);
  }
  use([
    install$8,
    install$6,
    install$7,
    install$9,
    install$1,
    install$2,
    install$3,
    install$g,
    install$f,
    install$e,
    install$b,
    install$c,
    installLabelLayout,
    installUniversalTransition,
    install
  ]);
  const _export_sfc = (sfc, props2) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key2, val] of props2) {
      target[key2] = val;
    }
    return target;
  };
  const _hoisted_1$2 = { class: "dashboard" };
  const _sfc_main$3 = {
    __name: "index",
    setup(__props) {
      onMounted(() => {
        initLineChart();
        initBarChart();
        initPieChart();
        initGaugeChart();
      });
      function initLineChart() {
        const lineChartDom = document.getElementById("line-chart-main");
        const lineChart = echarts.init(lineChartDom);
        const lineChartOption = {
          xAxis: {
            type: "category",
            data: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
          },
          yAxis: {
            type: "value"
          },
          series: [
            {
              data: [820, 932, 901, 934, 1290, 1330, 1320],
              type: "line",
              smooth: true
            }
          ]
        };
        lineChart.setOption(lineChartOption);
      }
      function initBarChart() {
        const barChartDom = document.getElementById("bar-chart-main");
        const barChart = echarts.init(barChartDom);
        const barChartOption = {
          xAxis: {
            type: "category",
            data: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
          },
          yAxis: {
            type: "value"
          },
          series: [
            {
              data: [120, 200, 150, 80, 70, 110, 130],
              type: "bar"
            }
          ]
        };
        barChart.setOption(barChartOption);
      }
      function initPieChart() {
        var pieChartDom = document.getElementById("pie-chart-main");
        var pieChart = echarts.init(pieChartDom);
        var pieChartOption = {
          tooltip: {
            trigger: "item"
          },
          legend: {
            top: "5%",
            left: "center"
          },
          series: [
            {
              name: "Access From",
              type: "pie",
              radius: ["40%", "70%"],
              avoidLabelOverlap: false,
              itemStyle: {
                borderRadius: 10,
                borderColor: "#fff",
                borderWidth: 2
              },
              label: {
                show: false,
                position: "center"
              },
              emphasis: {
                label: {
                  show: true,
                  fontSize: 40,
                  fontWeight: "bold"
                }
              },
              labelLine: {
                show: false
              },
              data: [
                { value: 1048, name: "Search Engine" },
                { value: 735, name: "Direct" },
                { value: 580, name: "Email" },
                { value: 484, name: "Union Ads" },
                { value: 300, name: "Video Ads" }
              ]
            }
          ]
        };
        pieChart.setOption(pieChartOption);
      }
      function initGaugeChart() {
        var gaugeChartDom = document.getElementById("gauge-chart-main");
        var gaugeChart = echarts.init(gaugeChartDom);
        var gaugeChartOption = {
          tooltip: {
            formatter: "{a} <br/>{b} : {c}%"
          },
          series: [
            {
              name: "Pressure",
              type: "gauge",
              progress: {
                show: true
              },
              detail: {
                valueAnimation: true,
                formatter: "{value}"
              },
              data: [
                {
                  value: 50,
                  name: "SCORE"
                }
              ]
            }
          ]
        };
        gaugeChart.setOption(gaugeChartOption);
      }
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$2, _cache[0] || (_cache[0] = [
          createBaseVNode("div", { id: "line-chart-main" }, null, -1),
          createBaseVNode("div", { id: "bar-chart-main" }, null, -1),
          createBaseVNode("div", { id: "pie-chart-main" }, null, -1),
          createBaseVNode("div", { id: "gauge-chart-main" }, null, -1)
        ]));
      };
    }
  };
  const index = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-d6af467e"]]);
  const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: index
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$2 = {};
  function _sfc_render(_ctx, _cache) {
    return openBlock(), createElementBlock("div", null, " 微应用数据详情 ");
  }
  const details = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]);
  const details$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: details
  }, Symbol.toStringTag, { value: "Module" }));
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
    const str = toString.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj2, fn, { allOwnKeys = false } = {}) {
    if (obj2 === null || typeof obj2 === "undefined") {
      return;
    }
    let i2;
    let l2;
    if (typeof obj2 !== "object") {
      obj2 = [obj2];
    }
    if (isArray(obj2)) {
      for (i2 = 0, l2 = obj2.length; i2 < l2; i2++) {
        fn.call(null, obj2[i2], i2, obj2);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj2) : Object.keys(obj2);
      const len2 = keys2.length;
      let key2;
      for (i2 = 0; i2 < len2; i2++) {
        key2 = keys2[i2];
        fn.call(null, obj2[key2], key2, obj2);
      }
    }
  }
  function findKey(obj2, key2) {
    key2 = key2.toLowerCase();
    const keys2 = Object.keys(obj2);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue2 = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue2);
    }
    return result;
  }
  const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key2) => {
      if (thisArg && isFunction(val)) {
        a2[key2] = bind(val, thisArg);
      } else {
        a2[key2] = val;
      }
    }, { allOwnKeys });
    return a2;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props2, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props2 && Object.assign(constructor.prototype, props2);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props2;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props2 = Object.getOwnPropertyNames(sourceObj);
      i2 = props2.length;
      while (i2-- > 0) {
        prop = props2[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position2) => {
    str = String(str);
    if (position2 === void 0 || position2 > str.length) {
      position2 = str.length;
    }
    position2 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i2 = thing.length;
    if (!isNumber(i2)) return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj2, fn) => {
    const generator = obj2 && obj2[Symbol.iterator];
    const iterator2 = generator.call(obj2);
    let result;
    while ((result = iterator2.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj2, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer2(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj2, prop) => hasOwnProperty2.call(obj2, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj2, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj2);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj2)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj2, reducedDescriptors);
  };
  const freezeMethods = (obj2) => {
    reduceDescriptors(obj2, (descriptor, name) => {
      if (isFunction(obj2) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj2[name];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj2 = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj2[value] = true;
      });
    };
    isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
    return obj2;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length: length2 } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length2 | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj2) => {
    const stack2 = new Array(10);
    const visit = (source, i2) => {
      if (isObject(source)) {
        if (stack2.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack2[i2] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack2[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj2, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };
  function AxiosError$1(message, code2, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError$1.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError$1, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError$1.from = (error, code2, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter2(obj2) {
      return obj2 !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError$1.call(axiosError, error.message, code2, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each2(token2, i2) {
      token2 = removeBrackets(token2);
      return !dots && i2 ? "[" + token2 + "]" : token2;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj2, formData, options2) {
    if (!utils$1.isObject(obj2)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options2 = utils$1.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each2(el, index2) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack2 = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack2.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack2.push(value);
      utils$1.forEach(value, function each2(el, key2) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack2.pop();
    }
    if (!utils$1.isObject(obj2)) {
      throw new TypeError("data must be an object");
    }
    build(obj2);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params2, options2) {
    this._pairs = [];
    params2 && toFormData$1(params2, this, options2);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append2(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each2(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params2, options2) {
    if (!params2) {
      return url;
    }
    const _encode = options2 && options2.encode || encode;
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params2, options2);
    } else {
      serializedParams = utils$1.isURLSearchParams(params2) ? params2.toString() : new AxiosURLSearchParams(params2, options2).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const hasStandardBrowserEnv = ((product) => {
    return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
  })(typeof navigator !== "undefined" && navigator.product);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options2) {
    return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key2, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject(arr) {
    const obj2 = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len2 = keys2.length;
    let key2;
    for (i2 = 0; i2 < len2; i2++) {
      key2 = keys2[i2];
      obj2[key2] = arr[key2];
    }
    return obj2;
  }
  function formDataToJSON(formData) {
    function buildPath2(path, value, target, index2) {
      let name = path[index2++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath2(path, value, target[name], index2);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj2 = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath2(parsePropPath(name), value, obj2, 0);
      });
      return obj2;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
      i2 = line2.indexOf(":");
      key2 = line2.substring(0, i2).trim().toLowerCase();
      val = line2.substring(i2 + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils$1.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils$1.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
      return char2.toUpperCase() + str;
    });
  }
  function buildAccessors(obj2, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj2, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$1.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isHeaders(header)) {
        for (const [key2, value] of header.entries()) {
          setHeader(value, key2, rewrite);
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key2);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$1.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key2 = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key2 = utils$1.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj2 = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj2[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj2;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed2 = new this(first);
      targets.forEach((target) => computed2.set(target));
      return computed2;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders$1);
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform2(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError$1(message, config, request) {
    AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true
  });
  function settle(resolve2, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match2 && match2[1] || "";
  }
  function speedometer(samplesCount, min3) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min3 = min3 !== void 0 ? min3 : 1e3;
    return function push(chunkLength) {
      const now2 = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now2;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now2;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now2 - firstSampleTS < min3) {
        return;
      }
      const passed = startedAt && now2 - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    const threshold = 1e3 / freq;
    let timer = null;
    return function throttled() {
      const force = this === true;
      const now2 = Date.now();
      if (force || now2 - timestamp > threshold) {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        timestamp = now2;
        return fn.apply(null, arguments);
      }
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          timestamp = Date.now();
          return fn.apply(null, arguments);
        }, threshold - (now2 - timestamp));
      }
    };
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2,
        lengthComputable: total != null
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    }, freq);
  };
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a2, b2, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a2, b2, caseless);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2, caseless);
      }
    }
    function valueFromConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2);
      }
    }
    function mergeDirectKeys(a2, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a2, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a2);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType } = _config;
      let onCanceled;
      function done() {
        if (_config.cancelToken) {
          _config.cancelToken.unsubscribe(onCanceled);
        }
        if (_config.signal) {
          _config.signal.removeEventListener("abort", onCanceled);
        }
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, _config, request));
        request = null;
      };
      request.onerror = function handleError2() {
        reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, _config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          _config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (typeof _config.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(_config.onDownloadProgress, true));
      }
      if (typeof _config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(_config.onUploadProgress));
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    let controller = new AbortController();
    let aborted;
    const onabort = function(cancel) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = cancel instanceof Error ? cancel : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = unsubscribe;
    return [signal, () => {
      timer && clearTimeout(timer);
      timer = null;
    }];
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len2 = chunk.byteLength;
    if (len2 < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len2) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize, encode2) {
    for await (const chunk of iterable) {
      yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
    const iterator2 = readBytes(stream, chunkSize, encode2);
    let bytes = 0;
    return new ReadableStream({
      type: "bytes",
      async pull(controller) {
        const { done, value } = await iterator2.next();
        if (done) {
          controller.close();
          onFinish();
          return;
        }
        let len2 = value.byteLength;
        onProgress && onProgress(bytes += len2);
        controller.enqueue(new Uint8Array(value));
      },
      cancel(reason) {
        onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const fetchProgressDecorator = (total, fn) => {
    const lengthComputable = total != null;
    return (loaded) => setTimeout(() => fn({
      lengthComputable,
      total,
      loaded
    }));
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const supportsRequestStream = isReadableStreamSupported && (() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  })();
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && !!(() => {
    try {
      return utils$1.isReadableStream(new Response("").body);
    } catch (err) {
    }
  })();
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      return (await new Request(body).arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length2 = utils$1.toFiniteNumber(headers.getContentLength());
    return length2 == null ? getBodyLength(body) : length2;
  };
  const fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
    let finished, request;
    const onFinish = () => {
      !finished && setTimeout(() => {
        composedSignal && composedSignal.unsubscribe();
      });
      finished = true;
    };
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
            requestContentLength,
            progressEventReducer(onUploadProgress)
          ), null, encodeText);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "cors" : "omit";
      }
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        withCredentials
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
        const options2 = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options2[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
            responseContentLength,
            progressEventReducer(onDownloadProgress, true)
          ), isStreamResponse && onFinish, encodeText),
          options2
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && onFinish();
      stopTimeout && stopTimeout();
      return await new Promise((resolve2, reject) => {
        settle(resolve2, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      onFinish();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError$1.from(err, err && err.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length2; i2++) {
        nameOrAdapter = adapters2[i2];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s2,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION$1 = "1.7.2";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options2);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options2[opt];
        const result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  let Axios$1 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy;
          Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
          const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack2;
            } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack2;
            }
          } catch (e2) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len2;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len2 = chain.length;
        promise = Promise.resolve(config);
        while (i2 < len2) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len2 = requestInterceptorChain.length;
      let newConfig = config;
      i2 = 0;
      while (i2 < len2) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len2 = responseInterceptorChain.length;
      while (i2 < len2) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  let CancelToken$1 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token2 = this;
      this.promise.then((cancel) => {
        if (!token2._listeners) return;
        let i2 = token2._listeners.length;
        while (i2-- > 0) {
          token2._listeners[i2](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token2.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token2.reason) {
          return;
        }
        token2.reason = new CanceledError$1(message, config, request);
        resolvePromise(token2.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token2 = new CancelToken2(function executor(c2) {
        cancel = c2;
      });
      return {
        token: token2,
        cancel
      };
    }
  };
  function spread$1(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode$1).forEach(([key2, value]) => {
    HttpStatusCode$1[value] = key2;
  });
  function createInstance(defaultConfig2) {
    const context = new Axios$1(defaultConfig2);
    const instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;
  axios.AxiosError = AxiosError$1;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread$1;
  axios.isAxiosError = isAxiosError$1;
  axios.mergeConfig = mergeConfig$1;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const {
    Axios,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig
  } = axios;
  const _hoisted_1$1 = { class: "custom-pagination" };
  const _sfc_main$1 = {
    __name: "pagination",
    props: {
      current: {
        type: Number,
        default: 1
      },
      pageSize: {
        type: Number,
        default: 20
      },
      total: {
        type: Number,
        default: 0
      }
    },
    emits: ["change", "show-size-change"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      function change(page, pageSize) {
        emit2("change", page);
      }
      function showSizeChange(current, size) {
        emit2("showSizeChange", size);
      }
      return (_ctx, _cache) => {
        const _component_a_pagination = resolveComponent("a-pagination");
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          createVNode(_component_a_pagination, {
            current: __props.current,
            "page-size": __props.pageSize,
            total: __props.total,
            "show-total": (total) => `Total ${total} items`,
            "show-quick-jumper": "",
            onChange: change,
            onShowSizeChange: showSizeChange
          }, null, 8, ["current", "page-size", "total", "show-total"])
        ]);
      };
    }
  };
  const Pagination = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-ee1ada23"]]);
  const _hoisted_1 = { class: "search" };
  const _hoisted_2 = { class: "content" };
  const _sfc_main = {
    __name: "list",
    setup(__props) {
      const { t: t2 } = useI18n();
      const statusList = reactive([
        { label: "关闭", value: "0" },
        { label: "运行中", value: "1" },
        { label: "已上线", value: "2" },
        { label: "异常", value: "3" }
      ]);
      const formState = reactive({
        ruleName: "",
        description: "",
        invocationsNum: 0,
        status: "",
        schedulingTime: ""
      });
      const searchCollapse = ref(false);
      const current = ref(1);
      const pageSize = ref(10);
      const total = ref(0);
      const tableData = ref();
      function handleReset() {
        formState.ruleName = "";
        formState.description = "";
        formState.invocationsNum = 0;
        formState.status = "";
        formState.schedulingTime = "";
      }
      function handleSearch(curr) {
        if (curr) current.value = curr;
        const params2 = {
          ruleName: formState.ruleName,
          description: formState.description,
          invocationsNum: formState.invocationsNum,
          status: formState.status,
          schedulingTime: formState.schedulingTime,
          current: current.value,
          pageSize: pageSize.value
        };
        axios.get("/admin/v1/rule", {
          params: params2
        }).then((res) => {
          const { success, data, total: totals } = res.data;
          if (success) {
            tableData.value = data;
            total.value = totals;
          }
        });
      }
      handleSearch();
      function handleChange(page) {
        current.value = page;
        handleSearch();
      }
      function handleShowSizeChange(size) {
        pageSize.value = size;
        handleSearch();
      }
      return (_ctx, _cache) => {
        const _component_a_input = resolveComponent("a-input");
        const _component_a_form_item = resolveComponent("a-form-item");
        const _component_a_col = resolveComponent("a-col");
        const _component_a_button = resolveComponent("a-button");
        const _component_a_row = resolveComponent("a-row");
        const _component_a_select_option = resolveComponent("a-select-option");
        const _component_a_select = resolveComponent("a-select");
        const _component_a_form = resolveComponent("a-form");
        const _component_a_table_column = resolveComponent("a-table-column");
        const _component_a_badge = resolveComponent("a-badge");
        const _component_a_table = resolveComponent("a-table");
        return openBlock(), createElementBlock("div", null, [
          createBaseVNode("div", _hoisted_1, [
            createVNode(_component_a_form, {
              ref: "formRef",
              class: "ant-advanced-search-form",
              model: formState
            }, {
              default: withCtx(() => [
                createVNode(_component_a_row, { gutter: 24 }, {
                  default: withCtx(() => [
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        createVNode(_component_a_form_item, {
                          label: "规则名称",
                          "label-col": { span: 8 },
                          "wrapper-col": { span: 16 }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_a_input, {
                              value: formState.name,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => formState.name = $event)
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        createVNode(_component_a_form_item, {
                          label: "描述",
                          "label-col": { span: 8 },
                          "wrapper-col": { span: 16 }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_a_input, {
                              value: formState.name,
                              "onUpdate:value": _cache[1] || (_cache[1] = ($event) => formState.name = $event)
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        searchCollapse.value ? (openBlock(), createBlock(_component_a_form_item, {
                          key: 0,
                          label: "服务调用次数",
                          "label-col": { span: 8 },
                          "wrapper-col": { span: 16 }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_a_input, {
                              value: formState.name,
                              "onUpdate:value": _cache[2] || (_cache[2] = ($event) => formState.name = $event)
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        })) : (openBlock(), createBlock(_component_a_form_item, {
                          key: 1,
                          label: "",
                          "wrapper-col": { span: 16, offset: 8 }
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("div", null, [
                              createVNode(_component_a_button, {
                                style: { "margin-right": "12px" },
                                onClick: handleReset
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(unref(t2)("btn.reset")), 1)
                                ]),
                                _: 1
                              }),
                              createVNode(_component_a_button, {
                                type: "primary",
                                style: { "margin-right": "12px" },
                                onClick: _cache[3] || (_cache[3] = ($event) => handleSearch(1))
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(unref(t2)("btn.search")), 1)
                                ]),
                                _: 1
                              }),
                              createBaseVNode("a", {
                                onClick: _cache[4] || (_cache[4] = ($event) => searchCollapse.value = !searchCollapse.value)
                              }, [
                                createTextVNode(toDisplayString$1(searchCollapse.value ? "收起" : "展开") + " ", 1),
                                searchCollapse.value ? (openBlock(), createBlock(unref(UpOutlined), { key: 0 })) : (openBlock(), createBlock(unref(DownOutlined), { key: 1 }))
                              ])
                            ])
                          ]),
                          _: 1
                        }))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                searchCollapse.value ? (openBlock(), createBlock(_component_a_row, {
                  key: 0,
                  gutter: 24
                }, {
                  default: withCtx(() => [
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        createVNode(_component_a_form_item, {
                          label: "状态",
                          "label-col": { span: 8 },
                          "wrapper-col": { span: 16 }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_a_select, {
                              value: formState.status,
                              "onUpdate:value": _cache[5] || (_cache[5] = ($event) => formState.status = $event)
                            }, {
                              default: withCtx(() => [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(statusList, ({ label, value }) => {
                                  return openBlock(), createBlock(_component_a_select_option, { value }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString$1(label), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"]);
                                }), 256))
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        createVNode(_component_a_form_item, {
                          label: "上次调度时间",
                          "label-col": { span: 8 },
                          "wrapper-col": { span: 16 }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_a_input, {
                              value: formState.name,
                              "onUpdate:value": _cache[6] || (_cache[6] = ($event) => formState.name = $event)
                            }, null, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_a_col, { span: 8 }, {
                      default: withCtx(() => [
                        createVNode(_component_a_form_item, {
                          label: "",
                          "wrapper-col": { span: 16, offset: 8 }
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("div", null, [
                              createVNode(_component_a_button, {
                                style: { "margin-right": "12px" },
                                onClick: handleReset
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(unref(t2)("btn.reset")), 1)
                                ]),
                                _: 1
                              }),
                              createVNode(_component_a_button, {
                                type: "primary",
                                style: { "margin-right": "12px" },
                                onClick: _cache[7] || (_cache[7] = ($event) => handleSearch(1))
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(unref(t2)("btn.search")), 1)
                                ]),
                                _: 1
                              }),
                              createBaseVNode("a", {
                                onClick: _cache[8] || (_cache[8] = ($event) => searchCollapse.value = !searchCollapse.value)
                              }, [
                                createTextVNode(toDisplayString$1(searchCollapse.value ? "收起" : "展开") + " ", 1),
                                searchCollapse.value ? (openBlock(), createBlock(unref(UpOutlined), { key: 0 })) : (openBlock(), createBlock(unref(DownOutlined), { key: 1 }))
                              ])
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["model"])
          ]),
          createBaseVNode("div", _hoisted_2, [
            createVNode(_component_a_table, {
              "data-source": tableData.value,
              pagination: false
            }, {
              default: withCtx(() => [
                createVNode(_component_a_table_column, {
                  title: "规则名称",
                  "data-index": "name"
                }),
                createVNode(_component_a_table_column, {
                  title: "描述",
                  "data-index": "desc"
                }),
                createVNode(_component_a_table_column, {
                  title: "创建人",
                  "data-index": "owner"
                }),
                createVNode(_component_a_table_column, {
                  title: "服务调用次数",
                  "data-index": "callNo"
                }),
                createVNode(_component_a_table_column, {
                  title: "状态",
                  "data-index": "status"
                }, {
                  default: withCtx(({ record }) => [
                    record.status === "0" ? (openBlock(), createBlock(_component_a_badge, {
                      key: 0,
                      status: "default",
                      text: "关闭"
                    })) : record.status === "1" ? (openBlock(), createBlock(_component_a_badge, {
                      key: 1,
                      status: "processing",
                      text: "运行中"
                    })) : record.status === "2" ? (openBlock(), createBlock(_component_a_badge, {
                      key: 2,
                      status: "success",
                      text: "已上线"
                    })) : record.status === "3" ? (openBlock(), createBlock(_component_a_badge, {
                      key: 3,
                      status: "error",
                      text: "异常"
                    })) : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(_component_a_table_column, {
                  title: "创建时间",
                  "data-index": "createdAt"
                }, {
                  default: withCtx(({ record }) => [
                    createTextVNode(toDisplayString$1(unref(formatDateTime)(record.createdAt, "dateTime")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_a_table_column, {
                  title: "上次调度时间",
                  "data-index": "updatedAt"
                }, {
                  default: withCtx(({ record }) => [
                    createTextVNode(toDisplayString$1(unref(formatDateTime)(record.updatedAt, "dateTime")), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_a_table_column, {
                  title: "操作",
                  "data-index": "tags"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_a_button, { type: "link" }, {
                      default: withCtx(() => _cache[9] || (_cache[9] = [
                        createTextVNode("配置")
                      ])),
                      _: 1,
                      __: [9]
                    }),
                    createVNode(_component_a_button, { type: "link" }, {
                      default: withCtx(() => _cache[10] || (_cache[10] = [
                        createTextVNode("订阅警报")
                      ])),
                      _: 1,
                      __: [10]
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["data-source"]),
            createVNode(Pagination, {
              current: current.value,
              pageSize: pageSize.value,
              total: total.value,
              onChange: handleChange,
              onShowSizeChange: handleShowSizeChange
            }, null, 8, ["current", "pageSize", "total"])
          ])
        ]);
      };
    }
  };
  const list = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-e97ab276"]]);
  const list$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: list
  }, Symbol.toStringTag, { value: "Module" }));
});
//# sourceMappingURL=index-Cm8C6sEu.js.map
